#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AE';
  package AE;use AnyEvent ();our$VERSION=$AnyEvent::VERSION;0.01
AE

$fatpacked{"AnyEvent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT';
  package AnyEvent;BEGIN {require "AnyEvent/constants.pl";&AnyEvent::common_sense}use Carp ();our$VERSION=0.01;our$MODEL;our@ISA;our@REGISTRY;our$VERBOSE;our%PROTOCOL;our$MAX_SIGNAL_LATENCY=$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}|| 10;BEGIN {eval "sub TAINT (){" .(${^TAINT}*1)."}";delete@ENV{grep /^PERL_ANYEVENT_/,keys%ENV}if ${^TAINT};$ENV{"PERL_ANYEVENT_$_"}=$ENV{"AE_$_"}for grep s/^AE_// &&!exists$ENV{"PERL_ANYEVENT_$_"},keys%ENV;@ENV{grep /^PERL_ANYEVENT_/,keys%ENV}=()if ${^TAINT};$VERBOSE=length$ENV{PERL_ANYEVENT_VERBOSE}? $ENV{PERL_ANYEVENT_VERBOSE}*1 : 4;my$idx;$PROTOCOL{$_}=++$idx for reverse split /\s*,\s*/,$ENV{PERL_ANYEVENT_PROTOCOLS}|| "ipv4,ipv6"}our@post_detect;sub post_detect(&) {my ($cb)=@_;push@post_detect,$cb;defined wantarray ? bless \$cb,"AnyEvent::Util::postdetect" : ()}sub AnyEvent::Util::postdetect::DESTROY {@post_detect=grep $_!=${$_[0]},@post_detect}our$POSTPONE_W;our@POSTPONE;sub _postpone_exec {undef$POSTPONE_W;&{shift@POSTPONE}while@POSTPONE}sub postpone(&) {push@POSTPONE,shift;$POSTPONE_W ||= AE::timer (0,0,\&_postpone_exec);()}sub log($$;@) {if ($_[0]<= ($VERBOSE || 1)){local ($!,$@);require AnyEvent::Log;goto&log}0}sub _logger($;$) {my ($level,$renabled)=@_;$$renabled=$level <= $VERBOSE;my$logger=[(caller)[0],$level,$renabled];$AnyEvent::Log::LOGGER{$logger+0}=$logger}if (length$ENV{PERL_ANYEVENT_LOG}){require AnyEvent::Log}BEGIN {*_fh_nonblocking=AnyEvent::WIN32 ? sub($$) {ioctl $_[0],0x8004667e,pack "L",$_[1]}: sub($$) {fcntl $_[0],AnyEvent::F_SETFL,$_[1]? AnyEvent::O_NONBLOCK : 0}}sub fh_block($) {_fh_nonblocking shift,0}sub fh_unblock($) {_fh_nonblocking shift,1}our@models=([EV::=>AnyEvent::Impl::EV::],[AnyEvent::Loop::=>AnyEvent::Impl::Perl::],[Irssi::=>AnyEvent::Impl::Irssi::],[Event::=>AnyEvent::Impl::Event::],[Glib::=>AnyEvent::Impl::Glib::],[Event::Lib::=>AnyEvent::Impl::EventLib::],[Tk::=>AnyEvent::Impl::Tk::],[UV::=>AnyEvent::Impl::UV::],[Qt::=>AnyEvent::Impl::Qt::],[POE::Kernel::=>AnyEvent::Impl::POE::],[Wx::=>AnyEvent::Impl::POE::],[Prima::=>AnyEvent::Impl::POE::],[IO::Async::Loop::=>AnyEvent::Impl::IOAsync::],[Cocoa::EventLoop::=>AnyEvent::Impl::Cocoa::],[FLTK::=>AnyEvent::Impl::FLTK::],);our@isa_hook;sub _isa_set {my@pkg=("AnyEvent",(map $_->[0],grep defined,@isa_hook),$MODEL);@{"$pkg[$_-1]::ISA"}=$pkg[$_]for 1 .. $#pkg;grep $_ && $_->[1],@isa_hook and AE::_reset ()}sub _isa_hook($$;$) {my ($i,$pkg,$reset_ae)=@_;$isa_hook[$i]=$pkg ? [$pkg,$reset_ae]: undef;_isa_set}our@methods=qw(io timer time now now_update signal child idle condvar);sub detect() {return$MODEL if$MODEL;AnyEvent::log fatal=>"IO::Async::Loop::AnyEvent detected - that module is broken by\n" ."design, abuses internals and breaks AnyEvent - will not continue." if exists$INC{"IO/Async/Loop/AnyEvent.pm"};local $!;local$SIG{__DIE__};*detect=sub () {$MODEL};delete @{"AnyEvent::"}{@methods};undef@methods;if ($ENV{PERL_ANYEVENT_MODEL}=~ /^([a-zA-Z0-9:]+)$/){my$model=$1;$model="AnyEvent::Impl::$model" unless$model =~ s/::$//;if (eval "require $model"){AnyEvent::log 7=>"Loaded model '$model' (forced by \$ENV{PERL_ANYEVENT_MODEL}), using it.";$MODEL=$model}else {AnyEvent::log 4=>"Unable to load model '$model' (from \$ENV{PERL_ANYEVENT_MODEL}):\n$@"}}unless ($MODEL){for (@REGISTRY,@models){my ($package,$model)=@$_;if (${"$package\::VERSION"}> 0){if (eval "require $model"){AnyEvent::log 7=>"Autodetected model '$model', using it.";$MODEL=$model;last}else {AnyEvent::log 8=>"Detected event loop $package, but cannot load '$model', skipping: $@"}}}unless ($MODEL){for (@REGISTRY,@models){my ($package,$model)=@$_;if (eval "require $package" and ${"$package\::VERSION"}> 0 and eval "require $model"){AnyEvent::log 7=>"Autoloaded model '$model', using it.";$MODEL=$model;last}}$MODEL or AnyEvent::log fatal=>"Backend autodetection failed - did you properly install AnyEvent?"}}undef@models;undef@REGISTRY;push @{"$MODEL\::ISA"},"AnyEvent::Base";for (qw(time signal child idle)){undef &{"AnyEvent::Base::$_"}if defined &{"$MODEL\::$_"}}_isa_set;if ($ENV{PERL_ANYEVENT_STRICT}){require AnyEvent::Strict}if ($ENV{PERL_ANYEVENT_DEBUG_WRAP}){require AnyEvent::Debug;AnyEvent::Debug::wrap ($ENV{PERL_ANYEVENT_DEBUG_WRAP})}if (length$ENV{PERL_ANYEVENT_DEBUG_SHELL}){require AnyEvent::Socket;require AnyEvent::Debug;my$shell=$ENV{PERL_ANYEVENT_DEBUG_SHELL};$shell =~ s/\$\$/$$/g;my ($host,$service)=AnyEvent::Socket::parse_hostport ($shell);$AnyEvent::Debug::SHELL=AnyEvent::Debug::shell ($host,$service)}(shift@post_detect)->()while@post_detect;undef@post_detect;*post_detect=sub(&) {shift->();undef};$MODEL}for my$name (@methods){*$name=sub {detect;goto &{UNIVERSAL::can AnyEvent=>"SUPER::$name"}}}sub _dupfh($$;$$) {my ($poll,$fh,$r,$w)=@_;my ($rw,$mode)=$poll eq "r" ? ($r,"<&"): ($w,">&");open my$fh2,$mode,$fh or die "AnyEvent->io: cannot dup() filehandle in mode '$poll': $!,";($fh2,$rw)}package AE;our$VERSION=$AnyEvent::VERSION;sub _reset() {eval q{
        # fall back to the main API by default - backends and AnyEvent::Base
        # implementations can overwrite these.
  
        sub io($$$) {
           AnyEvent->io (fh => $_[0], poll => $_[1] ? "w" : "r", cb => $_[2])
        }
  
        sub timer($$$) {
           AnyEvent->timer (after => $_[0], interval => $_[1], cb => $_[2])
        }
  
        sub signal($$) {
           AnyEvent->signal (signal => $_[0], cb => $_[1])
        }
  
        sub child($$) {
           AnyEvent->child (pid => $_[0], cb => $_[1])
        }
  
        sub idle($) {
           AnyEvent->idle (cb => $_[0]);
        }
  
        sub cv(;&) {
           AnyEvent->condvar (@_ ? (cb => $_[0]) : ())
        }
  
        sub now() {
           AnyEvent->now
        }
  
        sub now_update() {
           AnyEvent->now_update
        }
  
        sub time() {
           AnyEvent->time
        }
  
        *postpone = \&AnyEvent::postpone;
        *log      = \&AnyEvent::log;
     };die if $@}BEGIN {_reset}package AnyEvent::Base;sub time {eval q{ # poor man's autoloading {}
        # probe for availability of Time::HiRes
        if (eval "use Time::HiRes (); Time::HiRes::time (); 1") {
           *time     = sub { Time::HiRes::time () };
           *AE::time = \&    Time::HiRes::time     ;
           *now      = \&time;
           AnyEvent::log 8 => "using Time::HiRes for sub-second timing accuracy.";
           # if (eval "use POSIX (); (POSIX::times())...
        } else {
           *time     = sub   { CORE::time };
           *AE::time = sub (){ CORE::time };
           *now      = \&time;
           AnyEvent::log 3 => "Using built-in time(), no sub-second resolution!";
        }
     };die if $@;&time}*now=\&time;sub now_update {}sub _poll {Carp::croak "$AnyEvent::MODEL does not support blocking waits. Caught"}sub condvar {eval q{ # poor man's autoloading {}
        *condvar = sub {
           bless { @_ == 3 ? (_ae_cb => $_[2]) : () }, "AnyEvent::CondVar"
        };
  
        *AE::cv = sub (;&) {
           bless { @_ ? (_ae_cb => shift) : () }, "AnyEvent::CondVar"
        };
     };die if $@;&condvar}our$HAVE_ASYNC_INTERRUPT;sub _have_async_interrupt() {$HAVE_ASYNC_INTERRUPT=1*(!$ENV{PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT}&& eval "use Async::Interrupt 1.02 (); 1")unless defined$HAVE_ASYNC_INTERRUPT;$HAVE_ASYNC_INTERRUPT}our ($SIGPIPE_R,$SIGPIPE_W,%SIG_CB,%SIG_EV,$SIG_IO);our (%SIG_ASY,%SIG_ASY_W);our ($SIG_COUNT,$SIG_TW);sub _sig_add() {unless ($SIG_COUNT++){my$NOW=AE::now;$SIG_TW=AE::timer $MAX_SIGNAL_LATENCY - ($NOW - int$NOW),$MAX_SIGNAL_LATENCY,sub {}}}sub _sig_del {undef$SIG_TW unless --$SIG_COUNT}our$_sig_name_init;$_sig_name_init=sub {eval q{ # poor man's autoloading {}
        undef $_sig_name_init;
  
        if (_have_async_interrupt) {
           *sig2num  = \&Async::Interrupt::sig2num;
           *sig2name = \&Async::Interrupt::sig2name;
        } else {
           require Config;
  
           my %signame2num;
           @signame2num{ split ' ', $Config::Config{sig_name} }
                          = split ' ', $Config::Config{sig_num};
  
           my @signum2name;
           @signum2name[values %signame2num] = keys %signame2num;
  
           *sig2num = sub($) {
              $_[0] > 0 ? shift : $signame2num{+shift}
           };
           *sig2name = sub ($) {
              $_[0] > 0 ? $signum2name[+shift] : shift
           };
        }
     };die if $@};sub sig2num ($) {&$_sig_name_init;&sig2num}sub sig2name($) {&$_sig_name_init;&sig2name}sub signal {eval q{ # poor man's autoloading {}
        # probe for availability of Async::Interrupt 
        if (_have_async_interrupt) {
           AnyEvent::log 8 => "Using Async::Interrupt for race-free signal handling.";
  
           $SIGPIPE_R = new Async::Interrupt::EventPipe;
           $SIG_IO = AE::io $SIGPIPE_R->fileno, 0, \&_signal_exec;
  
        } else {
           AnyEvent::log 8 => "Using emulated perl signal handling with latency timer.";
  
           if (AnyEvent::WIN32) {
              require AnyEvent::Util;
  
              ($SIGPIPE_R, $SIGPIPE_W) = AnyEvent::Util::portable_pipe ();
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_R, 1) if $SIGPIPE_R;
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_W, 1) if $SIGPIPE_W; # just in case
           } else {
              pipe $SIGPIPE_R, $SIGPIPE_W;
              fcntl $SIGPIPE_R, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_R;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_W; # just in case
  
              # not strictly required, as $^F is normally 2, but let's make sure...
              fcntl $SIGPIPE_R, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
           }
  
           $SIGPIPE_R
              or Carp::croak "AnyEvent: unable to create a signal reporting pipe: $!\n";
  
           $SIG_IO = AE::io $SIGPIPE_R, 0, \&_signal_exec;
        }
  
        *signal = $HAVE_ASYNC_INTERRUPT
           ? sub {
                my (undef, %arg) = @_;
  
                # async::interrupt
                my $signal = sig2num $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG_ASY{$signal} ||= new Async::Interrupt
                   cb             => sub { undef $SIG_EV{$signal} },
                   signal         => $signal,
                   pipe           => [$SIGPIPE_R->filenos],
                   pipe_autodrain => 0,
                ;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
           : sub {
                my (undef, %arg) = @_;
  
                # pure perl
                my $signal = sig2name $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG{$signal} ||= sub {
                   local $!;
                   syswrite $SIGPIPE_W, "\x00", 1 unless %SIG_EV;
                   undef $SIG_EV{$signal};
                };
  
                # can't do signal processing without introducing races in pure perl,
                # so limit the signal latency.
                _sig_add;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
        ;
  
        *AnyEvent::Base::signal::DESTROY = sub {
           my ($signal, $cb) = @{$_[0]};
  
           _sig_del;
  
           delete $SIG_CB{$signal}{$cb};
  
           $HAVE_ASYNC_INTERRUPT
              ? delete $SIG_ASY{$signal}
              : # delete doesn't work with older perls - they then
                # print weird messages, or just unconditionally exit
                # instead of getting the default action.
                undef $SIG{$signal}
              unless keys %{ $SIG_CB{$signal} };
        };
  
        *_signal_exec = sub {
           $HAVE_ASYNC_INTERRUPT
              ? $SIGPIPE_R->drain
              : sysread $SIGPIPE_R, (my $dummy), 9;
  
           while (%SIG_EV) {
              for (keys %SIG_EV) {
                 delete $SIG_EV{$_};
                 &$_ for values %{ $SIG_CB{$_} || {} };
              }
           }
        };
     };die if $@;&signal}our%PID_CB;our$CHLD_W;our$CHLD_DELAY_W;sub _emit_childstatus($$) {my (undef,$rpid,$rstatus)=@_;$_->($rpid,$rstatus)for values %{$PID_CB{$rpid}|| {}},values %{$PID_CB{0}|| {}}}sub child {eval q{ # poor man's autoloading {}
        *_sigchld = sub {
           my $pid;
  
           AnyEvent->_emit_childstatus ($pid, $?)
              while ($pid = waitpid -1, WNOHANG) > 0;
        };
  
        *child = sub {
           my (undef, %arg) = @_;
  
           my $pid = $arg{pid};
           my $cb  = $arg{cb};
  
           $PID_CB{$pid}{$cb+0} = $cb;
  
           unless ($CHLD_W) {
              $CHLD_W = AE::signal CHLD => \&_sigchld;
              # child could be a zombie already, so make at least one round
              &_sigchld;
           }
  
           bless [$pid, $cb+0], "AnyEvent::Base::child"
        };
  
        *AnyEvent::Base::child::DESTROY = sub {
           my ($pid, $icb) = @{$_[0]};
  
           delete $PID_CB{$pid}{$icb};
           delete $PID_CB{$pid} unless keys %{ $PID_CB{$pid} };
  
           undef $CHLD_W unless keys %PID_CB;
        };
     };die if $@;&child}sub idle {eval q{ # poor man's autoloading {}
        *idle = sub {
           my (undef, %arg) = @_;
  
           my ($cb, $w, $rcb) = $arg{cb};
  
           $rcb = sub {
              if ($cb) {
                 $w = AE::time;
                 &$cb;
                 $w = AE::time - $w;
  
                 # never use more then 50% of the time for the idle watcher,
                 # within some limits
                 $w = 0.0001 if $w < 0.0001;
                 $w = 5      if $w > 5;
  
                 $w = AE::timer $w, 0, $rcb;
              } else {
                 # clean up...
                 undef $w;
                 undef $rcb;
              }
           };
  
           $w = AE::timer 0.05, 0, $rcb;
  
           bless \\$cb, "AnyEvent::Base::idle"
        };
  
        *AnyEvent::Base::idle::DESTROY = sub {
           undef $${$_[0]};
        };
     };die if $@;&idle}package AnyEvent::CondVar;our@ISA=AnyEvent::CondVar::Base::;sub new {my$class=shift;bless AnyEvent->condvar (@_),$class}package AnyEvent::CondVar::Base;${"AnyEvent::CondVar::Base::OVERLOAD"}{dummy}++;*{'AnyEvent::CondVar::Base::()'}=sub {};*{'AnyEvent::CondVar::Base::(&{}'}=sub {my$self=shift;sub {$self->send (@_)}};${'AnyEvent::CondVar::Base::()'}=1;our$WAITING;sub _send {}sub _wait {AnyEvent->_poll until $_[0]{_ae_sent}}sub send {my$cv=shift;$cv->{_ae_sent}=[@_];(delete$cv->{_ae_cb})->($cv)if$cv->{_ae_cb};$cv->_send}sub croak {$_[0]{_ae_croak}=$_[1];$_[0]->send}sub ready {$_[0]{_ae_sent}}sub recv {unless ($_[0]{_ae_sent}){$WAITING and Carp::croak "AnyEvent::CondVar: recursive blocking wait attempted";local$WAITING=1;$_[0]->_wait}$_[0]{_ae_croak}and Carp::croak $_[0]{_ae_croak};wantarray ? @{$_[0]{_ae_sent}}: $_[0]{_ae_sent}[0]}sub cb {my$cv=shift;@_ and $cv->{_ae_cb}=shift and $cv->{_ae_sent}and (delete$cv->{_ae_cb})->($cv);$cv->{_ae_cb}}sub begin {++$_[0]{_ae_counter};$_[0]{_ae_end_cb}=$_[1]if @_ > 1}sub end {return if --$_[0]{_ae_counter};&{$_[0]{_ae_end_cb}|| sub {$_[0]->send}}}*broadcast=\&send;*wait=\&recv;undef$SIG{CHLD}if$SIG{CHLD}eq 'IGNORE';$SIG{PIPE}=sub {}unless defined$SIG{PIPE};1
ANYEVENT

$fatpacked{"AnyEvent/DNS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DNS';
  package AnyEvent::DNS;use Carp ();use Socket qw(AF_INET SOCK_DGRAM SOCK_STREAM);use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util qw(AF_INET6);our$VERSION=$AnyEvent::VERSION;our@DNS_FALLBACK;{my$prep=sub {$_=$_->[rand @$_]for @_;push @_,splice @_,rand $_,0.01 for reverse 1..@_;$_=pack "H*",$_ for @_;\@_};my$ipv4=$prep->(["08080808","08080404"],);my$ipv6=$prep->(["20014860486000000000000000008888","20014860486000000000000000008844"],);undef$ipv4 unless$AnyEvent::PROTOCOL{ipv4};undef$ipv6 unless$AnyEvent::PROTOCOL{ipv6};($ipv6,$ipv4)=($ipv4,$ipv6)if$AnyEvent::PROTOCOL{ipv6}> $AnyEvent::PROTOCOL{ipv4};@DNS_FALLBACK=(@$ipv4,@$ipv6)}sub MAX_PKT() {4096}sub DOMAIN_PORT() {53}sub resolver ();sub a($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"a",sub {$cb->(map $_->[4],@_)})}sub aaaa($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"aaaa",sub {$cb->(map $_->[4],@_)})}sub mx($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"mx",sub {$cb->(map $_->[5],sort {$a->[4]<=> $b->[4]}@_)})}sub ns($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"ns",sub {$cb->(map $_->[4],@_)})}sub txt($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"txt",sub {$cb->(map $_->[4],@_)})}sub srv($$$$) {my ($service,$proto,$domain,$cb)=@_;resolver->resolve ("_$service._$proto.$domain"=>"srv",sub {my@res;my%pri;push @{$pri{$_->[4]}},[@$_[4,5,6,7]]for @_;for my$pri (sort {$a <=> $b}keys%pri){my@rr=sort {$a->[1]<=> $b->[1]}@{delete$pri{$pri}};my$sum;$sum += $_->[1]for@rr;while (@rr){my$w=int rand$sum + 1;for (0 .. $#rr){if (($w -= $rr[$_][1])<= 0){$sum -= $rr[$_][1];push@res,splice@rr,$_,1,();last}}}}$cb->(@res)})}sub ptr($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"ptr",sub {$cb->(map $_->[4],@_)})}sub any($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"*",$cb)}sub _munge_ptr($) {my$ipn=$_[0]or return;my$ptr;my$af=AnyEvent::Socket::address_family ($ipn);if ($af==AF_INET6){$ipn=substr$ipn,0,16;if ($ipn =~ s/^\x00{10}(?:\xff\xff|\x00\x00)//){$af=AF_INET}else {$ptr=join ".",(reverse split //,unpack "H32",$ipn),"ip6.arpa."}}if ($af==AF_INET){$ptr=join ".",(reverse unpack "C4",$ipn),"in-addr.arpa."}$ptr}sub reverse_lookup($$) {my ($ip,$cb)=@_;$ip=_munge_ptr AnyEvent::Socket::parse_address ($ip)or return$cb->();resolver->resolve ($ip=>"ptr",sub {$cb->(map $_->[4],@_)})}sub reverse_verify($$) {my ($ip,$cb)=@_;my$ipn=AnyEvent::Socket::parse_address ($ip)or return$cb->();my$af=AnyEvent::Socket::address_family ($ipn);my@res;my$cnt;my$ptr=_munge_ptr$ipn or return$cb->();$ip=AnyEvent::Socket::format_address ($ipn);ptr$ptr,sub {for my$name (@_){++$cnt;resolver->resolve ("$name."=>($af==(AF_INET)? "a" : "aaaa"),sub {for (@_){push@res,$name if $_->[4]eq $ip}$cb->(@res)unless --$cnt})}$cb->()unless$cnt}}our$EDNS0=$ENV{PERL_ANYEVENT_EDNS0}*1;our%opcode_id=(query=>0,iquery=>1,status=>2,notify=>4,update=>5,map +($_=>$_),3,6..15);our%opcode_str=reverse%opcode_id;our%rcode_id=(noerror=>0,formerr=>1,servfail=>2,nxdomain=>3,notimp=>4,refused=>5,yxdomain=>6,yxrrset=>7,nxrrset=>8,notauth=>9,notzone=>10,map +($_=>$_),11..15);our%rcode_str=reverse%rcode_id;our%type_id=(a=>1,ns=>2,md=>3,mf=>4,cname=>5,soa=>6,mb=>7,mg=>8,mr=>9,null=>10,wks=>11,ptr=>12,hinfo=>13,minfo=>14,mx=>15,txt=>16,aaaa=>28,srv=>33,naptr=>35,dname=>39,opt=>41,spf=>99,tkey=>249,tsig=>250,ixfr=>251,axfr=>252,mailb=>253,"*"=>255,);our%type_str=reverse%type_id;our%class_id=(in=>1,ch=>3,hs=>4,none=>254,"*"=>255,);our%class_str=reverse%class_id;sub _enc_name($) {pack "(C/a*)*",(split /\./,shift),""}if ($] < 5.008){*_enc_name=sub ($) {join "",map +(pack "C/a*",$_),(split /\./,shift),""}}sub _enc_qd() {(_enc_name $_->[0]).pack "nn",($_->[1]> 0 ? $_->[1]: $type_id {$_->[1]}),($_->[3]> 0 ? $_->[2]: $class_id{$_->[2]|| "in"})}sub _enc_rr() {die "encoding of resource records is not supported"}sub dns_pack($) {my ($req)=@_;pack "nn nnnn a* a* a* a* a*",$req->{id},!!$req->{qr}* 0x8000 + $opcode_id{$req->{op}}* 0x0800 +!!$req->{aa}* 0x0400 +!!$req->{tc}* 0x0200 +!!$req->{rd}* 0x0100 +!!$req->{ra}* 0x0080 +!!$req->{ad}* 0x0020 +!!$req->{cd}* 0x0010 + $rcode_id{$req->{rc}}* 0x0001,scalar @{$req->{qd}|| []},scalar @{$req->{an}|| []},scalar @{$req->{ns}|| []},$EDNS0 + scalar @{$req->{ar}|| []},(join "",map _enc_qd,@{$req->{qd}|| []}),(join "",map _enc_rr,@{$req->{an}|| []}),(join "",map _enc_rr,@{$req->{ns}|| []}),(join "",map _enc_rr,@{$req->{ar}|| []}),($EDNS0 ? pack "C nnNn",0,41,MAX_PKT,0,0 : "")}our$ofs;our$pkt;sub _dec_name {my@res;my$redir;my$ptr=$ofs;my$cnt;while (){return undef if ++$cnt >= 256;my$len=ord substr$pkt,$ptr++,1;if ($len >= 0xc0){$ptr++;$ofs=$ptr if$ptr > $ofs;$ptr=(unpack "n",substr$pkt,$ptr - 2,2)& 0x3fff}elsif ($len){push@res,substr$pkt,$ptr,$len;$ptr += $len}else {$ofs=$ptr if$ptr > $ofs;return join ".",@res}}}sub _dec_qd {my$qname=_dec_name;my ($qt,$qc)=unpack "nn",substr$pkt,$ofs;$ofs += 4;[$qname,$type_str{$qt}|| $qt,$class_str{$qc}|| $qc]}our%dec_rr=(1=>sub {join ".",unpack "C4",$_},2=>sub {local$ofs=$ofs - length;_dec_name},5=>sub {local$ofs=$ofs - length;_dec_name},6=>sub {local$ofs=$ofs - length;my$mname=_dec_name;my$rname=_dec_name;($mname,$rname,unpack "NNNNN",substr$pkt,$ofs)},11=>sub {((join ".",unpack "C4",$_),unpack "C a*",substr $_,4)},12=>sub {local$ofs=$ofs - length;_dec_name},13=>sub {unpack "C/a* C/a*",$_},15=>sub {local$ofs=$ofs + 2 - length;((unpack "n",$_),_dec_name)},16=>sub {unpack "(C/a*)*",$_},28=>sub {AnyEvent::Socket::format_ipv6 ($_)},33=>sub {local$ofs=$ofs + 6 - length;((unpack "nnn",$_),_dec_name)},35=>sub {my ($order,$preference,$flags,$service,$regexp,$offset)=unpack "nn C/a* C/a* C/a* .",$_;local$ofs=$ofs + $offset - length;($order,$preference,$flags,$service,$regexp,_dec_name)},39=>sub {local$ofs=$ofs - length;_dec_name},99=>sub {unpack "(C/a*)*",$_},);sub _dec_rr {my$name=_dec_name;my ($rt,$rc,$ttl,$rdlen)=unpack "nn N n",substr$pkt,$ofs;$ofs += 10;local $_=substr$pkt,$ofs,$rdlen;$ofs += $rdlen;[$name,$type_str{$rt}|| $rt,$class_str{$rc}|| $rc,$ttl,($dec_rr{$rt}|| sub {$_})->(),]}sub dns_unpack($) {local$pkt=shift;my ($id,$flags,$qd,$an,$ns,$ar)=unpack "nn nnnn A*",$pkt;local$ofs=6 * 2;{id=>$id,qr=>!!($flags & 0x8000),aa=>!!($flags & 0x0400),tc=>!!($flags & 0x0200),rd=>!!($flags & 0x0100),ra=>!!($flags & 0x0080),ad=>!!($flags & 0x0020),cd=>!!($flags & 0x0010),op=>$opcode_str{($flags & 0x001e)>> 11},rc=>$rcode_str{($flags & 0x000f)},qd=>[map _dec_qd,1 .. $qd],an=>[map _dec_rr,1 .. $an],ns=>[map _dec_rr,1 .. $ns],ar=>[map _dec_rr,1 .. $ar],}}use Carp ();use Scalar::Util ();use Socket ();our$NOW;our$RESOLVER;sub resolver() {$RESOLVER || do {$RESOLVER=new AnyEvent::DNS untaint=>1,max_outstanding=>$ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}*1 || 10,;$ENV{PERL_ANYEVENT_RESOLV_CONF}? $RESOLVER->_load_resolv_conf_file ($ENV{PERL_ANYEVENT_RESOLV_CONF}): $RESOLVER->os_config;$RESOLVER}}sub new {my ($class,%arg)=@_;my$self=bless {server=>[],timeout=>[2,5,5],search=>[],ndots=>1,max_outstanding=>10,reuse=>300,%arg,inhibit=>0,reuse_q=>[],},$class;my$got_socket;Scalar::Util::weaken (my$wself=$self);if (socket my$fh4,AF_INET,Socket::SOCK_DGRAM(),0){++$got_socket;AnyEvent::fh_unblock$fh4;$self->{fh4}=$fh4;$self->{rw4}=AE::io$fh4,0,sub {if (my$peer=recv$fh4,my$pkt,MAX_PKT,0){$wself->_recv ($pkt,$peer)}}}if (AF_INET6 && socket my$fh6,AF_INET6,Socket::SOCK_DGRAM(),0){++$got_socket;$self->{fh6}=$fh6;AnyEvent::fh_unblock$fh6;$self->{rw6}=AE::io$fh6,0,sub {if (my$peer=recv$fh6,my$pkt,MAX_PKT,0){$wself->_recv ($pkt,$peer)}}}$got_socket or Carp::croak "unable to create either an IPv4 or an IPv6 socket";$self->_compile;$self}sub _config_begin {++$_[0]{inhibit}}sub _config_done {--$_[0]{inhibit};$_[0]->_compile;$_[0]->_scheduler}sub parse_resolv_conf {my ($self,$resolvconf)=@_;$self->{server}=[];$self->{search}=[];my$attempts;for (split /\n/,$resolvconf){s/\s*[;#].*$//;if (/^\s*nameserver\s+(\S+)\s*$/i){my$ip=$1;if (my$ipn=AnyEvent::Socket::parse_address ($ip)){push @{$self->{server}},$ipn}else {AE::log 5=>"nameserver $ip invalid and ignored, while parsing resolver config."}}elsif (/^\s*domain\s+(\S*)\s*$/i){$self->{search}=[$1]}elsif (/^\s*search\s+(.*?)\s*$/i){$self->{search}=[split /\s+/,$1]}elsif (/^\s*sortlist\s+(.*?)\s*$/i){}elsif (/^\s*options\s+(.*?)\s*$/i){for (split /\s+/,$1){if (/^timeout:(\d+)$/){$self->{timeout}=[$1]}elsif (/^attempts:(\d+)$/){$attempts=$1}elsif (/^ndots:(\d+)$/){$self->{ndots}=$1}else {}}}else {}}$self->{timeout}=[($self->{timeout}[0])x $attempts]if$attempts;$self->_compile}sub _load_resolv_conf_file {my ($self,$resolv_conf)=@_;$self->_config_begin;require AnyEvent::IO;AnyEvent::IO::aio_load ($resolv_conf,sub {if (my ($contents)=@_){$self->parse_resolv_conf ($contents)}else {AE::log 4=>"$resolv_conf: $!"}$self->_config_done})}sub os_config {my ($self)=@_;$self->_config_begin;$self->{server}=[];$self->{search}=[];if ((AnyEvent::WIN32 || $^O =~ /cygwin/i)){unless (eval {require Net::DNS::Resolver;my$r=Net::DNS::Resolver->new;$r->nameservers or die;for my$s ($r->nameservers){if (my$ipn=AnyEvent::Socket::parse_address ($s)){push @{$self->{server}},$ipn}}$self->{search}=[$r->searchlist];1}){if (open my$fh,"ipconfig /all |"){my$dns;local $_;while (<$fh>){if (s/^\s.*\bdns\b.*://i){$dns=1}elsif (/^\S/ || /^\s[^:]{16,}: /){$dns=0}if ($dns && /^\s*(\S+)\s*$/){my$s=$1;$s =~ s/%\d+(?!\S)//;if (my$ipn=AnyEvent::Socket::parse_address ($s)){push @{$self->{server}},$ipn}else {push @{$self->{search}},$s}}}}}push @{$self->{server}},@DNS_FALLBACK;$self->_config_done}else {require AnyEvent::IO;AnyEvent::IO::aio_stat ("/etc/resolv.conf",sub {$self->_load_resolv_conf_file ("/etc/resolv.conf")if @_;$self->_config_done})}}sub timeout {my ($self,@timeout)=@_;$self->{timeout}=\@timeout;$self->_compile}sub max_outstanding {my ($self,$max)=@_;$self->{max_outstanding}=$max;$self->_compile}sub _compile {my$self=shift;my%search;$self->{search}=[grep 0 < length,grep!$search{$_}++,@{$self->{search}}];my%server;$self->{server}=[grep 0 < length,grep!$server{$_}++,@{$self->{server}}];unless (@{$self->{server}}){my$default=$AnyEvent::PROTOCOL{ipv6}> $AnyEvent::PROTOCOL{ipv4}? "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1" : "\x7f\x00\x00\x01";$self->{server}=[$default,@DNS_FALLBACK]}my@retry;for my$timeout (@{$self->{timeout}}){for my$server (@{$self->{server}}){push@retry,[$server,$timeout]}}$self->{retry}=\@retry}sub _feed {my ($self,$res)=@_;($res)=$res =~ /^(.*)$/s if AnyEvent::TAINT && $self->{untaint};$res=dns_unpack$res or return;my$id=$self->{id}{$res->{id}};return unless ref$id;$NOW=time;$id->[1]->($res)}sub _recv {my ($self,$pkt,$peer)=@_;my ($port,$host)=AnyEvent::Socket::unpack_sockaddr ($peer);return unless$port==DOMAIN_PORT && grep $_ eq $host,@{$self->{server}};$self->_feed ($pkt)}sub _free_id {my ($self,$id,$timeout)=@_;if ($timeout){$self->{id}{$id}=1;push @{$self->{reuse_q}},[$NOW + $self->{reuse},$id]}else {delete$self->{id}{$id}}--$self->{outstanding};$self->_scheduler}sub _exec {my ($self,$req)=@_;my$retry;my$do_retry;$do_retry=sub {my$retry_cfg=$self->{retry}[$retry++]or do {$self->_free_id ($req->[2],$retry > 1);undef$do_retry;return$req->[1]->()};my ($server,$timeout)=@$retry_cfg;$self->{id}{$req->[2]}=[(AE::timer$timeout,0,sub {$NOW=time;&$do_retry if$do_retry}),sub {my ($res)=@_;if ($res->{tc}){AnyEvent::Socket::tcp_connect (AnyEvent::Socket::format_address ($server),DOMAIN_PORT,sub {return unless$do_retry;my ($fh)=@_ or return &$do_retry;require AnyEvent::Handle;my$handle;$handle=new AnyEvent::Handle fh=>$fh,timeout=>$timeout,on_error=>sub {undef$handle;return unless$do_retry;&$do_retry};$handle->push_write (pack "n/a*",$req->[0]);$handle->push_read (chunk=>2,sub {$handle->unshift_read (chunk=>(unpack "n",$_[1]),sub {undef$handle;$self->_feed ($_[1])})})},sub {$timeout})}else {$self->_free_id ($req->[2],$retry > 1);undef$do_retry;return$req->[1]->($res)}}];my$sa=AnyEvent::Socket::pack_sockaddr (DOMAIN_PORT,$server);my$fh=AF_INET==AnyEvent::Socket::sockaddr_family ($sa)? $self->{fh4}: $self->{fh6}or return &$do_retry;send$fh,$req->[0],0,$sa};&$do_retry}sub _scheduler {my ($self)=@_;return if$self->{inhibit};$NOW=time;delete$self->{id}{(shift @{$self->{reuse_q}})->[1]}while @{$self->{reuse_q}}&& $self->{reuse_q}[0][0]<= $NOW;while ($self->{outstanding}< $self->{max_outstanding}){if (@{$self->{reuse_q}}>= 30000){$self->{reuse_to}||= AE::timer$self->{reuse_q}[0][0]- $NOW,0,sub {delete$self->{reuse_to};$self->_scheduler};last}if (my$req=shift @{$self->{queue}}){while (){$req->[2]=int rand 65536;last unless exists$self->{id}{$req->[2]}}++$self->{outstanding};$self->{id}{$req->[2]}=1;substr$req->[0],0,2,pack "n",$req->[2];$self->_exec ($req)}elsif (my$cb=shift @{$self->{wait}}){$cb->($self)}else {last}}}sub request($$) {my ($self,$req,$cb)=@_;for (@{$req->{qd}}){return AE::postpone sub {$cb->(undef)}if 255 < length $_->[0]}push @{$self->{queue}},[dns_pack$req,$cb];$self->_scheduler}sub resolve($%) {my$cb=pop;my ($self,$qname,$qtype,%opt)=@_;$self->wait_for_slot (sub {my$self=shift;my@search=$qname =~ s/\.$// ? "" : $opt{search}? @{$opt{search}}: ($qname =~ y/.//)>= $self->{ndots}? ("",@{$self->{search}}): (@{$self->{search}},"");my$class=$opt{class}|| "in";my%atype=$opt{accept}? map +($_=>1),@{$opt{accept}}: ($qtype=>1);my ($do_search,$do_req);$do_search=sub {@search or (undef$do_search),(undef$do_req),return$cb->();(my$name=lc "$qname." .shift@search)=~ s/\.$//;my$depth=10;$do_req=sub {$self->request ({rd=>1,qd=>[[$name,$qtype,$class]],},sub {my ($res)=@_ or return$do_search->();my$cname;while (){my@rr=grep$name eq lc $_->[0]&& ($atype{"*"}|| $atype{$_->[1]}),@{$res->{an}};(undef$do_search),(undef$do_req),return$cb->(@rr)if@rr;my@rr=grep$name eq lc $_->[0]&& $_->[1]eq "cname",@{$res->{an}};if (@rr){$depth-- or return$do_search->();$cname=1;$name=lc$rr[0][4]}elsif ($cname){return$do_req->()}else {return$do_search->()}}})};$do_req->()};$do_search->()})}sub wait_for_slot {my ($self,$cb)=@_;push @{$self->{wait}},$cb;$self->_scheduler}use AnyEvent::Socket ();1
ANYEVENT_DNS

$fatpacked{"AnyEvent/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DEBUG';
  package AnyEvent::Debug;use B ();use Carp ();use Errno ();use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util ();use AnyEvent::Socket ();use AnyEvent::Log ();our$TRACE=1;our ($TRACE_LOGGER,$TRACE_ENABLED);our%STRCACHE;sub shell($$) {local$TRACE=0;AnyEvent::Socket::tcp_server $_[0],$_[1],sub {my ($fh,$host,$port)=@_;syswrite$fh,"Welcome, $host:$port, use 'help' for more info!\015\012> ";my$rbuf;my$logger=new AnyEvent::Log::Ctx log_cb=>sub {syswrite$fh,shift;0};my$logger_guard=AnyEvent::Util::guard {$AnyEvent::Log::COLLECT->detach ($logger)};$AnyEvent::Log::COLLECT->attach ($logger);local$TRACE=0;my$rw;$rw=AE::io$fh,0,sub {my$len=sysread$fh,$rbuf,1024,length$rbuf;$logger_guard if 0;if (defined$len ? $len==0 : ($!!=Errno::EAGAIN && $!!=Errno::EWOULDBLOCK)){undef$rw}else {while ($rbuf =~ s/^(.*)\015?\012//){my$line=$1;AnyEvent::fh_block$fh;if ($line =~ /^\s*exit\b/){syswrite$fh,"sorry, no... if you want to execute exit, try CORE::exit.\015\012"}elsif ($line =~ /^\s*coro\b\s*(.*)/){my$arg=$1;if (eval {require Coro;require Coro::Debug}){if ($arg =~ /\S/){Coro::async (sub {select$fh;Coro::Debug::command ($arg);local $|=1;syswrite$fh,"> "});return}else {undef$rw;syswrite$fh,"switching to Coro::Debug...\015\012";Coro::async (sub {Coro::Debug::session ($fh)});return}}else {syswrite$fh,"Coro not available.\015\012"}}else {package AnyEvent::Debug::shell;no strict 'vars';local$LOGGER=$logger;my$old_stdout=select$fh;local $|=1;my@res=eval$line;select$old_stdout;syswrite$fh,"$@" if $@;syswrite$fh,"\015\012";if (@res > 1){syswrite$fh,"$_: $res[$_]\015\012" for 0 .. $#res}elsif (@res==1){syswrite$fh,"$res[0]\015\012"}}syswrite$fh,"> ";AnyEvent::fh_unblock$fh}}}}}{package AnyEvent::Debug::shell;our$LOGGER;sub help() {<<EOF}sub wl(;$) {my$re=@_ ? qr<$_[0]>i : qr<.>;my%res;while (my ($k,$v)=each%AnyEvent::Debug::Wrapped){my$s="$v";$res{$s}=$k .(exists$v->{error}? "*" : " ")if$s =~ $re}join "",map "$res{$_} $_\n",sort keys%res}sub w {map {$AnyEvent::Debug::Wrapped{$_}|| do {print "$_: no such wrapped watcher.\n";()}}@_}sub i {join "",map $_->id ." $_\n" .$_->verbose ."\n",&w}sub wr {AnyEvent::Debug::wrap (@_);"wrap level now $AnyEvent::Debug::WRAP_LEVEL"}sub t {if (@_){@_=&w;$_->trace (1)for @_;"tracing enabled for @_."}else {$AnyEvent::Debug::TRACE=1;"tracing for newly created watchers is now enabled."}}sub u {if (@_){@_=&w;$_->trace (0)for @_;"tracing disabled for @_."}else {$AnyEvent::Debug::TRACE=0;"tracing for newly created watchers is now disabled."}}sub v {$LOGGER->level (@_ ? $_[0]: $LOGGER->[1]? 0 : 9);"verbose logging is now " .($LOGGER->[1]? "enabled" : "disabled")."."}}our$WRAP_LEVEL;our$TRACE_CUR;our$POST_DETECT;sub wrap(;$) {my$PREV_LEVEL=$WRAP_LEVEL;$WRAP_LEVEL=@_ ? 0+shift : $WRAP_LEVEL ? 0 : 1;if ($AnyEvent::MODEL){if ($WRAP_LEVEL &&!$PREV_LEVEL){$TRACE_LOGGER=AnyEvent::Log::logger trace=>\$TRACE_ENABLED;AnyEvent::_isa_hook 0=>"AnyEvent::Debug::Wrap",1;AnyEvent::Debug::Wrap::_reset ()}elsif (!$WRAP_LEVEL && $PREV_LEVEL){AnyEvent::_isa_hook 0=>undef}}else {$POST_DETECT ||= AnyEvent::post_detect {undef$POST_DETECT;return unless$WRAP_LEVEL;(my$level,$WRAP_LEVEL)=($WRAP_LEVEL,undef);require AnyEvent::Strict unless$AnyEvent::Strict::VERSION;AnyEvent::post_detect {wrap ($level)}}}}sub path2mod($) {keys%INC;while (my ($k,$v)=each%INC){if ($_[0]eq $v){$k =~ s%/%::%g if$k =~ s/\.pm$//;return$k}}my$path=shift;$path =~ s%^\./%%;$path}sub cb2str($) {my$cb=shift;"CODE" eq ref$cb or return "$cb";eval {my$cv=B::svref_2object ($cb);my$gv=$cv->GV or return "$cb";my$name=$gv->NAME;return (AnyEvent::Debug::path2mod$gv->FILE).":" .$gv->LINE if$name eq "__ANON__";$gv->STASH->NAME ."::" .$name}|| "$cb"}sub sv2str($) {if (ref $_[0]){if (ref $_[0]eq "CODE"){return "$_[0]=" .cb2str $_[0]}else {return "$_[0]"}}else {for ("\'$_[0]\'"){substr $_,$Carp::MaxArgLen,length,"'..." if length > $Carp::MaxArgLen;return $_}}}sub backtrace(;$) {my$w=shift;my (@bt,@c);my ($modlen,$sub);for (;;){package DB;@c=caller$w++ or last;package AnyEvent::Debug;if ($c[7]){$sub="require $c[6]"}elsif (defined$c[6]){$sub="eval \"\""}else {$sub=($c[4]? "" : "&").$c[3];$sub .= "(" .(join ",",map sv2str$DB::args[$_],0 .. (@DB::args < $Carp::MaxArgNums ? @DB::args : $Carp::MaxArgNums)- 1).")" if$c[4]}push@bt,[\($STRCACHE{$c[1]}||= $c[1]),$c[2],$sub]}@DB::args=();bless \@bt,"AnyEvent::Debug::Backtrace"}package AnyEvent::Debug::Wrap;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Scalar::Util ();use Carp ();sub _reset {for my$name (qw(io timer signal child idle)){my$super="SUPER::$name";*$name=sub {my ($self,%arg)=@_;my$w;my$t=$TRACE;my ($pkg,$file,$line,$sub);$w=0;do {($pkg,$file,$line)=caller$w++}while$pkg =~ /^(?:AE|AnyEvent::(?:Socket|Handle|Util|Debug|Strict|Base|CondVar|CondVar::Base|Impl::.*)|Coro::AnyEvent::CondVar)$/;$sub=(caller$w)[3];my$cb=$arg{cb};$arg{cb}=sub {++$w->{called};local$TRACE_CUR=$w;$TRACE_LOGGER->("enter $w")if$TRACE_ENABLED && $t;eval {local$SIG{__DIE__}=sub {die $_[0].AnyEvent::Debug::backtrace if defined $^S};&$cb};if ($@){my$err="$@";push @{$w->{error}},[AE::now,$err]if @{$w->{error}}< 10;AE::log die=>"($w) $err" or warn "($w) $err"}$TRACE_LOGGER->("leave $w")if$TRACE_ENABLED && $t};$self=bless {type=>$name,w=>$self->$super (%arg),rfile=>\($STRCACHE{$file}||= $file),line=>$line,sub=>$sub,cur=>"$TRACE_CUR",now=>AE::now,arg=>\%arg,cb=>$cb,called=>0,rt=>\$t,},"AnyEvent::Debug::Wrapped";delete$arg{cb};$self->{bt}=AnyEvent::Debug::backtrace 1 if$WRAP_LEVEL >= 2;Scalar::Util::weaken ($w=$self);Scalar::Util::weaken ($AnyEvent::Debug::Wrapped{Scalar::Util::refaddr$self}=$self);$TRACE_LOGGER->("creat $w")if$TRACE_ENABLED && $t;$self}}}package AnyEvent::Debug::Wrapped;use AnyEvent ();BEGIN {AnyEvent::common_sense}use overload '""'=>sub {$_[0]{str}||= do {my ($pkg,$line)=@{$_[0]{caller}};my$mod=AnyEvent::Debug::path2mod ${$_[0]{rfile}};my$sub=$_[0]{sub};if (defined$sub){$sub =~ s/^\Q$mod\E:://;$sub="($sub)"}"$mod:$_[0]{line}$sub>$_[0]{type}>" .(AnyEvent::Debug::cb2str $_[0]{cb})}},fallback=>1,;sub id {Scalar::Util::refaddr shift}sub verbose {my ($self)=@_;my$res="type:    $self->{type} watcher\n" ."args:    " .(join " ",%{$self->{arg}})."\n" ."created: " .(AnyEvent::Log::format_time$self->{now})." ($self->{now})\n" ."file:    ${ $self->{rfile} }\n" ."line:    $self->{line}\n" ."subname: $self->{sub}\n" ."context: $self->{cur}\n" ."tracing: " .(${$self->{rt}}? "enabled" : "disabled")."\n" ."cb:      $self->{cb} (" .(AnyEvent::Debug::cb2str$self->{cb}).")\n" ."invoked: $self->{called} times\n";if (exists$self->{bt}){$res .= "created\n$self->{bt}"}if (exists$self->{error}){$res .= "errors:   " .@{$self->{error}}."\n";$res .= "error: " .(AnyEvent::Log::format_time $_->[0])." ($_->[0]) $_->[1]\n" for @{$self->{error}}}$res}sub trace {${$_[0]{rt}}=$_[1]}sub DESTROY {$TRACE_LOGGER->("dstry $_[0]")if$TRACE_ENABLED && ${$_[0]{rt}};delete$AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $_[0]}}package AnyEvent::Debug::Backtrace;use AnyEvent ();BEGIN {AnyEvent::common_sense}sub as_string {my ($self)=@_;my@bt;my$modlen;for (@$self){my ($rpath,$line,$sub)=@$_;$rpath=(AnyEvent::Debug::path2mod $$rpath)." line $line";$modlen=length$rpath if$modlen < length$rpath;$sub =~ s/\r/\\r/g;$sub =~ s/\n/\\n/g;$sub =~ s/([\x00-\x1f\x7e-\xff])/sprintf "\\x%02x", ord $1/ge;$sub =~ s/([^\x20-\x7e])/sprintf "\\x{%x}", ord $1/ge;push@bt,[$rpath,$sub]}join "",map {sprintf "%*s %s\n",-$modlen,$_->[0],$_->[1]}@bt}use overload '""'=>\&as_string,fallback=>1,;1
  help         this command
  wr [level]   sets wrap level to level (or toggles if missing)
  v [level]    sets verbosity (or toggles between 0 and 9 if missing)
  wl 'regex'   print wrapped watchers matching the regex (or all if missing)
  i id,...     prints the watcher with the given ids in more detail
  t            enable tracing for newly created watchers (enabled by default)
  ut           disable tracing for newly created watchers
  t  id,...    enable tracing for the given watcher (enabled by default)
  ut id,...    disable tracing for the given watcher
  w id,...     converts the watcher ids to watcher objects (for scripting)
  coro xxx     run xxx as Coro::Debug shell command, if available
  coro         switch to Coro::Debug shell, if available
  EOF
ANYEVENT_DEBUG

$fatpacked{"AnyEvent/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_HANDLE';
  package AnyEvent::Handle;use Scalar::Util ();use List::Util ();use Carp ();use Errno qw(EAGAIN EWOULDBLOCK EINTR);use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util qw(WSAEWOULDBLOCK);our$VERSION=$AnyEvent::VERSION;sub _load_func($) {my$func=$_[0.01];unless (defined &$func){my$pkg=$func;do {$pkg =~ s/::[^:]+$// or return;eval "require $pkg"}until defined &$func}\&$func}sub MAX_READ_SIZE() {131072}sub new {my$class=shift;my$self=bless {@_ },$class;if ($self->{fh}){$self->_start;return unless$self->{fh}}elsif ($self->{connect}){require AnyEvent::Socket;$self->{peername}=$self->{connect}[0]unless exists$self->{peername};$self->{_skip_drain_rbuf}=1;{Scalar::Util::weaken (my$self=$self);$self->{_connect}=AnyEvent::Socket::tcp_connect ($self->{connect}[0],$self->{connect}[1],sub {my ($fh,$host,$port,$retry)=@_;delete$self->{_connect};if ($fh){$self->{fh}=$fh;delete$self->{_skip_drain_rbuf};$self->_start;$self->{on_connect}and $self->{on_connect}($self,$host,$port,sub {delete @$self{qw(fh _tw _rtw _wtw _ww _rw _eof _queue rbuf _wbuf tls _tls_rbuf _tls_wbuf)};$self->{_skip_drain_rbuf}=1;&$retry})}else {if ($self->{on_connect_error}){$self->{on_connect_error}($self,"$!");$self->destroy if$self}else {$self->_error ($!,1)}}},sub {local$self->{fh}=$_[0];$self->{on_prepare}? $self->{on_prepare}->($self): ()})}}else {Carp::croak "AnyEvent::Handle: either an existing fh or the connect parameter must be specified"}$self}sub _start {my ($self)=@_;my$type=getsockopt$self->{fh},Socket::SOL_SOCKET (),Socket::SO_TYPE ();Carp::croak "AnyEvent::Handle: only stream sockets supported, anything else will NOT work!" if Socket::SOCK_STREAM ()!=(unpack "I",$type)&& defined$type;AnyEvent::fh_unblock$self->{fh};$self->{_activity}=$self->{_ractivity}=$self->{_wactivity}=AE::now;$self->{read_size}||= 2048;$self->{max_read_size}=$self->{read_size}if$self->{read_size}> ($self->{max_read_size}|| MAX_READ_SIZE);$self->timeout (delete$self->{timeout})if$self->{timeout};$self->rtimeout (delete$self->{rtimeout})if$self->{rtimeout};$self->wtimeout (delete$self->{wtimeout})if$self->{wtimeout};$self->no_delay (delete$self->{no_delay})if exists$self->{no_delay}&& $self->{no_delay};$self->keepalive (delete$self->{keepalive})if exists$self->{keepalive}&& $self->{keepalive};$self->oobinline (exists$self->{oobinline}? delete$self->{oobinline}: 1);$self->starttls (delete$self->{tls},delete$self->{tls_ctx})if$self->{tls};$self->on_drain (delete$self->{on_drain})if$self->{on_drain};$self->start_read if$self->{on_read}|| @{$self->{_queue}};$self->_drain_wbuf}sub _error {my ($self,$errno,$fatal,$message)=@_;$!=$errno;$message ||= "$!";if ($self->{on_error}){$self->{on_error}($self,$fatal,$message);$self->destroy if$fatal}elsif ($self->{fh}|| $self->{connect}){$self->destroy;Carp::croak "AnyEvent::Handle uncaught error: $message"}}sub fh {$_[0]{fh}}sub on_error {$_[0]{on_error}=$_[1]}sub on_eof {$_[0]{on_eof}=$_[1]}sub autocork {$_[0]{autocork}=$_[1]}sub no_delay {$_[0]{no_delay}=$_[1];setsockopt $_[0]{fh},Socket::IPPROTO_TCP (),Socket::TCP_NODELAY (),int $_[1]if $_[0]{fh}}sub keepalive {$_[0]{keepalive}=$_[1];eval {local$SIG{__DIE__};setsockopt $_[0]{fh},Socket::SOL_SOCKET (),Socket::SO_KEEPALIVE (),int $_[1]if $_[0]{fh}}}sub oobinline {$_[0]{oobinline}=$_[1];eval {local$SIG{__DIE__};setsockopt $_[0]{fh},Socket::SOL_SOCKET (),Socket::SO_OOBINLINE (),int $_[1]if $_[0]{fh}}}sub keepalive {$_[0]{keepalive}=$_[1];eval {local$SIG{__DIE__};setsockopt $_[0]{fh},Socket::SOL_SOCKET (),Socket::SO_KEEPALIVE (),int $_[1]if $_[0]{fh}}}sub on_starttls {$_[0]{on_starttls}=$_[1]}sub on_stoptls {$_[0]{on_stoptls}=$_[1]}sub rbuf_max {$_[0]{rbuf_max}=$_[1]}sub wbuf_max {$_[0]{wbuf_max}=$_[1]}for my$dir ("","r","w"){my$timeout="${dir}timeout";my$tw="_${dir}tw";my$on_timeout="on_${dir}timeout";my$activity="_${dir}activity";my$cb;*$on_timeout=sub {$_[0]{$on_timeout}=$_[1]};*$timeout=sub {my ($self,$new_value)=@_;$new_value >= 0 or Carp::croak "AnyEvent::Handle->$timeout called with negative timeout ($new_value), caught";$self->{$timeout}=$new_value;delete$self->{$tw};&$cb};*{"${dir}timeout_reset"}=sub {$_[0]{$activity}=AE::now};$cb=sub {my ($self)=@_;if ($self->{$timeout}&& $self->{fh}){my$NOW=AE::now;my$after=$self->{$activity}+ $self->{$timeout}- $NOW;if ($after <= 0){$self->{$activity}=$NOW;if ($self->{$on_timeout}){$self->{$on_timeout}($self)}else {$self->_error (Errno::ETIMEDOUT)}return unless$self->{$timeout};$after=$self->{$timeout}}Scalar::Util::weaken$self;return unless$self;$self->{$tw}||= AE::timer$after,0,sub {delete$self->{$tw};$cb->($self)}}else {delete$self->{$tw}}}}sub on_drain {my ($self,$cb)=@_;$self->{on_drain}=$cb;$cb->($self)if$cb && $self->{low_water_mark}>= (length$self->{wbuf})+ (length$self->{_tls_wbuf})}sub _drain_wbuf {my ($self)=@_;if (!$self->{_ww}&& length$self->{wbuf}){Scalar::Util::weaken$self;my$cb=sub {my$len=syswrite$self->{fh},$self->{wbuf};if (defined$len){substr$self->{wbuf},0,$len,"";$self->{_activity}=$self->{_wactivity}=AE::now;$self->{on_drain}($self)if$self->{low_water_mark}>= (length$self->{wbuf})+ (length$self->{_tls_wbuf})&& $self->{on_drain};delete$self->{_ww}unless length$self->{wbuf}}elsif ($!!=EAGAIN && $!!=EINTR && $!!=EWOULDBLOCK && $!!=WSAEWOULDBLOCK){$self->_error ($!,1)}};$cb->()unless$self->{autocork};$self->{_ww}=AE::io$self->{fh},1,$cb if length$self->{wbuf};if (defined$self->{wbuf_max}&& $self->{wbuf_max}< length$self->{wbuf}){$self->_error (Errno::ENOSPC,1),return}}}our%WH;sub register_write_type($$) {$WH{$_[0]}=$_[1]}sub push_write {my$self=shift;if (@_ > 1){my$type=shift;@_=($WH{$type}||= _load_func "$type\::anyevent_write_type" or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_write")->($self,@_)}if ($self->{tls}){utf8::downgrade$self->{_tls_wbuf}.= $_[0];&_dotls ($self)if$self->{fh}}else {utf8::downgrade$self->{wbuf}.= $_[0];$self->_drain_wbuf if$self->{fh}}}register_write_type netstring=>sub {my ($self,$string)=@_;(length$string).":$string,"};register_write_type packstring=>sub {my ($self,$format,$string)=@_;pack "$format/a*",$string};sub json_coder() {eval {require JSON::XS;JSON::XS->new->utf8}|| do {require JSON::PP;JSON::PP->new->utf8}}register_write_type json=>sub {my ($self,$ref)=@_;($self->{json}||= json_coder)->encode ($ref)};sub cbor_coder() {require CBOR::XS;CBOR::XS->new}register_write_type cbor=>sub {my ($self,$scalar)=@_;($self->{cbor}||= cbor_coder)->encode ($scalar)};register_write_type storable=>sub {my ($self,$ref)=@_;require Storable unless$Storable::VERSION;pack "w/a*",Storable::nfreeze ($ref)};sub push_shutdown {my ($self)=@_;delete$self->{low_water_mark};$self->on_drain (sub {shutdown $_[0]{fh},1})}sub _drain_rbuf {my ($self)=@_;return if$self->{_skip_drain_rbuf};local$self->{_skip_drain_rbuf}=1;while (){$self->{rbuf}.= delete$self->{_tls_rbuf}if exists$self->{_tls_rbuf};my$len=length$self->{rbuf};if (my$cb=shift @{$self->{_queue}}){unless ($cb->($self)){$self->_error (Errno::EPIPE,1),return if$self->{_eof};unshift @{$self->{_queue}},$cb;last}}elsif ($self->{on_read}){last unless$len;$self->{on_read}($self);if ($len==length$self->{rbuf}&&!@{$self->{_queue}}&& $self->{on_read}){$self->_error (Errno::EPIPE,1),return if$self->{_eof};last}}else {delete$self->{_rw}unless$self->{tls};last}}if ($self->{_eof}){$self->{on_eof}? $self->{on_eof}($self): $self->_error (0,1,"Unexpected end-of-file");return}if (defined$self->{rbuf_max}&& $self->{rbuf_max}< length$self->{rbuf}){$self->_error (Errno::ENOSPC,1),return}unless ($self->{_rw}){$self->start_read if$self->{on_read}|| @{$self->{_queue}}}}sub on_read {my ($self,$cb)=@_;$self->{on_read}=$cb;$self->_drain_rbuf if$cb}sub rbuf : lvalue {$_[0]{rbuf}}our%RH;sub register_read_type($$) {$RH{$_[0]}=$_[1]}sub push_read {my$self=shift;my$cb=pop;if (@_){my$type=shift;$cb=($RH{$type}||= _load_func "$type\::anyevent_read_type" or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_read")->($self,$cb,@_)}push @{$self->{_queue}},$cb;$self->_drain_rbuf}sub unshift_read {my$self=shift;my$cb=pop;if (@_){my$type=shift;$cb=($RH{$type}||= _load_func "$type\::anyevent_read_type" or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::unshift_read")->($self,$cb,@_)}unshift @{$self->{_queue}},$cb;$self->_drain_rbuf}register_read_type chunk=>sub {my ($self,$cb,$len)=@_;sub {$len <= length $_[0]{rbuf}or return;$cb->($_[0],substr $_[0]{rbuf},0,$len,"");1}};register_read_type line=>sub {my ($self,$cb,$eol)=@_;if (@_ < 3){sub {(my$pos=index $_[0]{rbuf},"\012")>= 0 or return;(my$str=substr $_[0]{rbuf},0,$pos + 1,"")=~ s/(\015?\012)\Z// or die;$cb->($_[0],$str,"$1");1}}else {$eol=quotemeta$eol unless ref$eol;$eol=qr|^(.*?)($eol)|s;sub {$_[0]{rbuf}=~ s/$eol// or return;$cb->($_[0],"$1","$2");1}}};register_read_type regex=>sub {my ($self,$cb,$accept,$reject,$skip)=@_;my$data;my$rbuf=\$self->{rbuf};sub {if ($$rbuf =~ $accept){$data .= substr $$rbuf,0,$+[0],"";$cb->($_[0],$data);return 1}if ($reject && $$rbuf =~ $reject){$_[0]->_error (Errno::EBADMSG)}if ($skip && $$rbuf =~ $skip){$data .= substr $$rbuf,0,$+[0],""}()}};register_read_type netstring=>sub {my ($self,$cb)=@_;sub {unless ($_[0]{rbuf}=~ s/^(0|[1-9][0-9]*)://){if ($_[0]{rbuf}=~ /[^0-9]/){$_[0]->_error (Errno::EBADMSG)}return}my$len=$1;$_[0]->unshift_read (chunk=>$len,sub {my$string=$_[1];$_[0]->unshift_read (chunk=>1,sub {if ($_[1]eq ","){$cb->($_[0],$string)}else {$_[0]->_error (Errno::EBADMSG)}})});1}};register_read_type packstring=>sub {my ($self,$cb,$format)=@_;sub {defined (my$len=eval {unpack$format,$_[0]{rbuf}})or return;$format=length pack$format,$len;if ($format + $len <= length $_[0]{rbuf}){my$data=substr $_[0]{rbuf},$format,$len;substr $_[0]{rbuf},0,$format + $len,"";$cb->($_[0],$data)}else {substr $_[0]{rbuf},0,$format,"";$_[0]->unshift_read (chunk=>$len,$cb)}1}};register_read_type json=>sub {my ($self,$cb)=@_;my$json=$self->{json}||= json_coder;my$data;sub {my$ref=eval {$json->incr_parse ($_[0]{rbuf})};if ($ref){$_[0]{rbuf}=$json->incr_text;$json->incr_text="";$cb->($_[0],$ref);1}elsif ($@){$json->incr_skip;$_[0]{rbuf}=$json->incr_text;$json->incr_text="";$_[0]->_error (Errno::EBADMSG);()}else {$_[0]{rbuf}="";()}}};register_read_type cbor=>sub {my ($self,$cb)=@_;my$cbor=$self->{cbor}||= cbor_coder;my$data;sub {my (@value)=eval {$cbor->incr_parse ($_[0]{rbuf})};if (@value){$cb->($_[0],@value);1}elsif ($@){$cbor->incr_reset;$_[0]->_error (Errno::EBADMSG);()}else {()}}};register_read_type storable=>sub {my ($self,$cb)=@_;require Storable unless$Storable::VERSION;sub {defined (my$len=eval {unpack "w",$_[0]{rbuf}})or return;my$format=length pack "w",$len;if ($format + $len <= length $_[0]{rbuf}){my$data=substr $_[0]{rbuf},$format,$len;substr $_[0]{rbuf},0,$format + $len,"";eval {$cb->($_[0],Storable::thaw ($data));1}or return $_[0]->_error (Errno::EBADMSG)}else {substr $_[0]{rbuf},0,$format,"";$_[0]->unshift_read (chunk=>$len,sub {eval {$cb->($_[0],Storable::thaw ($_[1]));1}or $_[0]->_error (Errno::EBADMSG)})}1}};register_read_type tls_detect=>sub {my ($self,$cb)=@_;sub {if ($self->{rbuf}=~ /^(?:\z| \x16 (\z| [\x03\x04] (?:\z| . (?:\z| [\x00-\x40] ))))/xs or $self->{rbuf}=~ /^(?:\z| [\x80-\xff] (?:\z| . (?:\z| \x01 (\z| [\x03\x04] (?:\z| . (?:\z| . ))))))/xs){return if 3!=length $1;my ($major,$minor)=unpack "CC",$1;$cb->($self,"accept",$major + $minor * 0.1)}else {$cb->($self,undef)}1}};register_read_type tls_autostart=>sub {my ($self,@tls)=@_;$RH{tls_detect}($self,sub {return unless $_[1];$_[0]->starttls (@tls)})};sub stop_read {my ($self)=@_;delete$self->{_rw}}sub start_read {my ($self)=@_;unless ($self->{_rw}|| $self->{_eof}||!$self->{fh}){Scalar::Util::weaken$self;$self->{_rw}=AE::io$self->{fh},0,sub {my$rbuf=\($self->{tls}? my$buf : $self->{rbuf});my$len=sysread$self->{fh},$$rbuf,$self->{read_size},length $$rbuf;if ($len > 0){$self->{_activity}=$self->{_ractivity}=AE::now;if ($self->{tls}){Net::SSLeay::BIO_write ($self->{_rbio},$$rbuf);&_dotls ($self)}else {$self->_drain_rbuf}if ($len==$self->{read_size}){$self->{read_size}*= 2;$self->{read_size}=$self->{max_read_size}|| MAX_READ_SIZE if$self->{read_size}> ($self->{max_read_size}|| MAX_READ_SIZE)}}elsif (defined$len){delete$self->{_rw};$self->{_eof}=1;$self->_drain_rbuf}elsif ($!!=EAGAIN && $!!=EINTR && $!!=EWOULDBLOCK && $!!=WSAEWOULDBLOCK){return$self->_error ($!,1)}}}}our$ERROR_SYSCALL;our$ERROR_WANT_READ;sub _tls_error {my ($self,$err)=@_;return$self->_error ($!,1)if$err==Net::SSLeay::ERROR_SYSCALL ();my$err=Net::SSLeay::ERR_error_string (Net::SSLeay::ERR_get_error ());$err =~ s/^error:[0-9a-fA-F]{8}:[^:]+:([^:]+):/\L$1: /;if ($self->{_on_starttls}){(delete$self->{_on_starttls})->($self,undef,$err);&_freetls}else {&_freetls;$self->_error (Errno::EPROTO,1,$err)}}sub _dotls {my ($self)=@_;my$tmp;while (length$self->{_tls_wbuf}){if (($tmp=Net::SSLeay::write ($self->{tls},$self->{_tls_wbuf}))<= 0){$tmp=Net::SSLeay::get_error ($self->{tls},$tmp);return$self->_tls_error ($tmp)if$tmp!=$ERROR_WANT_READ && ($tmp!=$ERROR_SYSCALL || $!);last}substr$self->{_tls_wbuf},0,$tmp,""}while (defined ($tmp=Net::SSLeay::read ($self->{tls}))){unless (length$tmp){$self->{_on_starttls}and (delete$self->{_on_starttls})->($self,undef,"EOF during handshake");&_freetls;if ($self->{on_stoptls}){$self->{on_stoptls}($self);return}else {delete$self->{_rw};$self->{_eof}=1}}$self->{_tls_rbuf}.= $tmp;$self->_drain_rbuf;$self->{tls}or return}$tmp=Net::SSLeay::get_error ($self->{tls},-1);return$self->_tls_error ($tmp)if$tmp!=$ERROR_WANT_READ && ($tmp!=$ERROR_SYSCALL || $!);while (length ($tmp=Net::SSLeay::BIO_read ($self->{_wbio}))){$self->{wbuf}.= $tmp;$self->_drain_wbuf;$self->{tls}or return}$self->{_on_starttls}and Net::SSLeay::state ($self->{tls})==Net::SSLeay::ST_OK ()and (delete$self->{_on_starttls})->($self,1,"TLS/SSL connection established")}our%TLS_CACHE;sub starttls {my ($self,$tls,$ctx)=@_;Carp::croak "It is an error to call starttls on an AnyEvent::Handle object while TLS is already active, caught" if$self->{tls};unless (defined$AnyEvent::TLS::VERSION){eval {require Net::SSLeay;require AnyEvent::TLS;1}or return$self->_error (Errno::EPROTO,1,"TLS support not available on this system")}$self->{tls}=$tls;$self->{tls_ctx}=$ctx if @_ > 2;return unless$self->{fh};$ERROR_SYSCALL=Net::SSLeay::ERROR_SYSCALL ();$ERROR_WANT_READ=Net::SSLeay::ERROR_WANT_READ ();$tls=delete$self->{tls};$ctx=$self->{tls_ctx};local$Carp::CarpLevel=1;if ("HASH" eq ref$ctx){if ($ctx->{cache}){my$key=$ctx+0;$ctx=$TLS_CACHE{$key}||= new AnyEvent::TLS %$ctx}else {$ctx=new AnyEvent::TLS %$ctx}}$self->{tls_ctx}=$ctx || TLS_CTX ();$self->{tls}=$tls=$self->{tls_ctx}->_get_session ($tls,$self,$self->{peername});Net::SSLeay::CTX_set_mode ($tls,1|2);$self->{_rbio}=Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());$self->{_wbio}=Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());Net::SSLeay::BIO_write ($self->{_rbio},$self->{rbuf});$self->{rbuf}="";Net::SSLeay::set_bio ($tls,$self->{_rbio},$self->{_wbio});$self->{_on_starttls}=sub {$_[0]{on_starttls}(@_)}if$self->{on_starttls};&_dotls;$self->start_read}sub stoptls {my ($self)=@_;if ($self->{tls}&& $self->{fh}){Net::SSLeay::shutdown ($self->{tls});&_dotls}}sub _freetls {my ($self)=@_;return unless$self->{tls};$self->{tls_ctx}->_put_session (delete$self->{tls})if$self->{tls}> 0;delete @$self{qw(_rbio _wbio _tls_wbuf _on_starttls)}}*resettls=\&_freetls;sub DESTROY {my ($self)=@_;&_freetls;my$linger=exists$self->{linger}? $self->{linger}: 3600;if ($linger && length$self->{wbuf}&& $self->{fh}){my$fh=delete$self->{fh};my$wbuf=delete$self->{wbuf};my@linger;push@linger,AE::io$fh,1,sub {my$len=syswrite$fh,$wbuf,length$wbuf;if ($len > 0){substr$wbuf,0,$len,""}elsif (defined$len || ($!!=EAGAIN && $!!=EINTR && $!!=EWOULDBLOCK && $!!=WSAEWOULDBLOCK)){@linger=()}};push@linger,AE::timer$linger,0,sub {@linger=()}}}sub destroy {my ($self)=@_;$self->DESTROY;%$self=();bless$self,"AnyEvent::Handle::destroyed"}sub AnyEvent::Handle::destroyed::AUTOLOAD {}sub destroyed {0}sub AnyEvent::Handle::destroyed::destroyed {1}our$TLS_CTX;sub TLS_CTX() {$TLS_CTX ||= do {require AnyEvent::TLS;new AnyEvent::TLS}}1
ANYEVENT_HANDLE

$fatpacked{"AnyEvent/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO';
  package AnyEvent::IO;use AnyEvent ();BEGIN {AnyEvent::common_sense}use base "Exporter";our@AIO_REQ=qw(aio_load aio_open aio_close aio_seek aio_read aio_write aio_truncate aio_utime aio_chown aio_chmod aio_stat aio_lstat aio_link aio_symlink aio_readlink aio_rename aio_unlink aio_mkdir aio_rmdir aio_readdir);*EXPORT=\@AIO_REQ;our@FLAGS=qw(O_RDONLY O_WRONLY O_RDWR O_CREAT O_EXCL O_TRUNC O_APPEND);*EXPORT_OK=\@FLAGS;our%EXPORT_TAGS=(flags=>\@FLAGS,aio=>\@AIO_REQ);our$MODEL;if ($MODEL){AE::log 7=>"Found preloaded IO model '$MODEL', using it."}else {if ($ENV{PERL_ANYEVENT_IO_MODEL}=~ /^([a-zA-Z0-9:]+)$/){if (eval {require "AnyEvent/IO/$ENV{PERL_ANYEVENT_IO_MODEL}.pm"}){AE::log 7=>"Loaded IO model '$MODEL' (forced by \$ENV{PERL_ANYEVENT_IO_MODEL}), using it."}else {undef$MODEL;AE::log 4=>"Unable to load IO model '$ENV{PERL_ANYEVENT_IO_MODEL}' (from \$ENV{PERL_ANYEVENT_IO_MODEL}):\n$@"}}unless ($MODEL){if (eval {require IO::AIO;require AnyEvent::AIO;require AnyEvent::IO::IOAIO}){AE::log 7=>"Autoloaded IO model 'IOAIO', using it."}else {require AnyEvent::IO::Perl;AE::log 7=>"Autoloaded IO model 'Perl', using it."}}}1
ANYEVENT_IO

$fatpacked{"AnyEvent/IO/IOAIO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_IOAIO';
  package AnyEvent::IO::IOAIO;use AnyEvent ();BEGIN {AnyEvent::common_sense}our$VERSION=$AnyEvent::VERSION;package AnyEvent::IO;use IO::AIO 0.01 ();use AnyEvent::AIO ();our$MODEL="AnyEvent::IO::IOAIO";sub aio_load($$) {my ($cb,$data)=$_[1];IO::AIO::aio_load $_[0],$data,sub {$cb->($_[0]>= 0 ? $data : ())}}sub aio_open($$$$) {my$cb=$_[3];IO::AIO::aio_open $_[0],$_[1],$_[2],sub {$cb->($_[0]or ())}}sub aio_close($$) {my$cb=$_[1];IO::AIO::aio_close $_[0],sub {$cb->($_[0]>= 0 ? 1 : ())}}sub aio_seek($$$$) {my ($cb)=$_[3];IO::AIO::aio_seek $_[0],$_[1],$_[2],sub {$cb->($_[0]>= 0 ? $_[0]: ())}}sub aio_read($$$) {my ($cb,$data)=$_[2];IO::AIO::aio_read $_[0],undef,$_[1],$data,0,sub {$cb->($_[0]>= 0 ? $data : ())}}sub aio_write($$$) {my$cb=$_[2];IO::AIO::aio_write $_[0],undef,(length $_[1]),$_[1],0,sub {$cb->($_[0]>= 0 ? $_[0]: ())}}sub aio_truncate($$$) {my$cb=$_[2];IO::AIO::aio_truncate $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_utime($$$$) {my$cb=$_[3];IO::AIO::aio_utime $_[0],$_[1],$_[2],sub {$cb->($_[0]? (): 1)}}sub aio_chown($$$$) {my$cb=$_[3];IO::AIO::aio_chown $_[0],$_[1],$_[2],sub {$cb->($_[0]? (): 1)}}sub aio_chmod($$$) {my$cb=$_[2];IO::AIO::aio_chmod $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_stat($$) {my$cb=$_[1];IO::AIO::aio_stat $_[0],sub {$cb->($_[0]? (): 1)}}sub aio_lstat($$) {my$cb=$_[1];IO::AIO::aio_lstat $_[0],sub {$cb->($_[0]? (): 1)}}sub aio_link($$$) {my$cb=$_[2];IO::AIO::aio_link $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_symlink($$$) {my$cb=$_[2];IO::AIO::aio_symlink $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_readlink($$) {my$cb=$_[1];IO::AIO::aio_readlink $_[0],sub {$cb->(defined $_[0]? $_[0]: ())}}sub aio_rename($$$) {my$cb=$_[2];IO::AIO::aio_rename $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_unlink($$) {my$cb=$_[1];IO::AIO::aio_unlink $_[0],sub {$cb->($_[0]? (): 1)}}sub aio_mkdir($$$) {my$cb=$_[2];IO::AIO::aio_mkdir $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_rmdir($$) {my$cb=$_[1];IO::AIO::aio_rmdir $_[0],sub {$cb->($_[0]? (): 1)}}sub aio_readdir($$) {my$cb=$_[1];IO::AIO::aio_readdirx $_[0],IO::AIO::READDIR_DIRS_FIRST | IO::AIO::READDIR_STAT_ORDER,sub {$cb->($_[0]or ())}}1
ANYEVENT_IO_IOAIO

$fatpacked{"AnyEvent/IO/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_PERL';
  package AnyEvent::IO::Perl;use AnyEvent ();BEGIN {AnyEvent::common_sense}our$VERSION=$AnyEvent::VERSION;package AnyEvent::IO;our$MODEL="AnyEvent::IO::Perl";sub aio_load($$) {my ($path,$cb,$fh,$data)=@_;$cb->((open$fh,"<:raw:perlio",$path and stat$fh and (-s _)==sysread$fh,$data,-s _)? $data : ())}sub aio_open($$$$) {sysopen my$fh,$_[0.01],$_[1],$_[2]or return $_[3]();$_[3]($fh)}sub aio_close($$) {$_[1](close $_[0])}sub aio_seek($$$$) {my$data;$_[3](sysseek $_[0],$_[1],$_[2]or ())}sub aio_read($$$) {my$data;$_[2]((defined sysread $_[0],$data,$_[1])? $data : ())}sub aio_write($$$) {my$res=syswrite $_[0],$_[1];$_[2](defined$res ? $res : ())}sub aio_truncate($$$) {$_[2](truncate $_[0],$_[1]or ())}sub aio_utime($$$$) {$_[3](utime $_[1],$_[2],$_[0]or ())}sub aio_chown($$$$) {$_[3](chown defined $_[1]? $_[1]: -1,defined $_[2]? $_[2]: -1,$_[0]or ())}sub aio_chmod($$$) {$_[2](chmod $_[1],$_[0]or ())}sub aio_stat($$) {$_[1](stat $_[0])}sub aio_lstat($$) {$_[1](lstat $_[0])}sub aio_link($$$) {$_[2](link $_[0],$_[1]or ())}sub aio_symlink($$$) {$_[2](symlink $_[0],$_[1]or ())}sub aio_readlink($$) {my$res=readlink $_[0];$_[1](defined$res ? $res : ())}sub aio_rename($$$) {$_[2](rename $_[0],$_[1]or ())}sub aio_unlink($$) {$_[1](unlink $_[0]or ())}sub aio_mkdir($$$) {$_[2](mkdir $_[0],$_[1]or ())}sub aio_rmdir($$) {$_[1](rmdir $_[0]or ())}sub aio_readdir($$) {my ($fh,@res);opendir$fh,$_[0]or return $_[1]();@res=grep!/^\.\.?$/,readdir$fh;$_[1]((closedir$fh)? \@res : ())}1
ANYEVENT_IO_PERL

$fatpacked{"AnyEvent/Impl/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_COCOA';
  package AnyEvent::Impl::Cocoa;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Cocoa::EventLoop;sub io {my ($class,%arg)=@_;Cocoa::EventLoop->io (%arg)}sub timer {my ($class,%arg)=@_;Cocoa::EventLoop->timer (%arg)}1
ANYEVENT_IMPL_COCOA

$fatpacked{"AnyEvent/Impl/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EV';
  package AnyEvent::Impl::EV;use AnyEvent ();BEGIN {AnyEvent::common_sense}use EV 4.00;*AE::time=\&EV::time;*AE::now=\&EV::now;*AE::now_update=\&EV::now_update;*AE::timer=\&EV::timer;*AE::signal=\&EV::signal;*AE::idle=\&EV::idle;sub time {EV::time}sub now {EV::now}sub now_update {EV::now_update}*AE::io=defined&EV::_ae_io ? \&EV::_ae_io : sub($$$) {EV::io $_[0],$_[1]? EV::WRITE : EV::READ,$_[2]};sub timer {my ($class,%arg)=@_;EV::timer$arg{after},$arg{interval},$arg{cb}}sub io {my ($class,%arg)=@_;EV::io $arg{fh},$arg{poll}eq "r" ? EV::READ : EV::WRITE,$arg{cb}}sub signal {my ($class,%arg)=@_;EV::signal$arg{signal},$arg{cb}}sub child {my ($class,%arg)=@_;my$cb=$arg{cb};EV::child$arg{pid},0,sub {$cb->($_[0]->rpid,$_[0]->rstatus)}}sub idle {my ($class,%arg)=@_;EV::idle$arg{cb}}sub _poll {EV::run EV::RUN_ONCE}sub AnyEvent::CondVar::Base::_wait {EV::run EV::RUN_ONCE until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_EV

$fatpacked{"AnyEvent/Impl/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENT';
  package AnyEvent::Impl::Event;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Event qw(unloop);sub io {my (undef,%arg)=@_;$arg{fd}=delete$arg{fh};$arg{poll}.= "e" if AnyEvent::WIN32;my$cb=$arg{cb};$arg{cb}=sub {&$cb};bless \(Event->io (%arg)),__PACKAGE__}sub timer {my (undef,%arg)=@_;$arg{after}=0 if$arg{after}< 0;my$cb=$arg{cb};$arg{cb}=sub {&$cb};bless \Event->timer (%arg,repeat=>$arg{interval}),__PACKAGE__}sub idle {my (undef,%arg)=@_;my$cb=$arg{cb};$arg{cb}=sub {&$cb};bless \Event->idle (repeat=>1,min=>0,%arg),__PACKAGE__}sub DESTROY {${$_[0]}->cancel}sub signal {my (undef,%arg)=@_;my$cb=$arg{cb};my$w=Event->signal (signal=>AnyEvent::Base::sig2name$arg{signal},cb=>sub {&$cb},);AnyEvent::Base::_sig_add;bless \$w,"AnyEvent::Impl::Event::signal"}sub AnyEvent::Impl::Event::signal::DESTROY {AnyEvent::Base::_sig_del;${$_[0]}->cancel}sub _poll {Event::one_event}sub AnyEvent::CondVar::Base::_wait {Event::one_event until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_EVENT

$fatpacked{"AnyEvent/Impl/EventLib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENTLIB';
  package AnyEvent::Impl::EventLib;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Event::Lib;sub ccb {my$keep_it=$_[0];$_[2]()}my$ccb=\&ccb;sub io {my (undef,%arg)=@_;my ($fh,$mode)=AnyEvent::_dupfh$arg{poll},$arg{fh},EV_READ,EV_WRITE;my$w=event_new$fh,$mode | EV_PERSIST,$ccb,$arg{cb};event_add$w;bless \\$w,__PACKAGE__}sub timer {my (undef,%arg)=@_;my$ival=$arg{interval};my$cb=$arg{cb};my$w;$w=timer_new$ccb,$ival ? sub {event_add$w,$ival;&$cb}: sub {undef$w ;&$cb};event_add$w,$arg{after}|| 1e-10;bless \\$w,__PACKAGE__}sub DESTROY {local $@;${${$_[0]}}->remove}sub signal {my (undef,%arg)=@_;my$w=signal_new AnyEvent::Base::sig2num$arg{signal},$ccb,$arg{cb};event_add$w;AnyEvent::Base::_sig_add;bless \\$w,"AnyEvent::Impl::EventLib::signal"}sub AnyEvent::Impl::EventLib::signal::DESTROY {AnyEvent::Base::_sig_del;local $@;${${$_[0]}}->remove}sub _poll {event_one_loop}sub AnyEvent::CondVar::Base::_wait {event_one_loop until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_EVENTLIB

$fatpacked{"AnyEvent/Impl/FLTK.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_FLTK';
  package AnyEvent::Impl::FLTK;use AnyEvent ();BEGIN {AnyEvent::common_sense}use FLTK 0.532 ();use Scalar::Util ();sub timer_interval_cb {my$id=shift;$id->[0]=FLTK::add_timeout$id->[1],\&timer_interval_cb,$id;&{$id->[2]}}sub timer {my ($class,%arg)=@_;my$cb=$arg{cb};if ($arg{interval}){my$id=[undef,$arg{interval},$cb];$id->[0]=FLTK::add_timeout$arg{after},\&timer_interval_cb,$id;return bless$id,"AnyEvent::Impl::FLTK::timer"}else {return FLTK::add_timeout$arg{after},sub {&$cb}}}sub AnyEvent::Impl::FLTK::timer::DESTROY {undef $_[0][0]}sub io {my ($class,%arg)=@_;my$cb=$arg{cb};my ($fh,$ev)=AnyEvent::_dupfh$arg{poll},$arg{fh},FLTK::READ,FLTK::WRITE | (AnyEvent::WIN32 ? FLTK::EXCEPT : 0);FLTK::add_fd$fh,$ev,sub {&$cb}}sub _poll {FLTK::wait}sub AnyEvent::CondVar::Base::_wait {FLTK::wait until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_FLTK

$fatpacked{"AnyEvent/Impl/Glib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_GLIB';
  package AnyEvent::Impl::Glib;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Glib 1.210 ();our$mainloop=Glib::MainContext->default;my%io_cond=(r=>["in","hup"],w=>["out","hup"],);sub io {my ($class,%arg)=@_;my$cb=$arg{cb};my$fd=fileno$arg{fh};defined$fd or $fd=$arg{fh};my$source=add_watch Glib::IO $fd,$io_cond{$arg{poll}},sub {&$cb;1};bless \\$source,$class}sub timer {my ($class,%arg)=@_;my$cb=$arg{cb};my$ival=$arg{interval}* 1000;my$source;$source=add Glib::Timeout$arg{after}< 0 ? 0 : $arg{after}* 1000,$ival ? sub {remove Glib::Source$source;$source=add Glib::Timeout$ival,sub {&$cb;1};&$cb;1}: sub {remove Glib::Source$source;undef$source;&$cb;1};bless \\$source,$class}sub idle {my ($class,%arg)=@_;my$cb=$arg{cb};my$source=add Glib::Idle sub {&$cb;1};bless \\$source,$class}sub DESTROY {remove Glib::Source $${$_[0]}if defined $${$_[0]}}our%pid_w;our%pid_cb;sub child {my ($class,%arg)=@_;$arg{pid}> 0 or Carp::croak "Glib does not support watching for all pids (pid == 0) as attempted";my$pid=$arg{pid};my$cb=$arg{cb};$pid_cb{$pid}{$cb+0}=$cb;$pid_w{$pid}||= Glib::Child->watch_add ($pid,sub {undef$pid_w{$pid};$_->($_[0],$_[1])for values %{$pid_cb{$pid}};1});bless [$pid,$cb+0],"AnyEvent::Impl::Glib::child"}sub AnyEvent::Impl::Glib::child::DESTROY {my ($pid,$icb)=@{$_[0]};delete$pid_cb{$pid}{$icb};unless (%{$pid_cb{$pid}}){delete$pid_cb{$pid};my$source=delete$pid_w{$pid};remove Glib::Source if defined$source}}sub _poll {$mainloop->iteration (1)}sub AnyEvent::CondVar::Base::_wait {$mainloop->iteration (1)until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_GLIB

$fatpacked{"AnyEvent/Impl/IOAsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IOASYNC';
  package AnyEvent::Impl::IOAsync;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Time::HiRes ();use Scalar::Util ();use IO::Async::Loop 0.33;our$LOOP=new IO::Async::Loop;sub set_loop($) {$LOOP=$_[0]}sub timer {my ($class,%arg)=@_;my$cb=$arg{cb};my$id;if (my$ival=$arg{interval}){my$ival_cb;$ival_cb=sub {$id=$LOOP->enqueue_timer (delay=>$ival,code=>$ival_cb);&$cb};$id=$LOOP->enqueue_timer (delay=>$arg{after},code=>$ival_cb);Scalar::Util::weaken$ival_cb}else {$id=$LOOP->enqueue_timer (delay=>$arg{after},code=>sub {undef$id;&$cb})}bless \\$id,"AnyEvent::Impl::IOAsync::timer"}sub AnyEvent::Impl::IOAsync::timer::DESTROY {$LOOP->cancel_timer (${${$_[0]}})if defined ${${$_[0]}}}sub io {my ($class,%arg)=@_;my ($fh)=AnyEvent::_dupfh$arg{poll},$arg{fh};my$event=$arg{poll}eq "r" ? "on_read_ready" : "on_write_ready";$LOOP->watch_io (handle=>$fh,$event=>$arg{cb},);bless [$fh,$event],"AnyEvent::Impl::IOAsync::io"}sub AnyEvent::Impl::IOAsync::io::DESTROY {$LOOP->unwatch_io (handle=>$_[0][0],$_[0][1]=>1,)}sub signal {my ($class,%arg)=@_;my$signal=$arg{signal};my$id=$LOOP->attach_signal ($arg{signal},$arg{cb});bless [$signal,$id],"AnyEvent::Impl::IOAsync::signal"}sub AnyEvent::Impl::IOAsync::signal::DESTROY {$LOOP->detach_signal (@{$_[0]})}our%pid_cb;sub child {my ($class,%arg)=@_;my$pid=$arg{pid};$LOOP->watch_child ($pid,$arg{cb});bless [$pid],"AnyEvent::Impl::IOAsync::child"}sub child {my ($class,%arg)=@_;my$pid=$arg{pid};my$cb=$arg{cb};unless (%{$pid_cb{$pid}}){$LOOP->watch_child ($pid,sub {$_->($_[0],$_[1])for values %{$pid_cb{$pid}}})}$pid_cb{$pid}{$cb+0}=$cb;bless [$pid,$cb+0],"AnyEvent::Impl::IOAsync::child"}sub AnyEvent::Impl::IOAsync::child::DESTROY {my ($pid,$icb)=@{$_[0]};delete$pid_cb{$pid}{$icb};unless (%{$pid_cb{$pid}}){delete$pid_cb{$pid};$LOOP->unwatch_child ($pid)}}sub _poll {$LOOP->loop_once}sub AnyEvent::CondVar::Base::_wait {$LOOP->loop_once until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_IOASYNC

$fatpacked{"AnyEvent/Impl/Irssi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IRSSI';
  package AnyEvent::Impl::Irssi;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Carp ();use Irssi ();our@ISA;sub init {my$pkg=caller;push@ISA,$pkg;local $/;eval "package $pkg; " .<DATA>;print "AnyEvent::Impl::Irssi fatal compilation error: $@" if $@;close DATA}Irssi::command "/script exec -permanent AnyEvent::Impl::Irssi::init 'AnyEvent adaptor'";1;__DATA__ 
  BEGIN { AnyEvent::common_sense }
  use base "AnyEvent::Base";
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = Irssi::input_add
        $fd,
        $arg{poll} eq "r" ? Irssi::INPUT_READ : Irssi::INPUT_WRITE,
        $cb,
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::io"
  }
  
  sub AnyEvent::Impl::Irssi::io::DESTROY {
     Irssi::input_remove $${$_[0]};
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb    = $arg{cb};
     my $ival  = $arg{interval} * 1000;
     my $after = $arg{after} * 1000;
  
     my $source; $source = Irssi::timeout_add_once $after > 10 ? $after : 10,
        ($ival ? sub {
                   $source = Irssi::timeout_add $ival > 10 ? $ival : 10, $cb, undef;
                   &$cb;
                   0
                 }
               : $cb),
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::timer"
  }
  
  sub AnyEvent::Impl::Irssi::timer::DESTROY {
     Irssi::timeout_remove $${$_[0]};
  }
  
  my $_pidwait = sub {
     my ($rpid, $rstatus) = @_;
  
     AnyEvent::Base->_emit_childstatus ($rpid, $rstatus);
  };
  
  Irssi::signal_add pidwait => $_pidwait;
  
  sub _emit_childstatus {
     my ($self, $rpid, $rstatus) = @_;
     $self->SUPER::_emit_childstatus ($rpid, $rstatus);
  
     Irssi::signal_remove pidwait => $_pidwait;
     Irssi::signal_emit   pidwait => $rpid+0, $rstatus+0;
     Irssi::signal_add    pidwait => $_pidwait;
  }
  
  #sub loop {
  #   Carp::croak "Irssi does not support blocking waits";
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Irssi>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_IRSSI

$fatpacked{"AnyEvent/Impl/POE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_POE';
  package AnyEvent::Impl::POE;use AnyEvent ();BEGIN {AnyEvent::common_sense}use POE;${POE::Kernel->new->[POE::Kernel::KR_RUN]}|= POE::Kernel::KR_RUN_CALLED;sub io {my ($class,%arg)=@_;my ($fh,$pee)=AnyEvent::_dupfh$arg{poll},$arg{fh},"select_read","select_write";my$cb=delete$arg{cb};my$cb=sub {&$cb};my$session=POE::Session->create (inline_states=>{_start=>sub {$_[KERNEL]->$pee ($fh=>"ready")},ready=>sub {$cb->()},stop=>sub {$_[KERNEL]->$pee ($fh)},},);bless \\$session,"AnyEvent::Impl::POE"}sub timer {my ($class,%arg)=@_;my$after=delete$arg{after};my$ival=delete$arg{interval};my$cb=delete$arg{cb};my$cb=sub {&$cb};my$session=POE::Session->create (inline_states=>{_start=>sub {$_[KERNEL]->delay_set (timeout=>$after)},timeout=>$ival ? sub {$_[KERNEL]->delay_set (timeout=>$ival);$cb->()}: $cb,stop=>sub {$_[KERNEL]->alarm_remove_all},},);bless \\$session,"AnyEvent::Impl::POE"}sub signal {my ($class,%arg)=@_;my$signal=AnyEvent::Base::sig2name delete$arg{signal};my$cb=delete$arg{cb};my$cb=sub {&$cb};my$session=POE::Session->create (inline_states=>{_start=>sub {},start=>sub {$_[KERNEL]->sig ($signal=>"catch");$_[KERNEL]->refcount_increment ($_[SESSION]->ID=>"poe")},catch=>sub {$cb->();$_[KERNEL]->sig_handled},stop=>sub {$_[KERNEL]->refcount_decrement ($_[SESSION]->ID=>"poe");$_[KERNEL]->sig ($signal)},},);POE::Kernel->call ($session,"start");bless \\$session,"AnyEvent::Impl::POE"}sub child {my ($class,%arg)=@_;my$pid=delete$arg{pid};my$cb=delete$arg{cb};my$cb=sub {&$cb};my$session=POE::Session->create (inline_states=>{_start=>sub {},start=>sub {$_[KERNEL]->sig (CHLD=>"child");$_[KERNEL]->refcount_increment ($_[SESSION]->ID=>"poe")},child=>sub {my ($rpid,$status)=@_[ARG1,ARG2];$cb->($rpid,$status)if$rpid==$pid || $pid==0},stop=>sub {$_[KERNEL]->refcount_decrement ($_[SESSION]->ID=>"poe");$_[KERNEL]->sig ("CHLD")},},);POE::Kernel->call ($session,"start");bless \\$session,"AnyEvent::Impl::POE"}sub DESTROY {POE::Kernel->call (${${$_[0]}},"stop")}sub _poll {POE::Kernel->loop_do_timeslice}sub AnyEvent::CondVar::Base::_wait {POE::Kernel->loop_do_timeslice until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_POE

$fatpacked{"AnyEvent/Impl/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_PERL';
  package AnyEvent::Impl::Perl;use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Loop;our$VERSION=$AnyEvent::VERSION;*AE::now=\&AnyEvent::Loop::now;*AE::now_update=\&AnyEvent::Loop::now_update;*AE::io=\&AnyEvent::Loop::io;*AE::timer=\&AnyEvent::Loop::timer;*AE::idle=\&AnyEvent::Loop::idle;*_poll=\&AnyEvent::Loop::one_event;*loop=\&AnyEvent::Loop::run;*now_update=\&AnyEvent::Loop::now_update;sub now {$AnyEvent::Loop::NOW}sub AnyEvent::CondVar::Base::_wait {AnyEvent::Loop::one_event until exists $_[0.01]{_ae_sent}}sub io {my (undef,%arg)=@_;AnyEvent::Loop::io$arg{fh},$arg{poll}eq "w",$arg{cb}}sub timer {my (undef,%arg)=@_;AnyEvent::Loop::timer$arg{after},$arg{interval},$arg{cb}}sub idle {my (undef,%arg)=@_;AnyEvent::Loop::idle$arg{cb}}1
ANYEVENT_IMPL_PERL

$fatpacked{"AnyEvent/Impl/Qt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_QT';
  package AnyEvent::Impl::Qt::Io;use Qt;use Qt::isa qw(Qt::SocketNotifier);use Qt::slots cb=>[];sub NEW {my ($class,$fh,$mode,$cb)=@_;shift->SUPER::NEW (fileno$fh,$mode);this->{fh}=$fh;this->{cb}=$cb;this->connect (this,SIGNAL "activated(int)",SLOT "cb()")}sub cb {this->setEnabled (0);this->{cb}->();this->setEnabled (1)}package AnyEvent::Impl::Qt::Timer;use Qt;use Qt::isa qw(Qt::Timer);use Qt::slots cb=>[];sub NEW {my ($class,$after,$interval,$cb)=@_;shift->SUPER::NEW ();this->{interval}=$interval;this->{cb}=$cb;this->connect (this,SIGNAL "timeout()",SLOT "cb()");this->start ($after,1)}sub cb {this->start (this->{interval},1)if defined this->{interval};this->{cb}->()}package AnyEvent::Impl::Qt;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Qt;use AnyEvent::Impl::Qt::Timer;use AnyEvent::Impl::Qt::Io;our$app=Qt::Application \@ARGV;sub io {my ($class,%arg)=@_;my ($fh,$qt)=AnyEvent::_dupfh$arg{poll},$arg{fh},Qt::SocketNotifier::Read (),Qt::SocketNotifier::Write ();AnyEvent::Impl::Qt::Io$fh,$qt,$arg{cb}}sub timer {my ($class,%arg)=@_;AnyEvent::Impl::Qt::Timer $arg{after}* 1000 || 1,$arg{interval}? $arg{interval}* 1000 || 1 : undef,$arg{cb}}sub _poll {Qt::app->processOneEvent}sub AnyEvent::CondVar::Base::_wait {Qt::app->processOneEvent until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_QT

$fatpacked{"AnyEvent/Impl/Tk.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_TK';
  package AnyEvent::Impl::Tk;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Tk ();our$mw=new MainWindow -title=>"AnyEvent Dummy Window";$mw->withdraw;END {undef$mw}sub io {my (undef,%arg)=@_;my ($fh,$tk)=AnyEvent::_dupfh$arg{poll},$arg{fh},"readable","writable";$mw->fileevent ($fh,$tk=>$arg{cb});bless [$fh,$tk],"AnyEvent::Impl::Tk::io"}sub AnyEvent::Impl::Tk::io::DESTROY {my ($fh,$tk)=@{$_[0]};$mw->fileevent ($fh,$tk=>"")}sub timer {my (undef,%arg)=@_;my$after=$arg{after}< 0 ? 0 : $arg{after}* 1000;my$cb=$arg{cb};my$id;if ($arg{interval}){my$ival=$arg{interval}* 1000;my$rcb=sub {$id=Tk::after$mw,$ival,[$_[0],$_[0]];&$cb};$id=Tk::after$mw,$after,[$rcb,$rcb]}else {$id=Tk::after$mw,$after,sub {&$cb}}bless \\$id,"AnyEvent::Impl::Tk::after"}sub idle {my (undef,%arg)=@_;my$cb=$arg{cb};my$id;my$rcb=sub {$id=Tk::after$mw,0=>[sub {$id=Tk::after$mw,idle=>[$_[0],$_[0]]},$_[0]];&$cb};$id=Tk::after$mw,idle=>[$rcb,$rcb];bless \\$id,"AnyEvent::Impl::Tk::after"}sub AnyEvent::Impl::Tk::after::DESTROY {Tk::after$mw,cancel=>$${$_[0]}}sub _poll {Tk::DoOneEvent (0)}sub AnyEvent::CondVar::Base::_wait {Tk::DoOneEvent (0)until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_TK

$fatpacked{"AnyEvent/Impl/UV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_UV';
  package AnyEvent::Impl::UV;use AnyEvent ();BEGIN {AnyEvent::common_sense}use UV 0.24;use Scalar::Util qw(weaken);sub warnlog {my$err=UV::last_error;AnyEvent::log warn=>"returned $_[0]: " .UV::err_name ($err)."($err): " .UV::strerror ($err);@_}my%io_watchers;sub io_watcher_cb {my$slaves=shift;my (undef,$events)=@_;return unless defined$slaves;for my$entry (keys %$slaves){my$slave=$slaves->{$entry};$slave->{cb}(@_)if$slave->{mode}& $events}}sub AnyEvent::Impl::UV::io_slave::new {bless {parent=>$_[1]},$_[0]}sub AnyEvent::Impl::UV::io_slave::DESTROY {my$self=$_[0];my$master=$self->{parent};delete$master->{slaves}{$self};if (keys %{$master->{slaves}}==0){if (defined$master->{w}){my$rc=UV::poll_stop$master->{w};warnlog$rc if$rc}delete$io_watchers{$master->{fd}};return}my$mode=0;for my$entry (keys %{$master->{slaves}}){$mode |= $master->{slaves}{$entry}{mode}}if ($master->{mode}!=$mode){$master->{mode}=$mode;my$rc=UV::poll_start$master->{w},$master->{mode},sub {io_watcher_cb$master->{slaves},@_};warnlog$rc if$rc}}sub io {my ($class,%arg)=@_;my$fd=fileno$arg{fh};defined$fd or $fd=$arg{fh};my$master=$io_watchers{$fd}||= {fd=>$fd };unless (defined$master->{w}){$master->{w}=UV::poll_init$fd;return warnlog$master->{w}unless defined$master->{w};$master->{slaves}={}}my$slave=AnyEvent::Impl::UV::io_slave->new ($master);weaken ($master->{slaves}->{$slave}=$slave);$slave->{mode}=$arg{poll}eq "r" ? UV::READABLE : UV::WRITABLE;$master->{mode}=0 unless defined$master->{mode};$slave->{cb}=$arg{cb};unless ($master->{mode}& $slave->{mode}){$master->{mode}|= $slave->{mode};my$rc=UV::poll_start$master->{w},$master->{mode},sub {io_watcher_cb$master->{slaves},@_};warnlog$rc if$rc}$slave}sub AnyEvent::Impl::UV::handle::new {my ($class,$w,$start,$stop,@args)=@_;return warnlog$w unless defined$w;my$rc=$start->($w,@args);warnlog$rc if$rc;bless {w=>$w,stop=>$stop },$class}sub AnyEvent::Impl::UV::handle::DESTROY {my$h=$_[0];return unless$h->{w};my$rc=$h->{stop}($h->{w});warnlog$rc if$rc;UV::close$h->{w}}sub idle {my ($class,%arg)=@_;AnyEvent::Impl::UV::handle->new (UV::timer_init,\&UV::idle_start,\&UV::idle_stop,$arg{cb})}sub timer {my ($class,%arg)=@_;AnyEvent::Impl::UV::handle->new (UV::timer_init,\&UV::timer_start,\&UV::timer_stop,$arg{after}* 1000,$arg{interval}* 1000,$arg{cb})}sub now {UV::now}sub _poll {UV::run UV::RUN_ONCE}sub AnyEvent::CondVar::Base::_wait {UV::run UV::RUN_NOWAIT until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_UV

$fatpacked{"AnyEvent/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOG';
  package AnyEvent::Log;use Carp ();use POSIX ();use AnyEvent ();BEGIN {AnyEvent::common_sense}our$VERSION=$AnyEvent::VERSION;our ($COLLECT,$FILTER,$LOG);our ($now_int,$now_str0.01,$now_str2);sub format_time($) {my$i=int $_[0];my$f=sprintf "%06d",1e6 * ($_[0]- $i);($now_int,$now_str1,$now_str2)=($i,split /\x01/,POSIX::strftime "%Y-%m-%d %H:%M:%S.\x01 %z",localtime$i)if$now_int!=$i;"$now_str1$f$now_str2"}our%CTX;sub _pkg_ctx($) {my$ctx=bless [$_[0],(1 << 10)- 1 - 1,{}],"AnyEvent::Log::Ctx";my$parent=$_[0]=~ /^(.+)::/ ? $CTX{$1}||= &_pkg_ctx ("$1"): $COLLECT;$ctx->[2]{$parent+0}=$parent;$ctx}our%STR2LEVEL=(fatal=>1,emerg=>1,exit=>1,alert=>2,critical=>3,crit=>3,error=>4,err=>4,die=>4,warn=>5,warning=>5,note=>6,notice=>6,info=>7,debug=>8,trace=>9,);our$TIME_EXACT;sub exact_time($) {$TIME_EXACT=shift;*_ts=$AnyEvent::MODEL ? $TIME_EXACT ? \&AE::now : \&AE::time : sub () {$TIME_EXACT ? do {require Time::HiRes;Time::HiRes::time ()}: time}}BEGIN {exact_time 0}AnyEvent::post_detect {exact_time$TIME_EXACT};our@LEVEL2STR=qw(0 fatal alert crit error warn note info debug trace);sub default_format($$$$) {my$ts=format_time $_[0];my$ct=" ";my@res;for (split /\n/,sprintf "%-5s %s: %s",$LEVEL2STR[$_[2]],$_[1][0],$_[3]){push@res,"$ts$ct$_\n";$ct=" + "}join "",@res}sub fatal_exit() {exit 1}sub _log {my ($ctx,$level,$format,@args)=@_;$level=$level > 0 && $level <= 9 ? $level+0 : $STR2LEVEL{$level}|| Carp::croak "$level: not a valid logging level, caught";my$mask=1 << $level;my ($success,%seen,@ctx,$now,@fmt);do {if (!ref$ctx){$level=$ctx}elsif ($ctx->[1]& $mask and!$seen{$ctx+0}++){if ($ctx->[5]> $level){push@ctx,$level;$level=$ctx->[5]}if ($ctx->[3]){local ($!,$@);unless ($now){$format=$format->()if ref$format;$format=sprintf$format,@args if@args;$format =~ s/\n$//;$now=_ts};my$str=$ctx->[4]? $ctx->[4]($now,$_[0],$level,$format): ($fmt[$level]||= default_format$now,$_[0],$level,$format);$success=1;$ctx->[3]($str)or push@ctx,values %{$ctx->[2]}}else {push@ctx,values %{$ctx->[2]}}}}while$ctx=pop@ctx;fatal_exit if$level <= 1;$success}sub log($$;@) {_log $CTX{(caller)[0]}||= _pkg_ctx +(caller)[0],@_}our%LOGGER;sub _reassess {local$SIG{__DIE__};my$die=sub {die};for (@_ ? $LOGGER{$_[0]}: values%LOGGER){my ($ctx,$level,$renabled)=@$_;$$renabled=!eval {_log$ctx,$level,$die;1}}}sub _logger {my ($ctx,$level,$renabled)=@_;$$renabled=1;my$logger=[$ctx,$level,$renabled];$LOGGER{$logger+0}=$logger;_reassess$logger+0;require AnyEvent::Util unless$AnyEvent::Util::VERSION;my$guard=AnyEvent::Util::guard (sub {delete$LOGGER{$logger+0}});sub {$guard if 0;_log$ctx,$level,@_ if $$renabled}}sub logger($;$) {_logger $CTX{(caller)[0]}||= _pkg_ctx +(caller)[0],@_}sub ctx(;$) {my$pkg=@_ ? shift : (caller)[0];ref$pkg ? $pkg : defined$pkg ? $CTX{$pkg}||= AnyEvent::Log::_pkg_ctx$pkg : bless [undef,(1 << 10)- 1 - 1],"AnyEvent::Log::Ctx"}our$ORIG_VERBOSE=$AnyEvent::VERBOSE;$AnyEvent::VERBOSE=9;sub reset {while (my ($k,$v)=each%CTX){@$v=($k,(1 << 10)- 1 - 1,{});$v->attach ($k =~ /^(.+)::/ ? $CTX{$1}: $AnyEvent::Log::COLLECT)}@$_=($_->[0],(1 << 10)- 1 - 1)for$LOG,$FILTER,$COLLECT;$LOG->title ('$AnyEvent::Log::LOG');$LOG->log_to_warn;$FILTER->slaves ($LOG);$FILTER->title ('$AnyEvent::Log::FILTER');$FILTER->level ($ORIG_VERBOSE);$COLLECT->slaves ($FILTER);$COLLECT->title ('$AnyEvent::Log::COLLECT');_reassess}*AnyEvent::log=*AE::log=\&log;*AnyEvent::logger=*AE::logger=\&logger;$_->[0]=ctx $_->[0]for values%LOGGER;$LOG=ctx undef;$FILTER=ctx undef;$COLLECT=ctx undef;AnyEvent::Log::reset;package AnyEvent::Log::LOG;package AE::Log::LOG;package AnyEvent::Log::FILTER;package AE::Log::FILTER;package AnyEvent::Log::COLLECT;package AE::Log::COLLECT;package AnyEvent::Log::Ctx;sub new {my$class=shift;my$ctx=AnyEvent::Log::ctx undef;while (@_){my ($k,$v)=splice @_,0,2;$ctx->$k (ref$v eq "ARRAY" ? @$v : $v)}bless$ctx,$class}sub title {$_[0][0]=$_[1]if @_ > 1;$_[0][0]}sub _lvl_lst {map {$_ > 0 && $_ <= 9 ? $_+0 : $_ eq "all" ? (1 .. 9): $STR2LEVEL{$_}|| Carp::croak "$_: not a valid logging level, caught"}@_}sub _lvl {$_[0]=~ /^(?:0|off|none)$/ ? 0 : (_lvl_lst $_[0])[-1]}our$NOP_CB=sub {0};sub levels {my$ctx=shift;$ctx->[1]=0;$ctx->[1]|= 1 << $_ for&_lvl_lst;AnyEvent::Log::_reassess}sub level {my$ctx=shift;$ctx->[1]=((1 << &_lvl)- 1)<< 1;AnyEvent::Log::_reassess}sub enable {my$ctx=shift;$ctx->[1]|= 1 << $_ for&_lvl_lst;AnyEvent::Log::_reassess}sub disable {my$ctx=shift;$ctx->[1]&= ~(1 << $_)for&_lvl_lst;AnyEvent::Log::_reassess}sub cap {my$ctx=shift;$ctx->[5]=&_lvl}sub attach {my$ctx=shift;$ctx->[2]{$_+0}=$_ for map {AnyEvent::Log::ctx $_}@_}sub detach {my$ctx=shift;delete$ctx->[2]{$_+0}for map {AnyEvent::Log::ctx $_}@_}sub slaves {undef $_[0][2];&attach}sub log_cb {my ($ctx,$cb)=@_;$ctx->[3]=$cb}sub fmt_cb {my ($ctx,$cb)=@_;$ctx->[4]=$cb}sub log_to_warn {my ($ctx,$path)=@_;$ctx->log_cb (sub {warn shift;0})}sub _log_to_disk {eval q{ # poor man's autoloading {}
        sub _log_to_disk {
           my ($ctx, $path, $keepopen) = @_;
  
           my $fh;
           my @queue;
           my $delay;
           my $disable;
  
           use AnyEvent::IO ();
  
           my $kick = sub {
              undef $delay;
              return unless @queue;
              $delay = 1;
  
              # we pass $kick to $kick, so $kick itself doesn't keep a reference to $kick.
              my $kick = shift;
  
              # write one or more messages
              my $write = sub {
                 # we write as many messages as have been queued
                 my $data = join "", @queue;
                 @queue = ();
  
                 AnyEvent::IO::aio_write $fh, $data, sub {
                    $disable = 1;
                    @_
                       ? ($_[0] == length $data or AE::log 4 => "unable to write to logfile '$path': short write")
                       :                           AE::log 4 => "unable to write to logfile '$path': $!";
                    undef $disable;
  
                    if ($keepopen) {
                       $kick->($kick);
                    } else {
                       AnyEvent::IO::aio_close ($fh, sub {
                          undef $fh;
                          $kick->($kick);
                       });
                    }
                 };
              };
  
              if ($fh) {
                 $write->();
              } else {
                 AnyEvent::IO::aio_open
                    $path,
                    AnyEvent::IO::O_CREAT | AnyEvent::IO::O_WRONLY | AnyEvent::IO::O_APPEND,
                    0666,
                    sub {
                       $fh = shift
                          or do {
                             $disable = 1;
                             AE::log 4 => "unable to open logfile '$path': $!";
                             undef $disable;
                             return;
                          };
  
                       $write->();
                    }
                 ;
              }
           };
  
           $ctx->log_cb (sub {
              return if $disable;
              push @queue, shift;
              $kick->($kick) unless $delay;
              0
           });
  
           $kick->($kick) if $keepopen; # initial open
        };
     };die if $@;&_log_to_disk}sub log_to_file {my ($ctx,$path)=@_;_log_to_disk$ctx,$path,1}sub log_to_path {my ($ctx,$path)=@_;_log_to_disk$ctx,$path,0}sub log_to_syslog {my ($ctx,$facility)=@_;require Sys::Syslog;$ctx->fmt_cb (sub {my$str=$_[3];$str =~ s/\n(?=.)/\n+ /g;[$_[2],"($_[1][0]) $str"]});$facility ||= "user";$ctx->log_cb (sub {my$lvl=$_[0][0]< 9 ? $_[0][0]: 8;Sys::Syslog::syslog ("$facility|" .($lvl - 1),$_)for split /\n/,$_[0][1];0})}*log=\&AnyEvent::Log::_log;*logger=\&AnyEvent::Log::_logger;package AnyEvent::Log;for (my$spec=$ENV{PERL_ANYEVENT_LOG}){my%anon;my$pkg=sub {$_[0]eq "log" ? $LOG : $_[0]eq "filter" ? $FILTER : $_[0]eq "collect" ? $COLLECT : $_[0]=~ /^%(.+)$/ ? ($anon{$1}||= do {my$ctx=ctx undef;$ctx->[0]=$_[0];$ctx}): $_[0]=~ /^(.*?)(?:::)?$/ ? ctx "$1" : die};/\G[[:space:]]+/gc;while (/\G((?:[^:=[:space:]]+|::|\\.)+)=/gc){my$ctx=$pkg->($1);my$level="level";while (/\G((?:[^,:[:space:]]+|::|\\.)+)/gc){for ("$1"){if ($_ eq "stderr"){$ctx->log_to_warn}elsif (/^file=(.+)/){$ctx->log_to_file ("$1")}elsif (/^path=(.+)/){$ctx->log_to_path ("$1")}elsif (/^syslog(?:=(.*))?/){require Sys::Syslog;$ctx->log_to_syslog ("$1")}elsif ($_ eq "nolog"){$ctx->log_cb (undef)}elsif (/^cap=(.+)/){$ctx->cap ("$1")}elsif (/^\+(.+)$/){$ctx->attach ($pkg->("$1"))}elsif ($_ eq "+"){$ctx->slaves}elsif ($_ eq "off" or $_ eq "0"){$ctx->level (0)}elsif ($_ eq "all"){$ctx->level ("all")}elsif ($_ eq "level"){$ctx->level ("all");$level="level"}elsif ($_ eq "only"){$ctx->level ("off");$level="enable"}elsif ($_ eq "except"){$ctx->level ("all");$level="disable"}elsif (/^\d$/){$ctx->$level ($_)}elsif (exists$STR2LEVEL{$_}){$ctx->$level ($_)}else {die "PERL_ANYEVENT_LOG ($spec): parse error at '$_'\n"}}/\G,/gc or last}/\G[:[:space:]]+/gc or last}/\G[[:space:]]+/gc;if (/\G(.+)/g){die "PERL_ANYEVENT_LOG ($spec): parse error at '$1'\n"}}1
ANYEVENT_LOG

$fatpacked{"AnyEvent/Loop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOOP';
  package AnyEvent::Loop;use Scalar::Util qw(weaken);use List::Util ();use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util ();our$VERSION=$AnyEvent::VERSION;our ($NOW,$MNOW);sub MAXWAIT() {0.01}BEGIN {local$SIG{__DIE__};my$time_hires=eval "use Time::HiRes (); 1";my$clk_tck=eval "use POSIX (); POSIX::sysconf (POSIX::_SC_CLK_TCK ())";my$round;if ($time_hires && eval "&Time::HiRes::clock_gettime (Time::HiRes::CLOCK_MONOTONIC ())"){AE::log 8=>"Using CLOCK_MONOTONIC as timebase.";*_update_clock=sub {$NOW=&Time::HiRes::time;$MNOW=Time::HiRes::clock_gettime (&Time::HiRes::CLOCK_MONOTONIC)}}elsif (100 <= $clk_tck && $clk_tck <= 1000000 && eval {(POSIX::times ())[0]!=-1}){AE::log 8=>"Using POSIX::times (monotonic) as timebase.";my$HZ1=1 / $clk_tck;my$last=(POSIX::times ())[0];my$next;*_update_clock=sub {$NOW=time;$next=(POSIX::times ())[0];$last -= 4294967296 if$last > $next;$MNOW += ($next - $last)* $HZ1;$last=$next};$round=$HZ1}elsif (eval "use Time::HiRes (); 1"){AE::log 8=>"Using Time::HiRes::time (non-monotonic) clock as timebase.";*_update_clock=sub {$NOW=$MNOW=&Time::HiRes::time}}else {AE::log fatal=>"Unable to find sub-second time source (is this really perl 5.8.0 or later?)"}$round=0.001 if$round < 0.001;$round -= $round * 1e-2;eval "sub ROUNDUP() { $round }"}_update_clock;sub now () {$NOW}sub now_update() {_update_clock}my@fds=([],[]);sub V() {0}sub W() {1}my$need_sort=1e300;my@timer;my@idle;sub one_event {_update_clock;if ($MNOW >= $need_sort){$need_sort=1e300;@timer=sort {$a->[0]<=> $b->[0]}@timer}if (@timer && $timer[0][0]<= $MNOW){do {my$timer=shift@timer;$timer->[1]&& $timer->[1]($timer)}while@timer && $timer[0][0]<= $MNOW}else {my ($wait,@vec,$fds)=(@timer && $timer[0][0]< $need_sort ? $timer[0][0]: $need_sort)- $MNOW;$wait=$wait < MAXWAIT ? $wait + ROUNDUP : MAXWAIT;$wait=0 if@idle;$fds=CORE::select $vec[0]=$fds[0][V],$vec[1]=$fds[1][V],AnyEvent::WIN32 ? $vec[2]=$fds[1][V]: undef,$wait;_update_clock;if ($fds > 0){$vec[1]|= $vec[2]if AnyEvent::WIN32;for (1,0){my$fds=$fds[$_];for (unpack "b*",$vec[$_]){while (/1/g){$_ && $_->[2]()for @{$fds->[W][(pos)- 1]|| []}}}}}elsif (AnyEvent::WIN32 && $fds && $!==AnyEvent::Util::WSAEINVAL){CORE::select undef,undef,undef,$wait if$wait}elsif (!@timer || $timer[0][0]> $MNOW &&!$fds){$$$_ && $$$_->()for@idle=grep $$$_,@idle}}}sub run {one_event while 1}sub io($$$) {my ($fd,$write,$cb)=@_;defined ($fd=fileno$fd)or $fd=$_[0];my$self=bless [$fd,$write,$cb,],"AnyEvent::Loop::io";my$fds=$fds[$self->[1]];my$q=$fds->[W][$fd]||= [];(vec$fds->[V],$fd,1)=1;$self->[3]=@$q;push @$q,$self;weaken$q->[-1];$self}sub AnyEvent::Loop::io::DESTROY {my ($self)=@_;my$fds=$fds[$self->[1]];my$fd=$self->[0];if (@{$fds->[W][$fd]}==1){delete$fds->[W][$fd];(vec$fds->[V],$fd,1)=0}else {my$q=$fds->[W][$fd];my$last=pop @$q;if ($last!=$self){weaken ($q->[$self->[3]]=$last);$last->[3]=$self->[3]}}}sub timer($$$) {my ($after,$interval,$cb)=@_;my$self;if ($interval){$self=[$MNOW + $after,sub {$_[0][0]=List::Util::max $_[0][0]+ $interval,$MNOW;push@timer,$_[0];weaken$timer[-1];$need_sort=$_[0][0]if $_[0][0]< $need_sort;&$cb}]}else {$self=[$MNOW + $after,$cb]}push@timer,$self;weaken$timer[-1];$need_sort=$self->[0]if$self->[0]< $need_sort;$self}sub idle($) {my$cb=shift;push@idle,\\$cb;weaken ${$idle[-1]};${$idle[-1]}}1
ANYEVENT_LOOP

$fatpacked{"AnyEvent/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_SOCKET';
  package AnyEvent::Socket;use Carp ();use Errno ();use Socket qw(AF_INET AF_UNIX SOCK_STREAM SOCK_DGRAM SOL_SOCKET SO_REUSEADDR);use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util qw(guard AF_INET6);use AnyEvent::DNS ();use base 'Exporter';our@EXPORT=qw(getprotobyname parse_hostport format_hostport parse_ipv4 parse_ipv6 parse_ip parse_address format_ipv4 format_ipv6 format_ip format_address address_family inet_aton tcp_server tcp_connect);our$VERSION=$AnyEvent::VERSION;sub parse_ip0.01($) {$_[0]=~ /^      (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* )
                (?:\. (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* ) ){0,3}$/x or return undef;@_=map /^0/ ? oct : $_,split /\./,$_[0];return undef if grep $_ >= 256,@_[0 .. @_ - 2];return undef if $_[-1]>= 2 ** (8 * (4 - $#_));pack "N",(pop)+ ($_[0]<< 24)+ ($_[1]<< 16)+ ($_[2]<< 8)}sub parse_ipv6($) {my$n=$_[0]=~ y/://;return undef if$n < 2 || $n > 8;my ($h,$t)=split /::/,$_[0],2;unless (defined$t){($h,$t)=(undef,$h)}my@h=split /:/,$h,-1;my@t=split /:/,$t,-1;if (@t && $t[-1]=~ /\./){return undef if$n > 6;my$ipn=parse_ipv4 pop@t or return undef;push@t,map +(sprintf "%x",$_),unpack "nn",$ipn}return undef unless@h + @t==8 || $_[0]=~ /::/;return undef if grep!/^[0-9a-fA-F]{1,4}$/,@h,@t;push@h,0 while@h + @t < 8;pack "n*",map hex,@h,@t}sub parse_unix($) {$_[0]eq "unix/" ? pack "S",AF_UNIX : undef}sub parse_address($) {for (&parse_ipv6){if ($_){s/^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff//;return $_}else {return&parse_ipv4 || &parse_unix}}}*aton=\&parse_address;our%PROTO_BYNAME;$PROTO_BYNAME{tcp}=Socket::IPPROTO_TCP ()if defined&Socket::IPPROTO_TCP;$PROTO_BYNAME{udp}=Socket::IPPROTO_UDP ()if defined&Socket::IPPROTO_UDP;$PROTO_BYNAME{icmp}=Socket::IPPROTO_ICMP()if defined&Socket::IPPROTO_ICMP;sub getprotobyname($) {my$name=lc shift;defined (my$proton=$PROTO_BYNAME{$name}|| (getprotobyname$name)[2])or return;($name,uc$name,$proton)}sub parse_hostport($;$) {my ($host,$port);for ("$_[0]"){return ("unix/",$_)if m%^/%;unless (($host)=/^\s* ([0-9a-fA-F:]*:[0-9a-fA-F:]*:[0-9a-fA-F\.:]*)/xgc and parse_ipv6$host){/^\s*/xgc;if (/^ \[ ([^\[\]]+) \]/xgc){$host=$1}elsif (/^ ([^\[\]:\ ]+) /xgc){$host=$1}else {return}}if (/\G (?:\s+|:|\#) ([^:[:space:]]+) \s*$/xgc){$port=$1}elsif (/\G\s*$/gc && length $_[1]){$port=$_[1]}else {return}}return if$host =~ /:/ &&!parse_ipv6$host;($host,$port)}sub format_hostport($;$) {my ($host,$port)=@_;$port=":$port" if length$port;$host="[$host]" if$host =~ /:/;"$host$port"}sub address_family($) {4==length $_[0]? AF_INET : 16==length $_[0]? AF_INET6 : unpack "S",$_[0]}sub format_ipv4($) {join ".",unpack "C4",$_[0]}sub format_ipv6($) {if ($_[0]=~ /^\x00\x00\x00\x00\x00\x00\x00\x00/){if (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 eq $_[0]){return "::"}elsif (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 eq $_[0]){return "::1"}elsif (v0.0.0.0.0.0.0.0.0.0.0.0 eq substr $_[0],0,12){return "::" .format_ipv4 substr $_[0],12}elsif (v0.0.0.0.0.0.0.0.0.0.255.255 eq substr $_[0],0,12){return "::ffff:" .format_ipv4 substr $_[0],12}elsif (v0.0.0.0.0.0.0.0.255.255.0.0 eq substr $_[0],0,12){return "::ffff:0:" .format_ipv4 substr $_[0],12}}my$ip=sprintf "%x:%x:%x:%x:%x:%x:%x:%x",unpack "n8",$_[0];$ip =~ s/(?:^|:) 0:0:0:0:0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)   0:0:0:0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)     0:0:0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)       0:0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)         0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)           0:0 (?:$|:)/::/x;$ip}sub format_address($) {if (4==length $_[0]){return&format_ipv4}elsif (16==length $_[0]){return $_[0]=~ /^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff(....)$/s ? format_ipv4 $1 : &format_ipv6}elsif (AF_UNIX==address_family $_[0]){return "unix/"}else {return undef}}*ntoa=\&format_address;sub inet_aton {my ($name,$cb)=@_;if (my$ipn=&parse_ipv4){$cb->($ipn)}elsif (my$ipn=&parse_ipv6){$cb->($ipn)}elsif ($name eq "localhost"){$cb->(v127.0.0.1,v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1)}else {require AnyEvent::DNS unless$AnyEvent::DNS::VERSION;my$ipv4=$AnyEvent::PROTOCOL{ipv4};my$ipv6=$AnyEvent::PROTOCOL{ipv6};my@res;my$cv=AE::cv {$cb->(map @$_,reverse@res)};$cv->begin;if ($ipv4){$cv->begin;AnyEvent::DNS::a ($name,sub {$res[$ipv4]=[map {parse_ipv4 $_}@_];$cv->end})};if ($ipv6){$cv->begin;AnyEvent::DNS::aaaa ($name,sub {$res[$ipv6]=[map {parse_ipv6 $_}@_];$cv->end})};$cv->end}}BEGIN {*sockaddr_family=$Socket::VERSION >= 1.75 ? \&Socket::sockaddr_family : (Socket::pack_sockaddr_in 0x5555,"\x55\x55\x55\x55" | eval {Socket::pack_sockaddr_un "U"})=~ /^\x00/ ? sub {unpack "xC",$_[0]}: sub {unpack "S",$_[0]}}my$pack_family=0x55==sockaddr_family ("\x55\x55")? "xC" : "S";sub pack_sockaddr($$) {my$af=address_family $_[1];if ($af==AF_INET){Socket::pack_sockaddr_in $_[0],$_[1]}elsif ($af==AF_INET6){pack "$pack_family nL a16 L",AF_INET6,$_[0],0,$_[1],0}elsif ($af==AF_UNIX){Socket::pack_sockaddr_un $_[0]}else {Carp::croak "pack_sockaddr: invalid host"}}my$sa_un_zero=$Socket::VERSION >= 2.011 ? "" : eval {Socket::pack_sockaddr_un ""};$sa_un_zero ^= $sa_un_zero;sub unpack_sockaddr($) {my$af=sockaddr_family $_[0];if ($af==AF_INET){Socket::unpack_sockaddr_in $_[0]}elsif ($af==AF_INET6){unpack "x2 n x4 a16",$_[0]}elsif ($af==AF_UNIX){((Socket::unpack_sockaddr_un $_[0]^ $sa_un_zero),pack "S",AF_UNIX)}else {Carp::croak "unpack_sockaddr: unsupported protocol family $af"}}our%HOSTS;our@HOSTS_CHECKING;our$HOSTS_MTIME;sub _parse_hosts($) {%HOSTS=();for (split /\n/,$_[0]){s/#.*$//;s/^[ \t]+//;y/A-Z/a-z/;my ($addr,@aliases)=split /[ \t]+/;next unless@aliases;if (my$ip=parse_ipv4$addr){($ip)=$ip =~ /^(.*)$/s if AnyEvent::TAINT;push @{$HOSTS{$_}[0]},$ip for@aliases}elsif (my$ip=parse_ipv6$addr){($ip)=$ip =~ /^(.*)$/s if AnyEvent::TAINT;push @{$HOSTS{$_}[1]},$ip for@aliases}}}sub _load_hosts_unless(&$@) {my ($cont,$cv,@dns)=@_;if (@dns){$cv->end}else {my$etc_hosts=length$ENV{PERL_ANYEVENT_HOSTS}? $ENV{PERL_ANYEVENT_HOSTS}: AnyEvent::WIN32 ? "$ENV{SystemRoot}/system32/drivers/etc/hosts" : "/etc/hosts";push@HOSTS_CHECKING,sub {$cont->();$cv->end};unless ($#HOSTS_CHECKING){require AnyEvent::IO;AnyEvent::IO::aio_stat ($etc_hosts,sub {if ((stat _)[9]ne $HOSTS_MTIME){AE::log 8=>"(re)loading $etc_hosts.";$HOSTS_MTIME=(stat _)[9];AnyEvent::IO::aio_load ($etc_hosts,sub {_parse_hosts $_[0];(shift@HOSTS_CHECKING)->()while@HOSTS_CHECKING})}else {(shift@HOSTS_CHECKING)->()while@HOSTS_CHECKING}})}}}sub resolve_sockaddr($$$$$$) {my ($node,$service,$proto,$family,$type,$cb)=@_;if ($node eq "unix/"){return$cb->()if$family || $service !~ /^\//;return$cb->([AF_UNIX,defined$type ? $type : SOCK_STREAM,0,Socket::pack_sockaddr_un$service])}unless (AF_INET6){$family!=6 or return$cb->();$family=4}$cb->()if$family==4 &&!$AnyEvent::PROTOCOL{ipv4};$cb->()if$family==6 &&!$AnyEvent::PROTOCOL{ipv6};$family ||= 4 unless$AnyEvent::PROTOCOL{ipv6};$family ||= 6 unless$AnyEvent::PROTOCOL{ipv4};$proto ||= "tcp";$type ||= $proto eq "udp" ? SOCK_DGRAM : SOCK_STREAM;my$proton=AnyEvent::Socket::getprotobyname$proto or Carp::croak "$proto: protocol unknown";my$port;if ($service =~ /^(\S+)=(\d+)$/){($service,$port)=($1,$2)}elsif ($service =~ /^\d+$/){($service,$port)=(undef,$service)}else {$port=(getservbyname$service,$proto)[2]or Carp::croak "$service/$proto: service unknown"}my$resolve=sub {my@target=@_;my@res;my$cv=AE::cv {$cb->(map $_->[2],sort {$AnyEvent::PROTOCOL{$b->[1]}<=> $AnyEvent::PROTOCOL{$a->[1]}or $a->[0]<=> $b->[0]}@res)};$cv->begin;for my$idx (0 .. $#target){my ($node,$port)=@{$target[$idx]};if (my$noden=parse_address$node){my$af=address_family$noden;if ($af==AF_INET && $family!=6){push@res,[$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,$noden]]}if ($af==AF_INET6 && $family!=4){push@res,[$idx,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,$noden]]}}else {$node =~ y/A-Z/a-z/;if ($family!=6){$cv->begin;AnyEvent::DNS::a$node,sub {push@res,[$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,parse_ipv4 $_]]for @_;_load_hosts_unless {push@res,map [$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,$_]],@{($HOSTS{$node}|| [])->[0]}}$cv,@_}}if ($family!=4){$cv->begin;AnyEvent::DNS::aaaa$node,sub {push@res,[$idx,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,parse_ipv6 $_]]for @_;_load_hosts_unless {push@res,map [$idx + 0.5,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,$_]],@{($HOSTS{$node}|| [])->[1]}}$cv,@_}}}}$cv->end};$node=AnyEvent::Util::idn_to_ascii$node if$node =~ /[^\x00-\x7f]/;if ($node eq "localhost"){$resolve->(["127.0.0.1",$port],["::1",$port])}elsif (defined$service &&!parse_address$node){AnyEvent::DNS::srv$service,$proto,$node,sub {my (@srv)=@_;if (@srv){$srv[0][2]ne "" || $#srv or return$cb->();$resolve->(map ["$_->[3].",$_->[2]],grep $_->[3]ne ".",@srv)}else {$resolve->([$node,$port])}}}else {$resolve->([$node,$port])}}sub tcp_connect($$$;$) {my ($host,$port,$connect,$prepare)=@_;my%state=(fh=>undef);resolve_sockaddr$host,$port,0,0,undef,sub {my@target=@_;$state{next}=sub {return unless exists$state{fh};my$errno=$!;my$target=shift@target or return AE::postpone {return unless exists$state{fh};%state=();$!=$errno;$connect->()};my ($domain,$type,$proto,$sockaddr)=@$target;socket$state{fh},$domain,$type,$proto or return$state{next}();AnyEvent::fh_unblock$state{fh};my$timeout=$prepare && $prepare->($state{fh});$timeout ||= 30 if AnyEvent::WIN32;$state{to}=AE::timer$timeout,0,sub {$!=Errno::ETIMEDOUT;$state{next}()}if$timeout;if ((connect$state{fh},$sockaddr)|| ($!==Errno::EINPROGRESS || $!==Errno::EWOULDBLOCK || $!==AnyEvent::Util::WSAEINVAL || $!==AnyEvent::Util::WSAEWOULDBLOCK)){$state{ww}=AE::io$state{fh},1,sub {if (my$sin=getpeername$state{fh}){my ($port,$host)=unpack_sockaddr$sin;delete$state{ww};delete$state{to};my$guard=guard {%state=()};$connect->(delete$state{fh},format_address$host,$port,sub {$guard->cancel;$state{next}()})}else {if ($!==Errno::ENOTCONN){sysread$state{fh},my$buf,1;$!=(unpack "l",getsockopt$state{fh},Socket::SOL_SOCKET(),Socket::SO_ERROR())|| Errno::EAGAIN if AnyEvent::CYGWIN && $!==Errno::EAGAIN}return if $!==Errno::EAGAIN;delete$state{ww};delete$state{to};$state{next}()}}}else {$state{next}()}};$!=Errno::ENXIO;$state{next}()};defined wantarray && guard {%state=()}}sub _tcp_bind($$$;$) {my ($host,$service,$done,$prepare)=@_;$host=$AnyEvent::PROTOCOL{ipv4}< $AnyEvent::PROTOCOL{ipv6}&& AF_INET6 ? "::" : "0" unless defined$host;my$ipn=parse_address$host or Carp::croak "AnyEvent::Socket::tcp_server: cannot parse '$host' as host address";my$af=address_family$ipn;my%state;Carp::croak "tcp_server/socket: address family not supported" if AnyEvent::WIN32 && $af==AF_UNIX;socket$state{fh},$af,SOCK_STREAM,0 or Carp::croak "tcp_server/socket: $!";if ($af==AF_INET || $af==AF_INET6){setsockopt$state{fh},SOL_SOCKET,SO_REUSEADDR,1 or Carp::croak "tcp_server/so_reuseaddr: $!" unless AnyEvent::WIN32;unless ($service =~ /^\d*$/){$service=(getservbyname$service,"tcp")[2]or Carp::croak "$service: service unknown"}}elsif ($af==AF_UNIX){unlink$service}bind$state{fh},pack_sockaddr$service,$ipn or Carp::croak "bind: $!";if ($af==AF_UNIX){my$fh=$state{fh};my$ino=(stat$fh)[1];$state{unlink}=guard {unlink$service if$ino==(stat$fh)[1]}}AnyEvent::fh_unblock$state{fh};my$len;if ($prepare){my ($service,$host)=unpack_sockaddr getsockname$state{fh};$len=$prepare && $prepare->($state{fh},format_address$host,$service)}$len ||= 128;listen$state{fh},$len or Carp::croak "listen: $!";$done->(\%state);defined wantarray ? guard {%state=()}: ()}sub tcp_bind($$$;$) {my ($host,$service,$done,$prepare)=@_;_tcp_bind$host,$service,sub {$done->(delete shift->{fh})},$prepare}sub tcp_server($$$;$) {my ($host,$service,$accept,$prepare)=@_;_tcp_bind$host,$service,sub {my$rstate=shift;$rstate->{aw}=AE::io$rstate->{fh},0,sub {while ($rstate->{fh}&& (my$peer=accept my$fh,$rstate->{fh})){AnyEvent::fh_unblock$fh;my ($service,$host)=unpack_sockaddr$peer;$accept->($fh,format_address$host,$service)}}},$prepare}sub tcp_nodelay($$) {my$onoff=int!!$_[1];setsockopt $_[0],Socket::IPPROTO_TCP (),Socket::TCP_NODELAY (),$onoff}sub tcp_congestion($$) {defined TCP_CONGESTION ? setsockopt $_[0],Socket::IPPROTO_TCP (),TCP_CONGESTION,"$_[1]" : undef}1
ANYEVENT_SOCKET

$fatpacked{"AnyEvent/Strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_STRICT';
  package AnyEvent::Strict;use Carp qw(confess);use Errno ();use POSIX ();$Carp::Internal{AE}=1;$Carp::Internal{AnyEvent::Strict}=1;use AnyEvent ();BEGIN {AnyEvent::common_sense}AnyEvent::_isa_hook 1=>"AnyEvent::Strict",1;BEGIN {if (defined&Internals::SvREADONLY){*wrap=sub {my$cb=shift;sub {local $_;Internals::SvREADONLY $_,1;&$cb}}}else {my$magic=[];*wrap=sub {my$cb=shift;sub {local $_=$magic;&$cb;if (!ref $_ || $_!=$magic){require AnyEvent::Debug;die "callback $cb (" .AnyEvent::Debug::cb2str ($cb).") modified \$_ without restoring it.\n"}}}}}our (@FD_INUSE,$FD_I);our$FD_CHECK_W=AE::timer 4,4,sub {my$cnt=(@FD_INUSE < 100 * 10 ? int@FD_INUSE * 0.1 : 100)|| 10;if ($FD_I <= 0){$FD_I=@FD_INUSE or return}$cnt=$FD_I if$cnt > $FD_I;eval {do {!$FD_INUSE[--$FD_I]or (POSIX::lseek$FD_I,0,1)!=-1 or $!!=Errno::EBADF or die}while --$cnt;1}or AE::log crit=>"File descriptor $FD_I registered with AnyEvent but prematurely closed, event loop might malfunction."};sub io {my$class=shift;my (%arg,$fh,$cb,$fd)=@_;ref$arg{cb}or confess "AnyEvent->io called with illegal cb argument '$arg{cb}'";$cb=wrap delete$arg{cb};$arg{poll}=~ /^[rw]$/ or confess "AnyEvent->io called with illegal poll argument '$arg{poll}'";$fh=delete$arg{fh};if ($fh =~ /^\s*\d+\s*$/){$fd=$fh;$fh=AnyEvent::_dupfh$arg{poll},$fh}else {defined eval {$fd=fileno$fh}or confess "AnyEvent->io called with illegal fh argument '$fh'"}-f$fh and confess "AnyEvent->io called with fh argument pointing to a file";delete$arg{poll};confess "AnyEvent->io called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;++$FD_INUSE[$fd];bless [$fd,$class->SUPER::io (@_,cb=>$cb)],"AnyEvent::Strict::io"}sub AnyEvent::Strict::io::DESTROY {--$FD_INUSE[$_[0][0]]}sub timer {my$class=shift;my%arg=@_;ref$arg{cb}or confess "AnyEvent->timer called with illegal cb argument '$arg{cb}'";my$cb=wrap delete$arg{cb};exists$arg{after}or confess "AnyEvent->timer called without mandatory 'after' parameter";delete$arg{after};!$arg{interval}or $arg{interval}> 0 or confess "AnyEvent->timer called with illegal interval argument '$arg{interval}'";delete$arg{interval};confess "AnyEvent->timer called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::timer (@_,cb=>$cb)}sub signal {my$class=shift;my%arg=@_;ref$arg{cb}or confess "AnyEvent->signal called with illegal cb argument '$arg{cb}'";my$cb=wrap delete$arg{cb};defined AnyEvent::Base::sig2num$arg{signal}and $arg{signal}==0 or confess "AnyEvent->signal called with illegal signal name '$arg{signal}'";delete$arg{signal};confess "AnyEvent->signal called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::signal (@_,cb=>$cb)}sub child {my$class=shift;my%arg=@_;ref$arg{cb}or confess "AnyEvent->child called with illegal cb argument '$arg{cb}'";my$cb=wrap delete$arg{cb};$arg{pid}=~ /^-?\d+$/ or confess "AnyEvent->child called with malformed pid value '$arg{pid}'";delete$arg{pid};confess "AnyEvent->child called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::child (@_,cb=>$cb)}sub idle {my$class=shift;my%arg=@_;ref$arg{cb}or confess "AnyEvent->idle called with illegal cb argument '$arg{cb}'";my$cb=wrap delete$arg{cb};confess "AnyEvent->idle called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::idle (@_,cb=>$cb)}sub condvar {my$class=shift;my%arg=@_;!exists$arg{cb}or ref$arg{cb}or confess "AnyEvent->condvar called with illegal cb argument '$arg{cb}'";my@cb=exists$arg{cb}? (cb=>wrap delete$arg{cb}): ();confess "AnyEvent->condvar called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::condvar (@cb)}sub time {my$class=shift;@_ and confess "AnyEvent->time wrongly called with paramaters";$class->SUPER::time (@_)}sub now {my$class=shift;@_ and confess "AnyEvent->now wrongly called with paramaters";$class->SUPER::now (@_)}1
ANYEVENT_STRICT

$fatpacked{"AnyEvent/TLS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_TLS';
  package AnyEvent::TLS;use Carp qw(croak);use Scalar::Util ();use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util ();use Net::SSLeay;our$VERSION=$AnyEvent::VERSION;our$REF_IDX;sub _tmpfile($) {require File::Temp unless$File::Temp::VERSION;my ($fh,$path)=File::Temp::tempfile ("aetlsXXXXXXXXX",TMPDIR=>0.01,EXLOCK=>0);my$guard=AnyEvent::Util::guard {unlink$path};syswrite$fh,$_[0];close$fh;($path,$guard)}our%DH_PARAMS=(skip512=>"MEYCQQD1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak|XUGfnHy9iUsiGSa6q6Jew1XpKgVfAgEC",skip1024=>"MIGHAoGBAPSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsY|jY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6|ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XpL3jHAgEC",skip2048=>"MIIBCAKCAQEA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadWoxTpj0BV|89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeSWc39uK50|T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0iP1YTknb|zSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF040zT9fBdX|Q6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQClCbAkbT|CD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwIBAg==",skip4096=>"MIICCAKCAgEA+hRyUsFN4VpJ1O8JLcCo/VWr19k3BCgJ4uk+d+KhehjdRqNDNyOQ|l/MOyQNQfWXPeGKmOmIig6Ev/nm6Nf9Z2B1h3R4hExf+zTiHnvVPeRBhjdQi81rt|Xeoh6TNrSBIKIHfUJWBh3va0TxxjQIs6IZOLeVNRLMqzeylWqMf49HsIXqbcokUS|Vt1BkvLdW48j8PPv5DsKRN3tloTxqDJGo9tKvj1Fuk74A+Xda1kNhB7KFlqMyN98|VETEJ6c7KpfOo30mnK30wqw3S8OtaIR/maYX72tGOno2ehFDkq3pnPtEbD2CScxc|alJC+EL7RPk5c/tgeTvCngvc1KZn92Y//EI7G9tPZtylj2b56sHtMftIoYJ9+ODM|sccD5Piz/rejE3Ome8EOOceUSCYAhXn8b3qvxVI1ddd1pED6FHRhFvLrZxFvBEM9|ERRMp5QqOaHJkM+Dxv8Cj6MqrCbfC4u+ZErxodzuusgDgvZiLF22uxMZbobFWyte|OvOzKGtwcTqO/1wV5gKkzu1ZVswVUQd5Gg8lJicwqRWyyNRczDDoG9jVDxmogKTH|AaqLulO7R8Ifa1SwF2DteSGVtgWEN8gDpN3RBmmPTDngyF2DHb5qmpnznwtFKdTL|KWbuHn491xNO25CQWMtem80uKw+pTnisBRF/454n1Jnhub144YRBoN8CAQI=",schmorp1024=>"MIGHAoGBAN+GjqAhNxLesSuGfDzYe6HdexXtHuxe85umshfPHfnmLSkGWl/FE27+|v+50mwY5XaNnCmo1VvGju4iTKxWoZTGgslUSc8KX197XWAXIpab8ESyg442if9Kr|vSOuu0fopwvvTOgHK8mkEWI4joU5G4/MQy+pnC5NIEVBP4HtGiTrAgEC",schmorp1539=>"MIHHAoHBByJzpVGUsXysX8w/+uuXRUCL9exhAixoHkaJU5lf4noJUtp9F0yr/5rb|hF8M9mSZJ+RlPyB+Zt37GPp1WQDO1+/2yZJX9kHE3+h5JCRoR8PKc2G+ts9jhM7r|CnTQ0z0b6s12Pusf+UhQPwLust4JAYE/LPuTK8yFiVx5L2a+aZhGMVlYN/12SEtY|jRl3lGXdZj9g8E2PzTQbA9CGy5dGIvz/ENTzTVleKuQ+80bzpVEPjZL9tv43Zc+l|MFLzxuE5uwIBAg==",schmorp2048=>"MIIBCAKCAQEAhR5Fn9h3Tgnc+q4o3CMkZtre3lLUyDT+1bf3aiVOt22JdDQndZLc|FeKz8AqliB3UIgNExc6oDtuG4znKPgklfOnHv/a9tl1AYQbV+QFM/E0jYl6oG8tF|Epgxezt1GCivvtu64ql0s213wr64QffNMt3hva8lNqK1PXfqp13PzzLzAVsfghrv|fMAX7/bYm1T5fAJdcah6FeZkKof+mqbs8HtRjfvrUF2npEM2WdupFu190vcwABnN|TTJheXCWv2BF2f9EEr61q3OUhSNWIThtZP+NKe2bACm1PebT0drAcaxKoMz9LjKr|y5onGs0TOuQ7JmhtZL45Zr4LwBcyTucLUwIBAg==",schmorp4096=>"MIICCAKCAgEA5WwA5lQg09YRYqc/JILCd2AfBmYBkF19wmCEJB8G3JhTxv8EGvYk|xyP2ecKVUvHTG8Xw/qpW8nRqzPIyV8QRf6YFYSf33Qnx2xYhcnqOumU3nfC0SNOL|/w2q1BA9BbHtW4574P+6hOQx9ftRtbtZ2HPKBMRcAKGjpYZiKopv0+UAM4NpEC2p|bfajp7pyVLeb/Aqm/oWP3L63wPlY1SDp+XRzrOAKB+/uLGqEwV0bBaxxGL29BpOp|O2z1ALGXiDCcLs9WTn9WqUhWDzUN6fahm53rd7zxwpFCb6K2YhaK0peG95jzSUJ8|aoL0KgWuC6v5+gPJHRu0HrQIdfAdN4VchqYOKE46uNNkQl8VJGu4RjYB7lFBpRwO|g2HCsGMo2X7BRmA1st66fh+JOd1smXMZG/2ozTOooL+ixcx4spNneg4aQerWl5cb|nWXKtPCp8yPzt/zoNzL3Fon2Ses3sNgMos0M/ZbnigScDxz84Ms6V/X8Z0L4m/qX|mL42dP40tgvmgqi6BdsBzcIWeHlEcIhmGcsEBxxKEg7gjb0OjjvatpUCJhmRrGjJ|LtMkBR68qr42OBMN/PBB4KPOWNUqTauXZajfCwYdbpvV24ZhtkcRdw1zisyARBSh|aTKW/GV8iLsUzlYN27LgVEwMwnWQaoecW6eOTNKGUURC3In6XZSvVzsCAQI=",schmorp8192=>"MIIECAKCBAEA/SAEbRSSLenVxoInHiltm/ztSwehGOhOiUKfzDcKlRBZHlCC9jBl|S/aeklM6Ucg8E6J2bnfoh6CAdnE/glQOn6CifhZr8X/rnlL9/eP+r9m+aiAw4l0D|MBd8BondbEqwTZthMmLtx0SslnevsFAZ1Cj8WgmUNaSPOukvJ1N7aQ98U+E99Pw3|VG8ANBydXqLqW2sogS8FtZoMbVywcQuaGmC7M6i3Akxe3CCSIpR/JkEZIytREBSC|CH+x3oW/w+wHzq3w8DGB9hqz1iMXqDMiPIMSdXC0DaIPokLnd7X8u6N14yCAco2h|P0gspD3J8pS2FpUY8ZTVjzbVCjhNNmTryBZAxHSWBuX4xYcCHUtfGlUe/IGLSVE1|xIdFpZUfvlvAJjVq0/TtDMg3r2JSXrhQVlr8MPJwSApDVr5kOBHT/uABio4z+5yR|PAvundznfyo9GGAWhIA36GQqsxSQfoRTjWssFoR/cu+9aomRwwOLkvObu8nCVVLH|nLdKDk5cIR0TvNs9HZ6ZmkzL7ah7cPzEKl7U6eE6yZLVYMNecnPLS6PSAIG4gxcq|CVQrrZjQLfTDrJn0OGgpShX85RaDsuiRtp2bpDZ23YDqdwr4wRjvIargjqc2zcF+|jIb7dUS6ci7bVG/CGOQUuiMWAiXZ3a1f343SMf9A05/sf1xwnMeco6STBLZ3X+PA|4urU+grtpWaFtS/fPD2ILn8nrJ3WuSKKUeSnVM46mmJQsOkyn7z8l3jNLB17GYKo|qc+0UuU/2PM9qtZdZElSM/ACLV2vdCuaibop4B9UIP9z3F8kfZ72+zKxpGiE+Bo1|x8SfG8FQw90mYIx+qZzJ8MCvc2wh+l4wDX5KxrhwvcouE2tHQlwfDgv/DiIXp173|hAmUCV0+bPRW8IIJvBODdAWtJe9hNwxj1FFYmPA7l4wa3gXV4I6tb+iO1MbwVjZ/|116tD5MdCo3JuSisgPYCHfkQccwEO0FHEuBbmfN+fQimQ8H0dePP8XctwbkplsB+|aLT5hYKmva/j9smEswgyHglPwc3WvZ+2DgKk7A7DHi7a2gDwCRQlHaXtNWx3992R|dfNgkSeB1CvGSQoo95WpC9ZoqGmcSlVqdetDU8iglPmfYTKO8aIPA6TuTQ/lQ0IW|90LQmqP23FwnNFiyqX8+rztLq4KVkTyeHIQwig6vFxgD8N+SbZCW2PPiB72TVF2U|WePU8MRTv1OIGBUBajF49k28HnZPSGlILHtFEkYkbPvomcE5ENnoejwzjktOTS5d|/R3SIOvCauOzadtzwTYOXT78ORaR1KI1cm8DzkkwJTd/Rrk07Q5vnvnSJQMwFUeH|PwJIgWBQf/GZ/OsDHmkbYR2ZWDClbKw2mwIBAg==",);sub init ();BEGIN {eval 'sub _check_tls_gt_1 (){' .(($Net::SSLeay::VERSION >= 1.55 && Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x1000100f)* 1).'}'}our%SSL_METHODS=(any=>\&Net::SSLeay::CTX_new,sslv23=>\&Net::SSLeay::CTX_new,sslv2=>\&Net::SSLeay::CTX_v2_new,sslv3=>\&Net::SSLeay::CTX_v3_new,tlsv1=>\&Net::SSLeay::CTX_tlsv1_new,);if (_check_tls_gt_1){$SSL_METHODS{tlsv1_1}=\&Net::SSLeay::CTX_tlsv1_1_new;$SSL_METHODS{tlsv1_2}=\&Net::SSLeay::CTX_tlsv1_2_new}else {for my$method (qw(tlsv1_1 tlsv1_2)){$SSL_METHODS{$method}=sub {croak "AnyEvent::TLS method '$method' requires openssl v1.0.1 and Net::SSLeay 1.55 or higher"}}}sub new {my ($class,%arg)=@_;init unless$REF_IDX;my$method=lc$arg{method}|| "any";my$ctx=($SSL_METHODS{$method}|| croak "'$method' is not a valid AnyEvent::TLS method (must be one of @{[ sort keys %SSL_METHODS ]})")->();my$self=bless {ctx=>$ctx },$class;my$op=Net::SSLeay::OP_ALL ();$op |= Net::SSLeay::OP_NO_SSLv2 ()unless$arg{sslv2};$op |= Net::SSLeay::OP_NO_SSLv3 ()if exists$arg{sslv3}&&!$arg{sslv3};$op |= Net::SSLeay::OP_NO_TLSv1 ()if exists$arg{tlsv1}&&!$arg{tlsv1};$op |= Net::SSLeay::OP_NO_TLSv1_1 ()if exists$arg{tlsv1_1}&&!$arg{tlsv1_1}&& _check_tls_gt_1;$op |= Net::SSLeay::OP_NO_TLSv1_2 ()if exists$arg{tlsv1_2}&&!$arg{tlsv1_2}&& _check_tls_gt_1;$op |= Net::SSLeay::OP_SINGLE_DH_USE ()if!exists$arg{dh_single_use}|| $arg{dh_single_use};Net::SSLeay::CTX_set_options ($ctx,$op);Net::SSLeay::CTX_set_cipher_list ($ctx,$arg{cipher_list})or croak "'$arg{cipher_list}' was not accepted as a valid cipher list by AnyEvent::TLS" if exists$arg{cipher_list};my ($dh_bio,$dh_file);if (exists$arg{dh_file}){$dh_file=$arg{dh_file};$dh_bio=Net::SSLeay::BIO_new_file ($dh_file,"r")or croak "$dh_file: failed to open DH parameter file: $!"}else {$arg{dh}="schmorp1539" unless exists$arg{dh};if (defined$arg{dh}){$dh_file="dh string";if ($arg{dh}=~ /^\w+$/){$dh_file="dh params $arg{dh}";$arg{dh}="-----BEGIN DH PARAMETERS-----\n" .$DH_PARAMS{$arg{dh}}."\n" ."-----END DH PARAMETERS-----";$arg{dh}=~ s/\|/\n/g}$dh_bio=Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());Net::SSLeay::BIO_write ($dh_bio,$arg{dh})}}if ($dh_bio){my$dh=Net::SSLeay::PEM_read_bio_DHparams ($dh_bio);Net::SSLeay::BIO_free ($dh_bio);$dh or croak "$dh_file: failed to parse DH parameters - not PEM format?";my$rv=Net::SSLeay::CTX_set_tmp_dh ($ctx,$dh);Net::SSLeay::DH_free ($dh);$rv or croak "$dh_file: failed to set DH parameters"}if ($arg{verify}){$self->{verify_mode}=Net::SSLeay::VERIFY_PEER ();$self->{verify_mode}|= Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT ()if$arg{verify_require_client_cert};$self->{verify_mode}|= Net::SSLeay::VERIFY_CLIENT_ONCE ()if$arg{verify_client_once}}else {$self->{verify_mode}=Net::SSLeay::VERIFY_NONE ()}$self->{verify_peername}=$arg{verify_peername}if exists$arg{verify_peername};$self->{verify_cb}=$arg{verify_cb}if exists$arg{verify_cb};$self->{session_ticket}=$arg{session_ticket}if exists$arg{session_ticket};$self->{debug}=$ENV{PERL_ANYEVENT_TLS_DEBUG}if length$ENV{PERL_ANYEVENT_TLS_DEBUG};$self->{debug}=$arg{debug}if exists$arg{debug};my$pw=$arg{cert_password};Net::SSLeay::CTX_set_default_passwd_cb ($ctx,ref$pw ? $pw : sub {$pw});if ($self->{verify_mode}){if (exists$arg{ca_file}or exists$arg{ca_path}or exists$arg{ca_cert}){if (exists$arg{ca_cert}){my ($ca_file,$g1)=_tmpfile delete$arg{ca_cert};Net::SSLeay::CTX_load_verify_locations ($ctx,$ca_file,undef)}if (exists$arg{ca_file}or exists$arg{ca_path}){Net::SSLeay::CTX_load_verify_locations ($ctx,$arg{ca_file},$arg{ca_path})}}elsif (length$ENV{PERL_ANYEVENT_CA_FILE}or length$ENV{PERL_ANYEVENT_CA_PATH}){Net::SSLeay::CTX_load_verify_locations ($ctx,$ENV{PERL_ANYEVENT_CA_FILE},$ENV{PERL_ANYEVENT_CA_PATH},)}else {Net::SSLeay::CTX_set_default_verify_paths ($ctx)}}if (exists$arg{cert}or exists$arg{cert_file}){my ($g1,$g2);if (exists$arg{cert}){croak "specifying both cert_file and cert is not allowed" if exists$arg{cert_file};($arg{cert_file},$g1)=_tmpfile delete$arg{cert}}if (exists$arg{key}or exists$arg{key_file}){if (exists$arg{key}){croak "specifying both key_file and key is not allowed" if exists$arg{key_file};($arg{key_file},$g2)=_tmpfile delete$arg{key}}}else {$arg{key_file}=$arg{cert_file}}Net::SSLeay::CTX_use_PrivateKey_file ($ctx,$arg{key_file},Net::SSLeay::FILETYPE_PEM ())or croak "$arg{key_file}: failed to load local private key (key_file or key)";Net::SSLeay::CTX_use_certificate_chain_file ($ctx,$arg{cert_file})or croak "$arg{cert_file}: failed to use local certificate chain (cert_file or cert)"}if ($arg{check_crl}){Net::SSLeay::OPENSSL_VERSION_NUMBER ()>= 0x00090702f or croak "check_crl requires openssl v0.9.7b or higher";Net::SSLeay::X509_STORE_set_flags (Net::SSLeay::CTX_get_cert_store ($ctx),Net::SSLeay::X509_V_FLAG_CRL_CHECK ())}Net::SSLeay::CTX_set_read_ahead ($ctx,1);$arg{prepare}->($self)if$arg{prepare};$self}sub new_from_ssleay {my ($class,$ctx)=@_;bless {ctx=>$ctx },$class}sub ctx {$_[0]{ctx}}sub verify_hostname($$$);sub _verify_hostname {my ($self,$cn,$cert)=@_;return 1 unless defined$cn;return 1 unless exists$self->{verify_peername}&& "none" ne lc$self->{verify_peername};return$self->{verify_peername}->($self,$cn,$cert)if ref$self->{verify_peername}&& "ARRAY" ne ref$self->{verify_peername};verify_hostname$cn,$cert,$self->{verify_peername}}sub verify {my ($self,$session,$ref,$cn,$preverify_ok,$x509_store_ctx)=@_;my$cert=$x509_store_ctx ? Net::SSLeay::X509_STORE_CTX_get_current_cert ($x509_store_ctx): undef;my$depth=Net::SSLeay::X509_STORE_CTX_get_error_depth ($x509_store_ctx);$preverify_ok &&= $self->_verify_hostname ($cn,$cert)unless$depth;$preverify_ok=$self->{verify_cb}->($self,$ref,$cn,$depth,$preverify_ok,$x509_store_ctx,$cert)if$self->{verify_cb};$preverify_ok}our$TLS_SNI_WARNED;sub _get_session($$;$$) {my ($self,$mode,$ref,$cn)=@_;my$session;if ($mode eq "accept"){$session=Net::SSLeay::new ($self->{ctx});Net::SSLeay::set_accept_state ($session);Net::SSLeay::set_options ($session,eval {Net::SSLeay::OP_NO_TICKET ()})unless$self->{session_ticket}||!exists$self->{session_ticket}}elsif ($mode eq "connect"){$session=Net::SSLeay::new ($self->{ctx});if (defined&Net::SSLeay::set_tlsext_host_name){Net::SSLeay::set_tlsext_host_name ($session,$cn)if length$cn}else {AE::log 6=>"TLS SNI not supported by your Net::SSLeay module, connecting without" unless$TLS_SNI_WARNED++}Net::SSLeay::set_connect_state ($session);Net::SSLeay::set_options ($session,eval {Net::SSLeay::OP_NO_TICKET ()})unless$self->{session_ticket}}else {croak "'$mode': unsupported TLS mode (must be either 'connect' or 'accept')"}if ($self->{debug}){}if ($self->{verify_mode}){Scalar::Util::weaken$self;Scalar::Util::weaken$ref;Net::SSLeay::set_verify $session,$self->{verify_mode},sub {$self->verify ($session,$ref,$cn,@_)}}$session}sub _put_session($$) {my ($self,$session)=@_;Net::SSLeay::set_verify$session,0,undef;Net::SSLeay::free ($session)}sub DESTROY {my ($self)=@_;Net::SSLeay::CTX_set_default_passwd_cb ($self->{ctx});Net::SSLeay::CTX_free ($self->{ctx})}sub init() {return if$REF_IDX;AE::log 5=>"Net::SSLeay versions older than 1.33 might malfunction." if$Net::SSLeay::VERSION < 1.33;Net::SSLeay::load_error_strings ();Net::SSLeay::SSLeay_add_ssl_algorithms ();Net::SSLeay::randomize ();$REF_IDX=Net::SSLeay::get_ex_new_index (0,0,0,0,0)until$REF_IDX}sub certname {$_[0]? Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_issuer_name ($_[0])).Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_subject_name ($_[0])): undef}our%CN_SCHEME=(rfc4513=>[0,1,2],rfc2818=>[0,2,1],rfc3207=>[0,0,2],none=>[],ldap=>"rfc4513",ldaps=>"ldap",http=>"rfc2818",https=>"http",smtp=>"rfc3207",smtps=>"smtp",xmpp=>"rfc3920",rfc3920=>"http",pop3=>"rfc2595",rfc2595=>"ldap",pop3s=>"pop3",imap=>"rfc2595",rfc2595=>"ldap",imaps=>"imap",acap=>"rfc2595",rfc2595=>"ldap",nntp=>"rfc4642",rfc4642=>"ldap",nntps=>"nntp",ftp=>"rfc4217",rfc4217=>"http",ftps=>"ftp",);sub match_cn($$$) {my ($name,$cn,$type)=@_;for ($name,$cn){s/[\x00-\x1f]+$//;s/^[\x00-\x1f]+//}my$pattern;if ($type==2 and $name =~m{^([^.]*)\*(.+)}){$pattern=qr{^\Q$1\E[^.]*\Q$2\E$}i}elsif ($type==1 and $name =~m{^\*(\..+)$}){$pattern=qr{^[^.]*\Q$1\E$}i}else {$pattern=qr{^\Q$name\E$}i}$cn =~ $pattern}sub verify_hostname($$$) {my ($cn,$cert,$scheme)=@_;while (!ref$scheme){$scheme=$CN_SCHEME{$scheme}or return 1}my$cert_cn=Net::SSLeay::X509_NAME_get_text_by_NID (Net::SSLeay::X509_get_subject_name ($cert),Net::SSLeay::NID_commonName ());my@cert_alt=Net::SSLeay::X509_get_subjectAltNames ($cert);require AnyEvent::Socket;my$ip=AnyEvent::Socket::parse_address ($cn);my$alt_dns_count;while (my ($type,$name)=splice@cert_alt,0,2){if ($type==Net::SSLeay::GEN_IPADD ()){return 1 if$ip eq $name}elsif ($type==Net::SSLeay::GEN_DNS ()){$alt_dns_count++;return 1 if match_cn$name,$cn,$scheme->[1]}}if ($scheme->[2]==2 || ($scheme->[2]==1 &&!$alt_dns_count)){return 1 if match_cn$cert_cn,$cn,$scheme->[0]}0}1
ANYEVENT_TLS

$fatpacked{"AnyEvent/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL';
  package AnyEvent::Util;use Carp ();use Errno ();use Socket ();use AnyEvent ();BEGIN {AnyEvent::common_sense}use base 'Exporter';our@EXPORT=qw(fh_nonblocking guard fork_call portable_pipe portable_socketpair run_cmd);our@EXPORT_OK=qw(AF_INET6 WSAEWOULDBLOCK WSAEINPROGRESS WSAEINVAL close_all_fds_except punycode_encode punycode_decode idn_nameprep idn_to_ascii idn_to_unicode);our$VERSION=$AnyEvent::VERSION;BEGIN {if ($AnyEvent::PROTOCOL{ip0.01}&& _AF_INET6 && socket my$ipv6_socket,_AF_INET6,Socket::SOCK_DGRAM(),0){*AF_INET6=\&_AF_INET6}else {*AF_INET6=sub () {0};delete$AnyEvent::PROTOCOL{ipv6}}my%ERR=(EBADMSG=>Errno::EDOM (),EPROTO=>Errno::ESPIPE (),);while (my ($k,$v)=each%ERR){next if eval "Errno::$k ()";AE::log 8=>"Broken Errno module, adding Errno::$k.";eval "sub Errno::$k () { $v }";push@Errno::EXPORT_OK,$k;push @{$Errno::EXPORT_TAGS{POSIX}},$k}}BEGIN {if (AnyEvent::WIN32){*_win32_socketpair=sub () {for (1..10){socket my$l,Socket::AF_INET(),Socket::SOCK_STREAM(),0 or next;bind$l,Socket::pack_sockaddr_in 0,"\x7f\x00\x00\x01" or next;my$sa=getsockname$l or next;listen$l,1 or next;socket my$r,Socket::AF_INET(),Socket::SOCK_STREAM(),0 or next;bind$r,Socket::pack_sockaddr_in 0,"\x7f\x00\x00\x01" or next;connect$r,$sa or next;accept my$w,$l or next;(Socket::unpack_sockaddr_in getpeername$r)[0]==(Socket::unpack_sockaddr_in getsockname$w)[0]or (($!=WSAEINVAL),next);return ($r,$w)}()};*portable_socketpair=\&_win32_socketpair;*portable_pipe=\&_win32_socketpair}else {*portable_pipe=sub () {my ($r,$w);pipe$r,$w or return;($r,$w)};*portable_socketpair=sub () {socketpair my$fh1,my$fh2,Socket::AF_UNIX(),Socket::SOCK_STREAM(),0 or return;($fh1,$fh2)}}}our$MAX_FORKS=int 1 * $ENV{PERL_ANYEVENT_MAX_FORKS};$MAX_FORKS=10 if$MAX_FORKS <= 0;my$forks;my@fork_queue;sub _fork_schedule;sub _fork_schedule {require Storable unless$Storable::VERSION;require POSIX unless$POSIX::VERSION;while ($forks < $MAX_FORKS){my$job=shift@fork_queue or last;++$forks;my$coderef=shift @$job;my$cb=pop @$job;my ($r,$w)=portable_pipe or ($forks and last)or die "fork_call: $!";my$pid=fork;if ($pid!=0){close$w;my$buf;my$ww;$ww=AE::io$r,0,sub {my$len=sysread$r,$buf,65536,length$buf;return unless defined$len or $!!=Errno::EINTR;if (!$len){undef$ww;close$r;--$forks;_fork_schedule;my$result=eval {Storable::thaw ($buf)};$result=[$@]unless$result;$@=shift @$result;$cb->(@$result);kill 9,$pid if AnyEvent::WIN32;waitpid$pid,0}}}elsif (defined$pid){close$r;my$result=eval {local$SIG{__DIE__};Storable::freeze ([undef,$coderef->(@$job)])};$result=Storable::freeze (["$@"])if $@;my$ofs;while (){my$len=(length$result)- $ofs or last;$len=syswrite$w,$result,$len < 65536 ? $len : 65536,$ofs;last unless$len || (!defined$len && $!==Errno::EINTR);$ofs += $len}if (AnyEvent::WIN32){shutdown$w,1;sleep 10;sysread$w,(my$buf),1}POSIX::_exit (0);exit 1}elsif (($!!=&Errno::EAGAIN && $!!=&Errno::EWOULDBLOCK && $!!=&Errno::ENOMEM)||!$forks){die "fork_call: $!"}}}sub fork_call(&@) {push@fork_queue,[@_];_fork_schedule}END {if (AnyEvent::WIN32){while ($forks){@fork_queue=();AnyEvent->one_event}}}sub dotted_quad($) {$_[0]=~ /^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)$/x}sub inet_aton {require AnyEvent::Socket;*inet_aton=\&AnyEvent::Socket::inet_aton;goto&inet_aton}BEGIN {*fh_nonblocking=\&AnyEvent::_fh_nonblocking}BEGIN {if (!$ENV{PERL_ANYEVENT_AVOID_GUARD}&& eval {require Guard;$Guard::VERSION >= 0.5}){*guard=\&Guard::guard;AE::log 8=>"Using Guard module to implement guards."}else {*AnyEvent::Util::guard::DESTROY=sub {local $@;eval {local$SIG{__DIE__};${$_[0]}->()};AE::log 4=>"Runtime error in AnyEvent::guard callback: $@" if $@};*AnyEvent::Util::guard::cancel=sub ($) {${$_[0]}=sub {}};*guard=sub (&) {bless \(my$cb=shift),"AnyEvent::Util::guard"};AE::log 8=>"Using pure-perl guard implementation."}}sub close_all_fds_except {my%except;@except{@_}=();require POSIX unless$POSIX::VERSION;if ($^O =~ /(freebsd|cygwin|linux)/){my$dir;if (opendir$dir,"/dev/fd" or opendir$dir,"/proc/self/fd"){my@fds=sort {$a <=> $b}grep /^\d+$/,readdir$dir;if (@fds < 20 or "@fds" ne join " ",0..$#fds){exists$except{$_}or POSIX::close ($_)for@fds;return}}}my$fd_max=eval {POSIX::sysconf (POSIX::_SC_OPEN_MAX ())- 1}|| 1023;exists$except{$_}or POSIX::close ($_)for 0..$fd_max}sub run_cmd {my$cmd=shift;require POSIX unless$POSIX::VERSION;my$cv=AE::cv;my%arg;my%redir;my@exe;while (@_){my ($type,$ob)=splice @_,0,2;my$fd=$type =~ s/^(\d+)// ? $1 : undef;if ($type eq ">"){$fd=1 unless defined$fd;if (defined eval {fileno$ob}){$redir{$fd}=$ob}elsif (ref$ob){my ($pr,$pw)=AnyEvent::Util::portable_pipe;$cv->begin;fcntl$pr,AnyEvent::F_SETFD,AnyEvent::FD_CLOEXEC;fh_nonblocking$pr,1;my$w;$w=AE::io$pr,0,"SCALAR" eq ref$ob ? sub {defined (sysread$pr,$$ob,16384,length $$ob and return)or ($!==Errno::EINTR and return);undef$w;$cv->end}: sub {my$buf;defined (sysread$pr,$buf,16384 and return$ob->($buf))or ($!==Errno::EINTR and return);undef$w;$cv->end;$ob->()};$redir{$fd}=$pw}else {push@exe,sub {open my$fh,">",$ob or POSIX::_exit (125);$redir{$fd}=$fh}}}elsif ($type eq "<"){$fd=0 unless defined$fd;if (defined eval {fileno$ob}){$redir{$fd}=$ob}elsif (ref$ob){my ($pr,$pw)=AnyEvent::Util::portable_pipe;$cv->begin;my$data;if ("SCALAR" eq ref$ob){$data=$$ob;$ob=sub {}}else {$data=$ob->()}fcntl$pw,AnyEvent::F_SETFD,AnyEvent::FD_CLOEXEC;fh_nonblocking$pw,1;my$w;$w=AE::io$pw,1,sub {my$len=syswrite$pw,$data;return unless defined$len or $!!=Errno::EINTR;if (!$len){undef$w;$cv->end}else {substr$data,0,$len,"";unless (length$data){$data=$ob->();unless (length$data){undef$w;$cv->end}}}};$redir{$fd}=$pr}else {push@exe,sub {open my$fh,"<",$ob or POSIX::_exit (125);$redir{$fd}=$fh}}}else {$arg{$type}=$ob}}my$pid=fork;defined$pid or Carp::croak "fork: $!";unless ($pid){$_->()for@exe;my (@oldfh,@close);for my$fh (values%redir){push@oldfh,$fh;$fh=fileno$fh;defined ($fh=POSIX::dup ($fh))or POSIX::_exit (124)while exists$redir{$fh}}while (my ($k,$v)=each%redir){defined POSIX::dup2 ($v,$k)or POSIX::_exit (123)}if ($arg{close_all}){close_all_fds_except 0,1,2,keys%redir}else {POSIX::close ($_)for values%redir}eval {$arg{on_prepare}();1}or POSIX::_exit (123)if exists$arg{on_prepare};ref$cmd ? exec {$cmd->[0]}@$cmd : exec$cmd;POSIX::_exit (126)}${$arg{'$$'}}=$pid if$arg{'$$'};%redir=();my$status;$cv->begin (sub {shift->send ($status)});my$cw;$cw=AE::child$pid,sub {$status=$_[1];undef$cw;$cv->end};$cv}sub punycode_encode($) {require "AnyEvent/Util/idna.pl";goto&punycode_encode}sub punycode_decode($) {require "AnyEvent/Util/idna.pl";goto&punycode_decode}our ($uts46_valid,$uts46_imap);sub idn_nameprep($;$) {local $_=$_[0];y/A-Z/a-z/;if (/[^0-9a-z\-.]/){unless (defined$uts46_imap){require Unicode::Normalize;require "AnyEvent/Util/uts46data.pl"}s{
           ([^0-9a-z\-.])
        }{
           my $chr = $1;
           unless (vec $uts46_valid, ord $chr, 1) {
              # not in valid class, search for mapping
              utf8::encode $chr; # the imap table is in utf-8
              (my $rep = index $uts46_imap, "\x00$chr") >= 0
                 or Carp::croak "$_[0]: disallowed characters (U+" . (unpack "H*", $chr) . ") during idn_nameprep";
  
              (substr $uts46_imap, $rep, 128) =~ /\x00 .[\x80-\xbf]* ([^\x00]*) \x00/x
                 or die "FATAL: idn_nameprep imap table has unexpected contents";
  
              $rep = $1;
              $chr = $rep unless $rep =~ s/^\x01// && $_[1]; # replace unless deviation and display
              utf8::decode $chr;
           }
           $chr
        }gex;$_=Unicode::Normalize::NFKC ($_)}s{
        (^|\.)(..)--([^\.]*)
     }{
        my ($pfx, $ace, $pc) = ($1, $2, $3);
  
        if ($ace eq "xn") {
           $pc = punycode_decode $pc; # will croak on error (we hope :)
  
           require Unicode::Normalize;
           $pc eq Unicode::Normalize::NFC ($pc)
              or Carp::croak "$_[0]: punycode label not in NFC detected during idn_nameprep";
  
           "$pfx$pc"
        } elsif ($ace !~ /^[a-z0-9]{2}$/) {
           "$pfx$ace--$pc"
        } else {
           Carp::croak "$_[0]: hyphens in 3rd/4th position of a label are not allowed";
        }
     }gex;/\.-|-\./ and Carp::croak "$_[0]: invalid hyphens detected during idn_nameprep";if (/[^0-9a-z\-.]/){unless (defined$uts46_imap){require "AnyEvent/Util/uts46data.pl"}vec$uts46_valid,ord,1 or $_[1]&& 0 <= index$uts46_imap,pack "C0U*",0,ord,1 or Carp::croak "$_[0]: disallowed characters during idn_nameprep" for split //}$_}sub idn_to_ascii($) {return $_[0]unless $_[0]=~ /[^\x00-\x7f]/;my@output;eval {for (split /\./,(idn_nameprep $_[0]),-1){if (/[^\x00-\x7f]/){eval {push@output,"xn--" .punycode_encode $_;1}or do {push@output,$_}}else {push@output,$_}}1}or return $_[0];shift@output while!length$output[0]&& @output > 1;join ".",@output}sub idn_to_unicode($) {my$res=eval {idn_nameprep $_[0],1};defined$res ? $res : $_[0]}1
ANYEVENT_UTIL

$fatpacked{"AnyEvent/Util/idna.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL_IDNA.PL';
  use AnyEvent ();BEGIN {AnyEvent::common_sense}use Carp ();use List::Util ();use integer;sub pyc_base () {36}sub pyc_tmin () {1}sub pyc_tmax () {26}sub pyc_initial_bias () {72}sub pyc_initial_n () {128}sub pyc_digits () {"abcdefghijklmnopqrstuvwxyz0123456789"}sub pyc_adapt($$$) {my ($delta,$numpoints,$firsttime)=@_;$delta=$firsttime ? $delta / 700 : $delta >> 1;$delta += $delta / $numpoints;my$k;while ($delta > (pyc_base - pyc_tmin)* pyc_tmax / 2){$delta /= pyc_base - pyc_tmin;$k += pyc_base}$k + $delta * (pyc_base - pyc_tmin + 1)/ ($delta + 38)}sub punycode_encode($) {my ($input)=@_;my ($n,$bias,$delta)=(pyc_initial_n,pyc_initial_bias);(my$output=$input)=~ y/\x00-\x7f//cd;my$h=my$b=length$output;my@input=split '',$input;$output .= "-" if$b && $h < @input;while ($h < @input){my$m=List::Util::min grep {$_ >= $n}map ord,@input;$m - $n <= (0x7fffffff - $delta)/ ($h + 1)or Carp::croak "punycode_encode: overflow in punycode delta encoding";$delta += ($m - $n)* ($h + 1);$n=$m;for my$i (@input){my$c=ord$i;++$delta < 0x7fffffff or Carp::croak "punycode_encode: overflow in punycode delta encoding" if$c < $n;if ($c==$n){my ($q,$k)=($delta,pyc_base);while (){my$t=List::Util::min pyc_tmax,List::Util::max pyc_tmin,$k - $bias;last if$q < $t;$output .= substr pyc_digits,$t + (($q - $t)% (pyc_base - $t)),1;$q=($q - $t)/ (pyc_base - $t);$k += pyc_base}$output .= substr pyc_digits,$q,1;$bias=pyc_adapt$delta,$h + 1,$h==$b;$delta=0;++$h}}++$delta;++$n}$output}sub punycode_decode($) {my ($input)=@_;my ($n,$bias,$i)=(pyc_initial_n,pyc_initial_bias);my$output;if ($input =~ /^(.*?)-([^-]*)$/x){$output=$1;$input=$2;$output =~ /[^\x00-\x7f]/ and Carp::croak "punycode_decode: malformed punycode"}while (length$input){my$oldi=$i;my$w=1;for (my$k=pyc_base;;$k += pyc_base){(my$digit=index pyc_digits,substr$input,0,1,"")>= 0 or Carp::croak "punycode_decode: malformed punycode";$i += $digit * $w;my$t=List::Util::max pyc_tmin,List::Util::min pyc_tmax,$k - $bias;last if$digit < $t;$w *= pyc_base - $t}my$outlen=1 + length$output;$bias=pyc_adapt$i - $oldi,$outlen,$oldi==0;$n += $i / $outlen;$i %= $outlen;substr$output,$i,0,chr$n;++$i}$output}1
ANYEVENT_UTIL_IDNA.PL

$fatpacked{"AnyEvent/Util/uts46data.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL_UTS46DATA.PL';
  $uts46_imap=q Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz a  2 3  1 o 14 12 34                                                       i ij ij      l l     n                            s                                     d d d lj lj lj nj nj nj                  dz dz dz                                               h  j r    w y  l s x                                                                                                                                                                                                                                                                                                                                            a  b d e  g h i j k l m n o  p r t u w a    b d e    g k m  o    p t u   v       i r u v        c    f                           z                                                                                a  ss                                                                                                                                                                                                        0 i 4 5 6 7 8 9  n 0 1 2 3 4 5 6 7 8 9  a e o x  h k l m n p s t rs c c  f g h h h h  i i l l n no p q r r r sm tel tm z  z k  b c e e f m o     i fax      d d e i j 17 19 110 13 23 15 25 35 45 16 56 18 38 58 78 1 i ii iii iv v vi vii viii ix x xi xii l c d m i ii iii iv v vi vii viii ix x xi xii l c d m 03       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z 0                                                               j v                                                                                                                                                                                                                                                                                 .                                                                                                                      pte 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35                                                                                 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 1 2 3 4 5 6 7 8 9 10 11 12 hg erg ev ltd                                                                                                                                        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 hpa da au bar ov pc dm dm2 dm3 iu      pa na a ma ka kb mb gb cal kcal pf nf f g mg kg hz khz mhz ghz thz l ml dl kl fm nm m mm cm km mm2 cm2 m2 km2 mm3 cm3 m3 km3 ms ms2 pa kpa mpa gpa rad rads rads2 ps ns s ms pv nv v mv kv mv pw nw w mw kw mw k m bq cc cd ckg db gy ha hp in kk km kt lm ln log lx mb mil mol ph ppm pr sr sv wb vm am 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 gal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ff fi fl ffi ffl st st                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -                                                                                                                                     - . 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z   .                                                                                                                                                                                                                                                                                                               a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a c d g j k n o p q s t u v w x y z a b c d f h i j k l m n p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b d e f g j k l m n o p q s t u v w x y a b c d e f g h i j k l m n o p q r s t u v w x y z a b d e f g i j k l m o s t u v w x y a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z                                                                                                                                                                                                                                                                                                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9                                                                                                                                                                                s c r cd wz a b c d e f g h i j k l m n o p q r s t u v w x y z hv mv sd ss ppv wc mc md dj                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;$uts46_valid=q     `        Z  UTT)1$N*-Q@U! 8    H      T       ? ?O        ?   y %9? ; 9 == =` =`@ /_     %;_?    {{          ======?    
   ? ? ? ?                   @       ? ?   ?   U      C @   @  0} '           B       
  O?                      ?          b          {                                 f?                                                                            ? ?                 ?? ?   ~~~ ?           ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               @                                                                                              `                                                      ??         ?                  ?          ?                         ?                    ?      7        o      ??                                                                                                                     ?    ?         9                 +                         ??                                                                                                                                                      ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ?? ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ? ?  ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ?                                                          ?                                                                                                                                                                                                                                   ?;1;
ANYEVENT_UTIL_UTS46DATA.PL

$fatpacked{"AnyEvent/constants.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_CONSTANTS.PL';
  sub AnyEvent::common_sense {local $^W;${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x3c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\x0c\x00\x00\x00";$^H |= 0x7c0}package AnyEvent;sub CYGWIN(){0}sub WIN32(){0}sub F_SETFD(){2}sub F_SETFL(){4}sub O_NONBLOCK(){4}sub FD_CLOEXEC(){1}package AnyEvent::Base;sub WNOHANG(){1}package AnyEvent::IO;sub O_RDONLY(){0}sub O_WRONLY(){1}sub O_RDWR(){2}sub O_CREAT(){512}sub O_EXCL(){2048}sub O_TRUNC(){1024}sub O_APPEND(){8}package AnyEvent::Util;sub WSAEINVAL(){-1e+99}sub WSAEWOULDBLOCK(){-1e+99}sub WSAEINPROGRESS(){-1e+99}sub _AF_INET6(){30}package AnyEvent::Socket;sub TCP_CONGESTION(){undef}sub TCP_CONNECTIONTIMEOUT(){32}sub TCP_CORK(){undef}sub TCP_DEFER_ACCEPT(){undef}sub TCP_INFO(){undef}sub TCP_INIT_CWND(){undef}sub TCP_KEEPALIVE(){16}sub TCP_KEEPCNT(){undef}sub TCP_KEEPIDLE(){undef}sub TCP_KEEPINIT(){undef}sub TCP_KEEPINTVL(){undef}sub TCP_LINGER2(){undef}sub TCP_MAXSEG(){2}sub TCP_MD5SIG(){undef}sub TCP_NOOPT(){8}sub TCP_NOPUSH(){4}sub TCP_QUICKACK(){undef}sub TCP_SACK_ENABLE(){undef}sub TCP_SYNCNT(){undef}sub TCP_WINDOW_CLAMP(){undef}1;
ANYEVENT_CONSTANTS.PL

$fatpacked{"App/Monastery.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MONASTERY';
  package App::Monastery;use feature ':5.10';use strict;use warnings;our$VERSION='0.01';use AE;use AnyEvent::Log;use AnyEvent::Handle;use JSON;use Encode;use FindBin;use File::Spec;use Getopt::Long;use IO::Handle;STDOUT->autoflush(1);use Time::HiRes ();use constant START=>Time::HiRes::time;use App::Monastery::Handler;sub run {my%options=(log=>'warn');Getopt::Long::GetOptions(\%options,'log|l');my$INIT=Time::HiRes::time;AnyEvent::Log::ctx->fmt_cb(sub {my$ts=sprintf '%.03f s',(Time::HiRes::time - $INIT);my@res;for (split /\n/,sprintf "%-5s %s: %s",$AnyEvent::Log::LEVEL2STR[$_[2]],$_[1][0],$_[3]){push@res,"$ts [$$] $_\n"}join '',@res});AnyEvent::Log::ctx->level($options{log});AnyEvent::Log::ctx->log_to_file('/tmp/perl-lang-server.log');my$handler=App::Monastery::Handler->new(logger=>AnyEvent::Log::ctx());$handler->init;my$hdl;$hdl=AnyEvent::Handle->new(fh=>\*STDIN,on_error=>sub {AE::log error=>'on_error: ' .$_[2];$hdl->destroy;exit},on_eof=>sub {AE::log info=>'Client disconnected';$hdl->destroy;exit});$hdl->on_read(sub {my ($h)=@_;$h->push_read(line=>"\015\012\015\012",sub {AE::log debug=>'header: ' .$_[1]});$h->push_read(json=>sub {my$json=JSON->new->utf8(1)->canonical(1)->encode($_[1]);AE::log debug=>'data: ' .$json;my$response=$handler->rpc->parse($json);return unless$response;my$length=length$response;AE::log info=>'resp: ' .$response;print "Content-Length: $length\r\n\r\n$response"})});AE::cv->recv}1;
APP_MONASTERY

$fatpacked{"App/Monastery/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MONASTERY_DOCUMENT';
  package App::Monastery::Document;use feature ':5.10';use strict;use warnings;use PPI;use List::Util qw(first sum);use Class::Tiny qw(file buf is_package _doc _mtime);sub BUILD {my ($self,$args)=@_;return unless$args->{file}or $args->{buf};if ($args->{file}){return unless -f $args->{file};$self->file($args->{file});$self->_mtime((stat$args->{file})[9]);$self->_doc(PPI::Document->new($self->file))}else {$self->_doc(PPI::Document->new(\$self->buf))}$self->is_package($self->_doc->find_any('PPI::Statement::Package'))}sub package {my ($self)=@_;my$package=$self->_doc->find_first('PPI::Statement::Package');return$package ? $package->namespace : undef}sub parents {my ($self)=@_;my$parents=$self->_doc->find(sub {return 0 unless $_[1]->isa('PPI::Statement');return 1 if $_[1]->isa('PPI::Statement::Include')&& $_[1]->content =~ /use (parent|base|['"]?Mojo::Base['"]?) /;return 1 if ($_[1]->children)[0]->isa('PPI::Token::Word')and ($_[1]->children)[0]->content eq 'extends';return 0});return []unless$parents;my%list;for my$parent (@{$parents}){my$mod=first {$_->isa('PPI::Token::Quote')|| $_->isa('PPI::Token::QuoteLike')}reverse$parent->children;next unless$mod;if ($mod->isa('PPI::Token::Quote')){my$name=$mod->content;$name =~ s/['"]//g;$list{$name}=undef}elsif ($mod->isa('PPI::Token::QuoteLike')){$list{$_}=undef foreach$mod->literal}}my@par=keys%list;return \@par}sub methods {my ($self)=@_;my$subs=$self->_doc->find('PPI::Statement::Sub');return []unless$subs;my%list;for my$sub (@{$subs}){next if$sub->name =~ /(BUILD|BUILDARGS|DESTROY|AUTOLOAD)/;$list{$sub->name }={label=>$sub->name,}}my@methods=values%list;return \@methods}sub tokens {my ($self)=@_;my$tokens=$self->_doc->find('PPI::Statement::Variable');return []unless$tokens;my%list;for my$token (@{$tokens}){my$word=$token->find_first('PPI::Token::Word');my$symbol=$token->find_first('PPI::Token::Symbol');next unless$word;next if$self->is_package and $word->content eq 'my';$list{$symbol->content }={label=>$symbol->content,}}my@symbols=values%list;return \@symbols}sub object_instances {my ($self)=@_;my$vars=$self->_doc->find('PPI::Statement::Variable');return []unless$vars;my%list;for my$var (@{$vars}){if ($var->content =~ /([\w:]+)->new/ || $var->content =~ /new ([\w:]+)/){my$inst=$var->find_first('PPI::Token::Symbol');$list{$inst->content }=$1}}return \%list}sub record {my ($self)=@_;return unless$self->is_package;return {_file=>$self->file,_mtime=>$self->_mtime,parents=>$self->parents,methods=>$self->methods,tokens=>$self->tokens }}1;
APP_MONASTERY_DOCUMENT

$fatpacked{"App/Monastery/Handler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MONASTERY_HANDLER';
  package App::Monastery::Handler;use feature ':5.10';use strict;use warnings;our$VERSION='0.01';use URI;use JSON;use FindBin;use File::Spec;use DBM::Deep;use JSON::RPC::Spec;use File::Find::Rule;use Number::Bytes::Human qw(format_bytes);use Perl::Tidy;use App::Monastery::Document;use Class::Tiny qw(_db rpc logger workspace buffer);sub BUILD {my ($self,$args)=@_;my$dbm_file=$ENV{MONASTERY_DBM}|| File::Spec->catfile(File::Spec->tmpdir,'app-monastery.db');$self->logger->log(info=>'[DBM] Using file: ' .$dbm_file);$self->logger->log(info=>'[DBM] Using ' .format_bytes((stat$dbm_file)[7]))if -f $dbm_file;$self->_db({_file=>$dbm_file });$self->buffer({});$self->rpc(JSON::RPC::Spec->new)}sub load_from_directory {my$self=shift;my@dirs=@_ > 1 ? @_ : ($_[0]);my@files=File::Find::Rule->new->name('*.pm')->in(@dirs);my%data;for my$file (@files){my$doc=App::Monastery::Document->new(file=>$file);next unless$doc;my$record=$doc->record or next;$data{packages}{$doc->package }=$record}return \%data}sub db {my ($self)=@_;return$self->_db->{$$}if$self->_db->{$$};my$dbm=DBM::Deep->new(file=>$self->_db->{_file},locking=>1,autoflush=>1,num_txns=>3);eval {$dbm->begin_work;$dbm->{key}='foo';$dbm->rollback};if ($@){AE::log error=>$self->_db->{_file}.' could not be written';die}$self->_db->{$$}=$dbm;return$self->_db->{$$}}sub load_buffer {my ($self,$uri,$src)=@_;my@lines=split /\n/,$src;$self->buffer->{$uri}={lines=>\@lines,doc=>App::Monastery::Document->new(buf=>$src)}}sub drop_buffer {delete $_[0]->buffer->{$_[1]}}sub init {my ($self)=@_;$self->logger->log(info=>__PACKAGE__ .'->init');my$reloaded=$self->db->{reloaded}// (time - 3600);if ($reloaded > (time - 3600)){$self->logger->log(info=>__PACKAGE__ .'->init: skipping run')}else {$self->db->{reloaded}=time;unless (my$child=fork){$self->logger->log(info=>'starting scan of @INC');my$data=$self->load_from_directory(@INC);$self->logger->log(info=>'scan @INC complete');$self->db->begin_work;$self->db->import($data);$self->db->commit;exit}}$self->rpc->register('initialize'=>sub {my ($params,$match)=@_;my$uri=URI->new($params->{rootUri});die 'Cannot read directory ' .$uri->file unless -d $uri->file;$self->workspace($uri->file);unless (my$child=fork){$self->logger->log(info=>'Loading symbols from ' .$uri->file);my$data=$self->load_from_directory($uri->file);$self->db->begin_work;$self->db->import($data);$self->db->commit;exit}return {capabilities=>{textDocumentSync=>1,documentFormattingProvider=>JSON::true,documentRangeFormattingProvider=>JSON::true,documentSymbolProvider=>JSON::false,workspaceSymbolProvider=>JSON::false,definitionProvider=>JSON::false,referencesProvider=>JSON::false,hoverProvider=>JSON::false,completionProvider=>{resolveProvider=>JSON::false,triggerCharacters=>['$',':','>' ]}}}});$self->rpc->register('shutdown'=>sub {$self->workspace(undef);$self->buffer({})});$self->rpc->register('exit'=>sub {exit});$self->rpc->register('textDocument/didOpen'=>sub {$self->load_buffer($_[0]->{textDocument}{uri},$_[0]->{textDocument}{text})});$self->rpc->register('textDocument/didChange'=>sub {$self->load_buffer($_[0]->{textDocument}{uri},$_[0]->{contentChanges}[0]{text})});$self->rpc->register('textDocument/completion'=>sub {my ($params,$match)=@_;my$response={isIncomplete=>JSON::true,items=>[]};my$buffer=$self->buffer->{$params->{textDocument}{uri}};my$line=$buffer->{lines}[$params->{position}{line}];$self->logger->log(info=>'completion line: ' .$line);if ($line =~ /([\$\:\w]+)->\w*$/){my$match=$1;$self->logger->log(info=>"completion: class method ($match)");if ($match =~ /\$/){$self->logger->log(info=>'class method: instance');my$instances=$buffer->{doc}->object_instances;if ($instances->{$match}){$response->{items}=$self->db->{packages}{$instances->{$match}}{methods}if$self->db->{packages}{$instances->{$match}};$response->{isIncomplete}=JSON::false;return$response}}else {$self->logger->log(info=>'class method: class');if ($self->db->{packages}{$match}){$self->logger->log(info=>"class method: Found $match");$response->{items}=$self->db->{packages}{$match}{methods}->export;$response->{isIncomplete}=JSON::false;return$response}}}if ($line =~ /([\:\w]+)$/){my$match=$1;$self->logger->log(info=>"completion: package ($match)");my@candidates=grep {$_ =~ /^$match/}keys %{$self->db->{packages}};@candidates=map {{label=>$_ }}@candidates;$response->{items}=\@candidates}return$response});$self->rpc->register('textDocument/formatting'=>sub {my ($output,$stderr,$log);my$buffer=$self->buffer->{$_[0]->{textDocument}{uri}};my$argv;$argv .= sprintf '-i %d ',delete $_[0]->{tabSize}if $_[0]{tabSize};$argv .= '-t ' if (exists $_[0]{insertSpaces}&&!$_[0]{insertSpaces});delete $_[0]{insertSpaces};for my$opt (keys %{$_[0]}){$argv .= sprintf '-%s %s',$opt,$_[0]{$opt}}my$err=Perl::Tidy::tidy(source=>$buffer->{lines},destination=>\$output,stderr=>\$stderr,errorfile=>\$stderr,logfile=>\$log,argv=>$argv);return {start=>{line=>0,character=>0 },end=>{line=>scalar @{$buffer->{lines}},character=>length$buffer->{lines}[-1]},newText=>$output }})}1;
APP_MONASTERY_HANDLER

$fatpacked{"B/Hooks/EndOfScope.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE';
  package B::Hooks::EndOfScope;use strict;use warnings;our$VERSION='0.01';use 5.008001;BEGIN {use Module::Implementation 0.05;Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>['on_scope_end' ],)->()}use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end' ],groups=>{default=>['on_scope_end']},};1;
B_HOOKS_ENDOFSCOPE

$fatpacked{"B/Hooks/EndOfScope/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP';
  package B::Hooks::EndOfScope::PP;use warnings;use strict;our$VERSION='0.01';use constant _PERL_VERSION=>"$]";BEGIN {if (_PERL_VERSION =~ /^5\.009/){die "By design B::Hooks::EndOfScope does not operate in pure-perl mode on perl 5.9.X\n"}elsif (_PERL_VERSION < '5.010'){require B::Hooks::EndOfScope::PP::HintHash;*on_scope_end=\&B::Hooks::EndOfScope::PP::HintHash::on_scope_end}else {require B::Hooks::EndOfScope::PP::FieldHash;*on_scope_end=\&B::Hooks::EndOfScope::PP::FieldHash::on_scope_end}}use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end'],groups=>{default=>['on_scope_end']},};sub __invoke_callback {local $@;eval {$_[0]->();1}or do {my$err=$@;require Carp;Carp::cluck((join ' ','A scope-end callback raised an exception, which can not be propagated when','B::Hooks::EndOfScope operates in pure-perl mode. Your program will CONTINUE','EXECUTION AS IF NOTHING HAPPENED AFTER THIS WARNING. Below is the complete','exception text, followed by a stack-trace of the callback execution:',)."\n\n$err\n\r");sleep 1 if -t *STDERR}}1;
B_HOOKS_ENDOFSCOPE_PP

$fatpacked{"B/Hooks/EndOfScope/PP/FieldHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_FIELDHASH';
  package B::Hooks::EndOfScope::PP::FieldHash;use strict;use warnings;our$VERSION='0.01';use Tie::Hash ();use Hash::Util::FieldHash 'fieldhash';fieldhash my%hh;{package B::Hooks::EndOfScope::PP::_TieHintHashFieldHash;our@ISA=('Tie::StdHash');sub DELETE {my$ret=shift->SUPER::DELETE(@_);B::Hooks::EndOfScope::PP::__invoke_callback($_)for @$ret;$ret}}sub on_scope_end (&) {$^H |= 0x020000;tie(%hh,'B::Hooks::EndOfScope::PP::_TieHintHashFieldHash')unless tied%hh;push @{$hh{\%^H}||= []},shift}1;
B_HOOKS_ENDOFSCOPE_PP_FIELDHASH

$fatpacked{"B/Hooks/EndOfScope/PP/HintHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_HINTHASH';
  package B::Hooks::EndOfScope::PP::HintHash;use strict;use warnings;our$VERSION='0.01';use Scalar::Util ();sub on_scope_end (&) {$^H |= 0x020000;push @{$^H{sprintf '__B_H_EOS__guardstack_0X%x',Scalar::Util::refaddr(\%^H)}||= bless ([],'B::Hooks::EndOfScope::PP::_SG_STACK')},shift}package B::Hooks::EndOfScope::PP::_SG_STACK;use warnings;use strict;sub DESTROY {B::Hooks::EndOfScope::PP::__invoke_callback($_)for @{$_[0]}}1;
B_HOOKS_ENDOFSCOPE_PP_HINTHASH

$fatpacked{"B/Hooks/EndOfScope/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_XS';
  package B::Hooks::EndOfScope::XS;use strict;use warnings;our$VERSION='0.01';use Variable::Magic 0.48 ();use Sub::Exporter::Progressive 0.001006 -setup=>{exports=>['on_scope_end'],groups=>{default=>['on_scope_end']},};my$wiz=Variable::Magic::wizard data=>sub {[$_[1]]},free=>sub {$_->()for @{$_[1]};()},local=>\undef ;sub on_scope_end (&) {my$cb=shift;$^H |= 0x020000;if (my$stack=Variable::Magic::getdata %^H,$wiz){push @{$stack},$cb}else {Variable::Magic::cast %^H,$wiz,$cb}}1;
B_HOOKS_ENDOFSCOPE_XS

$fatpacked{"B/Keywords.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_KEYWORDS';
  package B::Keywords;use strict;require Exporter;*import=*import=\&Exporter::import;use vars qw(@EXPORT_OK %EXPORT_TAGS);@EXPORT_OK=qw(@Scalars @Arrays @Hashes @Filehandles @Symbols @Functions @Barewords @TieIOMethods @UNIVERSALMethods @ExporterSymbols);%EXPORT_TAGS=('all'=>\@EXPORT_OK);use vars '$VERSION';$VERSION='0.01';use vars '@Scalars';@Scalars=(qw($a $b $_ $ARG $& $MATCH $` $PREMATCH $' $POSTMATCH $+ $LAST_PAREN_MATCH),($] < 5.008001 ? qw($* $MULTILINE_MATCHING) : ()),qw($. $INPUT_LINE_NUMBER $NR $/ $INPUT_RECORD_SEPARATOR $RS $| $OUTPUT_AUTOFLUSH),'$,',qw($OUTPUT_FIELD_SEPARATOR $OFS $\ $OUTPUT_RECORD_SEPARATOR $ORS $" $LIST_SEPARATOR $; $SUBSCRIPT_SEPARATOR $SUBSEP),'$#',qw($OFMT $% $FORMAT_PAGE_NUMBER $= $FORMAT_LINES_PER_PAGE $- $FORMAT_LINES_LEFT $~ $FORMAT_NAME $^ $FORMAT_TOP_NAME $: $FORMAT_LINE_BREAK_CHARACTERS $? $CHILD_ERROR $^CHILD_ERROR_NATIVE $! $ERRNO $OS_ERROR $@ $EVAL_ERROR $$ $PROCESS_ID $PID $< $REAL_USER_ID $UID $> $EFFECTIVE_USER_ID $EUID),'$(',qw($REAL_GROUP_ID $GID),'$)',qw($EFFECTIVE_GROUP_ID $EGID $0 $PROGRAM_NAME $[ $] $^A $ACCUMULATOR $^C $COMPILING $^CHILD_ERROR_NATIVE $^D $DEBUGGING $^E $EXTENDED_OS_ERROR $^ENCODING $^F $SYSTEM_FD_MAX $^GLOBAL_PHASE $^H $^I $INPLACE_EDIT $^L $FORMAT_FORMFEED $^LAST_FH $^M $^MATCH $^N $LAST_SUBMATCH_RESULT $^O $OSNAME $^OPEN $^P $PERLDB $^PREMATCH $^POSTMATCH $^R $LAST_REGEXP_CODE_RESULT $^RE_DEBUG_FLAGS $^RE_TRIE_MAXBUF $^S $EXCEPTIONS_BEING_CAUGHT $^T $BASETIME $^TAINT $^UNICODE $^UTF8CACHE $^UTF8LOCALE $^V $PERL_VERSION $^W $WARNING $^WARNING_BITS $^WIDE_SYSTEM_CALLS $^WIN32_SLOPPY_STAT $^X $EXECUTABLE_NAME $ARGV),);use vars '@Arrays';@Arrays=qw(@+ $LAST_MATCH_END @- @LAST_MATCH_START @ARGV @F @INC @_ @ARG);use vars '@Hashes';@Hashes=qw(%OVERLOAD %+ %LAST_MATCH_END %- %LAST_MATCH_START %! %OS_ERROR %ERRNO %^H %INC %ENV %SIG);use vars '@Filehandles';@Filehandles=qw(*ARGV ARGV *_ _ ARGVOUT DATA STDIN STDOUT STDERR);use vars '@Functions';@Functions=qw(__SUB__ AUTOLOAD BEGIN DESTROY END INIT CHECK UNITCHECK abs accept alarm atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir connect cos crypt dbmclose dbmopen defined delete die dump each endgrent endhostent endnetent endprotoent endpwent endservent eof eval evalbytes exec exists exit exp fc fcntl fileno flock fork format formline getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt glob gmtime goto grep hex index int import ioctl join keys kill last lc lcfirst length link listen local localtime log lstat map mkdir msgctl msgget msgrcv msgsnd my next not oct open opendir ord our pack pipe pop pos print printf prototype push quotemeta rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times truncate uc ucfirst umask undef unlink unimport unpack unshift untie use utime values vec wait waitpid wantarray warn write -r -w -x -o -R -W -X -O -e -z -s -f -d -l -p -S -b -c -t -u -g -k -T -B -M -A -C);use vars '@Barewords';@Barewords=qw(__FILE__ __LINE__ __PACKAGE__ __DATA__ __END__ CORE EQ GE GT LE LT NE NULL and cmp continue default do else elsif eq for foreach ge given gt if le lock lt m ne no or package q qq qr qw qx s sub tr unless until when while x xor y);use vars '@TieIOMethods';@TieIOMethods=qw(BINMODE CLEAR CLEARERR CLONE CLONE_SKIP CLOSE DELETE EOF ERROR EXISTS EXTEND FDOPEN FETCH FETCHSIZE FILENO FILL FIRSTKEY FLUSH GETC NEXTKEY OPEN POP POPPED PRINT PRINTF PUSH PUSHED READ READLINE SCALAR SEEK SETLINEBUF SHIFT SPLICE STORE STORESIZE SYSOPEN TELL TIEARRAY TIEHANDLE TIEHASH TIESCALAR UNREAD UNSHIFT UNTIE UTF8 WRITE);use vars '@UNIVERSALMethods';@UNIVERSALMethods=qw(can isa DOES VERSION);use vars '@ExporterSymbols';@ExporterSymbols=qw(@EXPORT @EXPORT_OK @EXPORT_FAIL @EXPORT_TAGS _push_tags _rebuild_cache as_heavy export export_fail export_fail_in export_ok_tags export_tags export_to_level heavy_export heavy_export_ok_tags heavy_export_tags heavy_export_to_level heavy_require_version require_version);use vars '@Symbols';@Symbols=(@Scalars,@Arrays,@Hashes,@Filehandles,@Functions);BEGIN {$^W=0}"You know, when you stop and think about it, Cthulhu is a bit a Mary Sue isn't he?" 
B_KEYWORDS

$fatpacked{"Canary/Stability.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CANARY_STABILITY';
  package Canary::Stability;BEGIN {$VERSION=0.01}sub sgr {local $|=1;$ENV{PERL_CANARY_STABILITY_COLOUR}ne 0 and ((-t STDOUT and length$ENV{TERM})or $ENV{PERL_CANARY_STABILITY_COLOUR})and print "\e[$_[0]m"}sub import {my (undef,$distname,$minvers,$minperl)=@_;$ENV{PERL_CANARY_STABILITY_DISABLE}and return;$minperl ||= 5.008002;print <<EOF;if ($minvers > $VERSION){sgr 33;print <<EOF}elsif ($] < $minperl){sgr 33;print <<EOF}elsif (defined$Internals::StabilityBranchVersion){sgr 32;print <<EOF}elsif ($] < 5.021){print <<EOF}else {sgr 31;print <<EOF;sgr 0;print <<EOF;unless ($ENV{PERL_CANARY_STABILITY_NOPROMPT}){require ExtUtils::MakeMaker;ExtUtils::MakeMaker::prompt ("Continue anyways? ","y")=~ /^y/i or die "FATAL: User aborted configuration of $distname.\n"}}sgr 0}1
  
  ***
  *** Canary::Stability COMPATIBILITY AND SUPPORT CHECK
  *** =================================================
  ***
  *** Hi!
  ***
  *** I do my best to provide predictable and reliable software.
  ***
  *** However, in recent releases, P5P (who maintain perl) have been
  *** introducing regressions that are sometimes subtle and at other times
  *** catastrophic, often for personal preferences with little or no concern
  *** for existing code, most notably CPAN.
  ***
  *** For this reason, it has become very hard for me to maintain the level
  *** of reliability and support I have committed myself to in the past, at
  *** least with some perl versions: I simply can't keep up working around new
  *** bugs or gratituous incompatibilities, and in turn you might suffer from
  *** unanticipated problems.
  ***
  *** Therefore I have introduced a support and compatibility check, the results
  *** of which follow below, together with a FAQ and some recommendations.
  ***
  *** This check is just to let you know that there might be a risk, so you can
  *** make judgement calls on how to proceed - it will not keep the module from
  *** installing or working.
  ***
  EOF
  *** The stability canary says: (nothing, it died of old age).
  ***
  *** Your Canary::Stability module (used by $distname) is too old.
  *** This is not a fatal problem - while you might want to upgrade to version
  *** $minvers (currently installed version: $VERSION) to get better support
  *** status testing, you might also not want to care at all, and all will
  *** be well as long $distname works well enough for you, as the stability
  *** canary is only used when installing the distribution.
  EOF
  *** The stability canary says: chirp (it seems concerned about something).
  ***
  *** Your perl version ($]) is older than the $distname distribution
  *** likes ($minperl). This is not a fatal problem - the module might work
  *** well with your version of perl, but it does mean the author likely
  *** won't do anything to make it work if it breaks.
  EOF
  *** The stability canary says: chirp! chirp! (it seems to be quite excited)
  ***
  *** It seems you are running schmorp's stability branch of perl.
  *** All should be well, and if it isn't, you should report this as a bug
  *** to the $distname author.
  EOF
  *** The stability canary says: chirp! chirp! (it seems to be quite happy)
  ***
  *** Your version of perl ($]) is quite supported by $distname, nothing
  *** else to be said, hope it comes in handy.
  EOF
  *** The stability canary says: (nothing, it was driven away by harsh weather)
  ***
  *** It seems you are running perl version $], likely the "official" or
  *** "standard" version. While there is nothing wrong with doing that,
  *** standard perl versions 5.022 and up are not supported by $distname.
  *** While this might be fatal, it might also be all right - if you run into
  *** problems, you might want to downgrade your perl or switch to the
  *** stability branch.
  ***
  *** If everything works fine, you can ignore this message.
  EOF
  ***
  *** Stability canary mini-FAQ:
  ***
  *** Do I need to do anything?
  ***    With luck, no. While some distributions are known to fail
  ***    already, most should probably work. This message is here
  ***    to alert you that your perl is not supported by $distname,
  ***    and if things go wrong, you either need to downgrade, or
  ***    sidegrade to the stability variant of your perl version,
  ***    or simply live with the consequences.
  ***
  *** What is this canary thing?
  ***    It's purpose is to check support status of $distname with
  ***    respect to your perl version.
  ***
  *** What is this "stability branch"?
  ***    It's a branch or fork of the official perl, by schmorp, to
  ***    improve stability and compatibility with existing modules.
  ***
  *** How can I skip this prompt on automated installs?
  ***    Set PERL_CANARY_STABILITY_NOPROMPT=1 in your environment.
  ***    More info is in the Canary::Stability manpage.
  ***
  *** Long version of this FAQ: http://stableperl.schmorp.de/faq.html
  *** Stability Branch homepage: http://stableperl.schmorp.de/
  ***
  
  EOF
CANARY_STABILITY

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;use strict;our$VERSION='0.01';sub croak {require Carp;Carp::croak(@_)}sub import {shift;my%args=@_;my$pkg=caller(0);my%key_ctor=(rw=>\&_mk_accessors,ro=>\&_mk_ro_accessors,wo=>\&_mk_wo_accessors,);for my$key (sort keys%key_ctor){if (defined$args{$key}){croak("value of the '$key' parameter should be an arrayref")unless ref($args{$key})eq 'ARRAY';$key_ctor{$key}->($pkg,@{$args{$key}})}}_mk_new($pkg)if$args{new};1}sub mk_new_and_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_new($pkg);_mk_accessors($pkg,@properties)}sub mk_new {my$pkg=caller(0);_mk_new($pkg)}sub mk_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_accessors($pkg,@properties)}sub mk_ro_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_ro_accessors($pkg,@properties)}sub mk_wo_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_wo_accessors($pkg,@properties)}sub _mk_new {my$pkg=shift;no strict 'refs';*{$pkg .'::new'}=__m_new($pkg)}sub _mk_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m($n)}}sub _mk_ro_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_ro($pkg,$n)}}sub _mk_wo_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_wo($pkg,$n)}}sub __m_new {my$pkg=shift;no strict 'refs';return sub {my$klass=shift;bless {(@_==1 && ref($_[0])eq 'HASH' ? %{$_[0]}: @_),},$klass}}sub __m {my$n=shift;sub {return $_[0]->{$n}if @_==1;return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}sub __m_ro {my ($pkg,$n)=@_;sub {if (@_==1){return $_[0]->{$n}if @_==1}else {my$caller=caller(0);croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'")}}}sub __m_wo {my ($pkg,$n)=@_;sub {if (@_==1){my$caller=caller(0);croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")}else {return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}}1;
CLASS_ACCESSOR_LITE

$fatpacked{"Class/Data/Inheritable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_DATA_INHERITABLE';
  package Class::Data::Inheritable;use strict qw(vars subs);use vars qw($VERSION);$VERSION='0.01';sub mk_classdata {my ($declaredclass,$attribute,$data)=@_;if(ref$declaredclass){require Carp;Carp::croak("mk_classdata() is a class method, not an object method")}my$accessor=sub {my$wantclass=ref($_[0])|| $_[0];return$wantclass->mk_classdata($attribute)->(@_)if @_>1 && $wantclass ne $declaredclass;$data=$_[1]if @_>1;return$data};my$alias="_${attribute}_accessor";*{$declaredclass.'::'.$attribute}=$accessor;*{$declaredclass.'::'.$alias}=$accessor}1;
CLASS_DATA_INHERITABLE

$fatpacked{"Class/Inspector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_INSPECTOR';
  package Class::Inspector;use 5.006;use strict qw{vars subs};use warnings;use File::Spec ();our$VERSION='0.01';BEGIN {local $@;eval "require utf8; utf8->import"}our$RE_IDENTIFIER=qr/\A[^\W\d]\w*\z/s;our$RE_CLASS=qr/\A[^\W\d]\w*(?:(?:\'|::)\w+)*\z/s;our$UNIX=!!($File::Spec::ISA[0]eq 'File::Spec::Unix');sub _resolved_inc_handler {my$class=shift;my$filename=$class->_inc_filename(shift)or return undef;for my$inc (@INC){if(ref$inc eq 'CODE'){my@ret=$inc->($inc,$filename);if(@ret){return 1}}}''}sub installed {my$class=shift;!!($class->loaded_filename($_[0])or $class->resolved_filename($_[0])or $class->_resolved_inc_handler($_[0]))}sub loaded {my$class=shift;my$name=$class->_class(shift)or return undef;$class->_loaded($name)}sub _loaded {my$class=shift;my$name=shift;return 1 if defined ${"${name}::VERSION"};return 1 if @{"${name}::ISA"};for (keys %{"${name}::"}){next if substr($_,-2,2)eq '::';return 1 if defined &{"${name}::$_"}}my$filename=$class->_inc_filename($name);return 1 if defined$INC{$filename};''}sub filename {my$class=shift;my$name=$class->_class(shift)or return undef;File::Spec->catfile(split /(?:\'|::)/,$name).'.pm'}sub resolved_filename {my$class=shift;my$filename=$class->_inc_filename(shift)or return undef;my@try_first=@_;for (@try_first,@INC){my$full="$_/$filename";next unless -e $full;return$UNIX ? $full : $class->_inc_to_local($full)}''}sub loaded_filename {my$class=shift;my$filename=$class->_inc_filename(shift);$UNIX ? $INC{$filename}: $class->_inc_to_local($INC{$filename})}sub functions {my$class=shift;my$name=$class->_class(shift)or return undef;return undef unless$class->loaded($name);my@functions=sort grep {/$RE_IDENTIFIER/o}grep {defined &{"${name}::$_"}}keys %{"${name}::"};\@functions}sub function_refs {my$class=shift;my$name=$class->_class(shift)or return undef;return undef unless$class->loaded($name);my@functions=map {\&{"${name}::$_"}}sort grep {/$RE_IDENTIFIER/o}grep {defined &{"${name}::$_"}}keys %{"${name}::"};\@functions}sub function_exists {my$class=shift;my$name=$class->_class(shift)or return undef;my$function=shift or return undef;return undef unless$class->loaded($name);defined &{"${name}::$function"}}sub methods {my$class=shift;my$name=$class->_class(shift)or return undef;my@arguments=map {lc $_}@_;my%options=();for (@arguments){if ($_ eq 'public'){return undef if$options{private};$options{public}=1}elsif ($_ eq 'private'){return undef if$options{public};$options{private}=1}elsif ($_ eq 'full'){return undef if$options{expanded};$options{full}=1}elsif ($_ eq 'expanded'){return undef if$options{full};$options{expanded}=1}else {return undef}}return undef unless$class->loaded($name);my@path=();my@queue=($name);my%seen=($name=>1);while (my$cl=shift@queue){push@path,$cl;unshift@queue,grep {!$seen{$_}++}map {s/^::/main::/;s/\'/::/g;$_}(@{"${cl}::ISA"})}my%methods=();for my$namespace (@path){my@functions=grep {!$methods{$_}}grep {/$RE_IDENTIFIER/o}grep {defined &{"${namespace}::$_"}}keys %{"${namespace}::"};for (@functions){$methods{$_}=$namespace}}my@methodlist=sort keys%methods;@methodlist=grep {!/^\_/}@methodlist if$options{public};@methodlist=grep {/^\_/}@methodlist if$options{private};@methodlist=map {"$methods{$_}::$_"}@methodlist if$options{full};@methodlist=map {["$methods{$_}::$_",$methods{$_},$_,\&{"$methods{$_}::$_"}]}@methodlist if$options{expanded};\@methodlist}sub subclasses {my$class=shift;my$name=$class->_class(shift)or return undef;my@found=();my@queue=grep {$_ ne 'main'}$class->_subnames('');while (@queue){my$c=shift(@queue);if ($class->_loaded($c)){local $@;eval {if ($c->isa($name)){push@found,$c unless$c eq $name}}}unshift@queue,map {"${c}::$_"}$class->_subnames($c)}@found ? \@found : ''}sub _subnames {my ($class,$name)=@_;return sort grep {substr($_,-2,2,'')eq '::' and /$RE_IDENTIFIER/o}keys %{"${name}::"}}sub children {my$class=shift;my$name=$class->_class(shift)or return ();no strict 'refs';map {"${name}::$_"}sort grep {s/::$//}keys %{"${name}::"}}sub recursive_children {my$class=shift;my$name=$class->_class(shift)or return ();my@children=($name);my$i=0;no strict 'refs';while (my$namespace=$children[$i++]){push@children,map {"${namespace}::$_"}grep {!/^::/}grep {s/::$//}keys %{"${namespace}::"}}sort@children}sub _class {my$class=shift;my$name=shift or return '';return 'main' if$name eq '::';$name =~ s/\A::/main::/;$name =~ /$RE_CLASS/o ? $name : ''}sub _inc_filename {my$class=shift;my$name=$class->_class(shift)or return undef;join('/',split /(?:\'|::)/,$name).'.pm'}sub _inc_to_local {return $_[1]if$UNIX;my$class=shift;my$inc_name=shift or return undef;my ($vol,$dir,$file)=File::Spec->splitpath($inc_name);$dir=File::Spec->catdir(File::Spec->splitdir($dir || ""));File::Spec->catpath($vol,$dir,$file || "")}1;
CLASS_INSPECTOR

$fatpacked{"Class/Inspector/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_INSPECTOR_FUNCTIONS';
  package Class::Inspector::Functions;use 5.006;use strict;use warnings;use Exporter ();use Class::Inspector ();our$VERSION='0.01';BEGIN {our@ISA='Exporter';our@EXPORT=qw(installed loaded filename functions methods subclasses);our@EXPORT_OK=qw(resolved_filename loaded_filename function_refs function_exists);our%EXPORT_TAGS=(ALL=>[@EXPORT_OK,@EXPORT ]);for my$meth (@EXPORT,@EXPORT_OK){my$sub=Class::Inspector->can($meth);no strict 'refs';*{$meth}=sub {&$sub('Class::Inspector',@_)}}}1;
CLASS_INSPECTOR_FUNCTIONS

$fatpacked{"Class/Method/Modifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_METHOD_MODIFIERS';
  use strict;use warnings;package Class::Method::Modifiers;our$VERSION='0.01';use base 'Exporter';our@EXPORT=qw(before after around);our@EXPORT_OK=(@EXPORT,qw(fresh install_modifier));our%EXPORT_TAGS=(moose=>[qw(before after around)],all=>\@EXPORT_OK,);BEGIN {*_HAS_READONLY=$] >= 5.008 ? sub(){1}: sub(){0}}our%MODIFIER_CACHE;sub _install_modifier;*_install_modifier=\&install_modifier;sub install_modifier {my$into=shift;my$type=shift;my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';return _fresh($into,$code,@names)if$type eq 'fresh';for my$name (@names){my$hit=$into->can($name)or do {require Carp;Carp::confess("The method '$name' is not found in the inheritance hierarchy for class $into")};my$qualified=$into.'::'.$name;my$cache=$MODIFIER_CACHE{$into}{$name}||= {before=>[],after=>[],around=>[],};if (!exists($cache->{"orig"})){no strict 'refs';$cache->{"orig"}=*{$qualified}{CODE};$cache->{"wrapped"}=$cache->{"orig"}|| $hit}if ($type eq 'after'){push @{$cache->{$type}},$code}else {unshift @{$cache->{$type}},$code}if ($type eq 'around'){my$method=$cache->{wrapped};my$attrs=_sub_attrs($code);$cache->{wrapped}=eval "package $into; +sub $attrs { \$code->(\$method, \@_); };"}if (@{$cache->{$type}}==1){my$before=$cache->{"before"};my$after=$cache->{"after"};my$wrapped=\$cache->{"wrapped"};my$attrs=_sub_attrs($cache->{wrapped});my$generated="package $into;\n";$generated .= "sub $name $attrs {";if (@$before){$generated .= '
                      for my $method (@$before) {
                          $method->(@_);
                      }
                  '}if (@$after){$generated .= '
                      my $ret;
                      if (wantarray) {
                          $ret = [$$wrapped->(@_)];
                          '.(_HAS_READONLY ? 'Internals::SvREADONLY(@$ret, 1);' : '').'
                      }
                      elsif (defined wantarray) {
                          $ret = \($$wrapped->(@_));
                      }
                      else {
                          $$wrapped->(@_);
                      }
  
                      for my $method (@$after) {
                          $method->(@_);
                      }
  
                      wantarray ? @$ret : $ret ? $$ret : ();
                  '}else {$generated .= '$$wrapped->(@_);'}$generated .= '}';no strict 'refs';no warnings 'redefine';no warnings 'closure';eval$generated}}}sub before {_install_modifier(scalar(caller),'before',@_)}sub after {_install_modifier(scalar(caller),'after',@_)}sub around {_install_modifier(scalar(caller),'around',@_)}sub fresh {my$code=pop;my@names=@_;@names=@{$names[0]}if ref($names[0])eq 'ARRAY';_fresh(scalar(caller),$code,@names)}sub _fresh {my ($into,$code,@names)=@_;for my$name (@names){if ($name !~ /\A [a-zA-Z_] [a-zA-Z0-9_]* \z/xms){require Carp;Carp::confess("Invalid method name '$name'")}if ($into->can($name)){require Carp;Carp::confess("Class $into already has a method named '$name'")}if (_is_in_package($code,$into)){no strict 'refs';*{"$into\::$name"}=$code}else {no warnings 'closure';my$attrs=_sub_attrs($code);eval "package $into; sub $name $attrs { \$code->(\@_) }"}}}sub _sub_attrs {my ($coderef)=@_;local*_sub=$coderef;local $@;(eval 'sub { _sub = 1 }')? ':lvalue' : ''}sub _is_in_package {my ($coderef,$package)=@_;require B;my$cv=B::svref_2object($coderef);return$cv->GV->STASH->NAME eq $package}1;
CLASS_METHOD_MODIFIERS

$fatpacked{"Class/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_TINY';
  use 5.006;use strict;no strict 'refs';use warnings;package Class::Tiny;our$VERSION='0.01';use Carp ();require($] >= 5.010 ? "mro.pm" : "MRO/Compat.pm");my%CLASS_ATTRIBUTES;sub import {my$class=shift;my$pkg=caller;$class->prepare_class($pkg);$class->create_attributes($pkg,@_)if @_}sub prepare_class {my ($class,$pkg)=@_;@{"${pkg}::ISA"}="Class::Tiny::Object" unless @{"${pkg}::ISA"}}sub create_attributes {my ($class,$pkg,@spec)=@_;my%defaults=map {ref $_ eq 'HASH' ? %$_ : ($_=>undef)}@spec;my@attr=grep {defined and!ref and /^[^\W\d]\w*$/s or Carp::croak "Invalid accessor name '$_'"}keys%defaults;$CLASS_ATTRIBUTES{$pkg}{$_}=$defaults{$_}for@attr;$class->_gen_accessor($pkg,$_)for grep {!*{"$pkg\::$_"}{CODE}}@attr;Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub _gen_accessor {my ($class,$pkg,$name)=@_;my$outer_default=$CLASS_ATTRIBUTES{$pkg}{$name};my$sub=$class->__gen_sub_body($name,defined($outer_default),ref($outer_default));eval "package $pkg; my \$default=\$outer_default; $sub";Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub __gen_sub_body {my ($self,$name,$has_default,$default_type)=@_;if ($has_default && $default_type eq 'CODE'){return << "HERE"}elsif ($has_default){return << "HERE"}else {return << "HERE"}}sub get_all_attributes_for {my ($class,$pkg)=@_;my%attr=map {$_=>undef}map {keys %{$CLASS_ATTRIBUTES{$_}|| {}}}@{mro::get_linear_isa($pkg)};return keys%attr}sub get_all_attribute_defaults_for {my ($class,$pkg)=@_;my$defaults={};for my$p (reverse @{mro::get_linear_isa($pkg)}){while (my ($k,$v)=each %{$CLASS_ATTRIBUTES{$p}|| {}}){$defaults->{$k}=$v}}return$defaults}package Class::Tiny::Object;our$VERSION='1.006';my (%HAS_BUILDARGS,%BUILD_CACHE,%DEMOLISH_CACHE,%ATTR_CACHE);my$_PRECACHE=sub {no warnings 'once';my ($class)=@_;my$linear_isa=@{"$class\::ISA"}==1 && ${"$class\::ISA"}[0]eq "Class::Tiny::Object" ? [$class]: mro::get_linear_isa($class);$DEMOLISH_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::DEMOLISH"}@$linear_isa ];$BUILD_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::BUILD"}reverse @$linear_isa ];$HAS_BUILDARGS{$class}=$class->can("BUILDARGS");return$ATTR_CACHE{$class}={map {$_=>1}Class::Tiny->get_all_attributes_for($class)}};sub new {my$class=shift;my$valid_attrs=$ATTR_CACHE{$class}|| $_PRECACHE->($class);my$args;if ($HAS_BUILDARGS{$class}){$args=$class->BUILDARGS(@_)}else {if (@_==1 && ref $_[0]){my%copy=eval {%{$_[0]}};Carp::croak("Argument to $class->new() could not be dereferenced as a hash")if $@;$args=\%copy}elsif (@_ % 2==0){$args={@_}}else {Carp::croak("$class->new() got an odd number of elements")}}my$self=bless {map {$_=>$args->{$_}}grep {exists$valid_attrs->{$_}}keys %$args },$class;$self->BUILDALL($args)if!delete$args->{__no_BUILD__}&& @{$BUILD_CACHE{$class}};return$self}sub BUILDALL {$_->(@_)for @{$BUILD_CACHE{ref $_[0]}}}require Devel::GlobalDestruction unless defined ${^GLOBAL_PHASE};sub DESTROY {my$self=shift;my$class=ref$self;my$in_global_destruction=defined ${^GLOBAL_PHASE} ? ${^GLOBAL_PHASE} eq 'DESTRUCT' : Devel::GlobalDestruction::in_global_destruction();for my$demolisher (@{$DEMOLISH_CACHE{$class}}){my$e=do {local ($?,$@);eval {$demolisher->($self,$in_global_destruction)};$@};no warnings 'misc';die$e if$e}}1;
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default->( \$_[0] ) )
      );
  }
  HERE
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default )
      );
  }
  HERE
  sub $name {
      return \@_ == 1 ? \$_[0]{$name} : ( \$_[0]{$name} =  \$_[1] );
  }
  HERE
CLASS_TINY

$fatpacked{"Clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLONE';
  package Clone;use strict;use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);require Exporter;require DynaLoader;require AutoLoader;@ISA=qw(Exporter DynaLoader);@EXPORT=qw();@EXPORT_OK=qw(clone);$VERSION='0.01';bootstrap Clone$VERSION;1;
CLONE

$fatpacked{"Config/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_TINY';
  package Config::Tiny;use strict;our$VERSION='0.01';BEGIN {require 5.008001;$Config::Tiny::errstr=''}sub new {return bless {},shift}sub read {my($class)=ref $_[0]? ref shift : shift;my($file,$encoding)=@_;return$class -> _error('No file name provided')if (!defined$file || ($file eq ''));$encoding=$encoding ? "<:$encoding" : '<';local $/=undef;open(CFG,$encoding,$file)or return$class -> _error("Failed to open file '$file' for reading: $!");my$contents=<CFG>;close(CFG);return$class -> _error("Reading from '$file' returned undef")if (!defined$contents);return$class -> read_string($contents)}sub read_string {my($class)=ref $_[0]? ref shift : shift;my($self)=bless {},$class;return undef unless defined $_[0];my$ns='_';my$counter=0;for (split /(?:\015{1,2}\012|\015|\012)/,shift){$counter++;next if /^\s*(?:\#|\;|$)/;s/\s\;\s.+$//g;if (/^\s*\[\s*(.+?)\s*\]\s*$/){$self->{$ns=$1}||= {};next}if (/^\s*([^=]+?)\s*=\s*(.*?)\s*$/){$self->{$ns}->{$1}=$2;next}return$self -> _error("Syntax error at line $counter: '$_'")}return$self}sub write {my($self)=shift;my($file,$encoding)=@_;return$self -> _error('No file name provided')if (!defined$file or ($file eq ''));$encoding=$encoding ? ">:$encoding" : '>';my($string)=$self->write_string;return undef unless defined$string;open(CFG,$encoding,$file)or return$self->_error("Failed to open file '$file' for writing: $!");print CFG$string;close CFG;return 1}sub write_string {my($self)=shift;my($contents)='';for my$section (sort {(($b eq '_')<=> ($a eq '_'))|| ($a cmp $b)}keys %$self){return$self->_error("Illegal whitespace in section name '$section'")if$section =~ /(?:^\s|\n|\s$)/s;my$block=$self->{$section};$contents .= "\n" if length$contents;$contents .= "[$section]\n" unless$section eq '_';for my$property (sort keys %$block){return$self->_error("Illegal newlines in property '$section.$property'")if$block->{$property}=~ /(?:\012|\015)/s;$contents .= "$property=$block->{$property}\n"}}return$contents}sub errstr {$Config::Tiny::errstr}sub _error {$Config::Tiny::errstr=$_[1];undef}1;
CONFIG_TINY

$fatpacked{"DBM/Deep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP';
  package DBM::Deep;use 5.008_004;use strict;use warnings FATAL=>'all';no warnings 'recursion';our$VERSION=q(0.01);use Scalar::Util ();use overload ('""'=>'0+'=>sub {$_[0]},)[0,2,1,2],fallback=>1;use constant DEBUG=>0;use DBM::Deep::Engine;sub TYPE_HASH () {DBM::Deep::Engine->SIG_HASH}sub TYPE_ARRAY () {DBM::Deep::Engine->SIG_ARRAY}my%obj_cache;use constant HAVE_HUFH=>scalar eval{require Hash::Util::FieldHash};HAVE_HUFH and Hash::Util::FieldHash::fieldhash(%obj_cache);sub _get_args {my$proto=shift;my$args;if (scalar(@_)> 1){if (@_ % 2){$proto->_throw_error("Odd number of parameters to " .(caller(1))[2])}$args={@_}}elsif (ref $_[0]){unless (eval {local$SIG{'__DIE__'};%{$_[0]}|| 1}){$proto->_throw_error("Not a hashref in args to " .(caller(1))[2])}$args=$_[0]}else {$args={file=>shift }}return$args}sub new {my$class=shift;my$args=$class->_get_args(@_);my$self;if (defined($args->{type})&& $args->{type}eq TYPE_ARRAY){$class='DBM::Deep::Array';require DBM::Deep::Array;tie @$self,$class,%$args}else {$class='DBM::Deep::Hash';require DBM::Deep::Hash;tie %$self,$class,%$args}return bless$self,$class}sub _init {my$class=shift;my ($args)=@_;if ($args->{locking}){$args->{autoflush}=1}my$self=bless {type=>TYPE_HASH,base_offset=>undef,staleness=>undef,engine=>undef,},$class;unless (exists$args->{engine}){my$class=exists$args->{dbi}? 'DBM::Deep::Engine::DBI' : exists$args->{_test}? 'DBM::Deep::Engine::Test' : 'DBM::Deep::Engine::File' ;eval "use $class";die $@ if $@;$args->{engine}=$class->new({%{$args},obj=>$self,})}for my$param (keys %$self){next unless exists$args->{$param};$self->{$param}=$args->{$param}}eval {local$SIG{'__DIE__'};$self->lock_exclusive;$self->_engine->setup($self);$self->unlock};if ($@){my$e=$@;eval {local$SIG{'__DIE__'};$self->unlock};die$e}if($self->{engine}->{external_refs}and my$sector=$self->{engine}->load_sector($self->{base_offset})){$sector->increment_refcount;Scalar::Util::weaken(my$feeble_ref=$self);$obj_cache{$self }=\$feeble_ref;if(!HAVE_HUFH){for(keys%obj_cache){delete$obj_cache{$_}if not ${$obj_cache{$_}}}}}return$self}sub TIEHASH {shift;require DBM::Deep::Hash;return DBM::Deep::Hash->TIEHASH(@_)}sub TIEARRAY {shift;require DBM::Deep::Array;return DBM::Deep::Array->TIEARRAY(@_)}sub lock_exclusive {my$self=shift->_get_self;return$self->_engine->lock_exclusive($self,@_)}*lock=\&lock_exclusive;sub lock_shared {my$self=shift->_get_self;unless ($self->_engine){require Carp;require Data::Dumper;Carp::cluck(Data::Dumper->Dump([$self],['self']))}return$self->_engine->lock_shared($self,@_)}sub unlock {my$self=shift->_get_self;return$self->_engine->unlock($self,@_)}sub _copy_value {my$self=shift->_get_self;my ($spot,$value)=@_;if (!ref$value){${$spot}=$value}else {my$r=Scalar::Util::reftype($value);my$tied;if ($r eq 'ARRAY'){$tied=tied(@$value)}elsif ($r eq 'HASH'){$tied=tied(%$value)}else {__PACKAGE__->_throw_error("Unknown type for '$value'")}if (eval {local$SIG{'__DIE__'};$tied->isa(__PACKAGE__)}){${$spot}=$tied->_repr;$tied->_copy_node(${$spot})}else {if ($r eq 'ARRAY'){${$spot}=[@{$value}]}else {${$spot}={%{$value}}}}my$c=Scalar::Util::blessed($value);if (defined$c &&!$c->isa(__PACKAGE__)){${$spot}=bless ${$spot},$c}}return 1}sub export {my$self=shift->_get_self;my$temp=$self->_repr;$self->lock_exclusive;$self->_copy_node($temp);$self->unlock;my$classname=$self->_engine->get_classname($self);if (defined$classname){bless$temp,$classname}return$temp}sub _check_legality {my$self=shift;my ($val)=@_;my$r=Scalar::Util::reftype($val);return$r if!defined$r || '' eq $r;return$r if 'HASH' eq $r;return$r if 'ARRAY' eq $r;__PACKAGE__->_throw_error("Storage of references of type '$r' is not supported.")}sub import {return if!ref $_[0];my$self=shift->_get_self;my ($struct)=@_;my$type=$self->_check_legality($struct);if (!$type){__PACKAGE__->_throw_error("Cannot import a scalar")}if (substr($type,0,1)ne $self->_type){__PACKAGE__->_throw_error("Cannot import " .('HASH' eq $type ? 'a hash' : 'an array')." into " .('HASH' eq $type ? 'an array' : 'a hash'))}my%seen;my$recurse;$recurse=sub {my ($db,$val)=@_;my$obj='HASH' eq Scalar::Util::reftype($db)? tied(%$db): tied(@$db);$obj ||= $db;my$r=$self->_check_legality($val);if ('HASH' eq $r){while (my ($k,$v)=each %$val){my$r=$self->_check_legality($v);if ($r){my$temp='HASH' eq $r ? {}: [];if (my$c=Scalar::Util::blessed($v)){bless$temp,$c}$obj->put($k,$temp);$recurse->($temp,$v)}else {$obj->put($k,$v)}}}elsif ('ARRAY' eq $r){for my$k (0 .. $#$val){my$v=$val->[$k];my$r=$self->_check_legality($v);if ($r){my$temp='HASH' eq $r ? {}: [];if (my$c=Scalar::Util::blessed($v)){bless$temp,$c}$obj->put($k,$temp);$recurse->($temp,$v)}else {$obj->put($k,$v)}}}};$recurse->($self,$struct);return 1}sub optimize {my$self=shift->_get_self;return unless$self->_engine->isa('DBM::Deep::Engine::File');my$temp_filename=$self->_engine->storage->{file}.'.tmp';my$db_temp=__PACKAGE__->new(file=>$temp_filename,type=>$self->_type,(map {$_=>$self->_engine->$_}qw(byte_size max_buckets data_sector_size num_txns)),);$self->lock_exclusive;$self->_engine->clear_cache;$self->_copy_node($db_temp);$self->unlock;$db_temp->_engine->storage->close;undef$db_temp;$self->_engine->storage->copy_stats($temp_filename);if ($^O eq 'MSWin32' || $^O eq 'cygwin'){$self->unlock;$self->_engine->storage->close}if (!rename$temp_filename,$self->_engine->storage->{file}){unlink$temp_filename;$self->unlock;$self->_throw_error("Optimize failed: Cannot copy temp file over original: $!")}$self->unlock;$self->_engine->storage->close;$self->_engine->storage->open;$self->lock_exclusive;$self->_engine->setup($self);$self->unlock;return 1}sub clone {my$self=shift->_get_self;return __PACKAGE__->new(type=>$self->_type,base_offset=>$self->_base_offset,staleness=>$self->_staleness,engine=>$self->_engine,)}sub supports {my$self=shift->_get_self;return$self->_engine->supports(@_)}sub db_version {shift->_get_self->_engine->db_version}{my%is_legal_filter=map {$_=>~~1,}qw(store_key store_value fetch_key fetch_value);sub set_filter {my$self=shift->_get_self;my$type=lc shift;my$func=shift;if ($is_legal_filter{$type}){$self->_engine->storage->{"filter_$type"}=$func;return 1}return}sub filter_store_key {$_[0]->set_filter(store_key=>$_[1])}sub filter_store_value {$_[0]->set_filter(store_value=>$_[1])}sub filter_fetch_key {$_[0]->set_filter(fetch_key=>$_[1])}sub filter_fetch_value {$_[0]->set_filter(fetch_value=>$_[1])}}sub begin_work {my$self=shift->_get_self;$self->lock_exclusive;my$rv=eval {local$SIG{'__DIE__'};$self->_engine->begin_work($self,@_)};my$e=$@;$self->unlock;die$e if$e;return$rv}sub rollback {my$self=shift->_get_self;$self->lock_exclusive;my$rv=eval {local$SIG{'__DIE__'};$self->_engine->rollback($self,@_)};my$e=$@;$self->unlock;die$e if$e;return$rv}sub commit {my$self=shift->_get_self;$self->lock_exclusive;my$rv=eval {local$SIG{'__DIE__'};$self->_engine->commit($self,@_)};my$e=$@;$self->unlock;die$e if$e;return$rv}sub _engine {my$self=$_[0]->_get_self;return$self->{engine}}sub _type {my$self=$_[0]->_get_self;return$self->{type}}sub _base_offset {my$self=$_[0]->_get_self;return$self->{base_offset}}sub _staleness {my$self=$_[0]->_get_self;return$self->{staleness}}sub _throw_error {my$n=0;while(1){my@caller=caller(++$n);next if$caller[0]=~ m/^DBM::Deep/;die "DBM::Deep: $_[1] at $caller[1] line $caller[2]\n"}}sub STORE {my$self=shift->_get_self;my ($key,$value)=@_;warn "STORE($self, '$key', '@{[defined$value?$value:'undef']}')\n" if DEBUG;unless ($self->_engine->storage->is_writable){$self->_throw_error('Cannot write to a readonly filehandle')}$self->lock_exclusive;if (!ref($value)&& $self->_engine->storage->{filter_store_value}){$value=$self->_engine->storage->{filter_store_value}->($value)}eval {local$SIG{'__DIE__'};$self->_engine->write_value($self,$key,$value)};if (my$e=$@){$self->unlock;die$e}$self->unlock;return 1}sub FETCH {my$self=shift->_get_self;my ($key)=@_;warn "FETCH($self, '$key')\n" if DEBUG;$self->lock_shared;my$result=$self->_engine->read_value($self,$key);$self->unlock;return ($result &&!ref($result)&& $self->_engine->storage->{filter_fetch_value})? $self->_engine->storage->{filter_fetch_value}->($result): $result}sub DELETE {my$self=shift->_get_self;my ($key)=@_;warn "DELETE($self, '$key')\n" if DEBUG;unless ($self->_engine->storage->is_writable){$self->_throw_error('Cannot write to a readonly filehandle')}$self->lock_exclusive;my$value=$self->_engine->delete_key($self,$key);if (defined$value &&!ref($value)&& $self->_engine->storage->{filter_fetch_value}){$value=$self->_engine->storage->{filter_fetch_value}->($value)}$self->unlock;return$value}sub EXISTS {my$self=shift->_get_self;my ($key)=@_;warn "EXISTS($self, '$key')\n" if DEBUG;$self->lock_shared;my$result=$self->_engine->key_exists($self,$key);$self->unlock;return$result}sub CLEAR {my$self=shift->_get_self;warn "CLEAR($self)\n" if DEBUG;my$engine=$self->_engine;unless ($engine->storage->is_writable){$self->_throw_error('Cannot write to a readonly filehandle')}$self->lock_exclusive;eval {local$SIG{'__DIE__'};$engine->clear($self)};my$e=$@;warn "$e\n" if$e && DEBUG;$self->unlock;die$e if$e;return 1}sub put {(shift)->STORE(@_)}sub get {(shift)->FETCH(@_)}sub store {(shift)->STORE(@_)}sub fetch {(shift)->FETCH(@_)}sub delete {(shift)->DELETE(@_)}sub exists {(shift)->EXISTS(@_)}sub clear {(shift)->CLEAR(@_)}sub _dump_file {shift->_get_self->_engine->_dump_file}sub _warnif {my$level;{my($pack,$file,$line,$bitmask)=(caller$level++)[0..2,9];redo if$pack =~ /^DBM::Deep(?:::|\z)/;if(vec$bitmask,$warnings'Offsets{$_[0]},1,|| vec$bitmask,$warnings'Offsets{all},1,){my$msg=$_[1]=~ /\n\z/ ? $_[1]: "$_[1] at $file line $line.\n";die$msg if vec$bitmask,$warnings'Offsets{$_[0]}+1,1,|| vec$bitmask,$warnings'Offsets{all}+1,1;warn$msg}}}sub _free {my$self=shift;if(my$sector=$self->{engine}->load_sector($self->{base_offset})){$sector->free}}sub DESTROY {my$self=shift;my$alter_ego=$self->_get_self;if(!$alter_ego || $self!=$alter_ego){return}return if!$self->{engine};if($self->{engine}->{external_refs}){$self->_free}}END {defined $$_ and $$_->_free,delete $$_->{engine}for(values%obj_cache)}1;
DBM_DEEP

$fatpacked{"DBM/Deep/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ARRAY';
  package DBM::Deep::Array;use 5.008_004;use strict;use warnings FATAL=>'all';no warnings 'recursion';our$NEGATIVE_INDICES=1;use base 'DBM::Deep';use Scalar::Util ();sub _get_self {Scalar::Util::reftype $_[0]eq 'ARRAY' ? tied @{$_[0]}: $_[0]}sub _repr {[]}sub TIEARRAY {my$class=shift;my$args=$class->_get_args(@_);$args->{type}=$class->TYPE_ARRAY;return$class->_init($args)}sub FETCH {my$self=shift->_get_self;my ($key)=@_;$self->lock_shared;if (!defined$key){$self->unlock;DBM::Deep->_throw_error("Cannot use an undefined array index.")}elsif ($key =~ /^-?\d+$/){if ($key < 0){$key += $self->FETCHSIZE;unless ($key >= 0){$self->unlock;return}}}elsif ($key ne 'length'){$self->unlock;DBM::Deep->_throw_error("Cannot use '$key' as an array index.")}my$rv=$self->SUPER::FETCH($key);$self->unlock;return$rv}sub STORE {my$self=shift->_get_self;my ($key,$value)=@_;$self->lock_exclusive;my$size;my$idx_is_numeric;if (!defined$key){$self->unlock;DBM::Deep->_throw_error("Cannot use an undefined array index.")}elsif ($key =~ /^-?\d+$/){$idx_is_numeric=1;if ($key < 0){$size=$self->FETCHSIZE;if ($key + $size < 0){die("Modification of non-creatable array value attempted, subscript $key")}$key += $size}}elsif ($key ne 'length'){$self->unlock;DBM::Deep->_throw_error("Cannot use '$key' as an array index.")}my$rv=$self->SUPER::STORE($key,$value);if ($idx_is_numeric){$size=$self->FETCHSIZE unless defined$size;if ($key >= $size){$self->STORESIZE($key + 1)}}$self->unlock;return$rv}sub EXISTS {my$self=shift->_get_self;my ($key)=@_;$self->lock_shared;if (!defined$key){$self->unlock;DBM::Deep->_throw_error("Cannot use an undefined array index.")}elsif ($key =~ /^-?\d+$/){if ($key < 0){$key += $self->FETCHSIZE;unless ($key >= 0){$self->unlock;return}}}elsif ($key ne 'length'){$self->unlock;DBM::Deep->_throw_error("Cannot use '$key' as an array index.")}my$rv=$self->SUPER::EXISTS($key);$self->unlock;return$rv}sub DELETE {my$self=shift->_get_self;my ($key)=@_;warn "ARRAY::DELETE($self,$key)\n" if DBM::Deep::DEBUG;$self->lock_exclusive;my$size=$self->FETCHSIZE;if (!defined$key){$self->unlock;DBM::Deep->_throw_error("Cannot use an undefined array index.")}elsif ($key =~ /^-?\d+$/){if ($key < 0){$key += $size;unless ($key >= 0){$self->unlock;return}}}elsif ($key ne 'length'){$self->unlock;DBM::Deep->_throw_error("Cannot use '$key' as an array index.")}my$rv=$self->SUPER::DELETE($key);if ($rv && $key==$size - 1){$self->STORESIZE($key)}$self->unlock;return$rv}sub FETCHSIZE {my$self=shift->_get_self;$self->lock_shared;my$SAVE_FILTER=$self->_engine->storage->{filter_fetch_value};$self->_engine->storage->{filter_fetch_value}=undef;my$size=$self->FETCH('length')|| 0;$self->_engine->storage->{filter_fetch_value}=$SAVE_FILTER;$self->unlock;return$size}sub STORESIZE {my$self=shift->_get_self;my ($new_length)=@_;$self->lock_exclusive;my$SAVE_FILTER=$self->_engine->storage->{filter_store_value};$self->_engine->storage->{filter_store_value}=undef;my$result=$self->STORE('length',$new_length,'length');$self->_engine->storage->{filter_store_value}=$SAVE_FILTER;$self->unlock;return$result}sub POP {my$self=shift->_get_self;$self->lock_exclusive;my$length=$self->FETCHSIZE();if ($length){my$content=$self->FETCH($length - 1);$self->DELETE($length - 1);$self->unlock;return$content}else {$self->unlock;return}}sub PUSH {my$self=shift->_get_self;$self->lock_exclusive;my$length=$self->FETCHSIZE();for my$content (@_){$self->STORE($length,$content);$length++}$self->unlock;return$length}sub _move_value {my$self=shift;my ($old_key,$new_key)=@_;return$self->_engine->make_reference($self,$old_key,$new_key)}sub SHIFT {my$self=shift->_get_self;warn "SHIFT($self)\n" if DBM::Deep::DEBUG;$self->lock_exclusive;my$length=$self->FETCHSIZE();if (!$length){$self->unlock;return}my$content=$self->DELETE(0);if ($length > 1){for (my$i=0;$i < $length - 1;$i++){$self->_move_value($i+1,$i)}$self->DELETE($length - 1)}$self->unlock;return$content}sub UNSHIFT {my$self=shift->_get_self;my@new_elements=@_;$self->lock_exclusive;my$length=$self->FETCHSIZE();my$new_size=scalar@new_elements;if ($length){for (my$i=$length - 1;$i >= 0;$i--){$self->_move_value($i,$i+$new_size)}$self->STORESIZE($length + $new_size)}for (my$i=0;$i < $new_size;$i++){$self->STORE($i,$new_elements[$i])}$self->unlock;return$length + $new_size}sub SPLICE {my$self=shift->_get_self;$self->lock_exclusive;my$length=$self->FETCHSIZE();my$offset=shift;$offset=0 unless defined$offset;if ($offset < 0){$offset += $length}my$splice_length;if (scalar @_){$splice_length=shift}else {$splice_length=$length - $offset}if ($splice_length < 0){$splice_length += ($length - $offset)}my@new_elements=@_;my$new_size=scalar@new_elements;my@old_elements=map {$self->FETCH($_)}$offset .. ($offset + $splice_length - 1);if ($new_size!=$splice_length){if ($new_size > $splice_length){for (my$i=$length - 1;$i >= $offset + $splice_length;$i--){$self->_move_value($i,$i + ($new_size - $splice_length))}$self->STORESIZE($length + $new_size - $splice_length)}else {for (my$i=$offset + $splice_length;$i < $length;$i++){$self->_move_value($i,$i + ($new_size - $splice_length))}for (my$i=0;$i < $splice_length - $new_size;$i++){$self->DELETE($length - 1);$length--}}}for (my$i=$offset;$i < $offset + $new_size;$i++){$self->STORE($i,shift@new_elements)}$self->unlock;return wantarray ? @old_elements : $old_elements[-1]}sub EXTEND {}sub _copy_node {my$self=shift;my ($db_temp)=@_;my$length=$self->length();for (my$index=0;$index < $length;$index++){$self->_copy_value(\$db_temp->[$index],$self->get($index))}return 1}sub _clear {my$self=shift;my$size=$self->FETCHSIZE;for my$key (0 .. $size - 1){$self->_engine->delete_key($self,$key,$key)}$self->STORESIZE(0);return}sub length {(shift)->FETCHSIZE(@_)}sub pop {(shift)->POP(@_)}sub push {(shift)->PUSH(@_)}sub unshift {(shift)->UNSHIFT(@_)}sub splice {(shift)->SPLICE(@_)}sub shift {(CORE::shift)->SHIFT(@_)}1;
DBM_DEEP_ARRAY

$fatpacked{"DBM/Deep/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_CONFIGDATA';
  package DBM::Deep::ConfigData;use strict;my$arrayref=eval do {local $/;<DATA>}or die "Couldn't load ConfigData data: $@";close DATA;my ($config,$features,$auto_features)=@$arrayref;sub config {$config->{$_[1]}}sub set_config {$config->{$_[1]}=$_[2]}sub set_feature {$features->{$_[1]}=0+!!$_[2]}sub auto_feature_names {sort grep!exists$features->{$_},keys %$auto_features}sub feature_names {my@features=(sort keys %$features,auto_feature_names());@features}sub config_names {sort keys %$config}sub write {my$me=__FILE__;require Data::Dumper;my$mode_orig=(stat$me)[2]& 07777;chmod($mode_orig | 0222,$me);open(my$fh,'+<',$me)or die "Can't rewrite $me: $!";seek($fh,0,0);while (<$fh>){last if /^__DATA__$/}die "Couldn't find __DATA__ token in $me" if eof($fh);seek($fh,tell($fh),0);my$data=[$config,$features,$auto_features];print($fh 'do{ my ' .Data::Dumper->new([$data],['x'])->Purity(1)->Dump().'$x; }');truncate($fh,tell($fh));close$fh;chmod($mode_orig,$me)or warn "Couldn't restore permissions on $me: $!"}sub feature {my ($package,$key)=@_;return$features->{$key}if exists$features->{$key};my$info=$auto_features->{$key}or return 0;require Module::Build;for my$type (sort keys %$info){my$prereqs=$info->{$type};next if$type eq 'description' || $type eq 'recommends';for my$modname (sort keys %$prereqs){my$status=Module::Build->check_installed_status($modname,$prereqs->{$modname});if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}__DATA__ do{ my $x = [
         {},
         {},
         {
           'mysql_engine' => {
                               'description' => 'DBI support via MySQL',
                               'requires' => {
                                               'DBD::mysql' => '4.001',
                                               'DBI' => '1.5'
                                             }
                             },
           'sqlite_engine' => {
                                'description' => 'DBI support via SQLite',
                                'requires' => {
                                                'DBD::SQLite' => '1.25',
                                                'DBI' => '1.5'
                                              }
                              }
         }
       ];
  $x; }
DBM_DEEP_CONFIGDATA

$fatpacked{"DBM/Deep/Engine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ENGINE';
  package DBM::Deep::Engine;use 5.008_004;use strict;use warnings FATAL=>'all';no warnings 'recursion';use DBM::Deep::Iterator ();sub SIG_HASH () {'H'}sub SIG_ARRAY () {'A'}sub read_value {die "read_value must be implemented in a child class"}sub get_classname {die "get_classname must be implemented in a child class"}sub make_reference {die "make_reference must be implemented in a child class"}sub key_exists {die "key_exists must be implemented in a child class"}sub delete_key {die "delete_key must be implemented in a child class"}sub write_value {die "write_value must be implemented in a child class"}sub setup {die "setup must be implemented in a child class"}sub begin_work {die "begin_work must be implemented in a child class"}sub rollback {die "rollback must be implemented in a child class"}sub commit {die "commit must be implemented in a child class"}sub get_next_key {my$self=shift;my ($obj,$prev_key)=@_;unless (defined$prev_key){eval "use " .$self->iterator_class;die $@ if $@;$obj->{iterator}=$self->iterator_class->new({base_offset=>$obj->_base_offset,engine=>$self,})}return$obj->{iterator}->get_next_key($obj)}sub lock_exclusive {my$self=shift;my ($obj)=@_;return$self->storage->lock_exclusive($obj)}sub lock_shared {my$self=shift;my ($obj)=@_;return$self->storage->lock_shared($obj)}sub unlock {my$self=shift;my ($obj)=@_;my$rv=$self->storage->unlock($obj);$self->flush if$rv;return$rv}sub flush {my$self=shift;$self->storage->flush;return}sub load_sector {$_[0]->sector_type->load(@_)}sub clear {die "clear must be implemented in a child class"}sub cache {$_[0]{cache}||= {}}sub clear_cache {%{$_[0]->cache}=()}sub supports {die "supports must be implemented in a child class"}sub storage {$_[0]{storage}}sub sector_type {die "sector_type must be implemented in a child class"}sub iterator_class {die "iterator_class must be implemented in a child class"}sub _descend {my$self=shift;my ($value,$value_sector)=@_;my$r=Scalar::Util::reftype($value)|| '';if ($r eq 'ARRAY'){my@temp=@$value;tie @$value,'DBM::Deep',{base_offset=>$value_sector->offset,staleness=>$value_sector->staleness,storage=>$self->storage,engine=>$self,};@$value=@temp;bless$value,'DBM::Deep::Array' unless Scalar::Util::blessed($value)}elsif ($r eq 'HASH'){my%temp=%$value;tie %$value,'DBM::Deep',{base_offset=>$value_sector->offset,staleness=>$value_sector->staleness,storage=>$self->storage,engine=>$self,};%$value=%temp;bless$value,'DBM::Deep::Hash' unless Scalar::Util::blessed($value)}return}1;
DBM_DEEP_ENGINE

$fatpacked{"DBM/Deep/Engine/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ENGINE_DBI';
  package DBM::Deep::Engine::DBI;use 5.008_004;use strict;use warnings FATAL=>'all';no warnings 'recursion';use base 'DBM::Deep::Engine';use DBM::Deep::Sector::DBI ();use DBM::Deep::Storage::DBI ();sub sector_type {'DBM::Deep::Sector::DBI'}sub iterator_class {'DBM::Deep::Iterator::DBI'}sub new {my$class=shift;my ($args)=@_;$args->{storage}=DBM::Deep::Storage::DBI->new($args)unless exists$args->{storage};my$self=bless {storage=>undef,external_refs=>undef,},$class;for my$param (keys %$self){next unless exists$args->{$param};$self->{$param}=$args->{$param}}return$self}sub setup {my$self=shift;my ($obj)=@_;$obj->{base_offset}||= 1;my ($rows)=$self->storage->read_from(refs=>$obj->_base_offset,qw(ref_type),);unless (@$rows){$self->storage->write_to(refs=>$obj->_base_offset,ref_type=>$obj->_type,)}my$sector=DBM::Deep::Sector::DBI::Reference->new({engine=>$self,offset=>$obj->_base_offset,})}sub read_value {my$self=shift;my ($obj,$key)=@_;my$sector=$self->load_sector($obj->_base_offset,'refs')or return;my$value_sector=$sector->get_data_for({key=>$key,allow_head=>1,});unless ($value_sector){return undef}return$value_sector->data}sub get_classname {my$self=shift;my ($obj)=@_;my$sector=$self->load_sector($obj->_base_offset,'refs')or return;return$sector->get_classname}sub make_reference {my$self=shift;my ($obj,$old_key,$new_key)=@_;my$sector=$self->load_sector($obj->_base_offset,'refs')or return;my$value_sector=$sector->get_data_for({key=>$old_key,allow_head=>1,});unless ($value_sector){$value_sector=DBM::Deep::Sector::DBI::Scalar->new({engine=>$self,data=>undef,});$sector->write_data({key=>$old_key,value=>$value_sector,})}if ($value_sector->isa('DBM::Deep::Sector::DBI::Reference')){$sector->write_data({key=>$new_key,value=>$value_sector,});$value_sector->increment_refcount}else {$sector->write_data({key=>$new_key,value=>$value_sector->clone,})}return}sub key_exists {my$self=shift;my ($obj,$key)=@_;my$sector=$self->load_sector($obj->_base_offset,'refs')or return '';my$data=$sector->get_data_for({key=>$key,allow_head=>1,});return$data ? 1 : ''}sub delete_key {my$self=shift;my ($obj,$key)=@_;my$sector=$self->load_sector($obj->_base_offset,'refs')or return '';return$sector->delete_key({key=>$key,allow_head=>0,})}sub write_value {my$self=shift;my ($obj,$key,$value)=@_;my$r=Scalar::Util::reftype($value)|| '';{last if$r eq '';last if$r eq 'HASH';last if$r eq 'ARRAY';DBM::Deep->_throw_error("Storage of references of type '$r' is not supported.")}my$sector=$self->load_sector($obj->_base_offset,'refs')or die "Cannot load sector at '@{[$obj->_base_offset]}'\n";;my ($type,$class);if ($r eq 'ARRAY' || $r eq 'HASH' and ref$value ne 'DBM::Deep::Null'){my$tmpvar;if ($r eq 'ARRAY'){$tmpvar=tied @$value}elsif ($r eq 'HASH'){$tmpvar=tied %$value}if ($tmpvar){my$is_dbm_deep=eval {local$SIG{'__DIE__'};$tmpvar->isa('DBM::Deep')};unless ($is_dbm_deep){DBM::Deep->_throw_error("Cannot store something that is tied.")}unless ($tmpvar->_engine->storage==$self->storage){DBM::Deep->_throw_error("Cannot store values across DBM::Deep files. Please use export() instead.")}my$value_sector=$self->load_sector($tmpvar->_base_offset,'refs');$sector->write_data({key=>$key,value=>$value_sector,});$value_sector->increment_refcount;return 1}$type=substr($r,0,1);$class='DBM::Deep::Sector::DBI::Reference'}else {if (tied($value)){DBM::Deep->_throw_error("Cannot store something that is tied.")}if (ref$value eq 'DBM::Deep::Null'){DBM::Deep::_warnif('uninitialized','Assignment of stale reference');$value=undef}$class='DBM::Deep::Sector::DBI::Scalar';$type='S'}my$value_sector=$class->new({engine=>$self,data=>$value,type=>$type,});$sector->write_data({key=>$key,value=>$value_sector,});$self->_descend($value,$value_sector);return 1}sub supports {my$self=shift;my ($feature)=@_;return if$feature eq 'transactions';return 1 if$feature eq 'singletons';return}sub db_version {return '1.0020'}sub clear {my$self=shift;my$obj=shift;my$sector=$self->load_sector($obj->_base_offset,'refs')or return;$sector->clear;return}1;
DBM_DEEP_ENGINE_DBI

$fatpacked{"DBM/Deep/Engine/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ENGINE_FILE';
  package DBM::Deep::Engine::File;use 5.008_004;use strict;use warnings FATAL=>'all';no warnings 'recursion';use base qw(DBM::Deep::Engine);use Scalar::Util ();use DBM::Deep::Null ();use DBM::Deep::Sector::File ();use DBM::Deep::Storage::File ();sub sector_type {'DBM::Deep::Sector::File'}sub iterator_class {'DBM::Deep::Iterator::File'}my$STALE_SIZE=2;sub SIG_FILE () {'DPDB'}sub SIG_HEADER () {'h'}sub SIG_NULL () {'N'}sub SIG_DATA () {'D'}sub SIG_UNIDATA () {'U'}sub SIG_INDEX () {'I'}sub SIG_BLIST () {'B'}sub SIG_FREE () {'F'}sub SIG_SIZE () {1}my%StP=(1=>'C',2=>'n',4=>'N',8=>'Q',);sub new {my$class=shift;my ($args)=@_;$args->{storage}=DBM::Deep::Storage::File->new($args)unless exists$args->{storage};my$self=bless {byte_size=>4,digest=>undef,hash_size=>16,hash_chars=>256,max_buckets=>16,num_txns=>1,trans_id=>0,data_sector_size=>64,entries=>{},storage=>undef,external_refs=>undef,},$class;delete$args->{byte_size};if (defined$args->{pack_size}){if (lc$args->{pack_size}eq 'small'){$args->{byte_size}=2}elsif (lc$args->{pack_size}eq 'medium'){$args->{byte_size}=4}elsif (lc$args->{pack_size}eq 'large'){$args->{byte_size}=8}else {DBM::Deep->_throw_error("Unknown pack_size value: '$args->{pack_size}'")}}for my$param (keys %$self){next unless exists$args->{$param};$self->{$param}=$args->{$param}}my%validations=(max_buckets=>{floor=>16,ceil=>256 },num_txns=>{floor=>1,ceil=>255 },data_sector_size=>{floor=>32,ceil=>256 },);while (my ($attr,$c)=each%validations){if (!defined$self->{$attr}||!length$self->{$attr}|| $self->{$attr}=~ /\D/ || $self->{$attr}< $c->{floor}){$self->{$attr}='(undef)' if!defined$self->{$attr};warn "Floor of $attr is $c->{floor}. Setting it to $c->{floor} from '$self->{$attr}'\n";$self->{$attr}=$c->{floor}}elsif ($self->{$attr}> $c->{ceil}){warn "Ceiling of $attr is $c->{ceil}. Setting it to $c->{ceil} from '$self->{$attr}'\n";$self->{$attr}=$c->{ceil}}}if (!$self->{digest}){require Digest::MD5;$self->{digest}=\&Digest::MD5::md5}return$self}sub read_value {my$self=shift;my ($obj,$key)=@_;my$sector=$self->load_sector($obj->_base_offset)or return;if ($sector->staleness!=$obj->_staleness){return}my$key_md5=$self->_apply_digest($key);my$value_sector=$sector->get_data_for({key_md5=>$key_md5,allow_head=>1,});unless ($value_sector){return undef}return$value_sector->data}sub get_classname {my$self=shift;my ($obj)=@_;my$sector=$self->load_sector($obj->_base_offset)or DBM::Deep->_throw_error("How did get_classname fail (no sector for '$obj')?!");if ($sector->staleness!=$obj->_staleness){return}return$sector->get_classname}sub make_reference {my$self=shift;my ($obj,$old_key,$new_key)=@_;my$sector=$self->load_sector($obj->_base_offset)or DBM::Deep->_throw_error("How did make_reference fail (no sector for '$obj')?!");if ($sector->staleness!=$obj->_staleness){return}my$old_md5=$self->_apply_digest($old_key);my$value_sector=$sector->get_data_for({key_md5=>$old_md5,allow_head=>1,});unless ($value_sector){$value_sector=DBM::Deep::Sector::File::Null->new({engine=>$self,data=>undef,});$sector->write_data({key_md5=>$old_md5,key=>$old_key,value=>$value_sector,})}if ($value_sector->isa('DBM::Deep::Sector::File::Reference')){$sector->write_data({key=>$new_key,key_md5=>$self->_apply_digest($new_key),value=>$value_sector,});$value_sector->increment_refcount}else {$sector->write_data({key=>$new_key,key_md5=>$self->_apply_digest($new_key),value=>$value_sector->clone,})}return}sub key_exists {my$self=shift;my ($obj,$key)=@_;my$sector=$self->load_sector($obj->_base_offset)or return '';if ($sector->staleness!=$obj->_staleness){return ''}my$data=$sector->get_data_for({key_md5=>$self->_apply_digest($key),allow_head=>1,});return$data ? 1 : ''}sub delete_key {my$self=shift;my ($obj,$key)=@_;my$sector=$self->load_sector($obj->_base_offset)or return;if ($sector->staleness!=$obj->_staleness){return}return$sector->delete_key({key_md5=>$self->_apply_digest($key),allow_head=>0,})}sub write_value {my$self=shift;my ($obj,$key,$value)=@_;my$r=Scalar::Util::reftype($value)|| '';{last if$r eq '';last if$r eq 'HASH';last if$r eq 'ARRAY';DBM::Deep->_throw_error("Storage of references of type '$r' is not supported.")}my$sector=$self->load_sector($obj->_base_offset)or DBM::Deep->_throw_error("Cannot write to a deleted spot in DBM::Deep.");if ($sector->staleness!=$obj->_staleness){DBM::Deep->_throw_error("Cannot write to a deleted spot in DBM::Deep.")}my ($class,$type);if (!defined$value){$class='DBM::Deep::Sector::File::Null'}elsif (ref$value eq 'DBM::Deep::Null'){DBM::Deep::_warnif('uninitialized','Assignment of stale reference');$class='DBM::Deep::Sector::File::Null';$value=undef}elsif ($r eq 'ARRAY' || $r eq 'HASH'){my$tmpvar;if ($r eq 'ARRAY'){$tmpvar=tied @$value}elsif ($r eq 'HASH'){$tmpvar=tied %$value}if ($tmpvar){my$is_dbm_deep=eval {local$SIG{'__DIE__'};$tmpvar->isa('DBM::Deep')};unless ($is_dbm_deep){DBM::Deep->_throw_error("Cannot store something that is tied.")}unless ($tmpvar->_engine->storage==$self->storage){DBM::Deep->_throw_error("Cannot store values across DBM::Deep files. Please use export() instead.")}my$loc=$sector->get_data_location_for({key_md5=>$self->_apply_digest($key),allow_head=>1,});if (defined($loc)&& $loc==$tmpvar->_base_offset){return 1}my$value_sector=$self->load_sector($tmpvar->_base_offset);$sector->write_data({key=>$key,key_md5=>$self->_apply_digest($key),value=>$value_sector,});$value_sector->increment_refcount;return 1}$class='DBM::Deep::Sector::File::Reference';$type=substr($r,0,1)}else {if (tied($value)){DBM::Deep->_throw_error("Cannot store something that is tied.")}$class='DBM::Deep::Sector::File::Scalar'}my$value_sector=$class->new({engine=>$self,data=>$value,type=>$type,});$sector->write_data({key=>$key,key_md5=>$self->_apply_digest($key),value=>$value_sector,});$self->_descend($value,$value_sector);return 1}sub setup {my$self=shift;my ($obj)=@_;unless ($obj->_base_offset){my$bytes_read=$self->_read_file_header;unless ($bytes_read){$self->_write_file_header;my$initial_reference=DBM::Deep::Sector::File::Reference->new({engine=>$self,type=>$obj->_type,});$obj->{base_offset}=$initial_reference->offset;$obj->{staleness}=$initial_reference->staleness;$self->storage->flush}else {$obj->{base_offset}=$bytes_read;my$initial_reference=DBM::Deep::Sector::File::Reference->new({engine=>$self,offset=>$obj->_base_offset,});unless ($initial_reference){DBM::Deep->_throw_error("Corrupted file, no master index record")}unless ($obj->_type eq $initial_reference->type){DBM::Deep->_throw_error("File type mismatch")}$obj->{staleness}=$initial_reference->staleness}}$self->storage->set_inode;return 1}sub begin_work {my$self=shift;my ($obj)=@_;unless ($self->supports('transactions')){DBM::Deep->_throw_error("Cannot begin_work unless transactions are supported")}if ($self->trans_id){DBM::Deep->_throw_error("Cannot begin_work within an active transaction")}my@slots=$self->read_txn_slots;my$found;for my$i (0 .. $self->num_txns-2){next if$slots[$i];$slots[$i]=1;$self->set_trans_id($i + 1);$found=1;last}unless ($found){DBM::Deep->_throw_error("Cannot allocate transaction ID")}$self->write_txn_slots(@slots);if (!$self->trans_id){DBM::Deep->_throw_error("Cannot begin_work - no available transactions")}return}sub rollback {my$self=shift;my ($obj)=@_;unless ($self->supports('transactions')){DBM::Deep->_throw_error("Cannot rollback unless transactions are supported")}if (!$self->trans_id){DBM::Deep->_throw_error("Cannot rollback without an active transaction")}for my$entry (@{$self->get_entries}){my$read_loc=$entry + $self->hash_size + $self->byte_size + $self->byte_size + ($self->trans_id - 1)* ($self->byte_size + $STALE_SIZE);my$data_loc=$self->storage->read_at($read_loc,$self->byte_size);$data_loc=unpack($StP{$self->byte_size},$data_loc);$self->storage->print_at($read_loc,pack($StP{$self->byte_size},0));if ($data_loc > 1){$self->load_sector($data_loc)->free}}$self->clear_entries;my@slots=$self->read_txn_slots;$slots[$self->trans_id-1]=0;$self->write_txn_slots(@slots);$self->inc_txn_staleness_counter($self->trans_id);$self->set_trans_id(0);return 1}sub commit {my$self=shift;my ($obj)=@_;unless ($self->supports('transactions')){DBM::Deep->_throw_error("Cannot commit unless transactions are supported")}if (!$self->trans_id){DBM::Deep->_throw_error("Cannot commit without an active transaction")}for my$entry (@{$self->get_entries}){my$base=$entry + $self->hash_size + $self->byte_size;my$head_loc=$self->storage->read_at($base,$self->byte_size);$head_loc=unpack($StP{$self->byte_size},$head_loc);my$spot=$base + $self->byte_size + ($self->trans_id - 1)* ($self->byte_size + $STALE_SIZE);my$trans_loc=$self->storage->read_at($spot,$self->byte_size,);$self->storage->print_at($base,$trans_loc);$self->storage->print_at($spot,pack($StP{$self->byte_size}.' ' .$StP{$STALE_SIZE},(0)x 2),);if ($head_loc > 1){$self->load_sector($head_loc)->free}}$self->clear_entries;my@slots=$self->read_txn_slots;$slots[$self->trans_id-1]=0;$self->write_txn_slots(@slots);$self->inc_txn_staleness_counter($self->trans_id);$self->set_trans_id(0);return 1}sub read_txn_slots {my$self=shift;my$bl=$self->txn_bitfield_len;my$num_bits=$bl * 8;return split '',unpack('b'.$num_bits,$self->storage->read_at($self->trans_loc,$bl,))}sub write_txn_slots {my$self=shift;my$num_bits=$self->txn_bitfield_len * 8;$self->storage->print_at($self->trans_loc,pack('b'.$num_bits,join('',@_)),)}sub get_running_txn_ids {my$self=shift;my@transactions=$self->read_txn_slots;my@trans_ids=map {$_+1}grep {$transactions[$_]}0 .. $#transactions}sub get_txn_staleness_counter {my$self=shift;my ($trans_id)=@_;return 0 unless$trans_id;return unpack($StP{$STALE_SIZE},$self->storage->read_at($self->trans_loc + $self->txn_bitfield_len + $STALE_SIZE * ($trans_id - 1),$STALE_SIZE,))}sub inc_txn_staleness_counter {my$self=shift;my ($trans_id)=@_;return 0 unless$trans_id;$self->storage->print_at($self->trans_loc + $self->txn_bitfield_len + $STALE_SIZE * ($trans_id - 1),pack($StP{$STALE_SIZE},$self->get_txn_staleness_counter($trans_id)+ 1),)}sub get_entries {my$self=shift;return [keys %{$self->{entries}{$self->trans_id}||= {}}]}sub add_entry {my$self=shift;my ($trans_id,$loc)=@_;$self->{entries}{$trans_id}||= {};$self->{entries}{$trans_id}{$loc}=undef}sub reindex_entry {my$self=shift;my ($old_loc,$new_loc)=@_;TRANS: while (my ($trans_id,$locs)=each %{$self->{entries}}){if (exists$locs->{$old_loc}){delete$locs->{$old_loc};$locs->{$new_loc}=undef;next TRANS}}}sub clear_entries {my$self=shift;delete$self->{entries}{$self->trans_id}}{my$header_fixed=length(__PACKAGE__->SIG_FILE)+ 1 + 4 + 4;my$this_file_version=4;my$min_file_version=3;sub _write_file_header {my$self=shift;my$nt=$self->num_txns;my$bl=$self->txn_bitfield_len;my$header_var=1 + 1 + 1 + 1 + $bl + $STALE_SIZE * ($nt - 1)+ 3 * $self->byte_size;my$loc=$self->storage->request_space($header_fixed + $header_var);$self->storage->print_at($loc,$self->SIG_FILE,$self->SIG_HEADER,pack('N',$this_file_version),pack('N',$header_var),pack('C',$self->byte_size),pack('C',$self->max_buckets - 1),pack('C',$self->data_sector_size - 1),pack('C',$nt),pack('C' .$bl,0),pack($StP{$STALE_SIZE}.($nt-1),0 x ($nt-1)),pack($StP{$self->byte_size},0),pack($StP{$self->byte_size},0),pack($StP{$self->byte_size},0),);$self->set_trans_loc($header_fixed + 4);$self->set_chains_loc($header_fixed + 4 + $bl + $STALE_SIZE * ($nt-1));$self->{v}=$this_file_version;return}sub _read_file_header {my$self=shift;my$buffer=$self->storage->read_at(0,$header_fixed);return unless length($buffer);my ($file_signature,$sig_header,$file_version,$size)=unpack('A4 A N N',$buffer);unless ($file_signature eq $self->SIG_FILE){$self->storage->close;DBM::Deep->_throw_error("Signature not found -- file is not a Deep DB")}unless ($sig_header eq $self->SIG_HEADER){$self->storage->close;DBM::Deep->_throw_error("Pre-1.00 file version found")}if ($file_version < $min_file_version){$self->storage->close;DBM::Deep->_throw_error("This file version is too old - " ._guess_version($file_version)." - expected " ._guess_version($min_file_version)." to " ._guess_version($this_file_version))}if ($file_version > $this_file_version){$self->storage->close;DBM::Deep->_throw_error("This file version is too new - probably " ._guess_version($file_version)." - expected " ._guess_version($min_file_version)." to " ._guess_version($this_file_version))}$self->{v}=$file_version;my$buffer2=$self->storage->read_at(undef,$size);my@values=unpack('C C C C',$buffer2);if (@values!=4 || grep {!defined}@values){$self->storage->close;DBM::Deep->_throw_error("Corrupted file - bad header")}if ($values[3]!=$self->{num_txns}){warn "num_txns ($self->{num_txns}) is different from the file ($values[3])\n"}@{$self}{qw(byte_size max_buckets data_sector_size num_txns)}=@values;$self->{max_buckets}+= 1;$self->{data_sector_size}+= 1;my$bl=$self->txn_bitfield_len;my$header_var=scalar(@values)+ $bl + $STALE_SIZE * ($self->num_txns - 1)+ 3 * $self->byte_size;unless ($size==$header_var){$self->storage->close;DBM::Deep->_throw_error("Unexpected size found ($size <-> $header_var).")}$self->set_trans_loc($header_fixed + scalar(@values));$self->set_chains_loc($header_fixed + scalar(@values)+ $bl + $STALE_SIZE * ($self->num_txns - 1));return length($buffer)+ length($buffer2)}sub _guess_version {$_[0]==4 and return 2;$_[0]==3 and return '1.0003';$_[0]==2 and return '1.00';$_[0]==1 and return '0.99';$_[0]==0 and return '0.91';return $_[0]-2}}sub _apply_digest {my$self=shift;my$victim=shift;utf8::encode$victim if$self->{v}>= 4;return$self->{digest}->($victim)}sub _add_free_blist_sector {shift->_add_free_sector(0,@_)}sub _add_free_data_sector {shift->_add_free_sector(1,@_)}sub _add_free_index_sector {shift->_add_free_sector(2,@_)}sub _add_free_sector {my$self=shift;my ($multiple,$offset,$size)=@_;my$chains_offset=$multiple * $self->byte_size;my$storage=$self->storage;my$staleness=unpack($StP{$STALE_SIZE},$storage->read_at($offset + $self->SIG_SIZE,$STALE_SIZE));$staleness=($staleness + 1)% (2 ** (8 * $STALE_SIZE));$storage->print_at($offset + $self->SIG_SIZE,pack($StP{$STALE_SIZE},$staleness));my$old_head=$storage->read_at($self->chains_loc + $chains_offset,$self->byte_size);$storage->print_at($self->chains_loc + $chains_offset,pack($StP{$self->byte_size},$offset),);$storage->print_at($offset + $self->SIG_SIZE + $STALE_SIZE,$old_head)}sub _request_blist_sector {shift->_request_sector(0,@_)}sub _request_data_sector {shift->_request_sector(1,@_)}sub _request_index_sector {shift->_request_sector(2,@_)}sub _request_sector {my$self=shift;my ($multiple,$size)=@_;my$chains_offset=$multiple * $self->byte_size;my$old_head=$self->storage->read_at($self->chains_loc + $chains_offset,$self->byte_size);my$loc=unpack($StP{$self->byte_size},$old_head);unless ($loc){my$offset=$self->storage->request_space($size);$self->storage->print_at($offset,chr(0)x $size);return$offset}my$new_head=$self->storage->read_at($loc + $self->SIG_SIZE + $STALE_SIZE,$self->byte_size);$self->storage->print_at($self->chains_loc + $chains_offset,$new_head);$self->storage->print_at($loc + $self->SIG_SIZE + $STALE_SIZE,pack($StP{$self->byte_size},0),);return$loc}sub byte_size {$_[0]{byte_size}}sub hash_size {$_[0]{hash_size}}sub hash_chars {$_[0]{hash_chars}}sub num_txns {$_[0]{num_txns}}sub max_buckets {$_[0]{max_buckets}}sub blank_md5 {chr(0)x $_[0]->hash_size}sub data_sector_size {$_[0]{data_sector_size}}sub txn_bitfield_len {my$self=shift;unless (exists$self->{txn_bitfield_len}){my$temp=($self->num_txns)/ 8;if ($temp > int($temp)){$temp=int($temp)+ 1}$self->{txn_bitfield_len}=$temp}return$self->{txn_bitfield_len}}sub trans_id {$_[0]{trans_id}}sub set_trans_id {$_[0]{trans_id}=$_[1]}sub trans_loc {$_[0]{trans_loc}}sub set_trans_loc {$_[0]{trans_loc}=$_[1]}sub chains_loc {$_[0]{chains_loc}}sub set_chains_loc {$_[0]{chains_loc}=$_[1]}sub supports {my$self=shift;my ($feature)=@_;if ($feature eq 'transactions'){return$self->num_txns > 1}return 1 if$feature eq 'singletons';return 1 if$feature eq 'unicode';return}sub db_version {return $_[0]{v}==3 ? '1.0003' : 2}sub clear {my$self=shift;my$obj=shift;my$sector=$self->load_sector($obj->_base_offset)or return;return unless$sector->staleness==$obj->_staleness;$sector->clear;return}sub _dump_file {my$self=shift;my$spot=$self->_read_file_header();my%types=(0=>'B',1=>'D',2=>'I',);my%sizes=('D'=>$self->data_sector_size,'B'=>DBM::Deep::Sector::File::BucketList->new({engine=>$self,offset=>1})->size,'I'=>DBM::Deep::Sector::File::Index->new({engine=>$self,offset=>1})->size,);my$return="";$return .= "NumTxns: " .$self->num_txns .$/;my%sectors;for my$multiple (0 .. 2){$return .= "Chains($types{$multiple}):";my$old_loc=$self->chains_loc + $multiple * $self->byte_size;while (1){my$loc=unpack($StP{$self->byte_size},$self->storage->read_at($old_loc,$self->byte_size),);unless ($loc){last}$sectors{$types{$multiple}}{$loc }=undef;$old_loc=$loc + $self->SIG_SIZE + $STALE_SIZE;$return .= " $loc"}$return .= $/}SECTOR: while ($spot < $self->storage->{end}){my$sector=$self->load_sector($spot);if (!$sector){for my$type (keys%sectors){if (exists$sectors{$type}{$spot}){my$size=$sizes{$type};$return .= sprintf "%08d: %s %04d\n",$spot,'F' .$type,$size;$spot += $size;next SECTOR}}die "********\n$return\nDidn't find free sector for $spot in chains\n********\n"}else {$return .= sprintf "%08d: %s  %04d",$spot,$sector->type,$sector->size;if ($sector->type =~ /^[DU]\z/){$return .= ' ' .$sector->data}elsif ($sector->type eq 'A' || $sector->type eq 'H'){$return .= ' REF: ' .$sector->get_refcount}elsif ($sector->type eq 'B'){for my$bucket ($sector->chopped_up){$return .= "\n    ";$return .= sprintf "%08d",unpack($StP{$self->byte_size},substr($bucket->[-1],$self->hash_size,$self->byte_size),);my$l=unpack($StP{$self->byte_size},substr($bucket->[-1],$self->hash_size + $self->byte_size,$self->byte_size,),);$return .= sprintf " %08d",$l;for my$txn (0 .. $self->num_txns - 2){my$l=unpack($StP{$self->byte_size},substr($bucket->[-1],$self->hash_size + 2 * $self->byte_size + $txn * ($self->byte_size + $STALE_SIZE),$self->byte_size,),);$return .= sprintf " %08d",$l}}}$return .= $/;$spot += $sector->size}}return$return}1;
DBM_DEEP_ENGINE_FILE

$fatpacked{"DBM/Deep/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_HASH';
  package DBM::Deep::Hash;use 5.008_004;use strict;use warnings FATAL=>'all';no warnings 'recursion';use base 'DBM::Deep';sub _get_self {tied %{$_[0]}or local *@,eval {exists $_[0]{_};1}? $_[0]: undef}sub _repr {return {}}sub TIEHASH {my$class=shift;my$args=$class->_get_args(@_);$args->{type}=$class->TYPE_HASH;return$class->_init($args)}sub FETCH {my$self=shift->_get_self;DBM::Deep->_throw_error("Cannot use an undefined hash key.")unless defined $_[0];my$key=($self->_engine->storage->{filter_store_key})? $self->_engine->storage->{filter_store_key}->($_[0]): $_[0];return$self->SUPER::FETCH($key,$_[0])}sub STORE {my$self=shift->_get_self;DBM::Deep->_throw_error("Cannot use an undefined hash key.")unless defined $_[0];my$key=($self->_engine->storage->{filter_store_key})? $self->_engine->storage->{filter_store_key}->($_[0]): $_[0];my$value=$_[1];return$self->SUPER::STORE($key,$value,$_[0])}sub EXISTS {my$self=shift->_get_self;DBM::Deep->_throw_error("Cannot use an undefined hash key.")unless defined $_[0];my$key=($self->_engine->storage->{filter_store_key})? $self->_engine->storage->{filter_store_key}->($_[0]): $_[0];return$self->SUPER::EXISTS($key)}sub DELETE {my$self=shift->_get_self;DBM::Deep->_throw_error("Cannot use an undefined hash key.")unless defined $_[0];my$key=($self->_engine->storage->{filter_store_key})? $self->_engine->storage->{filter_store_key}->($_[0]): $_[0];return$self->SUPER::DELETE($key,$_[0])}sub FIRSTKEY {my$self=shift->_get_self;$self->lock_shared;my$result=$self->_engine->get_next_key($self);$self->unlock;return ($result && $self->_engine->storage->{filter_fetch_key})? $self->_engine->storage->{filter_fetch_key}->($result): $result}sub NEXTKEY {my$self=shift->_get_self;my$prev_key=($self->_engine->storage->{filter_store_key})? $self->_engine->storage->{filter_store_key}->($_[0]): $_[0];$self->lock_shared;my$result=$self->_engine->get_next_key($self,$prev_key);$self->unlock;return ($result && $self->_engine->storage->{filter_fetch_key})? $self->_engine->storage->{filter_fetch_key}->($result): $result}sub first_key {(shift)->FIRSTKEY(@_)}sub next_key {(shift)->NEXTKEY(@_)}sub _clear {my$self=shift;while (defined(my$key=$self->first_key)){do {$self->_engine->delete_key($self,$key,$key)}while defined($key=$self->next_key($key))}return}sub _copy_node {my$self=shift;my ($db_temp)=@_;my$key=$self->first_key();while (defined$key){my$value=$self->get($key);$self->_copy_value(\$db_temp->{$key},$value);$key=$self->next_key($key)}return 1}1;
DBM_DEEP_HASH

$fatpacked{"DBM/Deep/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ITERATOR';
  package DBM::Deep::Iterator;use 5.008_004;use strict;use warnings FATAL=>'all';sub new {my$class=shift;my ($args)=@_;my$self=bless {engine=>$args->{engine},base_offset=>$args->{base_offset},},$class;Scalar::Util::weaken($self->{engine});$self->reset;return$self}sub reset {die "reset must be implemented in a child class"}sub get_next_key {die "get_next_key must be implemented in a child class"}1;
DBM_DEEP_ITERATOR

$fatpacked{"DBM/Deep/Iterator/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ITERATOR_DBI';
  package DBM::Deep::Iterator::DBI;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Iterator);sub reset {my$self=shift;eval {$self->{sth}->finish};delete$self->{sth};return}sub get_next_key {my$self=shift;my ($obj)=@_;unless (exists$self->{sth}){my$storage=$self->{engine}->storage;$self->{sth}=$storage->{dbh}->prepare("SELECT `key` FROM datas WHERE ref_id = ? ORDER BY " .$storage->rand_function,);$self->{sth}->execute($self->{base_offset})}my ($key)=$self->{sth}->fetchrow_array;return$key}1;
DBM_DEEP_ITERATOR_DBI

$fatpacked{"DBM/Deep/Iterator/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ITERATOR_FILE';
  package DBM::Deep::Iterator::File;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Iterator);use DBM::Deep::Iterator::File::BucketList ();use DBM::Deep::Iterator::File::Index ();sub reset {$_[0]{breadcrumbs}=[];return}sub get_sector_iterator {my$self=shift;my ($loc)=@_;my$sector=$self->{engine}->load_sector($loc)or return;if ($sector->isa('DBM::Deep::Sector::File::Index')){return DBM::Deep::Iterator::File::Index->new({iterator=>$self,sector=>$sector,})}elsif ($sector->isa('DBM::Deep::Sector::File::BucketList')){return DBM::Deep::Iterator::File::BucketList->new({iterator=>$self,sector=>$sector,})}DBM::Deep->_throw_error("get_sector_iterator(): Why did $loc make a $sector?")}sub get_next_key {my$self=shift;my ($obj)=@_;my$crumbs=$self->{breadcrumbs};my$e=$self->{engine};unless (@$crumbs){my$sector=$e->load_sector($self->{base_offset})or return;if ($sector->staleness!=$obj->_staleness){return}my$loc=$sector->get_blist_loc or return;push @$crumbs,$self->get_sector_iterator($loc)}FIND_NEXT_KEY: {unless (@$crumbs){$self->reset;return}my$iterator=$crumbs->[-1];if ($iterator->at_end){pop @$crumbs;redo FIND_NEXT_KEY}if ($iterator->isa('DBM::Deep::Iterator::File::Index')){if (my$next=$iterator->get_next_iterator){push @$crumbs,$next}redo FIND_NEXT_KEY}unless ($iterator->isa('DBM::Deep::Iterator::File::BucketList')){DBM::Deep->_throw_error("Should have a bucketlist iterator here - instead have $iterator")}my$key=$iterator->get_next_key;if (defined$key){return$key}redo FIND_NEXT_KEY}DBM::Deep->_throw_error("get_next_key(): How did we get here?")}1;
DBM_DEEP_ITERATOR_FILE

$fatpacked{"DBM/Deep/Iterator/File/BucketList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ITERATOR_FILE_BUCKETLIST';
  package DBM::Deep::Iterator::File::BucketList;use 5.008_004;use strict;use warnings FATAL=>'all';sub new {my$self=bless $_[1]=>$_[0];$self->{curr_index}=0;return$self}sub at_end {my$self=shift;return$self->{curr_index}>= $self->{iterator}{engine}->max_buckets}sub get_next_key {my$self=shift;return if$self->at_end;my$idx=$self->{curr_index}++;my$data_loc=$self->{sector}->get_data_location_for({allow_head=>1,idx=>$idx,})or return;return$self->{sector}->get_key_for($idx)->data}1;
DBM_DEEP_ITERATOR_FILE_BUCKETLIST

$fatpacked{"DBM/Deep/Iterator/File/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_ITERATOR_FILE_INDEX';
  package DBM::Deep::Iterator::File::Index;use 5.008_004;use strict;use warnings FATAL=>'all';sub new {my$self=bless $_[1]=>$_[0];$self->{curr_index}=0;return$self}sub at_end {my$self=shift;return$self->{curr_index}>= $self->{iterator}{engine}->hash_chars}sub get_next_iterator {my$self=shift;my$loc;while (!$loc){return if$self->at_end;$loc=$self->{sector}->get_entry($self->{curr_index}++)}return$self->{iterator}->get_sector_iterator($loc)}1;
DBM_DEEP_ITERATOR_FILE_INDEX

$fatpacked{"DBM/Deep/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_NULL';
  package DBM::Deep::Null;use 5.008_004;use strict;use warnings FATAL=>'all';use overload 'bool'=>sub {undef},'""'=>sub {undef},'0+'=>sub {0},('cmp'=>'<=>'=>sub {return 0 if!defined $_[1]||!length $_[1];return $_[2]? 1 : -1})[0,2,1,2],'%{}'=>sub {require Carp;Carp::croak("Can't use a stale reference as a HASH")},'@{}'=>sub {require Carp;Carp::croak("Can't use a stale reference as an ARRAY")},fallback=>1,nomethod=>'AUTOLOAD';sub AUTOLOAD {return}1;
DBM_DEEP_NULL

$fatpacked{"DBM/Deep/Sector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR';
  package DBM::Deep::Sector;use 5.008_004;use strict;use warnings FATAL=>'all';use Scalar::Util ();sub new {my$self=bless $_[1],$_[0];Scalar::Util::weaken($self->{engine});$self->_init;return$self}sub _init {}sub clone {my$self=shift;return ref($self)->new({engine=>$self->engine,type=>$self->type,data=>$self->data,})}sub engine {$_[0]{engine}}sub offset {$_[0]{offset}}sub type {$_[0]{type}}sub staleness {$_[0]{staleness}}sub load {die "load must be implemented in a child class"}1;
DBM_DEEP_SECTOR

$fatpacked{"DBM/Deep/Sector/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_DBI';
  package DBM::Deep::Sector::DBI;use 5.008_004;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Sector);use DBM::Deep::Sector::DBI::Reference ();use DBM::Deep::Sector::DBI::Scalar ();sub free {my$self=shift;$self->engine->storage->delete_from($self->table,$self->offset,)}sub reload {my$self=shift;$self->_init}sub load {my$self=shift;my ($engine,$offset,$type)=@_;if (!defined$type || $type eq 'refs'){return DBM::Deep::Sector::DBI::Reference->new({engine=>$engine,offset=>$offset,})}elsif ($type eq 'datas'){my$sector=DBM::Deep::Sector::DBI::Scalar->new({engine=>$engine,offset=>$offset,});if ($sector->{data_type}eq 'R'){return$self->load($engine,$sector->{value},'refs',)}return$sector}DBM::Deep->_throw_error("'$offset': Don't know what to do with type '$type'")}1;
DBM_DEEP_SECTOR_DBI

$fatpacked{"DBM/Deep/Sector/DBI/Reference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_DBI_REFERENCE';
  package DBM::Deep::Sector::DBI::Reference;use 5.008_004;use strict;use warnings FATAL=>'all';use base 'DBM::Deep::Sector::DBI';use Scalar::Util;sub table {'refs'}sub _init {my$self=shift;my$e=$self->engine;unless ($self->offset){my$classname=Scalar::Util::blessed(delete$self->{data});$self->{offset}=$self->engine->storage->write_to(refs=>undef,ref_type=>$self->type,classname=>$classname,)}else {my ($rows)=$self->engine->storage->read_from(refs=>$self->offset,qw(ref_type),);$self->{type}=$rows->[0]{ref_type}}return}sub get_data_for {my$self=shift;my ($args)=@_;my ($rows)=$self->engine->storage->read_from(datas=>{ref_id=>$self->offset,key=>$args->{key}},qw(id),);return unless$rows->[0]{id};$self->load($self->engine,$rows->[0]{id},'datas',)}sub write_data {my$self=shift;my ($args)=@_;if (($args->{value}->type || 'S')eq 'S'){$args->{value}{offset}=$self->engine->storage->write_to(datas=>$args->{value}{offset},ref_id=>$self->offset,data_type=>'S',key=>$args->{key},value=>$args->{value}{data},);$args->{value}->reload}else {$self->engine->storage->write_to(datas=>undef,ref_id=>$self->offset,data_type=>'R',key=>$args->{key},value=>$args->{value}{offset},)}}sub delete_key {my$self=shift;my ($args)=@_;my$old_value=$self->get_data_for({key=>$args->{key},});my$data;if ($old_value){$data=$old_value->data({export=>1 });$self->engine->storage->delete_from('datas',{ref_id=>$self->offset,key=>$args->{key},},);$old_value->free}return$data}sub get_classname {my$self=shift;my ($rows)=$self->engine->storage->read_from('refs',$self->offset,qw(classname),);return unless @$rows;return$rows->[0]{classname}}sub data {my$self=shift;my ($args)=@_;$args ||= {};my$engine=$self->engine;my$cache=$engine->cache;my$off=$self->offset;my$obj;if (!defined$cache->{$off }){$obj=DBM::Deep->new({type=>$self->type,base_offset=>$self->offset,storage=>$engine->storage,engine=>$engine,});$cache->{$off}=$obj;Scalar::Util::weaken($cache->{$off})}else {$obj=$cache->{$off}}unless ($args->{export}){if ($engine->storage->{autobless}){my$classname=$self->get_classname;if (defined$classname){bless$obj,$classname}}return$obj}if ($self->get_refcount > 1){return$obj}return$obj->export}sub free {my$self=shift;return if$self->decrement_refcount > 0;my$e=$self->engine;if(!$e->{external_refs}){eval {%{$e->cache->{$self->offset }}=()};eval {@{$e->cache->{$self->offset }}=()};bless$e->cache->{$self->offset },'DBM::Deep::Null';delete$e->cache->{$self->offset }}$e->storage->delete_from('datas',{ref_id=>$self->offset },);$e->storage->delete_from('datas',{value=>$self->offset,data_type=>'R' },);$self->SUPER::free(@_)}sub increment_refcount {my$self=shift;my$refcount=$self->get_refcount;$refcount++;$self->write_refcount($refcount);return$refcount}sub decrement_refcount {my$self=shift;my$refcount=$self->get_refcount;$refcount--;$self->write_refcount($refcount);return$refcount}sub get_refcount {my$self=shift;my ($rows)=$self->engine->storage->read_from('refs',$self->offset,qw(refcount),);return$rows->[0]{refcount}}sub write_refcount {my$self=shift;my ($num)=@_;$self->engine->storage->{dbh}->do("UPDATE refs SET refcount = ? WHERE id = ?",undef,$num,$self->offset,)}sub clear {my$self=shift;DBM::Deep->new({type=>$self->type,base_offset=>$self->offset,storage=>$self->engine->storage,engine=>$self->engine,})->_clear;return}1;
DBM_DEEP_SECTOR_DBI_REFERENCE

$fatpacked{"DBM/Deep/Sector/DBI/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_DBI_SCALAR';
  package DBM::Deep::Sector::DBI::Scalar;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Sector::DBI);sub table {'datas'}sub _init {my$self=shift;if ($self->offset){my ($rows)=$self->engine->storage->read_from(datas=>$self->offset,qw(id data_type key value),);$self->{$_}=$rows->[0]{$_}for qw(data_type key value)}return}sub data {my$self=shift;$self->{value}}1;
DBM_DEEP_SECTOR_DBI_SCALAR

$fatpacked{"DBM/Deep/Sector/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_FILE';
  package DBM::Deep::Sector::File;use 5.008_004;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Sector);use DBM::Deep::Sector::File::BucketList ();use DBM::Deep::Sector::File::Index ();use DBM::Deep::Sector::File::Null ();use DBM::Deep::Sector::File::Reference ();use DBM::Deep::Sector::File::Scalar ();my$STALE_SIZE=2;sub base_size {my$self=shift;return$self->engine->SIG_SIZE + $STALE_SIZE}sub free_meth {die "free_meth must be implemented in a child class"}sub free {my$self=shift;my$e=$self->engine;$e->storage->print_at($self->offset,$e->SIG_FREE);$e->storage->print_at($self->offset + $self->base_size,chr(0)x ($self->size - $self->base_size),);my$free_meth=$self->free_meth;$e->$free_meth($self->offset,$self->size);return}sub load {my$self=shift;my ($engine,$offset)=@_;return if!$offset || $offset <= 1;my$type=$engine->storage->read_at($offset,1);return if$type eq chr(0);if ($type eq $engine->SIG_ARRAY || $type eq $engine->SIG_HASH){return DBM::Deep::Sector::File::Reference->new({engine=>$engine,type=>$type,offset=>$offset,})}elsif ($type eq $engine->SIG_BLIST){return DBM::Deep::Sector::File::BucketList->new({engine=>$engine,type=>$type,offset=>$offset,})}elsif ($type eq $engine->SIG_INDEX){return DBM::Deep::Sector::File::Index->new({engine=>$engine,type=>$type,offset=>$offset,})}elsif ($type eq $engine->SIG_NULL){return DBM::Deep::Sector::File::Null->new({engine=>$engine,type=>$type,offset=>$offset,})}elsif ($type eq $engine->SIG_DATA || $type eq $engine->SIG_UNIDATA){return DBM::Deep::Sector::File::Scalar->new({engine=>$engine,type=>$type,offset=>$offset,})}elsif ($type eq $engine->SIG_FREE){return}DBM::Deep->_throw_error("'$offset': Don't know what to do with type '$type'")}1;
DBM_DEEP_SECTOR_FILE

$fatpacked{"DBM/Deep/Sector/File/BucketList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_FILE_BUCKETLIST';
  package DBM::Deep::Sector::File::BucketList;use 5.008_004;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Sector::File);my$STALE_SIZE=2;my%StP=(1=>'C',2=>'n',4=>'N',8=>'Q',);sub _init {my$self=shift;my$engine=$self->engine;unless ($self->offset){my$leftover=$self->size - $self->base_size;$self->{offset}=$engine->_request_blist_sector($self->size);$engine->storage->print_at($self->offset,$engine->SIG_BLIST);$engine->storage->print_at($self->offset + $self->base_size,chr(0)x $leftover,)}if ($self->{key_md5}){$self->find_md5}return$self}sub wipe {my$self=shift;$self->engine->storage->print_at($self->offset + $self->base_size,chr(0)x ($self->size - $self->base_size),)}sub size {my$self=shift;unless ($self->{size}){my$e=$self->engine;$self->{size}=$self->base_size + $e->max_buckets * $self->bucket_size}return$self->{size}}sub free_meth {'_add_free_blist_sector'}sub free {my$self=shift;my$e=$self->engine;for my$bucket ($self->chopped_up){my$rest=$bucket->[-1];my$l=unpack($StP{$e->byte_size},substr($rest,$e->hash_size,$e->byte_size));my$s=$e->load_sector($l);$s->free if$s;$l=unpack($StP{$e->byte_size},substr($rest,$e->hash_size + $e->byte_size,$e->byte_size,),);$s=$e->load_sector($l);$s->free if$s;for my$txn (0 .. $e->num_txns - 2){my$l=unpack($StP{$e->byte_size},substr($rest,$e->hash_size + 2 * $e->byte_size + $txn * ($e->byte_size + $STALE_SIZE),$e->byte_size,),);my$s=$e->load_sector($l);$s->free if$s}}$self->SUPER::free()}sub bucket_size {my$self=shift;unless ($self->{bucket_size}){my$e=$self->engine;my$location_size=$e->byte_size + $e->byte_size + ($e->num_txns - 1)* ($e->byte_size + $STALE_SIZE);$self->{bucket_size}=$e->hash_size + $location_size}return$self->{bucket_size}}sub chopped_up {my$self=shift;my$e=$self->engine;my@buckets;for my$idx (0 .. $e->max_buckets - 1){my$spot=$self->offset + $self->base_size + $idx * $self->bucket_size;my$md5=$e->storage->read_at($spot,$e->hash_size);last if$md5 eq $e->blank_md5;my$rest=$e->storage->read_at(undef,$self->bucket_size - $e->hash_size);push@buckets,[$spot,$md5 .$rest ]}return@buckets}sub write_at_next_open {my$self=shift;my ($entry)=@_;$self->{_next_open}=0 unless exists$self->{_next_open};my$spot=$self->offset + $self->base_size + $self->{_next_open}++ * $self->bucket_size;$self->engine->storage->print_at($spot,$entry);return$spot}sub has_md5 {my$self=shift;unless (exists$self->{found}){$self->find_md5}return$self->{found}}sub find_md5 {my$self=shift;$self->{found}=undef;$self->{idx}=-1;if (@_){$self->{key_md5}=shift}unless (exists$self->{key_md5}){DBM::Deep->_throw_error("Cannot find_md5 without a key_md5 set")}my$e=$self->engine;for my$idx (0 .. $e->max_buckets - 1){my$potential=$e->storage->read_at($self->offset + $self->base_size + $idx * $self->bucket_size,$e->hash_size,);if ($potential eq $e->blank_md5){$self->{idx}=$idx;return}if ($potential eq $self->{key_md5}){$self->{found}=1;$self->{idx}=$idx;return}}return}sub write_md5 {my$self=shift;my ($args)=@_;DBM::Deep->_throw_error("write_md5: no key")unless exists$args->{key};DBM::Deep->_throw_error("write_md5: no key_md5")unless exists$args->{key_md5};DBM::Deep->_throw_error("write_md5: no value")unless exists$args->{value};my$engine=$self->engine;$args->{trans_id}=$engine->trans_id unless exists$args->{trans_id};my$spot=$self->offset + $self->base_size + $self->{idx}* $self->bucket_size;$engine->add_entry($args->{trans_id},$spot);unless ($self->{found}){my$key_sector=DBM::Deep::Sector::File::Scalar->new({engine=>$engine,data=>$args->{key},});$engine->storage->print_at($spot,$args->{key_md5},pack($StP{$engine->byte_size},$key_sector->offset),)}my$loc=$spot + $engine->hash_size + $engine->byte_size;if ($args->{trans_id}){$loc += $engine->byte_size + ($args->{trans_id}- 1)* ($engine->byte_size + $STALE_SIZE);$engine->storage->print_at($loc,pack($StP{$engine->byte_size},$args->{value}->offset),pack($StP{$STALE_SIZE},$engine->get_txn_staleness_counter($args->{trans_id})),)}else {$engine->storage->print_at($loc,pack($StP{$engine->byte_size},$args->{value}->offset),)}}sub mark_deleted {my$self=shift;my ($args)=@_;$args ||= {};my$engine=$self->engine;$args->{trans_id}=$engine->trans_id unless exists$args->{trans_id};my$spot=$self->offset + $self->base_size + $self->{idx}* $self->bucket_size;$engine->add_entry($args->{trans_id},$spot);my$loc=$spot + $engine->hash_size + $engine->byte_size;if ($args->{trans_id}){$loc += $engine->byte_size + ($args->{trans_id}- 1)* ($engine->byte_size + $STALE_SIZE);$engine->storage->print_at($loc,pack($StP{$engine->byte_size},1),pack($StP{$STALE_SIZE},$engine->get_txn_staleness_counter($args->{trans_id})),)}else {$engine->storage->print_at($loc,pack($StP{$engine->byte_size},1),)}}sub delete_md5 {my$self=shift;my ($args)=@_;my$engine=$self->engine;return undef unless$self->{found};my$location=$self->get_data_location_for({allow_head=>0,});my$key_sector=$self->get_key_for;my$spot=$self->offset + $self->base_size + $self->{idx}* $self->bucket_size;$engine->storage->print_at($spot,$engine->storage->read_at($spot + $self->bucket_size,$self->bucket_size * ($engine->max_buckets - $self->{idx}- 1),),chr(0)x $self->bucket_size,);$key_sector->free;my$data_sector=$self->engine->load_sector($location);my$data=$data_sector->data({export=>1 });$data_sector->free;return$data}sub get_data_location_for {my$self=shift;my ($args)=@_;$args ||= {};$args->{allow_head}=0 unless exists$args->{allow_head};$args->{trans_id}=$self->engine->trans_id unless exists$args->{trans_id};$args->{idx}=$self->{idx}unless exists$args->{idx};my$e=$self->engine;my$spot=$self->offset + $self->base_size + $args->{idx}* $self->bucket_size + $e->hash_size + $e->byte_size;if ($args->{trans_id}){$spot += $e->byte_size + ($args->{trans_id}- 1)* ($e->byte_size + $STALE_SIZE)}my$buffer=$e->storage->read_at($spot,$e->byte_size + $STALE_SIZE,);my ($loc,$staleness)=unpack($StP{$e->byte_size}.' ' .$StP{$STALE_SIZE},$buffer);if ($args->{trans_id}){if ($staleness!=(my$s=$e->get_txn_staleness_counter($args->{trans_id}))){$e->storage->print_at($spot,pack($StP{$e->byte_size}.' ' .$StP{$STALE_SIZE},(0)x 2),);$loc=0}}if ($args->{trans_id}&&!$loc && $args->{allow_head}){return$self->get_data_location_for({trans_id=>0,allow_head=>1,idx=>$args->{idx},})}return$loc <= 1 ? 0 : $loc}sub get_data_for {my$self=shift;my ($args)=@_;$args ||= {};return unless$self->{found};my$location=$self->get_data_location_for({allow_head=>$args->{allow_head},});return$self->engine->load_sector($location)}sub get_key_for {my$self=shift;my ($idx)=@_;$idx=$self->{idx}unless defined$idx;if ($idx >= $self->engine->max_buckets){DBM::Deep->_throw_error("get_key_for(): Attempting to retrieve $idx")}my$location=$self->engine->storage->read_at($self->offset + $self->base_size + $idx * $self->bucket_size + $self->engine->hash_size,$self->engine->byte_size,);$location=unpack($StP{$self->engine->byte_size},$location);DBM::Deep->_throw_error("get_key_for: No location?")unless$location;return$self->engine->load_sector($location)}1;
DBM_DEEP_SECTOR_FILE_BUCKETLIST

$fatpacked{"DBM/Deep/Sector/File/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_FILE_DATA';
  package DBM::Deep::Sector::File::Data;use 5.008_004;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Sector::File);sub size {$_[0]{engine}->data_sector_size}sub free_meth {return '_add_free_data_sector'}1;
DBM_DEEP_SECTOR_FILE_DATA

$fatpacked{"DBM/Deep/Sector/File/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_FILE_INDEX';
  package DBM::Deep::Sector::File::Index;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Sector::File);my$STALE_SIZE=2;my%StP=(1=>'C',2=>'n',4=>'N',8=>'Q',);sub _init {my$self=shift;my$engine=$self->engine;unless ($self->offset){my$leftover=$self->size - $self->base_size;$self->{offset}=$engine->_request_index_sector($self->size);$engine->storage->print_at($self->offset,$engine->SIG_INDEX);$engine->storage->print_at($self->offset + $self->base_size,chr(0)x $leftover,)}return$self}sub size {my$self=shift;unless ($self->{size}){my$e=$self->engine;$self->{size}=$self->base_size + $e->byte_size * $e->hash_chars}return$self->{size}}sub free_meth {return '_add_free_index_sector'}sub free {my$self=shift;my$e=$self->engine;for my$i (0 .. $e->hash_chars - 1){my$l=$self->get_entry($i)or next;$e->load_sector($l)->free}$self->SUPER::free()}sub _loc_for {my$self=shift;my ($idx)=@_;return$self->offset + $self->base_size + $idx * $self->engine->byte_size}sub get_entry {my$self=shift;my ($idx)=@_;my$e=$self->engine;DBM::Deep->_throw_error("get_entry: Out of range ($idx)")if$idx < 0 || $idx >= $e->hash_chars;return unpack($StP{$e->byte_size},$e->storage->read_at($self->_loc_for($idx),$e->byte_size),)}sub set_entry {my$self=shift;my ($idx,$loc)=@_;my$e=$self->engine;DBM::Deep->_throw_error("set_entry: Out of range ($idx)")if$idx < 0 || $idx >= $e->hash_chars;$self->engine->storage->print_at($self->_loc_for($idx),pack($StP{$e->byte_size},$loc),)}1;
DBM_DEEP_SECTOR_FILE_INDEX

$fatpacked{"DBM/Deep/Sector/File/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_FILE_NULL';
  package DBM::Deep::Sector::File::Null;use 5.008_004;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Sector::File::Data);my$STALE_SIZE=2;my%StP=(1=>'C',2=>'n',4=>'N',8=>'Q',);sub type {$_[0]{engine}->SIG_NULL}sub data_length {0}sub data {return}sub _init {my$self=shift;my$engine=$self->engine;unless ($self->offset){my$leftover=$self->size - $self->base_size - 1 * $engine->byte_size - 1;$self->{offset}=$engine->_request_data_sector($self->size);$engine->storage->print_at($self->offset,$self->type);$engine->storage->print_at($self->offset + $self->base_size,pack($StP{$engine->byte_size},0),pack($StP{1},$self->data_length),chr(0)x $leftover,);return}}1;
DBM_DEEP_SECTOR_FILE_NULL

$fatpacked{"DBM/Deep/Sector/File/Reference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_FILE_REFERENCE';
  package DBM::Deep::Sector::File::Reference;use 5.008_004;use strict;use warnings FATAL=>'all';use base qw(DBM::Deep::Sector::File::Data);use Scalar::Util;my$STALE_SIZE=2;my%StP=(1=>'C',2=>'n',4=>'N',8=>'Q',);sub _init {my$self=shift;my$e=$self->engine;unless ($self->offset){my$classname=Scalar::Util::blessed(delete$self->{data});my$leftover=$self->size - $self->base_size - 3 * $e->byte_size;my$class_offset=0;if (defined$classname){my$class_sector=DBM::Deep::Sector::File::Scalar->new({engine=>$e,data=>$classname,});$class_offset=$class_sector->offset}$self->{offset}=$e->_request_data_sector($self->size);$e->storage->print_at($self->offset,$self->type);$e->storage->print_at($self->offset + $self->base_size,pack($StP{$e->byte_size},0),pack($StP{$e->byte_size},$class_offset),pack($StP{$e->byte_size},1),chr(0)x $leftover,)}else {$self->{type}=$e->storage->read_at($self->offset,1)}$self->{staleness}=unpack($StP{$STALE_SIZE},$e->storage->read_at($self->offset + $e->SIG_SIZE,$STALE_SIZE),);return}sub get_data_location_for {my$self=shift;my ($args)=@_;$args->{allow_head}=0 unless exists$args->{allow_head};$args->{create}=0 unless exists$args->{create};my$blist=$self->get_bucket_list({key_md5=>$args->{key_md5},key=>$args->{key},create=>$args->{create},});return unless$blist && $blist->{found};my$location=$blist->get_data_location_for({allow_head=>$args->{allow_head},})or return;return$location}sub get_data_for {my$self=shift;my ($args)=@_;my$location=$self->get_data_location_for($args)or return;return$self->engine->load_sector($location)}sub write_data {my$self=shift;my ($args)=@_;my$blist=$self->get_bucket_list({key_md5=>$args->{key_md5},key=>$args->{key},create=>1,})or DBM::Deep->_throw_error("How did write_data fail (no blist)?!");if ($self->engine->trans_id){if (!$blist->has_md5){$blist->mark_deleted({trans_id=>0,})}}else {my@trans_ids=$self->engine->get_running_txn_ids;if ($blist->has_md5){if (@trans_ids){my$old_value=$blist->get_data_for;for my$other_trans_id (@trans_ids){next if$blist->get_data_location_for({trans_id=>$other_trans_id,allow_head=>0,});$blist->write_md5({trans_id=>$other_trans_id,key=>$args->{key},key_md5=>$args->{key_md5},value=>$old_value->clone,})}}}else {if (@trans_ids){for my$other_trans_id (@trans_ids){next if$blist->get_data_location_for({trans_id=>$other_trans_id,allow_head=>0 });$blist->mark_deleted({trans_id=>$other_trans_id,})}}}}if ($blist->get_data_location_for({allow_head=>0 })){$blist->get_data_for({allow_head=>0 })->free}$blist->write_md5({key=>$args->{key},key_md5=>$args->{key_md5},value=>$args->{value},})}sub delete_key {my$self=shift;my ($args)=@_;my$blist=$self->get_bucket_list({key_md5=>$args->{key_md5},})or return;my$location=$blist->get_data_location_for({allow_head=>0,});my$old_value=$location && $self->engine->load_sector($location);my@trans_ids=$self->engine->get_running_txn_ids;if ($self->engine->trans_id==0){if (@trans_ids){for my$other_trans_id (@trans_ids){next if$blist->get_data_location_for({trans_id=>$other_trans_id,allow_head=>0 });$blist->write_md5({trans_id=>$other_trans_id,key=>$args->{key},key_md5=>$args->{key_md5},value=>$old_value->clone,})}}}my$data;if (@trans_ids){$blist->mark_deleted($args);if ($old_value){$data=$old_value->data({export=>1 });$old_value->free}}else {$data=$blist->delete_md5($args)}return$data}sub write_blist_loc {my$self=shift;my ($loc)=@_;my$engine=$self->engine;$engine->storage->print_at($self->offset + $self->base_size,pack($StP{$engine->byte_size},$loc),)}sub get_blist_loc {my$self=shift;my$e=$self->engine;my$blist_loc=$e->storage->read_at($self->offset + $self->base_size,$e->byte_size);return unpack($StP{$e->byte_size},$blist_loc)}sub get_bucket_list {my$self=shift;my ($args)=@_;$args ||= {};my$engine=$self->engine;my$blist_loc=$self->get_blist_loc;unless ($blist_loc){return unless$args->{create};my$blist=DBM::Deep::Sector::File::BucketList->new({engine=>$engine,key_md5=>$args->{key_md5},});$self->write_blist_loc($blist->offset);return$blist}my$sector=$engine->load_sector($blist_loc)or DBM::Deep->_throw_error("Cannot read sector at $blist_loc in get_bucket_list()");my$i=0;my$last_sector=undef;while ($sector->isa('DBM::Deep::Sector::File::Index')){$blist_loc=$sector->get_entry(ord(substr($args->{key_md5},$i++,1)));$last_sector=$sector;if ($blist_loc){$sector=$engine->load_sector($blist_loc)or DBM::Deep->_throw_error("Cannot read sector at $blist_loc in get_bucket_list()")}else {$sector=undef;last}}unless ($sector){return unless$args->{create};DBM::Deep->_throw_error("No last_sector when attempting to build a new entry")unless$last_sector;my$blist=DBM::Deep::Sector::File::BucketList->new({engine=>$engine,key_md5=>$args->{key_md5},});$last_sector->set_entry(ord(substr($args->{key_md5},$i - 1,1))=>$blist->offset);return$blist}$sector->find_md5($args->{key_md5});if (!$sector->has_md5 && $args->{create}&& $sector->{idx}==-1){{my$redo;my$new_index=DBM::Deep::Sector::File::Index->new({engine=>$engine,});my%blist_cache;for my$entry ($sector->chopped_up){my ($spot,$md5)=@{$entry};my$idx=ord(substr($md5,$i,1));my$blist=$blist_cache{$idx}||= DBM::Deep::Sector::File::BucketList->new({engine=>$engine,});$new_index->set_entry($idx=>$blist->offset);my$new_spot=$blist->write_at_next_open($md5);$engine->reindex_entry($spot=>$new_spot)}{my$idx=ord(substr($args->{key_md5},$i,1));if (keys%blist_cache==1 and each%blist_cache==$idx){++$i,++$redo}else {my$blist=$blist_cache{$idx}||= DBM::Deep::Sector::File::BucketList->new({engine=>$engine,});$new_index->set_entry($idx=>$blist->offset);$blist->find_md5($args->{key_md5});$blist->write_md5({key=>$args->{key},key_md5=>$args->{key_md5},value=>DBM::Deep::Sector::File::Null->new({engine=>$engine,data=>undef,}),})}}if ($last_sector){$last_sector->set_entry(ord(substr($args->{key_md5},$i - 1,1)),$new_index->offset,)}else {$engine->storage->print_at($self->offset + $self->base_size,pack($StP{$engine->byte_size},$new_index->offset),)}$sector->wipe;$sector->free;if ($redo){(undef,$sector)=%blist_cache;$last_sector=$new_index;redo}$sector=$blist_cache{ord(substr($args->{key_md5},$i,1))};$sector->find_md5($args->{key_md5})}}return$sector}sub get_class_offset {my$self=shift;my$e=$self->engine;return unpack($StP{$e->byte_size},$e->storage->read_at($self->offset + $self->base_size + 1 * $e->byte_size,$e->byte_size,),)}sub get_classname {my$self=shift;my$class_offset=$self->get_class_offset;return unless$class_offset;return$self->engine->load_sector($class_offset)->data}sub data {my$self=shift;my ($args)=@_;$args ||= {};my$engine=$self->engine;my$cache_entry=$engine->cache->{$self->offset }||= {};my$trans_id=$engine->trans_id;my$obj;if (!defined $$cache_entry{$trans_id }){$obj=DBM::Deep->new({type=>$self->type,base_offset=>$self->offset,staleness=>$self->staleness,storage=>$engine->storage,engine=>$engine,});$$cache_entry{$trans_id }=$obj;Scalar::Util::weaken($$cache_entry{$trans_id })}else {$obj=$$cache_entry{$trans_id }}unless ($args->{export}){if ($engine->storage->{autobless}){my$classname=$self->get_classname;if (defined$classname){bless$obj,$classname}}return$obj}if ($self->get_refcount > 1){return$obj}return$obj->export}sub free {my$self=shift;return if$self->decrement_refcount > 0;my$e=$self->engine;if(!$e->{external_refs}){my$cache=$e->cache;my$off=$self->offset;if(exists$cache->{$off }and exists$cache->{$off }{my$trans_id=$e->trans_id }){bless$cache->{$off }{$trans_id },'DBM::Deep::Null' if defined$cache->{$off }{$trans_id };delete$cache->{$off }{$trans_id }}}my$blist_loc=$self->get_blist_loc;$e->load_sector($blist_loc)->free if$blist_loc;my$class_loc=$self->get_class_offset;$e->load_sector($class_loc)->free if$class_loc;$self->SUPER::free()}sub increment_refcount {my$self=shift;my$refcount=$self->get_refcount;$refcount++;$self->write_refcount($refcount);return$refcount}sub decrement_refcount {my$self=shift;my$refcount=$self->get_refcount;$refcount--;$self->write_refcount($refcount);return$refcount}sub get_refcount {my$self=shift;my$e=$self->engine;return unpack($StP{$e->byte_size},$e->storage->read_at($self->offset + $self->base_size + 2 * $e->byte_size,$e->byte_size,),)}sub write_refcount {my$self=shift;my ($num)=@_;my$e=$self->engine;$e->storage->print_at($self->offset + $self->base_size + 2 * $e->byte_size,pack($StP{$e->byte_size},$num),)}sub clear {my$self=shift;my$blist_loc=$self->get_blist_loc or return;my$engine=$self->engine;if ($engine->get_running_txn_ids){$self->data->_get_self->_clear;return}my$sector=$engine->load_sector($blist_loc)or DBM::Deep->_throw_error("Cannot read sector at $blist_loc in clear()");$engine->storage->print_at($self->offset + $self->base_size,pack($StP{$engine->byte_size},0),);$sector->free;return}1;
DBM_DEEP_SECTOR_FILE_REFERENCE

$fatpacked{"DBM/Deep/Sector/File/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_SECTOR_FILE_SCALAR';
  package DBM::Deep::Sector::File::Scalar;use 5.008_004;use strict;use warnings FATAL=>'all';no warnings 'recursion';use base qw(DBM::Deep::Sector::File::Data);my$STALE_SIZE=2;my%StP=(1=>'C',2=>'n',4=>'N',8=>'Q',);sub free {my$self=shift;my$chain_loc=$self->chain_loc;$self->SUPER::free();if ($chain_loc){$self->engine->load_sector($chain_loc)->free}return}sub _init {my$self=shift;my$engine=$self->engine;unless ($self->offset){my$data_section=$self->size - $self->base_size - $engine->byte_size - 1;$self->{offset}=$engine->_request_data_sector($self->size);my$data=delete$self->{data};my$utf8=do {no warnings 'utf8';$data !~ /^[\0-\xff]*\z/};if($utf8){if($engine->{v}< 4){DBM::Deep->_throw_error("This database format version is too old for Unicode")}utf8::encode$data;$self->{type}=$engine->SIG_UNIDATA}else {$self->{type}=$engine->SIG_DATA}my$dlen=length$data;my$continue=1;my$curr_offset=$self->offset;while ($continue){my$next_offset=0;my ($leftover,$this_len,$chunk);if ($dlen > $data_section){$leftover=0;$this_len=$data_section;$chunk=substr($data,0,$this_len);$dlen -= $data_section;$next_offset=$engine->_request_data_sector($self->size);$data=substr($data,$this_len)}else {$leftover=$data_section - $dlen;$this_len=$dlen;$chunk=$data;$continue=0}$engine->storage->print_at($curr_offset,$self->type);$engine->storage->print_at($curr_offset + $self->base_size,pack($StP{$engine->byte_size},$next_offset),pack($StP{1},$this_len),$chunk,chr(0)x $leftover,);$curr_offset=$next_offset}return}}sub data_length {my$self=shift;my$buffer=$self->engine->storage->read_at($self->offset + $self->base_size + $self->engine->byte_size,1);return unpack($StP{1},$buffer)}sub chain_loc {my$self=shift;return unpack($StP{$self->engine->byte_size},$self->engine->storage->read_at($self->offset + $self->base_size,$self->engine->byte_size,),)}sub data {my$self=shift;my$engine=$self->engine;my$data;while (1){my$chain_loc=$self->chain_loc;$data .= $engine->storage->read_at($self->offset + $self->base_size + $engine->byte_size + 1,$self->data_length,);last unless$chain_loc;$self=$engine->load_sector($chain_loc)}utf8::decode$data if$self->type eq $engine->SIG_UNIDATA;return$data}1;
DBM_DEEP_SECTOR_FILE_SCALAR

$fatpacked{"DBM/Deep/Storage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_STORAGE';
  package DBM::Deep::Storage;use 5.008_004;use strict;use warnings FATAL=>'all';sub flush {die "flush must be implemented in a child class"}sub is_writable {die "is_writable must be implemented in a child class"}sub lock_exclusive {die "lock_exclusive must be implemented in a child class"}sub lock_shared {die "lock_shared must be implemented in a child class"}sub unlock {die "unlock must be implemented in a child class"}1;
DBM_DEEP_STORAGE

$fatpacked{"DBM/Deep/Storage/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_STORAGE_DBI';
  package DBM::Deep::Storage::DBI;use 5.008_004;use strict;use warnings FATAL=>'all';use base 'DBM::Deep::Storage';use DBI;sub new {my$class=shift;my ($args)=@_;my$self=bless {autobless=>1,dbh=>undef,dbi=>undef,},$class;for my$param (keys %$self){next unless exists$args->{$param};$self->{$param}=$args->{$param}}if ($self->{dbh}){$self->{driver}=lc$self->{dbh}->{Driver}->{Name}}else {$self->open}if ($self->driver eq 'sqlite'){$self->{dbh}->do('PRAGMA foreign_keys = ON')}return$self}sub open {my$self=shift;return if$self->{dbh};$self->{dbh}=DBI->connect($self->{dbi}{dsn},$self->{dbi}{username},$self->{dbi}{password},{AutoCommit=>1,PrintError=>0,RaiseError=>1,%{$self->{dbi}{connect_args}|| {}},},)or die$DBI::error;(undef,$self->{driver})=map defined($_)? lc($_): undef,DBI->parse_dsn($self->{dbi}{dsn});return 1}sub close {my$self=shift;$self->{dbh}->disconnect if$self->{dbh};return 1}sub DESTROY {my$self=shift;$self->close if ref$self}sub is_writable {my$self=shift;return 1}sub lock_exclusive {my$self=shift}sub lock_shared {my$self=shift}sub unlock {my$self=shift}sub read_from {my$self=shift;my ($table,$cond,@cols)=@_;$cond={id=>$cond }unless ref$cond;my@keys=keys %$cond;my$where=join ' AND ',map {"`$_` = ?"}@keys;return$self->{dbh}->selectall_arrayref("SELECT `@{[join '`,`', @cols ]}` FROM $table WHERE $where",{Slice=>{}},@{$cond}{@keys},)}sub flush {}sub write_to {my$self=shift;my ($table,$id,%args)=@_;my@keys=keys%args;my$sql="REPLACE INTO $table ( `id`, " .join(',',map {"`$_`"}@keys).") VALUES (" .join(',',('?')x (@keys + 1)).")";$self->{dbh}->do($sql,undef,$id,@args{@keys});return$self->{dbh}->last_insert_id("","","","")}sub delete_from {my$self=shift;my ($table,$cond)=@_;$cond={id=>$cond }unless ref$cond;my@keys=keys %$cond;my$where=join ' AND ',map {"`$_` = ?"}@keys;$self->{dbh}->do("DELETE FROM $table WHERE $where",undef,@{$cond}{@keys},)}sub driver {$_[0]{driver}}sub rand_function {my$self=shift;my$driver=$self->driver;$driver eq 'sqlite' and return 'random()';$driver eq 'mysql' and return 'RAND()';die "rand_function undefined for $driver\n"}1;
DBM_DEEP_STORAGE_DBI

$fatpacked{"DBM/Deep/Storage/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBM_DEEP_STORAGE_FILE';
  package DBM::Deep::Storage::File;use 5.008_004;use strict;use warnings FATAL=>'all';use Fcntl qw(:DEFAULT :flock :seek);use constant DEBUG=>0;use base 'DBM::Deep::Storage';sub new {my$class=shift;my ($args)=@_;my$self=bless {autobless=>1,autoflush=>1,end=>0,fh=>undef,file=>undef,file_offset=>0,locking=>1,locked=>0,filter_store_key=>undef,filter_store_value=>undef,filter_fetch_key=>undef,filter_fetch_value=>undef,},$class;for my$param (keys %$self){next unless exists$args->{$param};$self->{$param}=$args->{$param}}if ($self->{fh}&&!$self->{file_offset}){$self->{file_offset}=tell($self->{fh})}$self->open unless$self->{fh};return$self}sub open {my$self=shift;my$flags=O_CREAT | O_BINARY;if (!-e $self->{file}|| -w _){$flags |= O_RDWR}else {$flags |= O_RDONLY}my$fh;sysopen($fh,$self->{file},$flags)or die "DBM::Deep: Cannot sysopen file '$self->{file}': $!\n";$self->{fh}=$fh;binmode$fh;if ($self->{autoflush}){my$old=select$fh;$|=1;select$old}return 1}sub close {my$self=shift;if ($self->{fh}){close$self->{fh};$self->{fh}=undef}return 1}sub size {my$self=shift;return 0 unless$self->{fh};return((-s $self->{fh})- $self->{file_offset})}sub set_inode {my$self=shift;unless (defined$self->{inode}){my@stats=stat($self->{fh});$self->{inode}=$stats[1];$self->{end}=$stats[7]}return 1}sub print_at {my$self=shift;my$loc=shift;local ($,,$\);my$fh=$self->{fh};if (defined$loc){seek($fh,$loc + $self->{file_offset},SEEK_SET)}if (DEBUG){my$caller=join ':',(caller)[0,2];my$len=length(join '',@_);warn "($caller) print_at( " .(defined$loc ? $loc : '<undef>').", $len )\n"}print($fh @_)or die "Internal Error (print_at($loc)): $!\n";return 1}sub read_at {my$self=shift;my ($loc,$size)=@_;my$fh=$self->{fh};if (defined$loc){seek($fh,$loc + $self->{file_offset},SEEK_SET)}if (DEBUG){my$caller=join ':',(caller)[0,2];warn "($caller) read_at( " .(defined$loc ? $loc : '<undef>').", $size )\n"}my$buffer;read($fh,$buffer,$size);return$buffer}sub DESTROY {my$self=shift;return unless$self;$self->close;return}sub request_space {my$self=shift;my ($size)=@_;my$loc=$self->{end};$self->{end}+= $size;return$loc}sub copy_stats {my$self=shift;my ($temp_filename)=@_;my@stats=stat($self->{fh});my$perms=$stats[2]& 07777;my$uid=$stats[4];my$gid=$stats[5];chown($uid,$gid,$temp_filename);chmod($perms,$temp_filename)}sub flush {my$self=shift;my$old_fh=select$self->{fh};my$old_af=$|;$|=1;$|=$old_af;select$old_fh;return 1}sub is_writable {my$self=shift;my$fh=$self->{fh};return unless defined$fh;return unless defined fileno$fh;local $\='';no warnings;local $^W;return print$fh ''}sub lock_exclusive {my$self=shift;my ($obj)=@_;return$self->_lock($obj,LOCK_EX)}sub lock_shared {my$self=shift;my ($obj)=@_;return$self->_lock($obj,LOCK_SH)}sub _lock {my$self=shift;my ($obj,$type)=@_;$type=LOCK_EX unless defined$type;if ($^O eq 'MSWin32' || $^O eq 'cygwin'){$type=LOCK_EX}if (!defined($self->{fh})){return}if ($self->{locking}){if (!$self->{locked}){flock($self->{fh},$type);my@stats=stat($self->{fh});$self->{end}=$stats[7];if (defined($self->{inode})&& $stats[1]!=$self->{inode}){$self->close;$self->open;$obj->{engine}->setup($obj);flock($self->{fh},$type);$self->{end}=(stat($self->{fh}))[7]}}$self->{locked}++;return 1}return}sub unlock {my$self=shift;if (!defined($self->{fh})){return}if ($self->{locking}&& $self->{locked}> 0){$self->{locked}--;if (!$self->{locked}){flock($self->{fh},LOCK_UN);return 1}return}return}1;
DBM_DEEP_STORAGE_FILE

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.01';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;use strict;use Exporter 5.57 'import';use vars qw($VERSION @EXPORT_OK);use if $] > 5.017,'deprecate';$VERSION='0.01';@EXPORT_OK=qw(list_packages);sub list_packages {my$pack=shift;$pack .= "::" unless$pack =~ m!::$!;no strict 'refs';my@packs;my@stuff=grep!/^(main|)::$/,keys %{$pack};for my$cand (grep /::$/,@stuff){$cand =~ s!::$!!;my@children=list_packages($pack.$cand);push@packs,"$pack$cand" unless$cand =~ /^::/ || !__PACKAGE__->_loaded($pack.$cand);push@packs,@children}return grep {$_ !~ /::(::ISA::CACHE|SUPER)/}@packs}sub _loaded {my ($class,$name)=@_;no strict 'refs';return 1 if defined ${"${name}::VERSION"};return 1 if @{"${name}::ISA"};for (keys %{"${name}::"}){next if substr($_,-2,2)eq '::';return 1 if defined &{"${name}::$_"}}my$filename=join('/',split /(?:'|::)/,$name).'.pm';return 1 if defined$INC{$filename};''}1;
DEVEL_INNERPACKAGE

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;use 5.006;use strict;use warnings;our$VERSION='0.01';use Devel::StackTrace::Frame;use File::Spec;use Scalar::Util qw(blessed);use overload '""'=>\&as_string,fallback=>1;sub new {my$class=shift;my%p=@_;$p{unsafe_ref_capture}=!delete$p{no_refs}if exists$p{no_refs};my$self=bless {index=>undef,frames=>[],raw=>[],%p,},$class;$self->_record_caller_data;return$self}sub _record_caller_data {my$self=shift;my$filter=$self->{filter_frames_early}&& $self->_make_frame_filter;my$x=1 + ($self->{skip_frames}|| 0);while (my@c =$self->{no_args}? caller($x++): do {package DB;@DB::args=();caller($x++)}){my@args;@args=$self->{no_args}? (): @DB::args;my$raw={caller=>\@c,args=>\@args,};next if$filter &&!$filter->($raw);unless ($self->{unsafe_ref_capture}){$raw->{args}=[map {ref $_ ? $self->_ref_to_string($_): $_}@{$raw->{args}}]}push @{$self->{raw}},$raw}}sub _ref_to_string {my$self=shift;my$ref=shift;return overload::AddrRef($ref)if blessed$ref && $ref->isa('Exception::Class::Base');return overload::AddrRef($ref)unless$self->{respect_overload};local $@;local$SIG{__DIE__};my$str=eval {$ref .q{}};return $@ ? overload::AddrRef($ref): $str}sub _make_frames {my$self=shift;my$filter=!$self->{filter_frames_early}&& $self->_make_frame_filter;my$raw=delete$self->{raw};for my$r (@{$raw}){next if$filter &&!$filter->($r);$self->_add_frame($r->{caller},$r->{args})}}my$default_filter=sub {1};sub _make_frame_filter {my$self=shift;my (@i_pack_re,%i_class);if ($self->{ignore_package}){local $@;local$SIG{__DIE__};$self->{ignore_package}=[$self->{ignore_package}]unless eval {@{$self->{ignore_package}}};@i_pack_re =map {ref $_ ? $_ : qr/^\Q$_\E$/}@{$self->{ignore_package}}}my$p=__PACKAGE__;push@i_pack_re,qr/^\Q$p\E$/;if ($self->{ignore_class}){$self->{ignore_class}=[$self->{ignore_class}]unless ref$self->{ignore_class};%i_class=map {$_=>1}@{$self->{ignore_class}}}my$user_filter=$self->{frame_filter};return sub {return 0 if grep {$_[0]{caller}[0]=~ /$_/}@i_pack_re;return 0 if grep {$_[0]{caller}[0]->isa($_)}keys%i_class;if ($user_filter){return$user_filter->($_[0])}return 1}}sub _add_frame {my$self=shift;my$c=shift;my$p=shift;push @$c,(undef,undef)if scalar @$c==6;push @{$self->{frames}},Devel::StackTrace::Frame->new($c,$p,$self->{respect_overload},$self->{max_arg_length},$self->{message},$self->{indent})}sub next_frame {my$self=shift;$self->{index}=-1 unless defined$self->{index};my@f=$self->frames;if (defined$f[$self->{index}+ 1 ]){return$f[++$self->{index}]}else {$self->{index}=undef;return undef}}sub prev_frame {my$self=shift;my@f=$self->frames;$self->{index}=scalar@f unless defined$self->{index};if (defined$f[$self->{index}- 1 ]&& $self->{index}>= 1){return$f[--$self->{index}]}else {$self->{index}=undef;return undef}}sub reset_pointer {my$self=shift;$self->{index}=undef;return}sub frames {my$self=shift;if (@_){die "Devel::StackTrace->frames can only take Devel::StackTrace::Frame args\n" if grep {!$_->isa('Devel::StackTrace::Frame')}@_;$self->{frames}=\@_;delete$self->{raw}}else {$self->_make_frames if$self->{raw}}return @{$self->{frames}}}sub frame {my$self=shift;my$i=shift;return unless defined$i;return ($self->frames)[$i]}sub frame_count {my$self=shift;return scalar($self->frames)}sub as_string {my$self=shift;my$p=shift;my$st=q{};my$first=1;for my$f ($self->frames){$st .= $f->as_string($first,$p)."\n";$first=0}return$st}{package Devel::StackTraceFrame;our@ISA='Devel::StackTrace::Frame'}1;
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;use strict;use warnings;our$VERSION='0.01';BEGIN {no strict 'refs';for my$f (qw(package filename line subroutine hasargs wantarray evaltext is_require hints bitmask args)){next if$f eq 'args';*{$f}=sub {my$s=shift;return$s->{$f}}}}{my@fields=(qw(package filename line subroutine hasargs wantarray evaltext is_require hints bitmask));sub new {my$proto=shift;my$class=ref$proto || $proto;my$self=bless {},$class;@{$self}{@fields}=@{shift()};$self->{filename}=File::Spec->canonpath($self->{filename});$self->{args}=shift;$self->{respect_overload}=shift;$self->{max_arg_length}=shift;$self->{message}=shift;$self->{indent}=shift;return$self}}sub args {my$self=shift;return @{$self->{args}}}sub as_string {my$self=shift;my$first=shift;my$p=shift;my$sub=$self->subroutine;if ($first){$sub =defined$self->{message}? $self->{message}: 'Trace begun'}else {if (my$eval=$self->evaltext){if ($self->is_require){$sub="require $eval"}else {$eval =~ s/([\\\'])/\\$1/g;$sub="eval '$eval'"}}elsif ($sub eq '(eval)'){$sub='eval {...}'}if (my@a=$self->args){for (@a){unless (defined $_){$_='undef';next}$_=$self->Devel::StackTrace::_ref_to_string($_)if ref $_;local$SIG{__DIE__};local $@;eval {my$max_arg_length =exists$p->{max_arg_length}? $p->{max_arg_length}: $self->{max_arg_length};if ($max_arg_length && length $_ > $max_arg_length){substr($_,$max_arg_length)='...'}s/'/\\'/g;$_="'$_'" unless /^-?[\d.]+$/;s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg};if (my$e=$@){$_=$e =~ /malformed utf-8/i ? '(bad utf-8)' : '?'}}$sub .= '(' .join(', ',@a).')';$sub .= ' called'}}my$tab=$self->{indent}&&!$first ? "\t" : q{};return "${tab}$sub at " .$self->filename .' line ' .$self->line}1;
DEVEL_STACKTRACE_FRAME

$fatpacked{"Dist/CheckConflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_CHECKCONFLICTS';
  package Dist::CheckConflicts;BEGIN {$Dist::CheckConflicts::AUTHORITY='cpan:DOY'}$Dist::CheckConflicts::VERSION='0.01';use strict;use warnings;use 5.006;use base 'Exporter';our@EXPORT=our@EXPORT_OK=(qw(conflicts check_conflicts calculate_conflicts dist));use Carp;use Module::Runtime 0.009 'module_notional_filename','require_module';my%CONFLICTS;my%HAS_CONFLICTS;my%DISTS;sub import {my$pkg=shift;my$for=caller;my ($conflicts,$alsos,$dist);($conflicts,@_)=_strip_opt('-conflicts'=>@_);($alsos,@_)=_strip_opt('-also'=>@_);($dist,@_)=_strip_opt('-dist'=>@_);my%conflicts=%{$conflicts || {}};for my$also (@{$alsos || []}){eval {require_module($also)}or next;if (!exists$CONFLICTS{$also}){$also .= '::Conflicts';eval {require_module($also)}or next}if (!exists$CONFLICTS{$also}){next}my%also_confs=$also->conflicts;for my$also_conf (keys%also_confs){$conflicts{$also_conf}=$also_confs{$also_conf}if!exists$conflicts{$also_conf}|| $conflicts{$also_conf}lt $also_confs{$also_conf}}}$CONFLICTS{$for}=\%conflicts;$DISTS{$for}=$dist || $for;if (grep {$_ eq ':runtime'}@_){for my$conflict (keys%conflicts){$HAS_CONFLICTS{$conflict}||= [];push @{$HAS_CONFLICTS{$conflict}},$for}for my$conflict (keys%conflicts){if (exists$INC{module_notional_filename($conflict)}){_check_version([$for],$conflict)}}@INC=grep {!(ref($_)eq 'ARRAY' && @$_ > 1 && $_->[1]==\%CONFLICTS)}@INC;unshift@INC,[sub {my ($sub,$file)=@_;(my$mod=$file)=~ s{\.pm$}{};$mod =~ s{/}{::}g;return unless$mod =~ /[\w:]+/;return unless defined$HAS_CONFLICTS{$mod};{local$HAS_CONFLICTS{$mod};require$file}_check_version($HAS_CONFLICTS{$mod},$mod);my$called;return sub {return 0 if$called;$_="1;";$called=1;return 1}},\%CONFLICTS,]}$pkg->export_to_level(1,@_)}sub _strip_opt {my ($opt,@args)=@_;my$val;for my$idx (0 .. $#args - 1){if (defined$args[$idx]&& $args[$idx]eq $opt){$val=(splice@args,$idx,2)[1];last}}return ($val,@args)}sub _check_version {my ($fors,$mod)=@_;for my$for (@$fors){my$conflict_ver=$CONFLICTS{$for}{$mod};my$version=do {no strict 'refs';${${$mod .'::'}{VERSION}}};if ($version le $conflict_ver){warn <<EOF;return}}}sub conflicts {my$package=shift;return %{$CONFLICTS{$package }}}sub dist {my$package=shift;return$DISTS{$package }}sub check_conflicts {my$package=shift;my$dist=$package->dist;my@conflicts=$package->calculate_conflicts;return unless@conflicts;my$err="Conflicts detected for $dist:\n";for my$conflict (@conflicts){$err .= "  $conflict->{package} is version " ."$conflict->{installed}, but must be greater than version " ."$conflict->{required}\n"}die$err}sub calculate_conflicts {my$package=shift;my%conflicts=$package->conflicts;my@ret;CONFLICT: for my$conflict (keys%conflicts){my$success=do {local$SIG{__WARN__}=sub {};eval {require_module($conflict)}};my$error=$@;my$file=module_notional_filename($conflict);next if not $success and $error =~ /Can't locate \Q$file\E in \@INC/;warn "Warning: $conflict did not compile" if not $success;my$installed=$success ? $conflict->VERSION : 'unknown';push@ret,{package=>$conflict,installed=>$installed,required=>$conflicts{$conflict},}if not $success or $installed le $conflicts{$conflict}}return sort {$a->{package}cmp $b->{package}}@ret}1;
  Conflict detected for $DISTS{$for}:
    $mod is version $version, but must be greater than version $conflict_ver
  EOF
DIST_CHECKCONFLICTS

$fatpacked{"Email/Address.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EMAIL_ADDRESS';
  use strict;use warnings;package Email::Address;$Email::Address::VERSION='0.01';our$COMMENT_NEST_LEVEL ||= 1;our$STRINGIFY ||= 'format';our$COLLAPSE_SPACES=1 unless defined$COLLAPSE_SPACES;my$CTL=q{\x00-\x1F\x7F};my$special=q{()<>\\[\\]:;@\\\\,."};my$text=qr/[^\x0A\x0D]/;my$quoted_pair=qr/\\$text/;my$ctext=qr/(?>[^()\\]+)/;my ($ccontent,$comment)=(q{})x2;for (1 .. $COMMENT_NEST_LEVEL){$ccontent=qr/$ctext|$quoted_pair|$comment/;$comment=qr/\s*\((?:\s*$ccontent)*\s*\)\s*/}my$cfws=qr/$comment|\s+/;my$atext=qq/[^$CTL$special\\s]/;my$atom=qr/$cfws*$atext+$cfws*/;my$dot_atom_text=qr/$atext+(?:\.$atext+)*/;my$dot_atom=qr/$cfws*$dot_atom_text$cfws*/;my$qtext=qr/[^\\"]/;my$qcontent=qr/$qtext|$quoted_pair/;my$quoted_string=qr/$cfws*"$qcontent*"$cfws*/;my$word=qr/$atom|$quoted_string/;my$simple_word=qr/$atom|\.|\s*"$qcontent+"\s*/;my$obs_phrase=qr/$simple_word+/;my$phrase=qr/$obs_phrase|(?:$word+)/;my$local_part=qr/$dot_atom|$quoted_string/;my$dtext=qr/[^\[\]\\]/;my$dcontent=qr/$dtext|$quoted_pair/;my$domain_literal=qr/$cfws*\[(?:\s*$dcontent)*\s*\]$cfws*/;my$domain=qr/$dot_atom|$domain_literal/;my$display_name=$phrase;our$addr_spec=qr/$local_part\@$domain/;our$angle_addr=qr/$cfws*<$addr_spec>$cfws*/;our$name_addr=qr/(?>$display_name?)$angle_addr/;our$mailbox=qr/(?:$name_addr|$addr_spec)$comment*/;sub _PHRASE () {0}sub _ADDRESS () {1}sub _COMMENT () {2}sub _ORIGINAL () {3}sub _IN_CACHE () {4}sub __dump {return {phrase=>$_[0][_PHRASE],address=>$_[0][_ADDRESS],comment=>$_[0][_COMMENT],original=>$_[0][_ORIGINAL],}}our (%PARSE_CACHE,%FORMAT_CACHE,%NAME_CACHE);my$NOCACHE;sub __get_cached_parse {return if$NOCACHE;my ($class,$line)=@_;return @{$PARSE_CACHE{$line}}if exists$PARSE_CACHE{$line};return}sub __cache_parse {return if$NOCACHE;my ($class,$line,$addrs)=@_;$PARSE_CACHE{$line}=$addrs}sub parse {my ($class,$line)=@_;return unless$line;$line =~ s/[ \t]+/ /g if$COLLAPSE_SPACES;if (my@cached=$class->__get_cached_parse($line)){return@cached}my (@mailboxes)=($line =~ /$mailbox/go);my@addrs;for (@mailboxes){my$original=$_;my@comments=/($comment)/go;s/$comment//go if@comments;my ($user,$host,$com);($user,$host)=($1,$2)if s/<($local_part)\@($domain)>\s*\z//o;if (!defined($user)||!defined($host)){s/($local_part)\@($domain)//o;($user,$host)=($1,$2)}next if$user =~ /\P{ASCII}/;next if$host =~ /\P{ASCII}/;my ($phrase)=/($display_name)/o;for ($phrase,$host,$user,@comments){next unless defined $_;s/^\s+//;s/\s+$//;$_=undef unless length $_}$phrase =~ s/\\(.)/$1/g if$phrase;my$new_comment=join q{ },@comments;push@addrs,$class->new($phrase,"$user\@$host",$new_comment,$original);$addrs[-1]->[_IN_CACHE]=[\$line,$#addrs ]}$class->__cache_parse($line,\@addrs);return@addrs}sub new {my ($class,$phrase,$email,$comment,$orig)=@_;$phrase =~ s/\A"(.+)"\z/$1/ if$phrase;bless [$phrase,$email,$comment,$orig ]=>$class}sub purge_cache {%NAME_CACHE=();%FORMAT_CACHE=();%PARSE_CACHE=()}sub disable_cache {my ($class)=@_;$class->purge_cache;$NOCACHE=1}sub enable_cache {$NOCACHE=undef}BEGIN {my%_INDEX=(phrase=>_PHRASE,address=>_ADDRESS,comment=>_COMMENT,original=>_ORIGINAL,);for my$method (keys%_INDEX){no strict 'refs';my$index=$_INDEX{$method };*$method=sub {if ($_[1]){if ($_[0][_IN_CACHE]){my$replicant=bless [@{$_[0]}]=>ref $_[0];$PARSE_CACHE{${$_[0][_IN_CACHE][0]}}[$_[0][_IN_CACHE][1]]=$replicant;$_[0][_IN_CACHE]=undef}$_[0]->[$index ]=$_[1]}else {$_[0]->[$index ]}}}}sub host {($_[0]->[_ADDRESS]=~ /\@($domain)/o)[0]}sub user {($_[0]->[_ADDRESS]=~ /($local_part)\@/o)[0]}sub format {my$cache_str=do {no warnings 'uninitialized';"@{$_[0]}"};return$FORMAT_CACHE{$cache_str}if exists$FORMAT_CACHE{$cache_str};$FORMAT_CACHE{$cache_str}=$_[0]->_format}sub _format {my ($self)=@_;unless (defined$self->[_PHRASE]&& length$self->[_PHRASE]|| defined$self->[_COMMENT]&& length$self->[_COMMENT]){return defined$self->[_ADDRESS]? $self->[_ADDRESS]: ''}my$comment=defined$self->[_COMMENT]? $self->[_COMMENT]: '';$comment="($comment)" if length$comment and $comment !~ /\A\(.*\)\z/;my$format=sprintf q{%s <%s> %s},$self->_enquoted_phrase,(defined$self->[_ADDRESS]? $self->[_ADDRESS]: ''),$comment;$format =~ s/^\s+//;$format =~ s/\s+$//;return$format}sub _enquoted_phrase {my ($self)=@_;my$phrase=$self->[_PHRASE];return '' unless defined$phrase and length$phrase;return$phrase if$phrase =~ /\A=\?.+\?=\z/;$phrase =~ s/\A"(.+)"\z/$1/;$phrase =~ s/([\\"])/\\$1/g;return qq{"$phrase"}}sub name {my$cache_str=do {no warnings 'uninitialized';"@{$_[0]}"};return$NAME_CACHE{$cache_str}if exists$NAME_CACHE{$cache_str};my ($self)=@_;my$name=q{};if ($name=$self->[_PHRASE]){$name =~ s/^"//;$name =~ s/"$//;$name =~ s/($quoted_pair)/substr $1, -1/goe}elsif ($name=$self->[_COMMENT]){$name =~ s/^\(//;$name =~ s/\)$//;$name =~ s/($quoted_pair)/substr $1, -1/goe;$name =~ s/$comment/ /go}else {($name)=$self->[_ADDRESS]=~ /($local_part)\@/o}$NAME_CACHE{$cache_str}=$name}sub as_string {warn 'altering $Email::Address::STRINGIFY is deprecated; subclass instead' if$STRINGIFY ne 'format';$_[0]->can($STRINGIFY)->($_[0])}use overload '""'=>'as_string',fallback=>1;1;
EMAIL_ADDRESS

$fatpacked{"Exception/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS';
  package Exception::Class;use 5.008001;use strict;use warnings;our$VERSION='0.01';use Exception::Class::Base;use Scalar::Util qw(blessed reftype);our$BASE_EXC_CLASS;BEGIN {$BASE_EXC_CLASS ||= 'Exception::Class::Base'}our%CLASSES;sub import {my$class=shift;local$Exception::Class::Caller=caller();my%c;my%needs_parent;while (my$subclass=shift){my$def=ref $_[0]? shift : {};$def->{isa}=$def->{isa}? (ref$def->{isa}? $def->{isa}: [$def->{isa}]): [];$c{$subclass}=$def}MAKE_CLASSES: foreach my$subclass (sort {length$a <=> length$b}keys%c){my$def=$c{$subclass};next if$CLASSES{$subclass};{no strict 'refs';for my$parent (@{$def->{isa}}){unless (keys %{"$parent\::"}){$needs_parent{$subclass}={parents=>$def->{isa},def=>$def };next MAKE_CLASSES}}}$class->_make_subclass(subclass=>$subclass,def=>$def || {},)}for my$subclass (keys%needs_parent){my%seen;$class->_make_parents(\%needs_parent,$subclass,\%seen)}}sub _make_parents {my$class=shift;my$needs=shift;my$subclass=shift;my$seen=shift;my$child=shift;no strict 'refs';die "Class $subclass appears to be a typo as it is only specified in the 'isa' param for $child\n" unless exists$needs->{$subclass}|| $CLASSES{$subclass}|| keys %{"$subclass\::"};for my$c (@{$needs->{$subclass}{parents}}){next if$CLASSES{$c}|| keys %{"$c\::"};die "There appears to be some circularity involving $subclass\n" if$seen->{$subclass};$seen->{$subclass}=1;$class->_make_parents($needs,$c,$seen,$subclass)}return if$CLASSES{$subclass}|| keys %{"$subclass\::"};$class->_make_subclass(subclass=>$subclass,def=>$needs->{$subclass}{def})}sub _make_subclass {my$class=shift;my%p=@_;my$subclass=$p{subclass};my$def=$p{def};my$isa;if ($def->{isa}){$isa=ref$def->{isa}? join q{ },@{$def->{isa}}: $def->{isa}}$isa ||= $BASE_EXC_CLASS;my$version_name='VERSION';my$code=<<"EOPERL";if ($def->{description}){(my$desc=$def->{description})=~ s/([\\\'])/\\$1/g;$code .= <<"EOPERL"}my@fields;if (my$fields=$def->{fields}){@fields =ref$fields && reftype$fields eq 'ARRAY' ? @$fields : $fields;$code .= 'sub Fields { return ($_[0]->SUPER::Fields, ' .join(', ',map {"'$_'"}@fields).") }\n\n";for my$field (@fields){$code .= sprintf("sub %s { \$_[0]->{%s} }\n",$field,$field)}}if (my$alias=$def->{alias}){die 'Cannot make alias without caller' unless defined$Exception::Class::Caller;no strict 'refs';*{"$Exception::Class::Caller\::$alias"}=sub {$subclass->throw(@_)}}if (my$defaults=$def->{defaults}){$code .= "sub _defaults { return shift->SUPER::_defaults, our \%_DEFAULTS }\n";no strict 'refs';*{"$subclass\::_DEFAULTS"}={%$defaults}}eval$code;die $@ if $@;(my$filename="$subclass.pm")=~ s{::}{/}g;$INC{$filename}=__FILE__;$CLASSES{$subclass}=1}sub caught {my$e=$@;return$e unless $_[1];return unless blessed($e)&& $e->isa($_[1]);return$e}sub Classes {sort keys%Exception::Class::CLASSES}1;
  package $subclass;
  
  use base qw($isa);
  
  our \$$version_name = '1.1';
  
  1;
  
  EOPERL
  sub description
  {
      return '$desc';
  }
  EOPERL
EXCEPTION_CLASS

$fatpacked{"Exception/Class/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS_BASE';
  package Exception::Class::Base;use strict;use warnings;our$VERSION='0.01';use Class::Data::Inheritable 0.02;use Devel::StackTrace 2.00;use Scalar::Util qw(blessed);use base qw(Class::Data::Inheritable);BEGIN {__PACKAGE__->mk_classdata('Trace');__PACKAGE__->mk_classdata('UnsafeRefCapture');__PACKAGE__->mk_classdata('NoContextInfo');__PACKAGE__->NoContextInfo(0);__PACKAGE__->mk_classdata('RespectOverload');__PACKAGE__->RespectOverload(0);__PACKAGE__->mk_classdata('MaxArgLength');__PACKAGE__->MaxArgLength(0);sub NoRefs {my$self=shift;if (@_){my$val=shift;return$self->UnsafeRefCapture(!$val)}else {return$self->UnsafeRefCapture}}sub Fields {()}}use overload bool=>sub {1},'""'=>'as_string',fallback=>1;BEGIN {my@fields=qw(message pid uid euid gid egid time trace);for my$f (@fields){my$sub=sub {my$s=shift;return$s->{$f}};no strict 'refs';*{$f}=$sub}*error=\&message;my%trace_fields=(package=>'package',file=>'filename',line=>'line',);while (my ($f,$m)=each%trace_fields){my$sub=sub {my$s=shift;return$s->{$f}if exists$s->{$f};my$frame=$s->trace->frame(0);return$s->{$f}=$frame ? $frame->$m : undef};no strict 'refs';*{$f}=$sub}}sub Classes {Exception::Class::Classes()}sub throw {my$proto=shift;$proto->rethrow if ref$proto;die$proto->new(@_)}sub rethrow {my$self=shift;die$self}sub new {my$proto=shift;my$class=ref$proto || $proto;my$self=bless {},$class;$self->_initialize(@_);return$self}sub _initialize {my$self=shift;my%p=@_==1 ? (error=>$_[0]): @_;$self->{message}=$p{message}|| $p{error}|| q{};$self->{show_trace}=$p{show_trace}if exists$p{show_trace};if ($self->NoContextInfo){$self->{show_trace}=0;$self->{package}=$self->{file}=$self->{line}=undef}else {$self->{time}=CORE::time();$self->{pid}=$$;$self->{uid}=$<;$self->{euid}=$>;$self->{gid}=$(;$self->{egid}=$);my@ignore_class=(__PACKAGE__);my@ignore_package='Exception::Class';if (my$i=delete$p{ignore_class}){push@ignore_class,(ref($i)eq 'ARRAY' ? @$i : $i)}if (my$i=delete$p{ignore_package}){push@ignore_package,(ref($i)eq 'ARRAY' ? @$i : $i)}$self->{trace}=Devel::StackTrace->new(ignore_class=>\@ignore_class,ignore_package=>\@ignore_package,unsafe_ref_capture=>$self->UnsafeRefCapture,respect_overload=>$self->RespectOverload,max_arg_length=>$self->MaxArgLength,)}my%fields=map {$_=>1}$self->Fields;while (my ($key,$value)=each%p){next if$key =~ /^(?:error|message|show_trace)$/;if ($fields{$key}){$self->{$key}=$value}else {Exception::Class::Base->throw(error=>"unknown field $key passed to constructor for class " .ref$self)}}}sub context_hash {my$self=shift;return {time=>$self->{time},pid=>$self->{pid},uid=>$self->{uid},euid=>$self->{euid},gid=>$self->{gid},egid=>$self->{egid},}}sub field_hash {my$self=shift;my$hash={};for my$field ($self->Fields){$hash->{$field}=$self->$field}return$hash}sub description {return 'Generic exception'}sub show_trace {my$self=shift;return 0 unless$self->{trace};if (@_){$self->{show_trace}=shift}return exists$self->{show_trace}? $self->{show_trace}: $self->Trace}sub as_string {my$self=shift;my$str=$self->full_message;unless (defined$str && length$str){my$desc=$self->description;$str=defined$desc && length$desc ? "[$desc]" : '[Generic exception]'}$str .= "\n\n" .$self->trace->as_string if$self->show_trace;return$str}sub full_message {$_[0]->{message}}eval <<'EOF' if $]==5.006;sub caught {my$class=shift;my$e=$@;return unless defined$e && blessed($e)&& $e->isa($class);return$e}1;
  sub isa {
      my ( $inheritor, $base ) = @_;
      $inheritor = ref($inheritor) if ref($inheritor);
  
      my %seen;
  
      no strict 'refs';
      my @parents = ( $inheritor, @{"$inheritor\::ISA"} );
      while ( my $class = shift @parents ) {
          return 1 if $class eq $base;
  
          push @parents, grep { !$seen{$_}++ } @{"$class\::ISA"};
      }
      return 0;
  }
  EOF
EXCEPTION_CLASS_BASE

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;use 5.006001;use strict;use warnings;use Exporter::Tiny ();our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.01';sub import {my$me=shift;my$caller=caller;(my$nominal_file=$caller)=~ s(::)(/)g;$INC{"$nominal_file\.pm"}||= __FILE__;if (@_==2 and $_[0]eq -setup){my (undef,$opts)=@_;@_=@{delete($opts->{exports})|| []};if (%$opts){Exporter::Tiny::_croak('Unsupported Sub::Exporter-style options: %s',join(q[, ],sort keys %$opts),)}}ref($_)&& Exporter::Tiny::_croak('Expected sub name, got ref %s',$_)for @_;no strict qw(refs);push @{"$caller\::ISA"},'Exporter::Tiny';push @{"$caller\::EXPORT_OK"},@_}1;
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;use 5.006001;use strict;use warnings;no warnings qw(void once uninitialized numeric redefine);our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.01';our@EXPORT_OK=qw<mkopt mkopt_hash _croak _carp>;sub _croak ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::croak}sub _carp ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::carp}my$_process_optlist=sub {my$class=shift;my ($global_opts,$opts,$want,$not_want)=@_;while (@$opts){my$opt=shift @{$opts};my ($name,$value)=@$opt;($name =~ m{\A\!(/.+/[msixpodual]+)\z})? do {my@not=$class->_exporter_expand_regexp($1,$value,$global_opts);++$not_want->{$_->[0]}for@not}: ($name =~ m{\A\!(.+)\z})? (++$not_want->{$1}): ($name =~ m{\A[:-](.+)\z})? push(@$opts,$class->_exporter_expand_tag($1,$value,$global_opts)): ($name =~ m{\A/.+/[msixpodual]+\z})? push(@$opts,$class->_exporter_expand_regexp($name,$value,$global_opts)): push(@$want,$opt)}};sub import {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};$global_opts->{into}=caller unless exists$global_opts->{into};my@want;my%not_want;$global_opts->{not}=\%not_want;my@args=do {no strict qw(refs);@_ ? @_ : @{"$class\::EXPORT"}};my$opts=mkopt(\@args);$class->$_process_optlist($global_opts,$opts,\@want,\%not_want);my$permitted=$class->_exporter_permitted_regexp($global_opts);$class->_exporter_validate_opts($global_opts);for my$wanted (@want){next if$not_want{$wanted->[0]};my%symbols=$class->_exporter_expand_sub(@$wanted,$global_opts,$permitted);$class->_exporter_install_sub($_,$wanted->[1],$global_opts,$symbols{$_})for keys%symbols}}sub unimport {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};$global_opts->{into}=caller unless exists$global_opts->{into};$global_opts->{is_unimport}=1;my@want;my%not_want;$global_opts->{not}=\%not_want;my@args=do {our%TRACKED;@_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}})};my$opts=mkopt(\@args);$class->$_process_optlist($global_opts,$opts,\@want,\%not_want);my$permitted=$class->_exporter_permitted_regexp($global_opts);$class->_exporter_validate_unimport_opts($global_opts);my$expando=$class->can('_exporter_expand_sub');$expando=undef if$expando==\&_exporter_expand_sub;for my$wanted (@want){next if$not_want{$wanted->[0]};if ($wanted->[1]){_carp("Passing options to unimport '%s' makes no sense",$wanted->[0])unless (ref($wanted->[1])eq 'HASH' and not keys %{$wanted->[1]})}my%symbols=defined($expando)? $class->$expando(@$wanted,$global_opts,$permitted): ($wanted->[0]=>sub {"dummy"});$class->_exporter_uninstall_sub($_,$wanted->[1],$global_opts)for keys%symbols}}sub _exporter_validate_opts {1}sub _exporter_validate_unimport_opts {1}sub _exporter_merge_opts {my$class=shift;my ($tag_opts,$global_opts,@stuff)=@_;$tag_opts={}unless ref($tag_opts)eq q(HASH);_croak('Cannot provide an -as option for tags')if exists$tag_opts->{-as}&& ref$tag_opts->{-as}ne 'CODE';my$optlist=mkopt(\@stuff);for my$export (@$optlist){next if defined($export->[1])&& ref($export->[1])ne q(HASH);my%sub_opts=(%{$export->[1]or {}},%$tag_opts);$sub_opts{-prefix}=sprintf('%s%s',$tag_opts->{-prefix},$export->[1]{-prefix})if exists($export->[1]{-prefix})&& exists($tag_opts->{-prefix});$sub_opts{-suffix}=sprintf('%s%s',$export->[1]{-suffix},$tag_opts->{-suffix})if exists($export->[1]{-suffix})&& exists($tag_opts->{-suffix});$export->[1]=\%sub_opts}return @$optlist}sub _exporter_expand_tag {no strict qw(refs);my$class=shift;my ($name,$value,$globals)=@_;my$tags=\%{"$class\::EXPORT_TAGS"};return$class->_exporter_merge_opts($value,$globals,$tags->{$name}->($class,@_))if ref($tags->{$name})eq q(CODE);return$class->_exporter_merge_opts($value,$globals,@{$tags->{$name}})if exists$tags->{$name};return$class->_exporter_merge_opts($value,$globals,@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"})if$name eq 'all';return$class->_exporter_merge_opts($value,$globals,@{"$class\::EXPORT"})if$name eq 'default';$globals->{$name}=$value || 1;return}sub _exporter_expand_regexp {no strict qw(refs);our%TRACKED;my$class=shift;my ($name,$value,$globals)=@_;my$compiled=eval("qr$name");my@possible=$globals->{is_unimport}? keys(%{$TRACKED{$class}{$globals->{into}}}): @{"$class\::EXPORT_OK"};$class->_exporter_merge_opts($value,$globals,grep /$compiled/,@possible)}sub _exporter_permitted_regexp {no strict qw(refs);my$class=shift;my$re=join "|",map quotemeta,sort {length($b)<=> length($a)or $a cmp $b}@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"};qr{^(?:$re)$}ms}sub _exporter_expand_sub {my$class=shift;my ($name,$value,$globals,$permitted)=@_;$permitted ||= $class->_exporter_permitted_regexp($globals);no strict qw(refs);if ($name =~ $permitted){my$generator=$class->can("_generate_$name");return$name=>$class->$generator($name,$value,$globals)if$generator;my$sub=$class->can($name);return$name=>$sub if$sub}$class->_exporter_fail(@_)}sub _exporter_fail {my$class=shift;my ($name,$value,$globals)=@_;return if$globals->{is_unimport};_croak("Could not find sub '%s' exported by %s",$name,$class)}sub _exporter_install_sub {my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};my$installer=$globals->{installer}|| $globals->{exporter};$name=ref$globals->{as}? $globals->{as}->($name): ref$value->{-as}? $value->{-as}->($name): exists$value->{-as}? $value->{-as}: $name;return unless defined$name;unless (ref($name)){my ($prefix)=grep defined,$value->{-prefix},$globals->{prefix},q();my ($suffix)=grep defined,$value->{-suffix},$globals->{suffix},q();$name="$prefix$name$suffix"}return ($$name=$sym)if ref($name)eq q(SCALAR);return ($into->{$name}=$sym)if ref($into)eq q(HASH);no strict qw(refs);if (exists &{"$into\::$name"}and \&{"$into\::$name"}!=$sym){my ($level)=grep defined,$value->{-replace},$globals->{replace},q(0);my$action={carp=>\&_carp,0=>\&_carp,''=>\&_carp,warn=>\&_carp,nonfatal=>\&_carp,croak=>\&_croak,fatal=>\&_croak,die=>\&_croak,}->{$level}|| sub {};$action->($action==\&_croak ? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s" : "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",$into,$name,$_[0],$class,)}our%TRACKED;$TRACKED{$class}{$into}{$name}=$sym;no warnings qw(prototype);$installer ? $installer->($globals,[$name,$sym]): (*{"$into\::$name"}=$sym)}sub _exporter_uninstall_sub {our%TRACKED;my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};ref$into and return;no strict qw(refs);my$our_coderef=$TRACKED{$class}{$into}{$name};my$cur_coderef=exists(&{"$into\::$name"})? \&{"$into\::$name"}: -1;return unless$our_coderef==$cur_coderef;my$stash=\%{"$into\::"};my$old=delete$stash->{$name};my$full_name=join('::',$into,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});*$full_name=*{$old}{$type}}delete$TRACKED{$class}{$into}{$name}}sub mkopt {my$in=shift or return [];my@out;$in=[map(($_=>ref($in->{$_})? $in->{$_}: ()),sort keys %$in)]if ref($in)eq q(HASH);for (my$i=0;$i < @$in;$i++){my$k=$in->[$i];my$v;($i==$#$in)? ($v=undef): !defined($in->[$i+1])? (++$i,($v=undef)): !ref($in->[$i+1])? ($v=undef): ($v=$in->[++$i]);push@out,[$k=>$v ]}\@out}sub mkopt_hash {my$in=shift or return;my%out=map +($_->[0]=>$_->[1]),@{mkopt($in)};\%out}1;
EXPORTER_TINY

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.01';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.01';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.01';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.01';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.01';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.01';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"File/Find/Rule.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_FIND_RULE';
  package File::Find::Rule;use strict;use File::Spec;use Text::Glob 'glob_to_regex';use Number::Compare;use Carp qw/croak/;use File::Find ();our$VERSION='0.01';sub import {my$pkg=shift;my$to=caller;for my$sym (qw(find rule)){no strict 'refs';*{"$to\::$sym"}=\&{$sym}}for (grep /^:/,@_){my ($extension)=/^:(.*)/;eval "require File::Find::Rule::$extension";croak "couldn't bootstrap File::Find::Rule::$extension: $@" if $@}}*rule=\&find;sub find {my$object=__PACKAGE__->new();my$not=0;while (@_){my$method=shift;my@args;if ($method =~ s/^\!//){unshift @_,$method;$not=1;next}unless (defined prototype$method){my$args=shift;@args=ref$args eq 'ARRAY' ? @$args : $args}if ($not){$not=0;@args=$object->new->$method(@args);$method="not"}my@return=$object->$method(@args);return@return if$method eq 'in'}$object}sub new {my$referent=shift;my$class=ref$referent || $referent;bless {rules=>[],subs=>{},iterator=>[],extras=>{},maxdepth=>undef,mindepth=>undef,},$class}sub _force_object {my$object=shift;$object=$object->new()unless ref$object;$object}sub _flatten {my@flat;while (@_){my$item=shift;ref$item eq 'ARRAY' ? push @_,@{$item}: push@flat,$item}return@flat}sub name {my$self=_force_object shift;my@names=map {ref $_ eq "Regexp" ? $_ : glob_to_regex $_}_flatten(@_);push @{$self->{rules}},{rule=>'name',code=>join(' || ',map {"m{$_}"}@names),args=>\@_,};$self}use vars qw(%X_tests);%X_tests=(-r=>readable=>-R=>r_readable=>-w=>writeable=>-W=>r_writeable=>-w=>writable=>-W=>r_writable=>-x=>executable=>-X=>r_executable=>-o=>owned=>-O=>r_owned=>-e=>exists=>-f=>file=>-z=>empty=>-d=>directory=>-s=>nonempty=>-l=>symlink=>=>-p=>fifo=>-u=>setuid=>-S=>socket=>-g=>setgid=>-b=>block=>-k=>sticky=>-c=>character=>=>-t=>tty=>-M=>modified=>-A=>accessed=>-T=>ascii=>-C=>changed=>-B=>binary=>);for my$test (keys%X_tests){my$sub=eval 'sub () {
          my $self = _force_object shift;
          push @{ $self->{rules} }, {
              code => "' .$test .' \$_",
              rule => "'.$X_tests{$test}.'",
          };
          $self;
      } ';no strict 'refs';*{$X_tests{$test}}=$sub}use vars qw(@stat_tests);@stat_tests=qw(dev ino mode nlink uid gid rdev size atime mtime ctime blksize blocks);{my$i=0;for my$test (@stat_tests){my$index=$i++;my$sub=sub {my$self=_force_object shift;my@tests=map {Number::Compare->parse_to_perl($_)}@_;push @{$self->{rules}},{rule=>$test,args=>\@_,code=>'do { my $val = (stat $_)['.$index.'] || 0;'.join ('||',map {"(\$val $_)"}@tests).' }',};$self};no strict 'refs';*$test=$sub}}sub any {my$self=_force_object shift;push @{$self->{rules}},{rule=>"any",code=>'(' .join(' || ',map '( ' .$_->_compile .' )',@_).')',args=>\@_,};%{$self->{subs}}=map {%{$_->{subs}}}$self,@_;$self}*or=\&any;sub not {my$self=_force_object shift;push @{$self->{rules}},{rule=>'not',args=>\@_,code=>'(' .join (' && ',map {"!(".$_->_compile .")"}@_).")",};%{$self->{subs}}=map {%{$_->{subs}}}$self,@_;$self}*none=\&not;sub prune () {my$self=_force_object shift;push @{$self->{rules}},{rule=>'prune',code=>'$File::Find::prune = 1' };$self}sub discard () {my$self=_force_object shift;push @{$self->{rules}},{rule=>'discard',code=>'$discarded = 1',};$self}sub exec {my$self=_force_object shift;my$code=shift;push @{$self->{rules}},{rule=>'exec',code=>$code,};$self}sub grep {my$self=_force_object shift;my@pattern=map {ref $_ ? ref $_ eq 'ARRAY' ? map {[(ref $_ ? $_ : qr/$_/)=>0 ]}@$_ : [$_=>1 ]: [qr/$_/=>1 ]}@_;$self->exec(sub {local*FILE;open FILE,$_ or return;local ($_,$.);while (<FILE>){for my$p (@pattern){my ($rule,$ret)=@$p;return$ret if ref$rule eq 'Regexp' ? /$rule/ : $rule->(@_)}}return})}for my$setter (qw(maxdepth mindepth extras)){my$sub=sub {my$self=_force_object shift;$self->{$setter}=shift;$self};no strict 'refs';*$setter=$sub}sub relative () {my$self=_force_object shift;$self->{relative}=1;$self}sub canonpath () {my$self=_force_object shift;$self->{canonpath}=1;$self}sub DESTROY {}sub AUTOLOAD {our$AUTOLOAD;$AUTOLOAD =~ /::not_([^:]*)$/ or croak "Can't locate method $AUTOLOAD";my$method=$1;my$sub=sub {my$self=_force_object shift;$self->not($self->new->$method(@_))};{no strict 'refs';*$AUTOLOAD=$sub}&$sub}sub in {my$self=_force_object shift;my@found;my$fragment=$self->_compile;my%subs=%{$self->{subs}};warn "relative mode handed multiple paths - that's a bit silly\n" if$self->{relative}&& @_ > 1;my$topdir;my$code='sub {
          (my $path = $File::Find::name)  =~ s#^(?:\./+)+##;
          my @args = ($_, $File::Find::dir, $path);
          my $maxdepth = $self->{maxdepth};
          my $mindepth = $self->{mindepth};
          my $relative = $self->{relative};
          my $canonpath = $self->{canonpath};
  
          # figure out the relative path and depth
          my $relpath = $File::Find::name;
          $relpath =~ s{^\Q$topdir\E/?}{};
          my $depth = scalar File::Spec->splitdir($relpath);
          #print "name: \'$File::Find::name\' ";
          #print "relpath: \'$relpath\' depth: $depth relative: $relative\n";
  
          defined $maxdepth && $depth >= $maxdepth
             and $File::Find::prune = 1;
  
          defined $mindepth && $depth < $mindepth
             and return;
  
          #print "Testing \'$_\'\n";
  
          my $discarded;
          return unless ' .$fragment .';
          return if $discarded;
          if ($relative) {
              if ($relpath ne "") {
                  push @found, $canonpath ? File::Spec->canonpath($relpath) : $relpath;
              }
          }
          else {
              push @found, $canonpath ? File::Spec->canonpath($path) : $path;
          }
      }';my$sub=eval "$code" or die "compile error '$code' $@";for my$path (@_){$topdir=$path;$topdir =~ s{/?$}{} unless$topdir eq '/';$self->_call_find({%{$self->{extras}},wanted=>$sub},$path)}return@found}sub _call_find {my$self=shift;File::Find::find(@_)}sub _compile {my$self=shift;return '1' unless @{$self->{rules}};my$code=join " && ",map {if (ref $_->{code}){my$key="$_->{code}";$self->{subs}{$key}=$_->{code};"\$subs{'$key'}->(\@args) # $_->{rule}\n"}else {"( $_->{code} ) # $_->{rule}\n"}}@{$self->{rules}};return$code}sub start {my$self=_force_object shift;$self->{iterator}=[$self->in(@_)];$self}sub match {my$self=_force_object shift;return shift @{$self->{iterator}}}1;
FILE_FIND_RULE

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;use 5.00503;use strict;use Carp ();use Config ();use File::Spec ();use File::Which ();use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};BEGIN {$VERSION='0.01';require Exporter;@ISA=qw{Exporter};@EXPORT=qw{home};@EXPORT_OK=qw{home my_home my_desktop my_documents my_music my_pictures my_videos my_data my_dist_config my_dist_data users_home users_desktop users_documents users_music users_pictures users_videos users_data}}sub _CLASS ($) {(defined $_[0]and!ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*\z/s)? $_[0]: undef}sub _DRIVER ($$) {(defined _CLASS($_[0])and eval "require $_[0];" and!$@ and $_[0]->isa($_[1])and $_[0]ne $_[1])? $_[0]: undef}if ($IMPLEMENTED_BY){}elsif ($^O eq 'MSWin32'){$IMPLEMENTED_BY='File::HomeDir::Windows'}elsif ($^O eq 'darwin'){if (eval {require Mac::SystemDirectory;1}){$IMPLEMENTED_BY='File::HomeDir::Darwin::Cocoa'}elsif (eval {require Mac::Files;1}){$IMPLEMENTED_BY='File::HomeDir::Darwin::Carbon'}else {$IMPLEMENTED_BY='File::HomeDir::Darwin'}}elsif ($^O eq 'MacOS'){$IMPLEMENTED_BY='File::HomeDir::MacOS9'}elsif (File::Which::which('xdg-user-dir')){$IMPLEMENTED_BY='File::HomeDir::FreeDesktop'}else {$IMPLEMENTED_BY='File::HomeDir::Unix'}unless (_DRIVER($IMPLEMENTED_BY,'File::HomeDir::Driver')){Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY")}sub my_home {$IMPLEMENTED_BY->my_home}sub my_desktop {$IMPLEMENTED_BY->can('my_desktop')? $IMPLEMENTED_BY->my_desktop : Carp::croak("The my_desktop method is not implemented on this platform")}sub my_documents {$IMPLEMENTED_BY->can('my_documents')? $IMPLEMENTED_BY->my_documents : Carp::croak("The my_documents method is not implemented on this platform")}sub my_music {$IMPLEMENTED_BY->can('my_music')? $IMPLEMENTED_BY->my_music : Carp::croak("The my_music method is not implemented on this platform")}sub my_pictures {$IMPLEMENTED_BY->can('my_pictures')? $IMPLEMENTED_BY->my_pictures : Carp::croak("The my_pictures method is not implemented on this platform")}sub my_videos {$IMPLEMENTED_BY->can('my_videos')? $IMPLEMENTED_BY->my_videos : Carp::croak("The my_videos method is not implemented on this platform")}sub my_data {$IMPLEMENTED_BY->can('my_data')? $IMPLEMENTED_BY->my_data : Carp::croak("The my_data method is not implemented on this platform")}sub my_dist_data {my$params=ref $_[-1]eq 'HASH' ? pop : {};my$dist=pop or Carp::croak("The my_dist_data method requires an argument");my$data=my_data();return undef unless defined$data;my$var=$data eq home()? File::Spec->catdir($data,'.perl','dist',$dist): File::Spec->catdir($data,'Perl','dist',$dist);return$var if -d $var;return undef unless$params->{create};require File::Path;File::Path::mkpath($var);return$var}sub my_dist_config {my$params=ref $_[-1]eq 'HASH' ? pop : {};my$dist=pop or Carp::croak("The my_dist_config method requires an argument");my$config=$IMPLEMENTED_BY->can('my_config')? $IMPLEMENTED_BY->my_config : $IMPLEMENTED_BY->my_documents;return undef unless defined$config;my$etc=$config eq home()? File::Spec->catdir($config,'.perl',$dist): File::Spec->catdir($config,'Perl',$dist);return$etc if -d $etc;return undef unless$params->{create};require File::Path;File::Path::mkpath($etc);return$etc}sub users_home {$IMPLEMENTED_BY->can('users_home')? $IMPLEMENTED_BY->users_home($_[-1]): Carp::croak("The users_home method is not implemented on this platform")}sub users_desktop {$IMPLEMENTED_BY->can('users_desktop')? $IMPLEMENTED_BY->users_desktop($_[-1]): Carp::croak("The users_desktop method is not implemented on this platform")}sub users_documents {$IMPLEMENTED_BY->can('users_documents')? $IMPLEMENTED_BY->users_documents($_[-1]): Carp::croak("The users_documents method is not implemented on this platform")}sub users_music {$IMPLEMENTED_BY->can('users_music')? $IMPLEMENTED_BY->users_music($_[-1]): Carp::croak("The users_music method is not implemented on this platform")}sub users_pictures {$IMPLEMENTED_BY->can('users_pictures')? $IMPLEMENTED_BY->users_pictures($_[-1]): Carp::croak("The users_pictures method is not implemented on this platform")}sub users_videos {$IMPLEMENTED_BY->can('users_videos')? $IMPLEMENTED_BY->users_videos($_[-1]): Carp::croak("The users_videos method is not implemented on this platform")}sub users_data {$IMPLEMENTED_BY->can('users_data')? $IMPLEMENTED_BY->users_data($_[-1]): Carp::croak("The users_data method is not implemented on this platform")}sub home (;$) {if ($_[0]and $_[0]eq 'File::HomeDir'){shift()}return my_home()unless @_;my$name=shift;if (!defined$name){Carp::croak("Can't use undef as a username")}if (!length$name){Carp::croak("Can't use empty-string (\"\") as a username")}if ($name eq '.'){return my_home()}$IMPLEMENTED_BY->users_home($name)}CLASS: {package File::HomeDir::TIE;my$SINGLETON=bless {};sub TIEHASH {$SINGLETON}sub FETCH {unless (defined $_[1]){Carp::croak("Can't use undef as a username")}unless (length $_[1]){return File::HomeDir::my_home()}Carp::carp("The tied %~ hash has been deprecated");return File::HomeDir::home($_[1])}sub STORE {_bad('STORE')}sub EXISTS {_bad('EXISTS')}sub DELETE {_bad('DELETE')}sub CLEAR {_bad('CLEAR')}sub FIRSTKEY {_bad('FIRSTKEY')}sub NEXTKEY {_bad('NEXTKEY')}sub _bad ($) {Carp::croak("You can't $_[0] with the %~ hash")}}tie %~,'File::HomeDir::TIE';1;
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Unix ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='File::HomeDir::Unix'}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}my$home=(getpwuid($<))[7];return$home if$home && -d $home;return undef}sub _my_home {my($class,$path)=@_;my$home=$class->my_home;return undef unless defined$home;my$folder="$home/$path";unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}sub my_desktop {my$class=shift;$class->_my_home('Desktop')}sub my_documents {my$class=shift;$class->_my_home('Documents')}sub my_data {my$class=shift;$class->_my_home('Library/Application Support')}sub my_music {my$class=shift;$class->_my_home('Music')}sub my_pictures {my$class=shift;$class->_my_home('Pictures')}sub my_videos {my$class=shift;$class->_my_home('Movies')}sub users_home {my$class=shift;my$home=$class->SUPER::users_home(@_);return defined$home ? Cwd::abs_path($home): undef}sub users_desktop {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_desktop,$name)}sub users_documents {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_documents,$name)}sub users_data {my ($class,$name)=@_;$class->_to_user($class->my_data,$name)|| $class->users_home($name)}sub _to_user {my ($class,$path,$name)=@_;my$my_home=$class->my_home;my$users_home=$class->users_home($name);defined$users_home or return undef;$path =~ s/^\Q$my_home/$users_home/;return$path}1;
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Darwin ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='File::HomeDir::Darwin';local $@;eval "use prefork 'Mac::Files'"}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}require Mac::Files;$class->_find_folder(Mac::Files::kCurrentUserFolderType(),)}sub my_desktop {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kDesktopFolderType(),)}sub my_documents {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kDocumentsFolderType(),)}sub my_data {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kApplicationSupportFolderType(),)}sub my_music {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kMusicDocumentsFolderType(),)}sub my_pictures {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kPictureDocumentsFolderType(),)}sub my_videos {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kMovieDocumentsFolderType(),)}sub _find_folder {my$class=shift;my$name=shift;require Mac::Files;my$folder=Mac::Files::FindFolder(Mac::Files::kUserDomain(),$name,);return undef unless defined$folder;unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}sub users_home {my$class=shift;my$home=$class->SUPER::users_home(@_);return defined$home ? Cwd::abs_path($home): undef}sub users_desktop {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_desktop,$name)}sub users_documents {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_documents,$name)}sub users_data {my ($class,$name)=@_;$class->_to_user($class->my_data,$name)|| $class->users_home($name)}sub _to_user {my ($class,$path,$name)=@_;my$my_home=$class->my_home;my$users_home=$class->users_home($name);defined$users_home or return undef;$path =~ s/^\Q$my_home/$users_home/;return$path}1;
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Darwin ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='File::HomeDir::Darwin';local $@;eval "use prefork 'Mac::SystemDirectory'"}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}require Mac::SystemDirectory;return Mac::SystemDirectory::HomeDirectory()}sub my_desktop {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())}|| $class->SUPER::my_desktop}sub my_documents {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())}|| $class->SUPER::my_documents}sub my_data {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())}|| $class->SUPER::my_data}sub my_music {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())}|| $class->SUPER::my_music}sub my_pictures {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())}|| $class->SUPER::my_pictures}sub my_videos {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())}|| $class->SUPER::my_videos}sub _find_folder {my$class=shift;my$name=shift;require Mac::SystemDirectory;my$folder=Mac::SystemDirectory::FindDirectory($name);return undef unless defined$folder;unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}1;
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;use 5.00503;use strict;use Carp ();use vars qw{$VERSION};BEGIN {$VERSION='0.01'}sub my_home {Carp::croak("$_[0] does not implement compulsory method $_[1]")}1;
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;use 5.00503;use strict;use Carp ();use File::Spec ();use File::Which ();use File::HomeDir::Unix ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='File::HomeDir::Unix'}my$xdgprog=File::Which::which('xdg-user-dir');sub _my {my$thingy=qx($xdgprog $_[1]);chomp$thingy;return$thingy}sub my_desktop {shift->_my('DESKTOP')}sub my_documents {shift->_my('DOCUMENTS')}sub my_music {shift->_my('MUSIC')}sub my_pictures {shift->_my('PICTURES')}sub my_videos {shift->_my('VIDEOS')}sub my_data {$ENV{XDG_DATA_HOME}or File::Spec->catdir(shift->my_home,qw{.local share})}sub my_config {$ENV{XDG_CONFIG_HOME}or File::Spec->catdir(shift->my_home,qw{.config})}sub my_download {shift->_my('DOWNLOAD')}sub my_publicshare {shift->_my('PUBLICSHARE')}sub my_templates {shift->_my('TEMPLATES')}sub my_cache {$ENV{XDG_CACHE_HOME}|| File::Spec->catdir(shift->my_home,qw{.cache})}sub users_desktop {Carp::croak('The users_desktop method is not available on an XDG based system.')}sub users_documents {Carp::croak('The users_documents method is not available on an XDG based system.')}sub users_music {Carp::croak('The users_music method is not available on an XDG based system.')}sub users_pictures {Carp::croak('The users_pictures method is not available on an XDG based system.')}sub users_videos {Carp::croak('The users_videos method is not available on an XDG based system.')}sub users_data {Carp::croak('The users_data method is not available on an XDG based system.')}1;
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;use 5.00503;use strict;use Carp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='File::HomeDir::Driver'}SCOPE: {local $@;eval "use prefork 'Mac::Files'"}sub my_home {my$class=shift;if (defined$ENV{HOME}){return$ENV{HOME}}SCOPE: {local $@;eval {my$home=$class->my_desktop;return$home if$home and -d $home}}SCOPE: {local$SIG{'__DIE__'}='';my$home=(getpwuid($<))[7];return$home if$home and -d $home}Carp::croak("Could not locate current user's home directory")}sub my_desktop {my$class=shift;local$SIG{'__DIE__'}='';require Mac::Files;my$home=Mac::Files::FindFolder(Mac::Files::kOnSystemDisk(),Mac::Files::kDesktopFolderType(),);return$home if$home and -d $home;Carp::croak("Could not locate current user's desktop")}sub users_home {my ($class,$name)=@_;SCOPE: {local$SIG{'__DIE__'}='';my$home=(getpwnam($name))[7];return$home if defined$home and -d $home}Carp::croak("Failed to find home directory for user '$name'")}1;
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;use 5.00503;use strict;use Carp ();use File::Spec ();use File::Temp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA %DIR $ENABLED};BEGIN {$VERSION='0.01';@ISA='File::HomeDir::Driver';%DIR=();$ENABLED=0}sub import {my$class=shift;die "Attempted to initialise File::HomeDir::Test trice" if%DIR;my$BASE=File::Temp::tempdir(CLEANUP=>1);%DIR=map {$_=>File::Spec->catdir($BASE,$_)}qw{my_home my_desktop my_documents my_data my_music my_pictures my_videos};$ENV{HOME}=$DIR{my_home};$File::HomeDir::IMPLEMENTED_BY=$File::HomeDir::IMPLEMENTED_BY='File::HomeDir::Test';$ENABLED=1}sub my_home {mkdir($DIR{my_home},0755)unless -d $DIR{my_home};return$DIR{my_home}}sub my_desktop {mkdir($DIR{my_desktop},0755)unless -d $DIR{my_desktop};return$DIR{my_desktop}}sub my_documents {mkdir($DIR{my_documents},0755)unless -f $DIR{my_documents};return$DIR{my_documents}}sub my_data {mkdir($DIR{my_data},0755)unless -d $DIR{my_data};return$DIR{my_data}}sub my_music {mkdir($DIR{my_music},0755)unless -d $DIR{my_music};return$DIR{my_music}}sub my_pictures {mkdir($DIR{my_pictures},0755)unless -d $DIR{my_pictures};return$DIR{my_pictures}}sub my_videos {mkdir($DIR{my_videos},0755)unless -d $DIR{my_videos};return$DIR{my_videos}}sub users_home {return undef}1;
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;use 5.00503;use strict;use Carp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='File::HomeDir::Driver'}sub my_home {my$class=shift;my$home=$class->_my_home(@_);if (defined$home and!-d $home){$home=undef}return$home}sub _my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}if (exists$ENV{LOGDIR}and $ENV{LOGDIR}){return$ENV{LOGDIR}}SCOPE: {my$home=(getpwuid($<))[7];return$home if$home and -d $home}return undef}sub my_desktop {shift->my_home}sub my_documents {shift->my_home}sub my_data {shift->my_home}sub my_music {shift->my_home}sub my_pictures {shift->my_home}sub my_videos {shift->my_home}sub users_home {my ($class,$name)=@_;if ($name eq getpwuid($<)){return$class->my_home}SCOPE: {my$home=(getpwnam($name))[7];return$home if$home and -d $home}return undef}sub users_desktop {shift->users_home(@_)}sub users_documents {shift->users_home(@_)}sub users_data {shift->users_home(@_)}sub users_music {shift->users_home(@_)}sub users_pictures {shift->users_home(@_)}sub users_videos {shift->users_home(@_)}1;
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;use 5.00503;use strict;use Carp ();use File::Spec ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='File::HomeDir::Driver'}sub CREATE () {1}sub my_home {my$class=shift;if (exists$ENV{HOME}and $ENV{HOME}){return$ENV{HOME}}if (exists$ENV{USERPROFILE}and $ENV{USERPROFILE}){return$ENV{USERPROFILE}}if (exists$ENV{HOMEDRIVE}and exists$ENV{HOMEPATH}and $ENV{HOMEDRIVE}and $ENV{HOMEPATH}){return File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},'',)}return undef}sub my_desktop {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_DESKTOP(),CREATE);return$dir if$dir and $class->_d($dir)}for my$e ('USERPROFILE','WINDIR'){next unless$ENV{$e};my$desktop=File::Spec->catdir($ENV{$e},'Desktop');return$desktop if$desktop and $class->_d($desktop)}for my$fixed ("C:\\windows\\desktop","C:\\win95\\desktop","C:/win95/desktop","C:/windows/desktop",){return$fixed if$class->_d($fixed)}return undef}sub my_documents {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_PERSONAL(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_data {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_music {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_pictures {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_videos {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub _d {my$self=shift;my$path=shift;if ($path =~ /\\\\/){return 1}return -d $path}1;
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Remove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_REMOVE';
  package File::Remove;use 5.00503;use strict;use warnings;use vars qw{$VERSION @ISA @EXPORT_OK};use vars qw{$DEBUG $unlink $rmdir};BEGIN {$VERSION='0.01';@ISA=qw{Exporter};@EXPORT_OK=qw{remove rm clear trash}}use File::Path ();use File::Glob ();use File::Spec 3.29 ();use Cwd 3.29 ();use constant DEBUG=>!!$DEBUG;use constant IS_VMS=>!!($^O eq 'VMS');use constant IS_MAC=>!!($^O eq 'darwin');use constant IS_WIN32=>!!($^O =~ /^MSWin/ or $^O eq 'cygwin');my$glue;my@CLEANUP=();sub clear (@) {my@files=expand(@_);for my$file (@files){next unless -e $file;remove(\1,$file)}push@CLEANUP,map {[$$,$_ ]}@files}END {for my$file (@CLEANUP){next unless$file->[0]==$$;next unless -e $file->[1];remove(\1,$file->[1])}}sub remove (@) {my$recursive=(ref $_[0]eq 'SCALAR')? shift : \0;my$opts=(ref $_[0]eq 'HASH')? shift : {glob=>1};my@files=_expand_with_opts ($opts,@_);my@removes;for my$path (@files){if (-l $path){print "link: $path\n" if DEBUG;if ($unlink ? $unlink->($path): unlink($path)){push@removes,$path}next}unless (-e $path){print "missing: $path\n" if DEBUG;push@removes,$path;next}my$can_delete;if (IS_VMS){$can_delete=VMS::Filespec::candelete($path)}elsif (IS_WIN32){$can_delete=1}elsif (-w $path){$can_delete=1}elsif ($<==0){$can_delete=1}elsif ((lstat($path))[4]==$<){$can_delete=1}else {$can_delete=0}unless ($can_delete){print "nowrite: $path\n" if DEBUG;next}if (-f $path){print "file: $path\n" if DEBUG;unless (-w $path){(undef,undef,my$rp)=lstat$path or next;$rp &= 07777;$rp |= 0600;chmod$rp,$path}if ($unlink ? $unlink->($path): unlink($path)){next if -e $path;push@removes,$path}}elsif (-d $path){print "dir: $path\n" if DEBUG;my$dir=File::Spec->canonpath($path);my$chdir=_moveto($dir);if (length$chdir){chdir($chdir)or next}if ($$recursive){if (File::Path::rmtree([$dir ],DEBUG,0)){next if -e $path;push@removes,$path}}else {my ($save_mode)=(stat$dir)[2];chmod$save_mode & 0777,$dir;if ($rmdir ? $rmdir->($dir): rmdir($dir)){next if -e $path;push@removes,$path}}}else {print "???: $path\n" if DEBUG}}return@removes}sub rm (@) {goto&remove}sub trash (@) {local$unlink=$unlink;local$rmdir=$rmdir;if (ref $_[0]eq 'HASH'){my%options=%{+shift @_};$unlink=$options{unlink};$rmdir=$options{rmdir}}elsif (IS_WIN32){local $@;eval 'use Win32::FileOp ();';die "Can't load Win32::FileOp to support the Recycle Bin: \$@ = $@" if length $@;$unlink=\&Win32::FileOp::Recycle;$rmdir=\&Win32::FileOp::Recycle}elsif (IS_MAC){unless ($glue){local $@;eval 'use Mac::Glue ();';die "Can't load Mac::Glue::Finder to support the Trash Can: \$@ = $@" if length $@;$glue=Mac::Glue->new('Finder')}my$code=sub {my@files=map {Mac::Glue::param_type(Mac::Glue::typeAlias()=>$_)}@_;$glue->delete(\@files)};$unlink=$code;$rmdir=$code}else {die "Support for trash() on platform '$^O' not available at this time.\n"}remove(@_)}sub undelete (@) {goto&trash}sub _expand_with_opts {my$opts=shift;return ($opts->{glob}? expand(@_): @_)}sub expand (@) {map {-e $_ ? $_ : File::Glob::bsd_glob($_)}@_}sub _moveto {my$remove=File::Spec->rel2abs(shift);my$cwd=@_ ? shift : Cwd::cwd();$remove=Cwd::abs_path($remove);$cwd=Cwd::abs_path($cwd);my ($cv,$cd)=File::Spec->splitpath($cwd,1);my ($rv,$rd)=File::Spec->splitpath($remove,1);return '' unless$cv eq $rv;my@cd=File::Spec->splitdir($cd);my@rd=File::Spec->splitdir($rd);unless (@cd >= @rd){return ''}for (0 .. $#rd){$cd[$_]eq $rd[$_]or return ''}pop@rd;return File::Spec->catpath($rv,File::Spec->catdir(@rd),'')}1;
FILE_REMOVE

$fatpacked{"File/ShareDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SHAREDIR';
  package File::ShareDir;use 5.005;use strict;use warnings;use Carp ();use Config ();use Exporter ();use File::Spec ();use Class::Inspector ();use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};BEGIN {$VERSION='0.01';@ISA=qw{Exporter};@EXPORT_OK=qw{dist_dir dist_file module_dir module_file class_dir class_file};%EXPORT_TAGS=(ALL=>[@EXPORT_OK ],)}use constant IS_MACOS=>!!($^O eq 'MacOS');sub dist_dir {my$dist=_DIST(shift);my$dir;$dir=_dist_dir_new($dist);return$dir if defined$dir;$dir=_dist_dir_old($dist);return$dir if defined$dir;Carp::croak("Failed to find share dir for dist '$dist'")}sub _dist_dir_new {my$dist=shift;my$path=File::Spec->catdir('auto','share','dist',$dist,);for my$inc (@INC){next unless defined$inc and!ref$inc;my$dir=File::Spec->catdir($inc,$path);next unless -d $dir;unless (-r $dir){Carp::croak("Found directory '$dir', but no read permissions")}return$dir}return undef}sub _dist_dir_old {my$dist=shift;my$path=File::Spec->catdir('auto',split(/-/,$dist),);for my$inc (@INC){next unless defined$inc and!ref$inc;my$dir=File::Spec->catdir($inc,$path);next unless -d $dir;unless (-r $dir){Carp::croak("Found directory '$dir', but no read permissions")}return$dir}return undef}sub module_dir {my$module=_MODULE(shift);my$dir;$dir=_module_dir_new($module);return$dir if defined$dir;return _module_dir_old($module)}sub _module_dir_new {my$module=shift;my$path=File::Spec->catdir('auto','share','module',_module_subdir($module),);for my$inc (@INC){next unless defined$inc and!ref$inc;my$dir=File::Spec->catdir($inc,$path);next unless -d $dir;unless (-r $dir){Carp::croak("Found directory '$dir', but no read permissions")}return$dir}return undef}sub _module_dir_old {my$module=shift;my$short=Class::Inspector->filename($module);my$long=Class::Inspector->loaded_filename($module);$short =~ tr{/}{:} if IS_MACOS;substr($short,-3,3,'');$long =~ m/^(.*)\Q$short\E\.pm\z/s or die("Failed to find base dir");my$dir=File::Spec->catdir("$1",'auto',$short);unless (-d $dir){Carp::croak("Directory '$dir', does not exist")}unless (-r $dir){Carp::croak("Directory '$dir', no read permissions")}return$dir}sub dist_file {my$dist=_DIST(shift);my$file=_FILE(shift);my$path=_dist_file_new($dist,$file);return$path if defined$path;return _dist_file_old($dist,$file);}sub _dist_file_new {my$dist=shift;my$file=shift;my$dir=_dist_dir_new($dist);my$path=File::Spec->catfile($dir,$file);return undef unless -e $path;unless (-f $path){Carp::croak("Found dist_file '$path', but not a file")}unless (-r $path){Carp::croak("File '$path', no read permissions")}return$path}sub _dist_file_old {my$dist=shift;my$file=shift;my$path=File::Spec->catfile('auto',split(/-/,$dist),$file,);for my$inc (@INC){next unless defined$inc and!ref$inc;my$full=File::Spec->catdir($inc,$path);next unless -e $full;unless (-r $full){Carp::croak("Directory '$full', no read permissions")}return$full}Carp::croak("Failed to find shared file '$file' for dist '$dist'")}sub module_file {my$module=_MODULE(shift);my$file=_FILE(shift);my$dir=module_dir($module);my$path=File::Spec->catfile($dir,$file);unless (-e $path){Carp::croak("File '$file' does not exist in module dir")}unless (-r $path){Carp::croak("File '$file' cannot be read, no read permissions")}$path}sub class_file {my$module=_MODULE(shift);my$file=_FILE(shift);my@path=();my@queue=($module);my%seen=($module=>1);while (my$cl=shift@queue){push@path,$cl;no strict 'refs';unshift@queue,grep {!$seen{$_}++}map {s/^::/main::/;s/\'/::/g;$_}(@{"${cl}::ISA"})}for my$class (@path){local $@;my$dir=eval {module_dir($class)};next if $@;my$path=File::Spec->catfile($dir,$file);unless (-e $path){next}unless (-r $path){Carp::croak("File '$file' cannot be read, no read permissions")}return$path}Carp::croak("File '$file' does not exist in class or parent shared files")}sub _module_subdir {my$module=shift;$module =~ s/::/-/g;return$module}sub _dist_packfile {my$module=shift;my@dirs=grep {-e}($Config::Config{archlibexp},$Config::Config{sitearchexp});my$file=File::Spec->catfile('auto',split(/::/,$module),'.packlist',);for my$dir (@dirs){my$path=File::Spec->catfile($dir,$file);next unless -f $path;my$packlist=ExtUtils::Packlist->new($path);unless ($packlist){die "Failed to load .packlist file for $module"}die "CODE INCOMPLETE"}die "CODE INCOMPLETE"}sub _CLASS {(defined $_[0]and!ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*\z/s)? $_[0]: undef}sub _DIST {if (defined $_[0]and!ref $_[0]and $_[0]=~ /^[a-z0-9+_-]+$/is){return shift}Carp::croak("Not a valid distribution name")}sub _MODULE {my$module=_CLASS(shift)or Carp::croak("Not a valid module name");if (Class::Inspector->loaded($module)){return$module}Carp::croak("Module '$module' is not loaded")}sub _FILE {my$file=shift;unless (defined$file and!ref$file and length$file){Carp::croak("Did not pass a file name")}if (File::Spec->file_name_is_absolute($file)){Carp::croak("Cannot use absolute file name '$file'")}$file}1;
FILE_SHAREDIR

$fatpacked{"File/ShareDir/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SHAREDIR_INSTALL';
  package File::ShareDir::Install;use 5.008;use strict;use warnings;use Carp;use File::Spec;use IO::Dir;our$VERSION='0.01';our@DIRS;our%ALREADY;require Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(install_share delete_share);our@EXPORT_OK=qw(postamble install_share delete_share);our$INCLUDE_DOTFILES=0;our$INCLUDE_DOTDIRS=0;sub install_share {my$dir=@_ ? pop : 'share';my$type=@_ ? shift : 'dist';unless (defined$type and ($type =~ /^(module|dist)$/)){confess "Illegal or invalid share dir type '$type'"}if($type eq 'dist' and @_){confess "Too many parameters to install_share"}my$def=_mk_def($type);_add_module($def,$_[0]);_add_dir($def,$dir)}sub delete_share {my$dir=@_ ? pop : '';my$type=@_ ? shift : 'dist';unless (defined$type and ($type =~ /^(module|dist)$/)){confess "Illegal or invalid share dir type '$type'"}if($type eq 'dist' and @_){confess "Too many parameters to delete_share"}my$def=_mk_def("delete-$type");_add_module($def,$_[0]);_add_dir($def,$dir)}sub _mk_def {my($type)=@_;return {type=>$type,dotfiles=>$INCLUDE_DOTFILES,dotdirs=>$INCLUDE_DOTDIRS }}sub _add_module {my($def,$class)=@_;if($def->{type}=~ /module$/){my$module=_CLASS($class);unless (defined$module){confess "Missing or invalid module name '$_[0]'"}$def->{module}=$module}}sub _add_dir {my($def,$dir)=@_;$dir=[$dir ]unless ref$dir;my$del=0;$del=1 if$def->{type}=~ /^delete-/;for my$d (@$dir){unless ($del or (defined$d and -d $d)){confess "Illegal or missing directory '$d'"}if(not $del and $ALREADY{$d }++){confess "Directory '$d' is already being installed"}push@DIRS,{%$def };$DIRS[-1]{dir}=$d}}sub postamble {my$self=shift;my@ret;for my$def (@DIRS){push@ret,__postamble_share_dir($self,$def)}return join "\n",@ret}sub __postamble_share_dir {my($self,$def)=@_;my$dir=$def->{dir};my($idir);if($def->{type}eq 'delete-dist'){$idir=File::Spec->catdir(_dist_dir(),$dir)}elsif($def->{type}eq 'delete-module'){$idir=File::Spec->catdir(_module_dir($def),$dir)}elsif ($def->{type}eq 'dist'){$idir=_dist_dir()}else {$idir=_module_dir($def)}my@cmds;if($def->{type}=~ /^delete-/){@cmds="\$(RM_RF) $idir"}else {my$autodir='$(INST_LIB)';my$pm_to_blib=$self->oneliner(<<CODE,['-MExtUtils::Install']);my$files={};_scan_share_dir($files,$idir,$dir,$def);@cmds=$self->split_command($pm_to_blib,%$files)}my$r=join '',map {"\t\$(NOECHO) $_\n"}@cmds;return "config::\n$r"}sub _dist_dir {return File::Spec->catdir('$(INST_LIB)',qw(auto share dist),'$(DISTNAME)')}sub _module_dir {my($def)=@_;my$module=$def->{module};$module =~ s/::/-/g;return File::Spec->catdir('$(INST_LIB)',qw(auto share module),$module)}sub _scan_share_dir {my($files,$idir,$dir,$def)=@_;my$dh=IO::Dir->new($dir)or die "Unable to read $dir: $!";my$entry;while(defined($entry=$dh->read)){next if$entry =~ /(~|,v|#)$/;my$full=File::Spec->catfile($dir,$entry);if(-f $full){next if not $def->{dotfiles}and $entry =~ /^\./;$files->{$full }=File::Spec->catfile($idir,$entry)}elsif(-d $full){if($def->{dotdirs}){next if$entry eq '.' or $entry eq '..' or $entry =~ /^\.(svn|git|cvs)$/}else {next if$entry =~ /^\./}_scan_share_dir($files,File::Spec->catdir($idir,$entry),$full,$def)}}}sub _CLASS ($) {(defined $_[0]and !ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*$/s)? $_[0]: undef}1;
  pm_to_blib({\@ARGV}, '$autodir')
  CODE
FILE_SHAREDIR_INSTALL

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='0.01';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_DOS=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_CYG=>($^O eq 'cygwin');my@PATHEXT=('');if (IS_DOS){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_DOS and $exec =~ /\// and -f $exec and -x $exec;my@path=File::Spec->path;if (IS_DOS or IS_VMS or IS_MAC){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_DOS or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"Hook/LexWrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HOOK_LEXWRAP';
  use strict;use warnings;package Hook::LexWrap;our$VERSION='0.01';use Carp ();{no warnings 'redefine';*CORE::GLOBAL::caller=sub (;$) {my ($height)=($_[0]||0);my$i=1;my$name_cache;while (1){my@caller=CORE::caller()eq 'DB' ? do {package DB;CORE::caller($i++)}: CORE::caller($i++);return if not @caller;$caller[3]=$name_cache if$name_cache;$name_cache=$caller[0]eq 'Hook::LexWrap' ? $caller[3]: '';next if$name_cache || $height--!=0;return wantarray ? @_ ? @caller : @caller[0..2]: $caller[0]}}}sub import {no strict 'refs';*{caller()."::wrap"}=\&wrap}sub wrap (*@) {my ($typeglob,%wrapper)=@_;$typeglob=(ref$typeglob || $typeglob =~ /::/)? $typeglob : caller()."::$typeglob";my$original;{no strict 'refs';$original=ref$typeglob eq 'CODE' && $typeglob || *$typeglob{CODE}|| Carp::croak "Can't wrap non-existent subroutine ",$typeglob}Carp::croak "'$_' value is not a subroutine reference" foreach grep {$wrapper{$_}&& ref$wrapper{$_}ne 'CODE'}qw(pre post);no warnings 'redefine';my ($caller,$unwrap)=*CORE::GLOBAL::caller{CODE};my$imposter=sub {if ($unwrap){goto &$original}my ($return,$prereturn);if (wantarray){$prereturn=$return=[];()=$wrapper{pre}->(@_,$return)if$wrapper{pre};if (ref$return eq 'ARRAY' && $return==$prereturn &&!@$return){$return=[&$original ];()=$wrapper{post}->(@_,$return)if$wrapper{post}}return ref$return eq 'ARRAY' ? @$return : ($return)}elsif (defined wantarray){$return=bless sub {$prereturn=1},'Hook::LexWrap::Cleanup';my$dummy=$wrapper{pre}->(@_,$return)if$wrapper{pre};unless ($prereturn){$return=&$original;$dummy=scalar$wrapper{post}->(@_,$return)if$wrapper{post}}return$return}else {$return=bless sub {$prereturn=1},'Hook::LexWrap::Cleanup';$wrapper{pre}->(@_,$return)if$wrapper{pre};unless ($prereturn){&$original;$wrapper{post}->(@_,$return)if$wrapper{post}}return}};ref$typeglob eq 'CODE' and return defined wantarray ? $imposter : Carp::carp "Uselessly wrapped subroutine reference in void context";{no strict 'refs';*{$typeglob}=$imposter}return unless defined wantarray;return bless sub{$unwrap=1},'Hook::LexWrap::Cleanup'}package Hook::LexWrap::Cleanup;sub DESTROY {$_[0]->()}use overload q{""}=>sub {undef},q{0+}=>sub {undef},q{bool}=>sub {undef},q{fallback}=>1;1;
HOOK_LEXWRAP

$fatpacked{"IO/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_STRING';
  package IO::String;require 5.005_03;use strict;use vars qw($VERSION $DEBUG $IO_CONSTANTS);$VERSION="0.01";use Symbol ();sub new {my$class=shift;my$self=bless Symbol::gensym(),ref($class)|| $class;tie *$self,$self;$self->open(@_);return$self}sub open {my$self=shift;return$self->new(@_)unless ref($self);if (@_){my$bufref=ref($_[0])? $_[0]: \$_[0];$$bufref="" unless defined $$bufref;*$self->{buf}=$bufref}else {my$buf="";*$self->{buf}=\$buf}*$self->{pos}=0;*$self->{lno}=0;return$self}sub pad {my$self=shift;my$old=*$self->{pad};*$self->{pad}=substr($_[0],0,1)if @_;return "\0" unless defined($old)&& length($old);return$old}sub dump {require Data::Dumper;my$self=shift;print Data::Dumper->Dump([$self],['*self']);print Data::Dumper->Dump([*$self{HASH}],['$self{HASH}']);return}sub TIEHANDLE {print "TIEHANDLE @_\n" if$DEBUG;return $_[0]if ref($_[0]);my$class=shift;my$self=bless Symbol::gensym(),$class;$self->open(@_);return$self}sub DESTROY {print "DESTROY @_\n" if$DEBUG}sub close {my$self=shift;delete *$self->{buf};delete *$self->{pos};delete *$self->{lno};undef *$self if $] eq "5.008";return 1}sub opened {my$self=shift;return defined *$self->{buf}}sub binmode {my$self=shift;return 1 unless @_;return 0}sub getc {my$self=shift;my$buf;return$buf if$self->read($buf,1);return undef}sub ungetc {my$self=shift;$self->setpos($self->getpos()- 1);return 1}sub eof {my$self=shift;return length(${*$self->{buf}})<= *$self->{pos}}sub print {my$self=shift;if (defined $\){if (defined $,){$self->write(join($,,@_).$\)}else {$self->write(join("",@_).$\)}}else {if (defined $,){$self->write(join($,,@_))}else {$self->write(join("",@_))}}return 1}*printflush=\*print;sub printf {my$self=shift;print "PRINTF(@_)\n" if$DEBUG;my$fmt=shift;$self->write(sprintf($fmt,@_));return 1}my($SEEK_SET,$SEEK_CUR,$SEEK_END);sub _init_seek_constants {if ($IO_CONSTANTS){require IO::Handle;$SEEK_SET=&IO::Handle::SEEK_SET;$SEEK_CUR=&IO::Handle::SEEK_CUR;$SEEK_END=&IO::Handle::SEEK_END}else {$SEEK_SET=0;$SEEK_CUR=1;$SEEK_END=2}}sub seek {my($self,$off,$whence)=@_;my$buf=*$self->{buf}|| return 0;my$len=length($$buf);my$pos=*$self->{pos};_init_seek_constants()unless defined$SEEK_SET;if ($whence==$SEEK_SET){$pos=$off}elsif ($whence==$SEEK_CUR){$pos += $off}elsif ($whence==$SEEK_END){$pos=$len + $off}else {die "Bad whence ($whence)"}print "SEEK(POS=$pos,OFF=$off,LEN=$len)\n" if$DEBUG;$pos=0 if$pos < 0;$self->truncate($pos)if$pos > $len;*$self->{pos}=$pos;return 1}sub pos {my$self=shift;my$old=*$self->{pos};if (@_){my$pos=shift || 0;my$buf=*$self->{buf};my$len=$buf ? length($$buf): 0;$pos=$len if$pos > $len;*$self->{pos}=$pos}return$old}sub getpos {shift->pos}*sysseek=\&seek;*setpos=\&pos;*tell=\&getpos;sub getline {my$self=shift;my$buf=*$self->{buf}|| return;my$len=length($$buf);my$pos=*$self->{pos};return if$pos >= $len;unless (defined $/){*$self->{pos}=$len;return substr($$buf,$pos)}unless (length $/){my$para="";my$eol=0;my$c;while (defined($c=$self->getc)){if ($c eq "\n"){$eol++;next if$eol > 2}elsif ($eol > 1){$self->ungetc($c);last}else {$eol=0}$para .= $c}return$para}my$idx=index($$buf,$/,$pos);if ($idx < 0){*$self->{pos}=$len;$.=++ *$self->{lno};return substr($$buf,$pos)}$len=$idx - $pos + length($/);*$self->{pos}+= $len;$.=++ *$self->{lno};return substr($$buf,$pos,$len)}sub getlines {die "getlines() called in scalar context\n" unless wantarray;my$self=shift;my($line,@lines);push(@lines,$line)while defined($line=$self->getline);return@lines}sub READLINE {goto&getlines if wantarray;goto&getline}sub input_line_number {my$self=shift;my$old=*$self->{lno};*$self->{lno}=shift if @_;return$old}sub truncate {my$self=shift;my$len=shift || 0;my$buf=*$self->{buf};if (length($$buf)>= $len){substr($$buf,$len)='';*$self->{pos}=$len if$len < *$self->{pos}}else {$$buf .= ($self->pad x ($len - length($$buf)))}return 1}sub read {my$self=shift;my$buf=*$self->{buf};return undef unless$buf;my$pos=*$self->{pos};my$rem=length($$buf)- $pos;my$len=$_[1];$len=$rem if$len > $rem;return undef if$len < 0;if (@_ > 2){substr($_[0],$_[2])=substr($$buf,$pos,$len)}else {$_[0]=substr($$buf,$pos,$len)}*$self->{pos}+= $len;return$len}sub write {my$self=shift;my$buf=*$self->{buf};return unless$buf;my$pos=*$self->{pos};my$slen=length($_[0]);my$len=$slen;my$off=0;if (@_ > 1){$len=$_[1]if $_[1]< $len;if (@_ > 2){$off=$_[2]|| 0;die "Offset outside string" if$off > $slen;if ($off < 0){$off += $slen;die "Offset outside string" if$off < 0}my$rem=$slen - $off;$len=$rem if$rem < $len}}substr($$buf,$pos,$len)=substr($_[0],$off,$len);*$self->{pos}+= $len;return$len}*sysread=\&read;*syswrite=\&write;sub stat {my$self=shift;return unless$self->opened;return 1 unless wantarray;my$len=length ${*$self->{buf}};return (undef,undef,0666,1,$>,$),undef,$len,undef,undef,undef,512,int(($len+511)/512))}sub FILENO {return undef}sub blocking {my$self=shift;my$old=*$self->{blocking}|| 0;*$self->{blocking}=shift if @_;return$old}my$notmuch=sub {return};*fileno=$notmuch;*error=$notmuch;*clearerr=$notmuch;*sync=$notmuch;*flush=$notmuch;*setbuf=$notmuch;*setvbuf=$notmuch;*untaint=$notmuch;*autoflush=$notmuch;*fcntl=$notmuch;*ioctl=$notmuch;*GETC=\&getc;*PRINT=\&print;*PRINTF=\&printf;*READ=\&read;*WRITE=\&write;*SEEK=\&seek;*TELL=\&getpos;*EOF=\&eof;*CLOSE=\&close;*BINMODE=\&binmode;sub string_ref {my$self=shift;return *$self->{buf}}*sref=\&string_ref;1;
IO_STRING

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;use strict;use Carp ();use base qw(Exporter);@JSON::EXPORT=qw(from_json to_json jsonToObj objToJson encode_json decode_json);BEGIN {$JSON::VERSION='0.01';$JSON::DEBUG=0 unless (defined$JSON::DEBUG);$JSON::DEBUG=$ENV{PERL_JSON_DEBUG }if exists$ENV{PERL_JSON_DEBUG }}my$Module_XS='JSON::XS';my$Module_PP='JSON::PP';my$Module_bp='JSON::backportPP';my$PP_Version='2.27203';my$XS_Version='2.34';my@PublicMethods=qw/ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref allow_blessed convert_blessed filter_json_object filter_json_single_key_object shrink max_depth max_size encode decode decode_prefix allow_unknown/;my@Properties=qw/ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref allow_blessed convert_blessed shrink max_depth max_size allow_unknown/;my@XSOnlyMethods=qw/allow_tags/;my@PPOnlyMethods=qw/indent_length sort_by allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed/;my$_INSTALL_DONT_DIE=1;my$_INSTALL_ONLY=2;my$_ALLOW_UNSUPPORTED=0;my$_UNIV_CONV_BLESSED=0;my$_USSING_bpPP=0;unless ($JSON::Backend){$JSON::DEBUG and Carp::carp("Check used worker module...");my$backend=exists$ENV{PERL_JSON_BACKEND}? $ENV{PERL_JSON_BACKEND}: 1;if ($backend eq '1' or $backend =~ /JSON::XS\s*,\s*JSON::PP/){_load_xs($_INSTALL_DONT_DIE)or _load_pp()}elsif ($backend eq '0' or $backend eq 'JSON::PP'){_load_pp()}elsif ($backend eq '2' or $backend eq 'JSON::XS'){_load_xs()}elsif ($backend eq 'JSON::backportPP'){$_USSING_bpPP=1;_load_pp()}else {Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid."}}sub import {my$pkg=shift;my@what_to_export;my$no_export;for my$tag (@_){if ($tag eq '-support_by_pp'){if (!$_ALLOW_UNSUPPORTED++){JSON::Backend::XS ->support_by_pp(@PPOnlyMethods)if ($JSON::Backend eq $Module_XS)}next}elsif ($tag eq '-no_export'){$no_export++,next}elsif ($tag eq '-convert_blessed_universally'){eval q|
                  require B;
                  *UNIVERSAL::TO_JSON = sub {
                      my $b_obj = B::svref_2object( $_[0] );
                      return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                              : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                              : undef
                              ;
                  }
              | if (!$_UNIV_CONV_BLESSED++);next}push@what_to_export,$tag}return if ($no_export);__PACKAGE__->export_to_level(1,$pkg,@what_to_export)}sub jsonToObj {my$alternative='from_json';if (defined $_[0]and UNIVERSAL::isa($_[0],'JSON')){shift @_;$alternative='decode'}Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";return JSON::from_json(@_)};sub objToJson {my$alternative='to_json';if (defined $_[0]and UNIVERSAL::isa($_[0],'JSON')){shift @_;$alternative='encode'}Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";JSON::to_json(@_)};sub to_json ($@) {if (ref($_[0])eq 'JSON' or (@_ > 2 and $_[0]eq 'JSON')){Carp::croak "to_json should not be called as a method."}my$json=JSON->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}$json->encode($_[0])}sub from_json ($@) {if (ref($_[0])eq 'JSON' or $_[0]eq 'JSON'){Carp::croak "from_json should not be called as a method."}my$json=JSON->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}return$json->decode($_[0])}sub true {$JSON::true}sub false {$JSON::false}sub null {undef}sub require_xs_version {$XS_Version}sub backend {my$proto=shift;$JSON::Backend}sub is_xs {return $_[0]->backend eq $Module_XS}sub is_pp {return not $_[0]->is_xs}sub pureperl_only_methods {@PPOnlyMethods}sub property {my ($self,$name,$value)=@_;if (@_==1){my%props;for$name (@Properties){my$method='get_' .$name;if ($name eq 'max_size'){my$value=$self->$method();$props{$name}=$value==1 ? 0 : $value;next}$props{$name}=$self->$method()}return \%props}elsif (@_ > 3){Carp::croak('property() can take only the option within 2 arguments.')}elsif (@_==2){if (my$method=$self->can('get_' .$name)){if ($name eq 'max_size'){my$value=$self->$method();return$value==1 ? 0 : $value}$self->$method()}}else {$self->$name($value)}}sub _load_xs {my$opt=shift;$JSON::DEBUG and Carp::carp "Load $Module_XS.";JSON::Boolean::_overrride_overload($Module_XS);JSON::Boolean::_overrride_overload($Module_PP);eval qq|
          use $Module_XS $XS_Version ();
      |;if ($@){if (defined$opt and $opt & $_INSTALL_DONT_DIE){$JSON::DEBUG and Carp::carp "Can't load $Module_XS...($@)";return 0}Carp::croak $@}unless (defined$opt and $opt & $_INSTALL_ONLY){_set_module($JSON::Backend=$Module_XS);my$data=join("",<DATA>);close(DATA);eval$data;JSON::Backend::XS->init}return 1};sub _load_pp {my$opt=shift;my$backend=$_USSING_bpPP ? $Module_bp : $Module_PP;$JSON::DEBUG and Carp::carp "Load $backend.";JSON::Boolean::_overrride_overload($Module_XS);JSON::Boolean::_overrride_overload($backend);if ($_USSING_bpPP){eval qq| require $backend |}else {eval qq| use $backend $PP_Version () |}if ($@){if ($backend eq $Module_PP){$JSON::DEBUG and Carp::carp "Can't load $Module_PP ($@), so try to load $Module_bp";$_USSING_bpPP++;$backend=$Module_bp;JSON::Boolean::_overrride_overload($backend);local $^W;eval qq| require $Module_bp |}Carp::croak $@ if $@}unless (defined$opt and $opt & $_INSTALL_ONLY){_set_module($JSON::Backend=$Module_PP);JSON::Backend::PP->init}};sub _set_module {return if defined$JSON::true;my$module=shift;local $^W;no strict qw(refs);$JSON::true=${"$module\::true"};$JSON::false=${"$module\::false"};push@JSON::ISA,$module;if (JSON->is_xs and JSON->backend->VERSION < 3){eval 'package JSON::PP::Boolean';push @{"$module\::Boolean::ISA"},qw(JSON::PP::Boolean)}*{"JSON::is_bool"}=\&{"$module\::is_bool"};for my$method ($module eq $Module_XS ? @PPOnlyMethods : @XSOnlyMethods){*{"JSON::$method"}=sub {Carp::carp("$method is not supported in $module.");$_[0]}}return 1}package JSON::Boolean;my%Installed;sub _overrride_overload {return;return if ($Installed{$_[0]}++);my$boolean=$_[0].'::Boolean';eval sprintf(q|
          package %s;
          use overload (
              '""' => sub { ${$_[0]} == 1 ? 'true' : 'false' },
              'eq' => sub {
                  my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
                  if ($op eq 'true' or $op eq 'false') {
                      return "$obj" eq 'true' ? 'true' eq $op : 'false' eq $op;
                  }
                  else {
                      return $obj ? 1 == $op : 0 == $op;
                  }
              },
          );
      |,$boolean);if ($@){Carp::croak $@}if (exists$INC{'JSON/XS.pm'}and $boolean eq 'JSON::XS::Boolean'){local $^W;my$true=do {bless \(my$dummy=1),$boolean};my$false=do {bless \(my$dummy=0),$boolean};*JSON::XS::true=sub () {$true};*JSON::XS::false=sub () {$false}}elsif (exists$INC{'JSON/PP.pm'}and $boolean eq 'JSON::PP::Boolean'){local $^W;my$true=do {bless \(my$dummy=1),$boolean};my$false=do {bless \(my$dummy=0),$boolean};*JSON::PP::true=sub {$true};*JSON::PP::false=sub {$false}}return 1}package JSON::Backend::PP;sub init {local $^W;no strict qw(refs);*{"JSON::decode_json"}=\&{"JSON::PP::decode_json"};*{"JSON::encode_json"}=\&{"JSON::PP::encode_json"};*{"JSON::PP::is_xs"}=sub {0};*{"JSON::PP::is_pp"}=sub {1};return 1}package JSON;1;__DATA__ 
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  use constant INDENT_LENGTH_FLAG => 15 << 12;
  
  use constant UNSUPPORTED_ENCODE_FLAG => {
      ESCAPE_SLASH      => 0x00000010,
      ALLOW_BIGNUM      => 0x00000020,
      AS_NONBLESSED     => 0x00000040,
      EXPANDED          => 0x10000000, # for developer's
  };
  
  use constant UNSUPPORTED_DECODE_FLAG => {
      LOOSE             => 0x00000001,
      ALLOW_BIGNUM      => 0x00000002,
      ALLOW_BAREKEY     => 0x00000004,
      ALLOW_SINGLEQUOTE => 0x00000008,
      EXPANDED          => 0x20000000, # for developer's
  };
  
  
  sub init {
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"JSON::XS::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::XS::encode_json"};
      *{"JSON::XS::is_xs"}  = sub { 1 };
      *{"JSON::XS::is_pp"}  = sub { 0 };
      return 1;
  }
  
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      local $^W;
      no strict qw(refs);
  
      my $JSON_XS_encode_orignal     = \&JSON::XS::encode;
      my $JSON_XS_decode_orignal     = \&JSON::XS::decode;
      my $JSON_XS_incr_parse_orignal = \&JSON::XS::incr_parse;
  
      *JSON::XS::decode     = \&JSON::Backend::XS::Supportable::_decode;
      *JSON::XS::encode     = \&JSON::Backend::XS::Supportable::_encode;
      *JSON::XS::incr_parse = \&JSON::Backend::XS::Supportable::_incr_parse;
  
      *{JSON::XS::_original_decode}     = $JSON_XS_decode_orignal;
      *{JSON::XS::_original_encode}     = $JSON_XS_encode_orignal;
      *{JSON::XS::_original_incr_parse} = $JSON_XS_incr_parse_orignal;
  
      push @JSON::Backend::XS::Supportable::ISA, 'JSON';
  
      my $pkg = 'JSON::Backend::XS::Supportable';
  
      *{JSON::new} = sub {
          my $proto = JSON::XS->new; $$proto = 0;
          bless  $proto, $pkg;
      };
  
  
      for my $method (@methods) {
          my $flag = uc($method);
          my $type |= (UNSUPPORTED_ENCODE_FLAG->{$flag} || 0);
             $type |= (UNSUPPORTED_DECODE_FLAG->{$flag} || 0);
  
          next unless($type);
  
          $pkg->_make_unsupported_method($method => $type);
      }
  
  #    push @{"JSON::XS::Boolean::ISA"}, qw(JSON::PP::Boolean);
  #    push @{"JSON::PP::Boolean::ISA"}, qw(JSON::Boolean);
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  
      return 1;
  }
  
  
  
  
  #
  # Helper classes for XS
  #
  
  package JSON::Backend::XS::Supportable;
  
  $Carp::Internal{'JSON::Backend::XS::Supportable'} = 1;
  
  sub _make_unsupported_method {
      my ($pkg, $method, $type) = @_;
  
      local $^W;
      no strict qw(refs);
  
      *{"$pkg\::$method"} = sub {
          local $^W;
          if (defined $_[1] ? $_[1] : 1) {
              ${$_[0]} |= $type;
          }
          else {
              ${$_[0]} &= ~$type;
          }
          $_[0];
      };
  
      *{"$pkg\::get_$method"} = sub {
          ${$_[0]} & $type ? 1 : '';
      };
  
  }
  
  
  sub _set_for_pp {
      JSON::_load_pp( $_INSTALL_ONLY );
  
      my $type  = shift;
      my $pp    = JSON::PP->new;
      my $prop = $_[0]->property;
  
      for my $name (keys %$prop) {
          $pp->$name( $prop->{$name} ? $prop->{$name} : 0 );
      }
  
      my $unsupported = $type eq 'encode' ? JSON::Backend::XS::UNSUPPORTED_ENCODE_FLAG
                                          : JSON::Backend::XS::UNSUPPORTED_DECODE_FLAG;
      my $flags       = ${$_[0]} || 0;
  
      for my $name (keys %$unsupported) {
          next if ($name eq 'EXPANDED'); # for developer's
          my $enable = ($flags & $unsupported->{$name}) ? 1 : 0;
          my $method = lc $name;
          $pp->$method($enable);
      }
  
      $pp->indent_length( $_[0]->get_indent_length );
  
      return $pp;
  }
  
  sub _encode { # using with PP encode
      if (${$_[0]}) {
          _set_for_pp('encode' => @_)->encode($_[1]);
      }
      else {
          $_[0]->_original_encode( $_[1] );
      }
  }
  
  
  sub _decode { # if unsupported-flag is set, use PP
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->decode($_[1]);
      }
      else {
          $_[0]->_original_decode( $_[1] );
      }
  }
  
  
  sub decode_prefix { # if unsupported-flag is set, use PP
      _set_for_pp('decode' => @_)->decode_prefix($_[1]);
  }
  
  
  sub _incr_parse {
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->incr_parse($_[1]);
      }
      else {
          $_[0]->_original_incr_parse( $_[1] );
      }
  }
  
  
  sub get_indent_length {
      ${$_[0]} << 4 >> 16;
  }
  
  
  sub indent_length {
      my $length = $_[1];
  
      if (!defined $length or $length > 15 or $length < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          local $^W;
          $length <<= 12;
          ${$_[0]} &= ~ JSON::Backend::XS::INDENT_LENGTH_FLAG;
          ${$_[0]} |= $length;
          *JSON::XS::encode = \&JSON::Backend::XS::Supportable::_encode;
      }
  
      $_[0];
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # If you want to use PP only support features, call with '-support_by_pp'
   # When XS unsupported feature is enable, using PP (de|en)code instead of XS ones.
   
   use JSON -support_by_pp;
   
   # option-acceptable interfaces (expect/generate UNICODE by default)
   
   $json_text   = to_json( $perl_scalar, { ascii => 1, pretty => 1 } );
   $perl_scalar = from_json( $json_text, { utf8  => 1 } );
   
   # Between (en|de)code_json and (to|from)_json, if you want to write
   # a code which communicates to an outer world (encoded in UTF-8),
   # recommend to use (en|de)code_json.
   
  =head1 VERSION
  
      2.90
  
  This version is compatible with JSON::XS B<2.34> and later.
  (Not yet compatble to JSON::XS B<3.0x>.)
  
  
  =head1 NOTE
  
  JSON::PP was earlier included in the C<JSON> distribution, but
  has since Perl 5.14 been a core module. For this reason,
  L<JSON::PP> was removed from the JSON distribution and can now
  be found also in the Perl5 repository at
  
  =over
  
  =item * L<http://perl5.git.perl.org/perl.git>
  
  =back
  
  (The newest JSON::PP version still exists in CPAN.)
  
  Instead, the C<JSON> distribution will include JSON::backportPP
  for backwards computability. JSON.pm should thus work as it did
  before.
  
  =head1 DESCRIPTION
  
   *************************** CAUTION **************************************
   *                                                                        *
   * INCOMPATIBLE CHANGE (JSON::XS version 2.90)                            *
   *                                                                        *
   * JSON.pm had patched JSON::XS::Boolean and JSON::PP::Boolean internally *
   * on loading time for making these modules inherit JSON::Boolean.        *
   * But since JSON::XS v3.0 it use Types::Serialiser as boolean class.     *
   * Then now JSON.pm breaks boolean classe overload features and           *
   * -support_by_pp if JSON::XS v3.0 or later is installed.                 *
   *                                                                        *
   * JSON::true and JSON::false returned JSON::Boolean objects.             *
   * For workaround, they return JSON::PP::Boolean objects in this version. *
   *                                                                        *
   *     isa_ok(JSON::true, 'JSON::PP::Boolean');                           *
   *                                                                        *
   * And it discards a feature:                                             *
   *                                                                        *
   *     ok(JSON::true eq 'true');                                          *
   *                                                                        *
   * In other word, JSON::PP::Boolean overload numeric only.                *
   *                                                                        *
   *     ok( JSON::true == 1 );                                             *
   *                                                                        *
   **************************************************************************
  
   ************************** CAUTION ********************************
   * This is 'JSON module version 2' and there are many differences  *
   * to version 1.xx                                                 *
   * Please check your applications using old version.              *
   *   See to 'INCOMPATIBLE CHANGES TO OLD VERSION'                  *
   *******************************************************************
  
  JSON (JavaScript Object Notation) is a simple data format.
  See to L<http://www.json.org/> and C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>).
  
  This module converts Perl data structures to JSON and vice versa using either
  L<JSON::XS> or L<JSON::PP>.
  
  JSON::XS is the fastest and most proper JSON module on CPAN which must be
  compiled and installed in your environment.
  JSON::PP is a pure-Perl module which is bundled in this distribution and
  has a strong compatibility to JSON::XS.
  
  This module try to use JSON::XS by default and fail to it, use JSON::PP instead.
  So its features completely depend on JSON::XS or JSON::PP.
  
  See to L<BACKEND MODULE DECISION>.
  
  To distinguish the module name 'JSON' and the format type JSON,
  the former is quoted by CE<lt>E<gt> (its results vary with your using media),
  and the latter is left just as it is.
  
  Module name : C<JSON>
  
  Format type : JSON
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module (i.e. backend modules) knows how to handle Unicode, documents
  how and when it does so, and even documents what "correct" means.
  
  Even though there are limitations, this feature is available since Perl version 5.6.
  
  JSON::XS requires Perl 5.8.2 (but works correctly in 5.8.8 or later), so in older versions
  C<JSON> should call JSON::PP as the backend which can be used since Perl 5.005.
  
  With Perl 5.8.x JSON::PP works, but from 5.8.0 to 5.8.2, because of a Perl side problem,
  JSON::PP works slower in the versions. And in 5.005, the Unicode handling is not available.
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> for more information.
  
  See also to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>
  and L<JSON::XS/ENCODING/CODESET_FLAG_NOTES>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  L</MAPPING> section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  See to L<JSON::XS/FEATURES> and L<JSON::PP/FEATURES>.
  
  =item * fast
  
  This module returns a JSON::XS object itself if available.
  Compared to other JSON modules and other serialisers such as Storable,
  JSON::XS usually compares favorably in terms of speed, too.
  
  If not available, C<JSON> returns a JSON::PP object instead of JSON::XS and
  it is very slow as pure-Perl.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an
  object oriented interface interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format possible
  (nice for simple line-based protocols), a pure-ASCII format (for when your transport
  is not 8-bit clean, still supports the whole Unicode range), or a pretty-printed
  format (for when you want to read that stuff). Or you can combine those features
  in whatever way you like.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  C<to_json> and C<from_json> are additional functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar)
  
  Converts the given Perl data structure to a json string.
  
  This function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Takes a hash reference as the second.
  
     $json_text = to_json($perl_scalar, $flag_hashref)
  
  So,
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
  
  equivalent to:
  
     $json_text = JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<encode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text)
  
  The opposite of C<to_json>: expects a json string and tries
  to parse it, returning the resulting reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->decode($json_text)
  
  Takes a hash reference as the second.
  
      $perl_scalar = from_json($json_text, $flag_hashref)
  
  So,
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
  
  equivalent to:
  
      $perl_scalar = JSON->new->utf8(1)->decode($json_text)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<decode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<from_json>.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
    # or
    $perl_scalar = from_json( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<to_json>.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # or 
    $unicode_json_text = to_json( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  =head2 new
  
      $json = JSON->new
  
  Returns a new C<JSON> object inherited from either JSON::XS or JSON::PP
  that can be used to de/encode JSON strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
  This feature depends on the used Perl version and environment.
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  The indent space length is three and JSON::XS cannot change the indent
  space length.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, identifying them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The indent space length is three.
  With JSON::PP, you can also access C<indent_length> to change indent space length.
  
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =over
  
  =item convert_blessed_universally mode
  
  If use C<JSON> with C<-convert_blessed_universally>, the C<UNIVERSAL::TO_JSON>
  subroutine is defined as the below code:
  
     *UNIVERSAL::TO_JSON = sub {
         my $b_obj = B::svref_2object( $_[0] );
         return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                 : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                 : undef
                 ;
     }
  
  This will cause that C<encode> method converts simple blessed objects into
  JSON objects as non-blessed object.
  
     JSON -convert_blessed_universally;
     $json->allow_blessed->convert_blessed->encode( $blessed_object )
  
  This feature is experimental and may be removed in the future.
  
  =back
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  With JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  With JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>. See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE> and L<JSON::PP/METHODS>.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing. (JSON::XS)
  
  With JSON::PP as the backend, when a large value (100 or more) was set and
  it de/encodes a deep nested object/text, it may raise a warning
  'Deep recursion on subroutine' at the perl runtime phase.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS>, below, for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 property
  
      $boolean = $json->property($property_name)
  
  Returns a boolean value about above some properties.
  
  The available properties are C<ascii>, C<latin1>, C<utf8>,
  C<indent>,C<space_before>, C<space_after>, C<relaxed>, C<canonical>,
  C<allow_nonref>, C<allow_unknown>, C<allow_blessed>, C<convert_blessed>,
  C<shrink>, C<max_depth> and C<max_size>.
  
     $boolean = $json->property('utf8');
      => 0
     $json->utf8;
     $boolean = $json->property('utf8');
      => 1
  
  Sets the property with a given boolean value.
  
      $json = $json->property($property_name => $boolean);
  
  With no argument, it returns all the above properties as a hash reference.
  
      $flag_hashref = $json->property();
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  The backend module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP SUPPORT METHODS
  
  The below methods are JSON::PP own methods, so when C<JSON> works
  with JSON::PP (i.e. the created object is a JSON::PP object), available.
  See to L<JSON::PP/JSON::PP OWN METHODS> in detail.
  
  If you use C<JSON> with additional C<-support_by_pp>, some methods
  are available even with JSON::XS. See to L<USE PP FEATURES EVEN THOUGH XS BACKEND>.
  
     BEING { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
     # functional interfaces too.
     print to_json(["/"], {escape_slash => 1});
     print from_json('["foo"]', {utf8 => 1});
  
  If you do not want to all functions but C<-support_by_pp>,
  use C<-no_export>.
  
     use JSON -support_by_pp, -no_export;
     # functional interfaces are not exported.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  any JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<MAPPING> about the conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But by default
  JSON backend modules encode strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  With JSON::XS, The indent space length is 3 and cannot be changed.
  With JSON::PP, it sets the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  with 'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  If the backend is JSON::PP and C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  In future, the ordered object feature will be added to JSON::PP using C<tie> mechanism.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  With C<convert_blessed_universally> mode,  C<encode> converts blessed
  hash references or blessed array references (contains other blessed references)
  into JSON members and arrays.
  
     use JSON -convert_blessed_universally;
     JSON->new->allow_blessed->convert_blessed->encode( $blessed_object );
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  If the backend is JSON::PP and C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 JSON and ECMAscript
  
  See to L<JSON::XS/JSON and ECMAscript>.
  
  =head1 JSON and YAML
  
  JSON is not a subset of YAML.
  See to L<JSON::XS/JSON and YAML>.
  
  
  =head1 BACKEND MODULE DECISION
  
  When you use C<JSON>, C<JSON> tries to C<use> JSON::XS. If this call failed, it will
  C<uses> JSON::PP. The required JSON::XS version is I<2.2> or later.
  
  The C<JSON> constructor method returns an object inherited from the backend module,
  and JSON::XS object is a blessed scalar reference while JSON::PP is a blessed hash
  reference.
  
  So, your program should not depend on the backend module, especially
  returned objects should not be modified.
  
   my $json = JSON->new; # XS or PP?
   $json->{stash} = 'this is xs object'; # this code may raise an error!
  
  To check the backend module, there are some methods - C<backend>, C<is_pp> and C<is_xs>.
  
    JSON->backend; # 'JSON::XS' or 'JSON::PP'
    
    JSON->backend->is_pp: # 0 or 1
    
    JSON->backend->is_xs: # 1 or 0
    
    $json->is_xs; # 1 or 0
    
    $json->is_pp; # 0 or 1
  
  
  If you set an environment variable C<PERL_JSON_BACKEND>, the calling action will be changed.
  
  =over
  
  =item PERL_JSON_BACKEND = 0 or PERL_JSON_BACKEND = 'JSON::PP'
  
  Always use JSON::PP
  
  =item PERL_JSON_BACKEND == 1 or PERL_JSON_BACKEND = 'JSON::XS,JSON::PP'
  
  (The default) Use compiled JSON::XS if it is properly compiled & installed,
  otherwise use JSON::PP.
  
  =item PERL_JSON_BACKEND == 2 or PERL_JSON_BACKEND = 'JSON::XS'
  
  Always use compiled JSON::XS, die if it isn't properly compiled & installed.
  
  =item PERL_JSON_BACKEND = 'JSON::backportPP'
  
  Always use JSON::backportPP.
  JSON::backportPP is JSON::PP back port module.
  C<JSON> includes JSON::backportPP instead of JSON::PP.
  
  =back
  
  These ideas come from L<DBI::PurePerl> mechanism.
  
  example:
  
   BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::PP' }
   use JSON; # always uses JSON::PP
  
  In future, it may be able to specify another module.
  
  =head1 USE PP FEATURES EVEN THOUGH XS BACKEND
  
  Many methods are available with either JSON::XS or JSON::PP and
  when the backend module is JSON::XS, if any JSON::PP specific (i.e. JSON::XS unsupported)
  method is called, it will C<warn> and be noop.
  
  But If you C<use> C<JSON> passing the optional string C<-support_by_pp>,
  it makes a part of those unsupported methods available.
  This feature is achieved by using JSON::PP in C<de/encode>.
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 2 } # with JSON::XS
     use JSON -support_by_pp;
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
  At this time, the returned object is a C<JSON::Backend::XS::Supportable>
  object (re-blessed XS object), and  by checking JSON::XS unsupported flags
  in de/encoding, can support some unsupported methods - C<loose>, C<allow_bignum>,
  C<allow_barekey>, C<allow_singlequote>, C<escape_slash> and C<indent_length>.
  
  When any unsupported methods are not enable, C<XS de/encode> will be
  used as is. The switch is achieved by changing the symbolic tables.
  
  C<-support_by_pp> is effective only when the backend module is JSON::XS
  and it makes the de/encoding speed down a bit.
  
  See to L<JSON::PP SUPPORT METHODS>.
  
  =head1 INCOMPATIBLE CHANGES TO OLD VERSION
  
  There are big incompatibility between new version (2.00) and old (1.xx).
  If you use old C<JSON> 1.xx in your code, please check it.
  
  See to L<Transition ways from 1.xx to 2.xx.>
  
  =over
  
  =item jsonToObj and objToJson are obsoleted.
  
  Non Perl-style name C<jsonToObj> and C<objToJson> are obsoleted
  (but not yet deleted from the source).
  If you use these functions in your code, please replace them
  with C<from_json> and C<to_json>.
  
  
  =item Global variables are no longer available.
  
  C<JSON> class variables - C<$JSON::AUTOCONVERT>, C<$JSON::BareKey>, etc...
  - are not available any longer.
  Instead, various features can be used through object methods.
  
  
  =item Package JSON::Converter and JSON::Parser are deleted.
  
  Now C<JSON> bundles with JSON::PP which can handle JSON more properly than them.
  
  =item Package JSON::NotString is deleted.
  
  There was C<JSON::NotString> class which represents JSON value C<true>, C<false>, C<null>
  and numbers. It was deleted and replaced by C<JSON::Boolean>.
  
  C<JSON::Boolean> represents C<true> and C<false>.
  
  C<JSON::Boolean> does not represent C<null>.
  
  C<JSON::null> returns C<undef>.
  
  C<JSON> makes L<JSON::XS::Boolean> and L<JSON::PP::Boolean> is-a relation
  to L<JSON::Boolean>.
  
  =item function JSON::Number is obsoleted.
  
  C<JSON::Number> is now needless because JSON::XS and JSON::PP have
  round-trip integrity.
  
  =item JSONRPC modules are deleted.
  
  Perl implementation of JSON-RPC protocol - C<JSONRPC >, C<JSONRPC::Transport::HTTP>
  and C<Apache::JSONRPC > are deleted in this distribution.
  Instead of them, there is L<JSON::RPC> which supports JSON-RPC protocol version 1.1.
  
  =back
  
  =head2 Transition ways from 1.xx to 2.xx.
  
  You should set C<suport_by_pp> mode firstly, because
  it is always successful for the below codes even with JSON::XS.
  
      use JSON -support_by_pp;
  
  =over
  
  =item Exported jsonToObj (simple)
  
    from_json($json_text);
  
  =item Exported objToJson (simple)
  
    to_json($perl_scalar);
  
  =item Exported jsonToObj (advanced)
  
    $flags = {allow_barekey => 1, allow_singlequote => 1};
    from_json($json_text, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    $JSON::QuotApos = 1;
    jsonToObj($json_text);
  
  =item Exported objToJson (advanced)
  
    $flags = {allow_blessed => 1, allow_barekey => 1};
    to_json($perl_scalar, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    objToJson($perl_scalar);
  
  =item jsonToObj as object method
  
    $json->decode($json_text);
  
  =item objToJson as object method
  
    $json->encode($perl_scalar);
  
  =item new method with parameters
  
  The C<new> method in 2.x takes any parameters no longer.
  You can set parameters instead;
  
     $json = JSON->new->pretty;
  
  =item $JSON::Pretty, $JSON::Indent, $JSON::Delimiter
  
  If C<indent> is enable, that means C<$JSON::Pretty> flag set. And
  C<$JSON::Delimiter> was substituted by C<space_before> and C<space_after>.
  In conclusion:
  
     $json->indent->space_before->space_after;
  
  Equivalent to:
  
    $json->pretty;
  
  To change indent length, use C<indent_length>.
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->pretty->indent_length(2)->encode($perl_scalar);
  
  =item $JSON::BareKey
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_barekey->decode($json_text)
  
  =item $JSON::ConvBlessed
  
  use C<-convert_blessed_universally>. See to L<convert_blessed>.
  
  =item $JSON::QuotApos
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_singlequote->decode($json_text)
  
  =item $JSON::SingleQuote
  
  Disable. C<JSON> does not make such a invalid JSON string any longer.
  
  =item $JSON::KeySort
  
    $json->canonical->encode($perl_scalar)
  
  This is the ascii sort.
  
  If you want to use with your own sort routine, check the C<sort_by> method.
  
  (Only with JSON::PP, even if C<-support_by_pp> is used currently.)
  
    $json->sort_by($sort_routine_ref)->encode($perl_scalar)
   
    $json->sort_by(sub { $JSON::PP::a <=> $JSON::PP::b })->encode($perl_scalar)
  
  Can't access C<$a> and C<$b> but C<$JSON::PP::a> and C<$JSON::PP::b>.
  
  =item $JSON::SkipInvalid
  
    $json->allow_unknown
  
  =item $JSON::AUTOCONVERT
  
  Needless. C<JSON> backend modules have the round-trip integrity.
  
  =item $JSON::UTF8
  
  Needless because C<JSON> (JSON::XS/JSON::PP) sets
  the UTF8 flag on properly.
  
      # With UTF8-flagged strings
  
      $json->allow_nonref;
      $str = chr(1000); # UTF8-flagged
  
      $json_text  = $json->utf8(0)->encode($str);
      utf8::is_utf8($json_text);
      # true
      $json_text  = $json->utf8(1)->encode($str);
      utf8::is_utf8($json_text);
      # false
  
      $str = '"' . chr(1000) . '"'; # UTF8-flagged
  
      $perl_scalar  = $json->utf8(0)->decode($str);
      utf8::is_utf8($perl_scalar);
      # true
      $perl_scalar  = $json->utf8(1)->decode($str);
      # died because of 'Wide character in subroutine'
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =item $JSON::UnMapping
  
  Disable. See to L<MAPPING>.
  
  =item $JSON::SelfConvert
  
  This option was deleted.
  Instead of it, if a given blessed object has the C<TO_JSON> method,
  C<TO_JSON> will be executed with C<convert_blessed>.
  
    $json->convert_blessed->encode($blessed_hashref_or_arrayref)
    # if need, call allow_blessed
  
  Note that it was C<toJson> in old version, but now not C<toJson> but C<TO_JSON>.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item example programs
  
  =back
  
  =head1 THREADS
  
  No test with JSON::PP. If with JSON::XS, See to L<JSON::XS/THREADS>.
  
  
  =head1 BUGS
  
  Please report bugs relevant to C<JSON> to E<lt>makamaka[at]cpan.orgE<gt>.
  
  
  =head1 SEE ALSO
  
  Most of the document is copied and modified from JSON::XS doc.
  
  L<JSON::XS>, L<JSON::PP>
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/MaybeXS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_MAYBEXS';
  package JSON::MaybeXS;use strict;use warnings FATAL=>'all';use base qw(Exporter);our$VERSION='0.01';$VERSION=eval$VERSION;sub _choose_json_module {return 'Cpanel::JSON::XS' if$INC{'Cpanel/JSON/XS.pm'};return 'JSON::XS' if$INC{'JSON/XS.pm'};my@err;return 'Cpanel::JSON::XS' if eval {require Cpanel::JSON::XS;1};push@err,"Error loading Cpanel::JSON::XS: $@";return 'JSON::XS' if eval {require JSON::XS;1};push@err,"Error loading JSON::XS: $@";return 'JSON::PP' if eval {require JSON::PP;1};push@err,"Error loading JSON::PP: $@";die join("\n","Couldn't load a JSON module:",@err)}BEGIN {our$JSON_Class=_choose_json_module();$JSON_Class->import(qw(encode_json decode_json))}our@EXPORT=qw(encode_json decode_json JSON);my@EXPORT_ALL=qw(is_bool);our@EXPORT_OK=qw(is_bool to_json from_json);our%EXPORT_TAGS=(all=>[@EXPORT,@EXPORT_ALL ],legacy=>[@EXPORT,@EXPORT_OK ],);sub JSON () {our$JSON_Class}sub new {shift;my%args=@_==1 ? %{$_[0]}: @_;my$new=(our$JSON_Class)->new;$new->$_($args{$_})for keys%args;return$new}use Scalar::Util ();sub is_bool {die 'is_bool is not a method' if $_[1];Scalar::Util::blessed($_[0])and ($_[0]->isa('JSON::XS::Boolean')or $_[0]->isa('Cpanel::JSON::XS::Boolean')or $_[0]->isa('JSON::PP::Boolean'))}use Carp ();sub from_json ($@) {if (ref($_[0])=~ /^JSON/ or $_[0]=~ /^JSON/){Carp::croak "from_json should not be called as a method."}my$json=JSON()->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}return$json->decode($_[0])}sub to_json ($@) {if (ref($_[0])=~ /^JSON/ or (@_ > 2 and $_[0]=~ /^JSON/)){Carp::croak "to_json should not be called as a method."}my$json=JSON()->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}$json->encode($_[0])}1;
JSON_MAYBEXS

$fatpacked{"JSON/RPC/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_RPC_SPEC';
  package JSON::RPC::Spec;use Moo;use Carp ();use version;our$VERSION=version->declare("0.01");use Try::Tiny;use Router::Simple;use JSON::RPC::Spec::Procedure;use JSON::RPC::Spec::Client;with qw(JSON::RPC::Spec::Common);use constant DEBUG=>$ENV{PERL_JSON_RPC_SPEC_DEBUG}|| 0;has router=>(is=>'lazy',isa=>sub {my$self=shift;$self->can('match')or Carp::croak('method match required.')},);has _procedure=>(is=>'lazy');has _client=>(is=>'lazy',handles=>[qw(compose)],);has [qw(_is_batch _content)]=>(is=>'rw');use namespace::clean;sub _build_router {Router::Simple->new}sub _build__procedure {JSON::RPC::Spec::Procedure->new(router=>shift->router)}sub _build__client {JSON::RPC::Spec::Client->new}sub _parse_json {my ($self,$extra_args)=@_;warn qq{-- start parsing @{[$self->_content]}\n} if DEBUG;unless (length$self->_content){return$self->_rpc_invalid_request}my ($req,$err);try {$req=$self->coder->decode($self->_content)}catch {$err=$_;warn qq{-- error : @{[$err]} } if DEBUG};if ($err){return$self->_rpc_parse_error}if (ref$req eq 'ARRAY'){$self->_is_batch(1)}else {$self->_is_batch(0);$req=[$req]}unless (scalar @{$req}){return$self->_rpc_invalid_request}my@response;for my$obj (@{$req}){my$res=$self->_procedure->parse($obj,$extra_args);push@response,$res if$res}return unless@response;return [@response]if$self->_is_batch;return$response[0]}sub parse_without_encode {my$self=shift;my$json_string=shift;my$extra_args=+[@_];$self->_content($json_string);return$self->_parse_json($extra_args)}sub parse {my$self=shift;my$json_string=shift;my$extra_args=+[@_];$self->_content($json_string);my$result=$self->_parse_json($extra_args);return unless$result;return$self->coder->encode($result)}sub register {my ($self,$pattern,$cb)=@_;if (!defined$pattern){Carp::croak('pattern required')}if (ref$cb ne 'CODE'){Carp::croak('code required')}$self->router->connect($pattern,+{$self->_callback_key=>$cb},+{});return$self}1;
JSON_RPC_SPEC

$fatpacked{"JSON/RPC/Spec/Client.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_RPC_SPEC_CLIENT';
  package JSON::RPC::Spec::Client;use Moo;use Carp ();with qw(JSON::RPC::Spec::Common);use namespace::clean;sub compose {my ($self,$method,$params,$id)=@_;my@args;if (defined$id){@args=(id=>$id)}return$self->coder->encode(+{jsonrpc=>$self->_jsonrpc,method=>$method,params=>$params,@args })}1;
JSON_RPC_SPEC_CLIENT

$fatpacked{"JSON/RPC/Spec/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_RPC_SPEC_COMMON';
  package JSON::RPC::Spec::Common;use Moo::Role;use Carp ();use JSON::MaybeXS qw(JSON);has coder=>(is=>'lazy',isa=>sub {my$self=shift;$self->can('encode')or Carp::croak('method encode required.');$self->can('decode')or Carp::croak('method decode required.')},);has [qw(_callback_key _jsonrpc)]=>(is=>'lazy');has [qw(_id _is_notification)]=>(is=>'rw');use namespace::clean;sub _build_coder {JSON->new->utf8}sub _build__callback_key {'_callback'}sub _build__jsonrpc {'2.0'}sub _error {my ($self,$error)=@_;return +{jsonrpc=>$self->_jsonrpc,error=>$error,id=>$self->_id }}sub _rpc_invalid_request {my ($self)=@_;my$error={code=>-32600,message=>'Invalid Request' };$self->_is_notification(undef);$self->_id(undef);return$self->_error($error)}sub _rpc_method_not_found {my ($self)=@_;my$error={code=>-32601,message=>'Method not found' };return$self->_error($error)}sub _rpc_invalid_params {my ($self)=@_;my$error={code=>-32602,message=>'Invalid params' };return$self->_error($error)}sub _rpc_internal_error {my ($self,@args)=@_;my$error={code=>-32603,message=>'Internal error',@args };return$self->_error($error)}sub _rpc_parse_error {my ($self)=@_;my$error={code=>-32700,message=>'Parse error' };$self->_id(undef);return$self->_error($error)}1;
JSON_RPC_SPEC_COMMON

$fatpacked{"JSON/RPC/Spec/Procedure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_RPC_SPEC_PROCEDURE';
  package JSON::RPC::Spec::Procedure;use Moo;use Carp ();use Try::Tiny;with qw(JSON::RPC::Spec::Common);use constant DEBUG=>$ENV{PERL_JSON_RPC_SPEC_DEBUG}|| 0;has router=>(is=>'ro',required=>1,isa=>sub {my$self=shift;$self->can('match')or Carp::croak('method match required.')},);use namespace::clean;sub parse {my ($self,$obj,$extra_args)=@_;if (ref$obj ne 'HASH'){return$self->_rpc_invalid_request}$self->_is_notification(!exists$obj->{id});$self->_id($obj->{id});my$method=$obj->{method}|| '';if ($method eq '' or $method =~ m!\A\.|\A[0-9]+\z!){return$self->_rpc_invalid_request}my ($result,$err);try {$result=$self->_trigger($method,$obj->{params},$extra_args)}catch {$err=$_;warn qq{-- error : @{[$err]} } if DEBUG};if ($self->_is_notification){return}if ($err){my$error;if ($err =~ m!rpc_method_not_found!){$error=$self->_rpc_method_not_found}elsif ($err =~ m!rpc_invalid_params!){$error=$self->_rpc_invalid_params}else {$error=$self->_rpc_internal_error(data=>$err)}return$error}return +{jsonrpc=>$self->_jsonrpc,result=>$result,id=>$self->_id }}sub _trigger {my ($self,$name,$params,$extra_args)=@_;my$router=$self->router;my$matched=$router->match($name);unless ($matched){Carp::croak 'rpc_method_not_found on trigger'}my$cb=delete$matched->{$self->_callback_key};return$cb->($params,$matched,@{$extra_args})}1;
JSON_RPC_SPEC_PROCEDURE

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package JSON::PP;use 5.005;use strict;use base qw(Exporter);use overload ();use Carp ();use B ();use vars qw($VERSION);$VERSION='0.01';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if ($] < 5.008){my$helper=$] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$flag_name='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /}}my%encode_allow_method =map {($_=>1)}qw/utf8 pretty allow_nonref latin1 self_encode escape_slash allow_blessed convert_blessed indent indent_length allow_bignum as_nonblessed/;my%decode_allow_method =map {($_=>1)}qw/utf8 allow_nonref loose allow_singlequote allow_bignum allow_barekey max_size relaxed/;my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent=>0,FLAGS=>0,fallback=>sub {encode_error('Invalid value. JSON can only reference.')},indent_length=>3,};bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->indent_length(3)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub filter_json_object {$_[0]->{cb_object}=defined $_[1]? $_[1]: 0;$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_ > 1){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.")}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$idx=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed)=@{$idx}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$idx->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($idx->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));return$self->blessed_to_json($obj)if ($allow_blessed and $as_nonblessed);encode_error(sprintf("encountered object '%s', but neither allow_blessed " ."nor convert_blessed settings are enabled",$obj))unless ($allow_blessed);return 'null'}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,string_to_json($self,$k).$del .($self->object_to_json($obj->{$k})|| $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{' .(@res ? $pre : '').(@res ? join(",$pre",@res).$post : '').'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,$self->object_to_json($v)|| $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[' .(@res ? $pre : '').(@res ? join(",$pre",@res).$post : '').']'}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return$value if$flags & (B::SVp_IOK | B::SVp_NOK)and!($flags & B::SVp_POK);my$type=ref($value);if(!$type){return string_to_json($self,$value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}elsif ($type){if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}else {return$self->{fallback}->($value)if ($self->{fallback}and ref($self->{fallback})eq 'CODE');return 'null'}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bigint;my$singlequote;my$loose;my$allow_barekey;sub PP_decode_json {my ($self,$opt);($self,$text,$opt)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$idx=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bigint,$allow_barekey,$singlequote)=@{$idx}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE];if ($utf8){utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}else {utf8::upgrade($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}my@octets=unpack('C4',$text);$encoding=($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown';white();my$valid_start=defined$ch;my$result=value();return undef if (!$result && ($opt & 0x10000000));decode_error("malformed JSON string, neither array, object, number, string or atom")unless$valid_start;if (!$idx->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();if ($ch){return ($result,$consumed)if ($opt & 0x00000001);decode_error("garbage after JSON object")}($opt & 0x00000001)? ($result,$consumed): $result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my ($i,$s,$t,$u);my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){if ($utf8){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}}else {utf8::encode($ch)}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){$at--;decode_error('invalid character encountered while parsing JSON string')}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch le ' '){next_chr()}elsif($ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}decode_error(", or ] expected while parsing array")}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at--;decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return$JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return$JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;if($ch eq '0'){my$peek=substr($text,$at,1);my$hex=$peek =~ /[xX]/;if($hex){decode_error("malformed number (leading zero must not be followed by another digit)");($n)=(substr($text,$at+1)=~ /^([0-9a-fA-F]+)/)}else{($n)=(substr($text,$at)=~ /^([0-7]+)/);if (defined$n and length$n > 1){decode_error("malformed number (leading zero must not be followed by another digit)")}}if(defined$n and length($n)){if (!$hex and length($n)==1){decode_error("malformed number (leading zero must not be followed by another digit)")}$at += length($n)+ $hex;next_chr;return$hex ? hex($n): oct($n)}}if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($v !~ /[.eE]/ and length$v > $max_intsize){if ($allow_bigint){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}elsif ($allow_bigint){require Math::BigFloat;return Math::BigFloat->new($v)}return 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type=$] >= 5.008 ? 'U*' : $] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' ;for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==1){return$val[0]}}my@val=$cb_object->($o)if ($cb_object);if (@val==0 or @val > 1){return$o}else {return$val[0]}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if ($] >= 5.008){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode}if ($] >= 5.008 and $] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}unless ($INC{'JSON/PP.pm'}){eval q|
          package
              JSON::PP::Boolean;
  
          use overload (
              "0+"     => sub { ${$_[0]} },
              "++"     => sub { $_[0] = ${$_[0]} + 1 },
              "--"     => sub { $_[0] = ${$_[0]} - 1 },
              fallback => 1,
          );
      |}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {defined $_[0]and UNIVERSAL::isa($_[0],"JSON::PP::Boolean")}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use vars qw($VERSION);$VERSION='0.01';my$unpack_format=$] < 5.006 ? 'C*' : 'U*';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_parsing=>0,incr_p=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}my$max_size=$coder->get_max_size;if (defined wantarray){$self->{incr_mode}=INCR_M_WS unless defined$self->{incr_mode};if (wantarray){my@ret;$self->{incr_parsing}=1;do {push@ret,$self->_incr_parse($coder,$self->{incr_text});unless (!$self->{incr_nest}and $self->{incr_mode}==INCR_M_JSON){$self->{incr_mode}=INCR_M_WS if$self->{incr_mode}!=INCR_M_STR}}until (length$self->{incr_text}>= $self->{incr_p});$self->{incr_parsing}=0;return@ret}else {$self->{incr_parsing}=1;my$obj=$self->_incr_parse($coder,$self->{incr_text});$self->{incr_parsing}=0 if defined$obj;return$obj ? $obj : undef}}}sub _incr_parse {my ($self,$coder,$text,$skip)=@_;my$p=$self->{incr_p};my$restore=$p;my@obj;my$len=length$text;if ($self->{incr_mode}==INCR_M_WS){while ($len > $p){my$s=substr($text,$p,1);$p++ and next if (0x20 >= unpack($unpack_format,$s));$self->{incr_mode}=INCR_M_JSON;last}}while ($len > $p){my$s=substr($text,$p++,1);if ($s eq '"'){if (substr($text,$p - 2,1)eq '\\'){next}if ($self->{incr_mode}!=INCR_M_STR){$self->{incr_mode}=INCR_M_STR}else {$self->{incr_mode}=INCR_M_JSON;unless ($self->{incr_nest}){last}}}if ($self->{incr_mode}==INCR_M_JSON){if ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}}elsif ($s eq ']' or $s eq '}'){last if (--$self->{incr_nest}<= 0)}elsif ($s eq '#'){while ($len > $p){last if substr($text,$p++,1)eq "\n"}}}}$self->{incr_p}=$p;return if ($self->{incr_mode}==INCR_M_STR and not $self->{incr_nest});return if ($self->{incr_mode}==INCR_M_JSON and $self->{incr_nest}> 0);return '' unless (length substr($self->{incr_text},0,$p));local$Carp::CarpLevel=2;$self->{incr_p}=$restore;$self->{incr_c}=$p;my ($obj,$tail)=$coder->PP_decode_json(substr($self->{incr_text},0,$p),0x10000001);$self->{incr_text}=substr($self->{incr_text},$p);$self->{incr_p}=0;return$obj || ''}sub incr_text {if ($_[0]->{incr_parsing}){Carp::croak("incr_text can not be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_c});$self->{incr_p}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_p}=0;$self->{incr_mode}=0;$self->{incr_nest}=0;$self->{incr_parsing}=0}1;
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  use JSON::backportPP ();use strict;1;
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package JSON::backportPP5005;use 5.005;use strict;my@properties;$JSON::PP5005::VERSION='0.01';BEGIN {sub utf8::is_utf8 {0}sub utf8::upgrade {}sub utf8::downgrade {1}sub utf8::encode {}sub utf8::decode {}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;sub B::SVp_IOK () {0x01000000}sub B::SVp_NOK () {0x02000000}sub B::SVp_POK () {0x04000000}$INC{'bytes.pm'}=1}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): sprintf('\u%04x',$_)}unpack('C*',$_[0]))}sub _encode_latin1 {join('',map {chr($_)}unpack('C*',$_[0]))}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$bit=unpack('B32',pack('N',$uni));if ($bit =~ /^00000000000(...)(......)(......)(......)$/){my ($w,$x,$y,$z)=($1,$2,$3,$4);return pack('B*',sprintf('11110%s10%s10%s10%s',$w,$x,$y,$z))}else {Carp::croak("Invalid surrogate pair")}}sub _decode_unicode {my ($u)=@_;my ($utf8bit);if ($u =~ /^00([89a-f][0-9a-f])$/i){return pack('H2',$1)}my$bit=unpack("B*",pack("H*",$u));if ($bit =~ /^00000(.....)(......)$/){$utf8bit=sprintf('110%s10%s',$1,$2)}elsif ($bit =~ /^(....)(......)(......)$/){$utf8bit=sprintf('1110%s10%s10%s',$1,$2,$3)}else {Carp::croak("Invalid escaped unicode")}return pack('B*',$utf8bit)}sub JSON::PP::incr_text {$_[0]->{_incr_parser}||= JSON::PP::IncrParser->new;if ($_[0]->{_incr_parser}->{incr_parsing}){Carp::croak("incr_text can not be called when the incremental parser already started parsing")}$_[0]->{_incr_parser}->{incr_text}=$_[1]if (@_ > 1);$_[0]->{_incr_parser}->{incr_text}}1;
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package JSON::backportPP56;use 5.006;use strict;my@properties;$JSON::PP56::VERSION='0.01';BEGIN {sub utf8::is_utf8 {my$len=length $_[0];{use bytes;return$len!=length $_[0]}}sub utf8::upgrade {}sub utf8::downgrade ($;$) {return 1 unless (utf8::is_utf8($_[0]));if (_is_valid_utf8($_[0])){my$downgrade;for my$c (unpack("U*",$_[0])){if ($c < 256){$downgrade .= pack("C",$c)}else {$downgrade .= pack("U",$c)}}$_[0]=$downgrade;return 1}else {Carp::croak("Wide character in subroutine entry")unless ($_[1]);0}}sub utf8::encode ($) {if (utf8::is_utf8($_[0])){$_[0]=pack("C*",unpack("C*",$_[0]))}else {$_[0]=pack("U*",unpack("C*",$_[0]));$_[0]=pack("C*",unpack("C*",$_[0]))}}sub utf8::decode ($) {if (_is_valid_utf8($_[0])){utf8::downgrade($_[0]);$_[0]=pack("U*",unpack("U*",$_[0]))}}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&JSON::PP::_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&JSON::PP::_decode_unicode;unless (defined&B::SVp_NOK){eval q{ sub B::SVp_NOK () { 0x02000000; } }}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _unpack_emu {return!utf8::is_utf8($_[0])? unpack('C*',$_[0]): _is_valid_utf8($_[0])? unpack('U*',$_[0]): unpack('C*',$_[0])}sub _is_valid_utf8 {my$str=$_[0];my$is_utf8;while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg){if (defined $1){$is_utf8=1 if (!defined$is_utf8)}else {$is_utf8=0 if (!defined$is_utf8);if ($is_utf8){return}}}return$is_utf8}1;
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"Lingua/EN/Inflect.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LINGUA_EN_INFLECT';
  package Lingua::EN::Inflect;use strict;use vars qw($VERSION @EXPORT_OK %EXPORT_TAGS @ISA);use Env;require Exporter;@ISA=qw(Exporter);our$VERSION='0.01';%EXPORT_TAGS=(ALL=>[qw(classical inflect PL PL_N PL_V PL_ADJ NO NUM A AN PL_eq PL_N_eq PL_V_eq PL_ADJ_eq PART_PRES ORD NUMWORDS WORDLIST def_noun def_verb def_adj def_a def_an)],INFLECTIONS=>[qw(classical inflect PL PL_N PL_V PL_ADJ PL_eq NO NUM A AN PART_PRES)],PLURALS=>[qw(classical inflect PL PL_N PL_V PL_ADJ NO NUM PL_eq PL_N_eq PL_V_eq PL_ADJ_eq)],COMPARISONS=>[qw(classical PL_eq PL_N_eq PL_V_eq PL_ADJ_eq)],ARTICLES=>[qw(classical inflect NUM A AN)],NUMERICAL=>[qw(ORD NUMWORDS)],USER_DEFINED=>[qw(def_noun def_verb def_adj def_a def_an)],);Exporter::export_ok_tags(qw(ALL));my%def_classical=(all=>0,zero=>0,herd=>0,names=>1,persons=>0,ancient=>0,);my%all_classical=(all=>1,zero=>1,herd=>1,names=>1,persons=>1,ancient=>1,noble_and_ancient=>10,);my%classical=%def_classical;my$classical_mode=join '|',keys%all_classical;$classical_mode=qr/^(?:$classical_mode)$/;sub classical {if (!@_){%classical=%all_classical;return}if (@_==1 && $_[0]!~ $classical_mode){%classical=$_[0]? %all_classical : ();return}while (@_){my$arg=shift;if ($arg !~ $classical_mode){die "Unknown classical mode ($arg)\n"}if (@_ && $_[0]!~ $classical_mode){$classical{$arg}=shift}else {$classical{$arg}=1}if ($arg eq 'all'){%classical=$classical{all}? %all_classical : ()}}}my$persistent_count;sub NUM {if (defined $_[0]){$persistent_count=$_[0];return $_[0]if!defined($_[1])|| $_[1]}else {$persistent_count=undef}return ''}sub enclose {"(?:$_[0])"}sub inflect {my$save_persistent_count=$persistent_count;my@sections=split /(NUM\([^)]*\))/,$_[0];my$inflection="";for (@sections){unless (s/NUM\(\s*?(?:([^),]*)(?:,([^)]*))?)?\)/ NUM($1,$2) /xe){1 while s/\bPL   \( ([^),]*) (, ([^)]*) )? \)  / PL($1,$3)   /xeg || s/\bPL_N \( ([^),]*) (, ([^)]*) )? \)  / PL_N($1,$3) /xeg || s/\bPL_V \( ([^),]*) (, ([^)]*) )? \)  / PL_V($1,$3) /xeg || s/\bPL_ADJ \( ([^),]*) (, ([^)]*) )? \)  / PL_ADJ($1,$3) /xeg || s/\bAN?  \( ([^),]*) (, ([^)]*) )? \)  / A($1,$3)    /xeg || s/\bNO   \( ([^),]*) (, ([^)]*) )? \)  / NO($1,$3)   /xeg || s/\bORD  \( ([^)]*) \)                 / ORD($1)   /xeg || s/\bNUMWORDS  \( ([^)]*) \)            / NUMWORDS($1)   /xeg || s/\bPART_PRES  \( ([^)]*) \)            / PART_PRES($1)   /xeg}$inflection .= $_}$persistent_count=$save_persistent_count;return$inflection}my%PL_sb_irregular_s=("corpus"=>"corpuses|corpora","opus"=>"opuses|opera","magnum opus"=>"magnum opuses|magna opera","genus"=>"genera","mythos"=>"mythoi","penis"=>"penises|penes","testis"=>"testes","atlas"=>"atlases|atlantes","yes"=>"yeses",'editio princeps'=>'editiones principes','starets'=>'startsy','staretz'=>'startzy',);my%PL_sb_irregular=("child"=>"children","brother"=>"brothers|brethren","loaf"=>"loaves","hoof"=>"hoofs|hooves","beef"=>"beefs|beeves","thief"=>"thiefs|thieves","money"=>"monies","mongoose"=>"mongooses","ox"=>"oxen","cow"=>"cows|kine","graffito"=>"graffiti","prima donna"=>"prima donnas|prime donne","octopus"=>"octopuses|octopodes","genie"=>"genies|genii","ganglion"=>"ganglions|ganglia","trilby"=>"trilbys","turf"=>"turfs|turves","numen"=>"numina","atman"=>"atmas","occiput"=>"occiputs|occipita",'sabretooth'=>'sabretooths','sabertooth'=>'sabertooths','lowlife'=>'lowlifes','flatfoot'=>'flatfoots','tenderfoot'=>'tenderfoots','Romany'=>'Romanies','romany'=>'romanies','Tornese'=>'Tornesi','Jerry'=>'Jerrys','jerry'=>'jerries','Mary'=>'Marys','mary'=>'maries','talouse'=>'talouses','blouse'=>'blouses','Rom'=>'Roma','rom'=>'roma','carmen'=>'carmina','cheval'=>'chevaux','chervonetz'=>'chervontzi','kuvasz'=>'kuvaszok','felo'=>'felones','put-off'=>'put-offs','set-off'=>'set-offs','set-out'=>'set-outs','set-to'=>'set-tos','brother-german'=>'brothers-german|brethren-german','studium generale'=>'studia generali',%PL_sb_irregular_s,);my$PL_sb_irregular=enclose join '|',reverse sort keys%PL_sb_irregular;my@PL_sb_z_zes=("batz","quartz","topaz","snooz(?=e)","kibbutz",);my$PL_sb_z_zes=enclose join '|',@PL_sb_z_zes;my@PL_sb_U_is_ides=("aphis",);my$PL_sb_U_is_ides=enclose join "|",map {substr($_,0,-2)}@PL_sb_U_is_ides;my@PL_sb_C_is_ides=("ephemeris","iris","clitoris","chrysalis","epididymis",".*itis",);my$PL_sb_C_is_ides=enclose join "|",map {substr($_,0,-2)}@PL_sb_C_is_ides;my@PL_sb_U_a_ata=("plasmalemma","pseudostoma",);my$PL_sb_U_a_ata=enclose join "|",map {substr($_,0,-1)}@PL_sb_U_a_ata;my@PL_sb_C_a_ata=("anathema","bema","carcinoma","charisma","diploma","dogma","drama","edema","enema","enigma","lemma","lymphoma","magma","melisma","miasma","oedema","sarcoma","schema","soma","stigma","stoma","trauma","gumma","pragma","bema",);my$PL_sb_C_a_ata=enclose join "|",map {substr($_,0,-1)}@PL_sb_C_a_ata;my$PL_sb_U_a_ae=enclose join "|",("alumna","alga","vertebra","persona");my$PL_sb_C_a_ae=enclose join "|",("amoeba","antenna","formula","hyperbola","medusa","nebula","parabola","abscissa","hydra","nova","lacuna","aurora",".*umbra","flora","fauna",);my$PL_sb_C_en_ina=enclose join "|",map {substr($_,0,-2)}("stamen","foramen","lumen");my$PL_sb_U_um_a=enclose join "|",map {substr($_,0,-2)}("bacterium","agendum","desideratum","erratum","stratum","datum","ovum","extremum","candelabrum","intermedium","malum","Progymnasium",);my$PL_sb_C_um_a=enclose join "|",map {substr($_,0,-2)}("maximum","minimum","momentum","optimum","quantum","cranium","curriculum","dictum","phylum","aquarium","compendium","emporium","enconium","gymnasium","honorarium","interregnum","lustrum","memorandum","millennium","rostrum","spectrum","speculum","stadium","trapezium","ultimatum","medium","vacuum","velum","consortium",);my$PL_sb_U_us_i=enclose join "|",map {substr($_,0,-2)}("alumnus","alveolus","bacillus","bronchus","locus","nucleus","stimulus","meniscus","sarcophagus","interradius","perradius","triradius",);my$PL_sb_C_us_i=enclose join "|",map {substr($_,0,-2)}("focus","radius","genius","incubus","succubus","nimbus","fungus","nucleolus","stylus","torus","umbilicus","uterus","hippopotamus","cactus",);my$PL_sb_C_us_us=enclose join "|",("status","apparatus","prospectus","sinus","hiatus","impetus","plexus",);my$PL_sb_U_on_a=enclose join "|",map {substr($_,0,-2)}("criterion","perihelion","aphelion","phenomenon","prolegomenon","noumenon","organon","asyndeton","hyperbaton","legomenon",);my$PL_sb_C_on_a=enclose join "|",map {substr($_,0,-2)}("oxymoron",);my@PL_sb_C_o_i=("solo","soprano","basso","alto","contralto","tempo","piano","virtuoso",);my$PL_sb_C_o_i=enclose join "|",map {substr($_,0,-1)}@PL_sb_C_o_i;my$PL_sb_U_o_os=enclose join "|",("^ado","aficionado","aggro","albino","allegro","ammo","Antananarivo","archipelago","armadillo","auto","avocado","Bamako","Barquisimeto","bimbo","bingo","Biro","bolero","Bolzano","bongo","Boto","burro","Cairo","canto","cappuccino","casino","cello","Chicago","Chimango","cilantro","cochito","coco","Colombo","Colorado","commando","concertino","contango","credo","crescendo","cyano","demo","ditto","Draco","dynamo","embryo","Esperanto","espresso","euro","falsetto","Faro","fiasco","Filipino","flamenco","furioso","generalissimo","Gestapo","ghetto","gigolo","gizmo","Greensboro","gringo","Guaiabero","guano","gumbo","gyro","hairdo","hippo","Idaho","impetigo","inferno","info","intermezzo","intertrigo","Iquico","^ISO","jumbo","junto","Kakapo","kilo","Kinkimavo","Kokako","Kosovo","Lesotho","libero","libido","libretto","lido","Lilo","limbo","limo","lineno","lingo","lino","livedo","loco","logo","lumbago","macho","macro","mafioso","magneto","magnifico","Majuro","Malabo","manifesto","Maputo","Maracaibo","medico","memo","metro","Mexico","micro","Milano","Monaco","mono","Montenegro","Morocco","Muqdisho","myo","^NATO","^NCO","neutrino","^NGO","Ningbo","octavo","oregano","Orinoco","Orlando","Oslo","^oto","panto","Paramaribo","Pardusco","pedalo","photo","pimento","pinto","pleco","Pluto","pogo","polo","poncho","Porto-Novo","Porto","pro","psycho","pueblo","quarto","Quito","rhino","risotto","rococo","rondo","Sacramento","saddo","sago","salvo","Santiago","Sapporo","Sarajevo","scherzando","scherzo","silo","sirocco","sombrero","staccato","sterno","stucco","stylo","sumo","Taiko","techno","terrazzo","testudo","timpano","tiro","tobacco","Togo","Tokyo","torero","Torino","Toronto","torso","tremolo","typo","tyro","ufo","UNESCO","vaquero","vermicello","verso","vibrato","violoncello","Virgo","weirdo","WHO","WTO","Yamoussoukro","yo-yo","zero","Zibo",@PL_sb_C_o_i,);my$PL_sb_U_ch_chs=enclose join "|",map {substr($_,0,-2)}qw(czech eunuch stomach);my$PL_sb_U_ex_ices=enclose join "|",map {substr($_,0,-2)}("codex","murex","silex",);my$PL_sb_U_ix_ices=enclose join "|",map {substr($_,0,-2)}("radix","helix",);my$PL_sb_C_ex_ices=enclose join "|",map {substr($_,0,-2)}("vortex","vertex","cortex","latex","pontifex","apex","index","simplex",);my$PL_sb_C_ix_ices=enclose join "|",map {substr($_,0,-2)}("appendix",);my$PL_sb_C_i=enclose join "|",("afrit","afreet","efreet",);my$PL_sb_C_im=enclose join "|",("goy","seraph","cherub","zuz","kibbutz",);my$PL_sb_U_man_mans=enclose join "|",qw(\bataman caiman cayman ceriman \bdesman \bdolman \bfarman \bharman \bhetman human \bleman ottoman shaman talisman Alabaman Bahaman Burman German Hiroshiman Liman Nakayaman Norman Oklahoman Panaman Roman Selman Sonaman Tacoman Yakiman Yokohaman Yuman);my@PL_sb_uninflected_s=("breeches","britches","pajamas","pyjamas","clippers","gallows","hijinks","headquarters","pliers","scissors","testes","herpes","pincers","shears","proceedings","trousers","cantus","coitus","nexus","contretemps","corps","debris",".*ois","siemens",".*measles","mumps","diabetes","jackanapes",".*series","species","rabies","chassis","innings","news","mews","haggis",);my$PL_sb_uninflected_herd=enclose join "|",("wildebeest","swine","eland","bison","buffalo","elk","rhinoceros",'zucchini','caribou','dace','grouse','guinea[- ]fowl','haddock','hake','halibut','herring','mackerel','pickerel','pike','roe','seed','shad','snipe','teal','turbot','water[- ]fowl',);my$PL_sb_lese_lesen=enclose join "|",('Auslese','beerenauslese','Spaetlese','trockenbeerenauslese',);my$PL_sb_uninflected=enclose join "|",(".*fish","tuna","salmon","mackerel","trout","bream","sea[- ]bass","carp","cod","flounder","whiting",".*deer",".*sheep","moose","Portuguese","Amoyese","Borghese","Congoese","Faroese","Foochowese","Genevese","Genoese","Gilbertese","Hottentotese","Kiplingese","Kongoese","Lucchese","Maltese","Nankingese","Niasese","Pekingese","Piedmontese","Pistoiese","Sarawakese","Shavese","Vermontese","Wenchowese","Yengeese",".*[nrlm]ese",@PL_sb_uninflected_s,".*pox","graffiti","djinn",'samuri','.*craft$','offspring','pence','quid','hertz',);my$PL_sb_singular_s=enclose join '|',(".*ss","acropolis","aegis","alias","asbestos","bathos","bias","bronchitis","bursitis","caddis","cannabis","canvas","chaos","cosmos","dais","digitalis","epidermis","ethos","eyas","gas","glottis","hubris","ibis","lens","mantis","marquis","metropolis","pathos","pelvis","polis","rhinoceros","sassafras","trellis",".*us","[A-Z].*es",@PL_sb_C_is_ides,@PL_sb_U_is_ides,);my$PL_v_special_s=enclose join '|',($PL_sb_singular_s,@PL_sb_uninflected_s,keys%PL_sb_irregular_s,'(.*[csx])is','(.*)ceps','[A-Z].*s',);my%PL_sb_postfix_adj=('general'=>['(?!major|lieutenant|brigadier|adjutant|.*star)\S+'],'martial'=>[qw(court)],);for (keys%PL_sb_postfix_adj){$PL_sb_postfix_adj{$_}=enclose enclose(join('|',@{$PL_sb_postfix_adj{$_}}))."(?=(?:-|\\s+)$_)"}my$PL_sb_postfix_adj='(' .join('|',values%PL_sb_postfix_adj).')(.*)';my$PL_prep=enclose join '|',qw ( about above across after against amid amidst among around as at athwart atop barring before behind below beneath beside besides between betwixt beyond but by circa despite down during except failing for from given in inside into like minus near next of off on onto out outside over pace past per plus pro qua round sans save since than through throughout thru thruout till times to toward towards under underneath unlike until unto up upon versus via vs with within without worth);my$PL_sb_prep_dual_compound='(.*?)((?:-|\s+)(?:'.$PL_prep.'|d[eua])(?:-|\s+))a(?:-|\s+)(.*)';my$PL_sb_prep_compound='(.*?)((-|\s+)('.$PL_prep.'|d[eua])((-|\s+)(.*))?)';my%PL_pron_nom=("i"=>"we","myself"=>"ourselves","you"=>"you","yourself"=>"yourselves","she"=>"they","herself"=>"themselves","he"=>"they","himself"=>"themselves","it"=>"they","itself"=>"themselves","they"=>"they","themself"=>"themselves","mine"=>"ours","yours"=>"yours","hers"=>"theirs","his"=>"theirs","its"=>"theirs","theirs"=>"theirs",);my%PL_pron_acc=("me"=>"us","myself"=>"ourselves","you"=>"you","yourself"=>"yourselves","her"=>"them","herself"=>"themselves","him"=>"them","himself"=>"themselves","it"=>"them","itself"=>"themselves","them"=>"them","themself"=>"themselves",);my$PL_pron_acc=enclose join '|',keys%PL_pron_acc;my%PL_v_irregular_pres=("am"=>"are","are"=>"are","is"=>"are","was"=>"were","were"=>"were","was"=>"were","have"=>"have","have"=>"have","has"=>"have","do"=>"do","do"=>"do","does"=>"do",);my$PL_v_irregular_pres=enclose join '|',keys%PL_v_irregular_pres;my%PL_v_ambiguous_pres=("act"=>"act","act"=>"act","acts"=>"act","blame"=>"blame","blame"=>"blame","blames"=>"blame","can"=>"can","can"=>"can","can"=>"can","must"=>"must","must"=>"must","must"=>"must","fly"=>"fly","fly"=>"fly","flies"=>"fly","copy"=>"copy","copy"=>"copy","copies"=>"copy","drink"=>"drink","drink"=>"drink","drinks"=>"drink","fight"=>"fight","fight"=>"fight","fights"=>"fight","fire"=>"fire","fire"=>"fire","fires"=>"fire","like"=>"like","like"=>"like","likes"=>"like","look"=>"look","look"=>"look","looks"=>"look","make"=>"make","make"=>"make","makes"=>"make","reach"=>"reach","reach"=>"reach","reaches"=>"reach","run"=>"run","run"=>"run","runs"=>"run","sink"=>"sink","sink"=>"sink","sinks"=>"sink","sleep"=>"sleep","sleep"=>"sleep","sleeps"=>"sleep","view"=>"view","view"=>"view","views"=>"view",);my$PL_v_ambiguous_pres=enclose join '|',keys%PL_v_ambiguous_pres;my$PL_v_irregular_non_pres=enclose join '|',("did","had","ate","made","put","spent","fought","sank","gave","sought","shall","could","ought","should",);my$PL_v_ambiguous_non_pres=enclose join '|',("thought","saw","bent","will","might","cut",);my$PL_v_oes_oe=enclose join "|",qw(.*shoes .*hoes .*toes canoes floes oboes roes throes woes);my$PL_count_zero=enclose join '|',(0,"no","zero","nil");my$PL_count_one=enclose join '|',(1,"a","an","one","each","every","this","that",);my%PL_adj_special=("a"=>"some","an"=>"some","this"=>"these","that"=>"those",);my$PL_adj_special=enclose join '|',keys%PL_adj_special;my%PL_adj_poss=("my"=>"our","your"=>"your","its"=>"their","her"=>"their","his"=>"their","their"=>"their",);my$PL_adj_poss=enclose join '|',keys%PL_adj_poss;sub checkpat {local$SIG{__WARN__}=sub {0};do {$@ =~ s/at.*?$//;die "\nBad user-defined singular pattern:\n\t$@\n"}if (!eval "'' =~ m/$_[0]/; 1;" or $@);return @_}sub checkpatsubs {checkpat($_[0]);if (defined $_[1]){local$SIG{__WARN__}=sub {0};do {$@ =~ s/at.*?$//;die "\nBad user-defined plural string: '$_[1]'\n\t$@\n"}if (!eval "qq{$_[1]}; 1;" or $@)}return @_}my@PL_sb_user_defined=();my@PL_v_user_defined=();my@PL_adj_user_defined=();my@A_a_user_defined=();sub def_noun {unshift@PL_sb_user_defined,checkpatsubs(@_);return 1}sub def_verb {unshift@PL_v_user_defined,checkpatsubs(@_[4,5]);unshift@PL_v_user_defined,checkpatsubs(@_[2,3]);unshift@PL_v_user_defined,checkpatsubs(@_[0,1]);return 1}sub def_adj {unshift@PL_adj_user_defined,checkpatsubs(@_);return 1}sub def_a {unshift@A_a_user_defined,checkpat(@_,'a');return 1}sub def_an {unshift@A_a_user_defined,checkpat(@_,'an');return 1}sub ud_match {my$word=shift;for (my$i=0;$i < @_;$i+=2){if ($word =~ /^(?:$_[$i])$/i){last unless defined $_[$i+1];return eval '"'.$_[$i+1].'"'}}return undef}do {local$SIG{__WARN__}=sub {0};my$rcfile;$rcfile=$INC{'Lingua//EN/Inflect.pm'}|| '';$rcfile =~ s/Inflect.pm$/.inflectrc/;do$rcfile or die "\nBad .inflectrc file ($rcfile):\n\t$@\n" if$rcfile && -r $rcfile && -s $rcfile;$rcfile="$ENV{HOME}/.inflectrc" || '';do$rcfile or die "\nBad .inflectrc file ($rcfile):\n\t$@\n" if$rcfile && -r $rcfile && -s $rcfile};sub postprocess {my ($orig,$inflected)=@_;$inflected =~ s/([^|]+)\|(.+)/ $classical{all}?$2:$1 /e;return$orig =~ /^I$/ ? $inflected : $orig =~ /^[A-Z]+$/ ? uc$inflected : $orig =~ /^[A-Z]/ ? ucfirst$inflected : $inflected}sub PL {my ($str,$count)=@_;my ($pre,$word,$post)=($str =~ m/\A(\s*)(.+?)(\s*)\Z/);return$str unless$word;my$plural=postprocess$word,_PL_special_adjective($word,$count)|| _PL_special_verb($word,$count)|| _PL_noun($word,$count);return$pre.$plural.$post}sub PL_N {my ($str,$count)=@_;my ($pre,$word,$post)=($str =~ m/\A(\s*)(.+?)(\s*)\Z/);return$str unless$word;my$plural=postprocess$word,_PL_noun($word,$count);return$pre.$plural.$post}sub PL_V {my ($str,$count)=@_;my ($pre,$word,$post)=($str =~ m/\A(\s*)(.+?)(\s*)\Z/);return$str unless$word;my$plural=postprocess$word,_PL_special_verb($word,$count)|| _PL_general_verb($word,$count);return$pre.$plural.$post}sub PL_ADJ {my ($str,$count)=@_;my ($pre,$word,$post)=($str =~ m/\A(\s*)(.+?)(\s*)\Z/);return$str unless$word;my$plural=postprocess$word,_PL_special_adjective($word,$count)|| $word;return$pre.$plural.$post}sub PL_eq {_PL_eq(@_,\&PL_N)|| _PL_eq(@_,\&PL_V)|| _PL_eq(@_,\&PL_ADJ)}sub PL_N_eq {_PL_eq(@_,\&PL_N)}sub PL_V_eq {_PL_eq(@_,\&PL_V)}sub PL_ADJ_eq {_PL_eq(@_,\&PL_ADJ)}sub _PL_eq {my ($word1,$word2,$PL)=@_;my%classval=%classical;%classical=%all_classical;my$result="";$result="eq" if!$result && $word1 eq $word2;$result="p:s" if!$result && $word1 eq &$PL($word2);$result="s:p" if!$result && &$PL($word1)eq $word2;%classical=();$result="p:s" if!$result && $word1 eq &$PL($word2);$result="s:p" if!$result && &$PL($word1)eq $word2;%classical=%classval;if ($PL==\&PL || $PL==\&PL_N){$result="p:p" if!$result && _PL_check_plurals_N($word1,$word2);$result="p:p" if!$result && _PL_check_plurals_N($word2,$word1)}if ($PL==\&PL || $PL==\&PL_ADJ){$result="p:p" if!$result && _PL_check_plurals_ADJ($word1,$word2,$PL)}return$result}sub _PL_reg_plurals {$_[0]=~ /($_[1])($_[2]\|\1$_[3]|$_[3]\|\1$_[2])/}sub _PL_check_plurals_N {my$pair="$_[0]|$_[1]";for (values%PL_sb_irregular_s){return 1 if $_ eq $pair}for (values%PL_sb_irregular){return 1 if $_ eq $pair}return 1 if _PL_reg_plurals($pair,$PL_sb_U_a_ata,"as","ata")|| _PL_reg_plurals($pair,$PL_sb_C_a_ata,"as","ata")|| _PL_reg_plurals($pair,$PL_sb_U_is_ides,"is","ides")|| _PL_reg_plurals($pair,$PL_sb_C_is_ides,"is","ides")|| _PL_reg_plurals($pair,$PL_sb_C_a_ae,"s","e")|| _PL_reg_plurals($pair,$PL_sb_C_en_ina,"ens","ina")|| _PL_reg_plurals($pair,$PL_sb_C_um_a,"ums","a")|| _PL_reg_plurals($pair,$PL_sb_C_us_i,"uses","i")|| _PL_reg_plurals($pair,$PL_sb_C_on_a,"ons","a")|| _PL_reg_plurals($pair,$PL_sb_C_o_i,"os","i")|| _PL_reg_plurals($pair,$PL_sb_C_ex_ices,"exes","ices")|| _PL_reg_plurals($pair,$PL_sb_C_ix_ices,"ixes","ices")|| _PL_reg_plurals($pair,$PL_sb_C_i,"s","i")|| _PL_reg_plurals($pair,$PL_sb_C_im,"s","im")|| _PL_reg_plurals($pair,'.*eau',"s","x")|| _PL_reg_plurals($pair,'.*ieu',"s","x")|| _PL_reg_plurals($pair,'.*tri',"xes","ces")|| _PL_reg_plurals($pair,'.{2,}[yia]n',"xes","ges");return 0}sub _PL_check_plurals_ADJ {my ($word1a,$word2a)=@_;my ($word1b,$word2b)=@_;$word1a='' unless$word1a =~ s/'s?$//;$word2a='' unless$word2a =~ s/'s?$//;$word1b='' unless$word1b =~ s/s'$//;$word2b='' unless$word2b =~ s/s'$//;if ($word1a){return 1 if$word2a && (_PL_check_plurals_N($word1a,$word2a)|| _PL_check_plurals_N($word2a,$word1a));return 1 if$word2b && (_PL_check_plurals_N($word1a,$word2b)|| _PL_check_plurals_N($word2b,$word1a))}if ($word1b){return 1 if$word2a && (_PL_check_plurals_N($word1b,$word2a)|| _PL_check_plurals_N($word2a,$word1b));return 1 if$word2b && (_PL_check_plurals_N($word1b,$word2b)|| _PL_check_plurals_N($word2b,$word1b))}return ""}sub _PL_noun {my ($word,$count)=@_;my$value;$count=$persistent_count if!defined($count)&& defined($persistent_count);$count=(defined$count and $count=~/^($PL_count_one)$/io or defined$count and $classical{zero}and $count=~/^($PL_count_zero)$/io)? 1 : 2;return$word if$count==1;return$value if defined($value=ud_match($word,@PL_sb_user_defined));$word eq '' and return$word;$word =~ /^($PL_sb_uninflected)$/i &&!exists$PL_sb_irregular{$word}&& $word !~ /^($PL_sb_lese_lesen)$/i and return$word;$classical{herd}and $word =~ /^($PL_sb_uninflected_herd)$/i and return$word;$word =~ /^($PL_sb_irregular)$/i and return ($PL_sb_irregular{$1}|| $PL_sb_irregular{lc $1});$word =~ /(.*)\b($PL_sb_irregular)$/i and return $1 .($PL_sb_irregular{$2}|| $PL_sb_irregular{lc $2});$word =~ /^(?:$PL_sb_postfix_adj)$/i and $value=$2 and return _PL_noun($1,2).$value;$word =~ /^(?:$PL_sb_prep_dual_compound)$/i and $value=[$2,$3]and return _PL_noun($1,2).$value->[0]._PL_noun($value->[1]);$word =~ /^(?:$PL_sb_prep_compound)$/i and $value=$2 and return _PL_noun($1,2).$value;$word =~ /^((?:$PL_prep)\s+)($PL_pron_acc)$/i and return $1.$PL_pron_acc{lc($2)};$value=$PL_pron_nom{lc($word)}and return$value;$word =~ /^($PL_pron_acc)$/i and return$PL_pron_acc{lc($1)};$word =~ /(.*$PL_sb_U_man_mans)$/i and return "$1s";$word =~ /(\S*)quy$/i and return "$1quies";$word =~ /(\S*)(person)$/i and return$classical{persons}?"$1persons":"$1people";$word =~ /(.*)man$/i and return "$1men";$word =~ /(.*[ml])ouse$/i and return "$1ice";$word =~ /(.*)goose$/i and return "$1geese";$word =~ /(.*)tooth$/i and return "$1teeth";$word =~ /(.*)foot$/i and return "$1feet";$word =~ /(.*)ceps$/i and return$word;$word =~ /(.*)zoon$/i and return "$1zoa";$word =~ /(.*[csx])is$/i and return "$1es";$word =~ /(.*$PL_sb_U_a_ata)a$/i and return "$1ata";$word =~ /(.*$PL_sb_U_is_ides)is$/i and return "$1ides";$word =~ /(.*$PL_sb_U_ch_chs)ch$/i and return "$1chs";$word =~ /(.*$PL_sb_U_ex_ices)ex$/i and return "$1ices";$word =~ /(.*$PL_sb_U_ix_ices)ix$/i and return "$1ices";$word =~ /(.*$PL_sb_U_um_a)um$/i and return "$1a";$word =~ /(.*$PL_sb_U_us_i)us$/i and return "$1i";$word =~ /(.*$PL_sb_U_on_a)on$/i and return "$1a";$word =~ /(.*$PL_sb_U_a_ae)$/i and return "$1e";$word =~ /(.*$PL_sb_lese_lesen)$/i and return "$1n";if ($classical{ancient}){$word =~ /(.*)trix$/i and return "$1trices";$word =~ /(.*)eau$/i and return "$1eaux";$word =~ /(.*)ieu$/i and return "$1ieux";$word =~ /(.{2,}[yia])nx$/i and return "$1nges";$word =~ /(.*$PL_sb_C_en_ina)en$/i and return "$1ina";$word =~ /(.*$PL_sb_C_ex_ices)ex$/i and return "$1ices";$word =~ /(.*$PL_sb_C_ix_ices)ix$/i and return "$1ices";$word =~ /(.*$PL_sb_C_um_a)um$/i and return "$1a";$word =~ /(.*$PL_sb_C_us_i)us$/i and return "$1i";$word =~ /(.*$PL_sb_C_us_us)$/i and return "$1";$word =~ /(.*$PL_sb_C_a_ae)$/i and return "$1e";$word =~ /(.*$PL_sb_C_a_ata)a$/i and return "$1ata";$word =~ /(.*$PL_sb_C_is_ides)is$/i and return "$1ides";$word =~ /(.*$PL_sb_C_o_i)o$/i and return "$1i";$word =~ /(.*$PL_sb_C_on_a)on$/i and return "$1a";$word =~ /$PL_sb_C_im$/i and return "${word}im";$word =~ /$PL_sb_C_i$/i and return "${word}i"}$word =~ /^($PL_sb_singular_s)$/i and return "$1es";$word =~ /^([A-Z].*s)$/ and $classical{names}and return "$1es";$word =~ /^($PL_sb_z_zes)$/i and return "$1es";$word =~ /^(.*[^z])(z)$/i and return "$1zzes";$word =~ /^(.*)([cs]h|x|zz|ss)$/i and return "$1$2es";$word =~ /(.*[eao])lf$/i and return "$1lves";$word =~ /(.*[^d])eaf$/i and return "$1eaves";$word =~ /(.*[nlw])ife$/i and return "$1ives";$word =~ /(.*)arf$/i and return "$1arves";$word =~ /(.*[aeiou])y$/i and return "$1ys";$word =~ /([A-Z].*y)$/ and $classical{names}and return "$1s";$word =~ /(.*)y$/i and return "$1ies";$word =~ /$PL_sb_U_o_os$/i and return "${word}s";$word =~ /[aeiou]o$/i and return "${word}s";$word =~ /o$/i and return "${word}es";return "${word}s"}sub _PL_special_verb {my ($word,$count)=@_;$count=$persistent_count if!defined($count)&& defined($persistent_count);$count=(defined$count and $count=~/^($PL_count_one)$/io or defined$count and $classical{zero}and $count=~/^($PL_count_zero)$/io)? 1 : 2;return undef if$count=~/^($PL_count_one)$/io;my$value;return$value if defined($value=ud_match($word,@PL_v_user_defined));$word =~ /^($PL_v_irregular_pres)((\s.*)?)$/i and return$PL_v_irregular_pres{lc $1}.$2;$word =~ /^($PL_v_irregular_non_pres)((\s.*)?)$/i and return$word;$word =~ /^($PL_v_irregular_pres)(n't(\s.*)?)$/i and return$PL_v_irregular_pres{lc $1}.$2;$word =~ /^\S+n't\b/i and return$word;$word =~ /^($PL_v_special_s)$/ and return undef;$word =~ /\s/ and return undef;$word =~ /^quizzes$/i and return "quiz";$word =~ /^(.*)([cs]h|[x]|zz|ss)es$/i and return "$1$2";$word =~ /^(..+)ies$/i and return "$1y";$word =~ /($PL_v_oes_oe)$/ and return substr($1,0,-1);$word =~ /^(.+)oes$/i and return "$1o";$word =~ /^(.*[^s])s$/i and return $1;return undef}sub _PL_general_verb {my ($word,$count)=@_;$count=$persistent_count if!defined($count)&& defined($persistent_count);$count=(defined$count and $count=~/^($PL_count_one)$/io or defined$count and $classical{zero}and $count=~/^($PL_count_zero)$/io)? 1 : 2;return$word if$count=~/^($PL_count_one)$/io;$word =~ /^($PL_v_ambiguous_pres)((\s.*)?)$/i and return$PL_v_ambiguous_pres{lc $1}.$2;$word =~ /^($PL_v_ambiguous_non_pres)((\s.*)?)$/i and return$word;return$word}sub _PL_special_adjective {my ($word,$count)=@_;$count=$persistent_count if!defined($count)&& defined($persistent_count);$count=(defined$count and $count=~/^($PL_count_one)$/io or defined$count and $classical{zero}and $count=~/^($PL_count_zero)$/io)? 1 : 2;return$word if$count=~/^($PL_count_one)$/io;my$value;return$value if defined($value=ud_match($word,@PL_adj_user_defined));$word =~ /^($PL_adj_special)$/i and return$PL_adj_special{lc $1};$word =~ /^($PL_adj_poss)$/i and return$PL_adj_poss{lc $1};$word =~ /^(.*)'s?$/ and do {my$pl=PL_N($1);return "$pl'" .($pl =~ m/s$/ ? "" : "s")};return undef}my$A_abbrev=q{
  (?! FJO | [HLMNS]Y.  | RY[EO] | SQU
    | ( F[LR]? | [HL] | MN? | N | RH? | S[CHKLMNPTVW]? | X(YL)?) [AEIOU])
  [FHLMNRSX][A-Z]
  };my$A_y_cons='y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)';my$A_explicit_an=enclose join '|',("euler","hour(?!i)","heir","honest","hono",);my$A_ordinal_an=enclose join '|',("[aefhilmnorsx]-?th",);my$A_ordinal_a=enclose join '|',("[bcdgjkpqtuvwyz]-?th",);sub A {my ($str,$count)=@_;my ($pre,$word,$post)=($str =~ m/\A(\s*)(?:an?\s+)?(.+?)(\s*)\Z/i);return$str unless$word;my$result=_indef_article($word,$count);return$pre.$result.$post}sub AN {goto&A}sub _indef_article {my ($word,$count)=@_;$count=$persistent_count if!defined($count)&& defined($persistent_count);return "$count $word" if defined$count && $count!~/^($PL_count_one)$/io;my$value;return "$value $word" if defined($value=ud_match($word,@A_a_user_defined));$word =~ /^($A_ordinal_a)/i and return "a $word";$word =~ /^($A_ordinal_an)/i and return "an $word";$word =~ /^($A_explicit_an)/i and return "an $word";$word =~ /^[aefhilmnorsx]$/i and return "an $word";$word =~ /^[bcdgjkpqtuvwyz]$/i and return "a $word";$word =~ /^($A_abbrev)/ox and return "an $word";$word =~ /^[aefhilmnorsx][.-]/i and return "an $word";$word =~ /^[a-z][.-]/i and return "a $word";$word =~ /^[^aeiouy]/i and return "a $word";$word =~ /^e[uw]/i and return "a $word";$word =~ /^onc?e\b/i and return "a $word";$word =~ /^uni([^nmd]|mo)/i and return "a $word";$word =~ /^ut[th]/i and return "an $word";$word =~ /^u[bcfhjkqrst][aeiou]/i and return "a $word";$word =~ /^U[NK][AIEO]?/ and return "a $word";$word =~ /^[aeiou]/i and return "an $word";$word =~ /^($A_y_cons)/io and return "an $word";return "a $word"}sub NO {my ($str,$count,$opt_ref)=@_;my ($pre,$word,$post)=($str =~ m/\A(\s*)(.+?)(\s*)\Z/);$count=$persistent_count if!defined($count)&& defined($persistent_count);$count=0 unless$count;if ($count =~ /^$PL_count_zero$/){return "${pre}no ".PL($word,0).$post }$count =~ s{[^\d.e+-]}{}gi;1 while$count =~ s{([.].*)[.]}{$1};$count=defined$opt_ref->{words_below}&& $count < $opt_ref->{words_below}? NUMWORDS($count): $count;if (defined$opt_ref->{comma}|| defined$opt_ref->{comma_every}){$opt_ref->{comma_every}=3 if!defined$opt_ref->{comma_every};$opt_ref->{comma}=',' if!defined$opt_ref->{comma}|| $opt_ref->{comma}=~ /^\d+$/;$count=_commify($count,@{$opt_ref}{'comma','comma_every'})}return "$pre$count " .PL($word,$count).$post}sub _commify {my ($number,$comma,$every)=@_;return if!defined$comma;return if!defined$comma;$number =~ s{(?:(?<=^)|(?<=^-))(\d\d{$every,})}
                  { my $n = $1;
                    $n=~s/(?<=.)(?=(?:.{$every})+$)/$comma/g;
                    $n;
                  }e;return$number}sub PART_PRES {local $_=PL_V(shift,2);s/ie$/y/ or s/ue$/u/ or s/([auy])e$/$1/ or s/ski$/ski/ or s/[^b]i$// or s/^(are|were)$/be/ or s/^(had)$/hav/ or s/(hoe)$/$1/ or s/([^e])e$/$1/ or m/er$/ or s/([^aeiou][aeiouy]([bdgmnprst]))$/$1$2/;return "${_}ing"}my%nth=(0=>'th',1=>'st',2=>'nd',3=>'rd',4=>'th',5=>'th',6=>'th',7=>'th',8=>'th',9=>'th',11=>'th',12=>'th',13=>'th',);my%ordinal;@ordinal{qw(ty one two three five eight nine twelve)}=qw(tieth first second third fifth eighth ninth twelfth);my$ordinal_suff=join '|',keys%ordinal,"";$ordinal{""}='th';sub ORD($) {my$num=shift;if ($num =~ /\d/){my$tail=substr($num,-3);return$num .($nth{$tail%100}|| $nth{$tail%10})}else {$num =~ s/($ordinal_suff)\Z/$ordinal{$1}/;return$num}}my%default_args=('group'=>0,'comma'=>',','and'=>'and','zero'=>'zero','one'=>'one','decimal'=>'point',);my@unit=('',qw(one two three four five six seven eight nine));my@teen=qw(ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen);my@ten=('','',qw(twenty thirty forty fifty sixty seventy eighty ninety));our%millmap=('0'=>{US=>q(),UK=>q(),EU=>q()},'3'=>{US=>q(thousand),UK=>q(thousand),EU=>q(thousand)},'6'=>{US=>q(million),UK=>q(million),EU=>q(million)},'9'=>{US=>q(billion),UK=>q(thousand million),EU=>q(milliard)},'12'=>{US=>q(trillion),UK=>q(billion),EU=>q(billion)},'15'=>{US=>q(quadrillion),UK=>q(thousand billion),EU=>q(billiard)},'18'=>{US=>q(quintillion),UK=>q(trillion),EU=>q(trillion)},'21'=>{US=>q(sextillion),UK=>q(thousand trillion),EU=>q(trilliard)},'24'=>{US=>q(septillion),UK=>q(quadrillion),EU=>q(quadrillion)},'27'=>{US=>q(octillion),UK=>q(thousand quadrillion),EU=>q(quadrilliard)},'30'=>{US=>q(nonillion),UK=>q(quintillion),EU=>q(quintillion)},'33'=>{US=>q(decillion),UK=>q(thousand quintillion),EU=>q(quintilliard)},'36'=>{US=>q(undecillion),UK=>q(sextillion),EU=>q(sextillion)},'39'=>{US=>q(duodecillion),UK=>q(thousand sextillion),EU=>q(sextilliard)},'42'=>{US=>q(tredecillion),UK=>q(septillion),EU=>q(septillion)},'45'=>{US=>q(quattuordecillion),UK=>q(thousand septillion),EU=>q(septilliard)},'48'=>{US=>q(quindecillion),UK=>q(octillion),EU=>q(octillion)},'51'=>{US=>q(sedecillion),UK=>q(thousand octillion),EU=>q(octilliard)},'54'=>{US=>q(septendecillion),UK=>q(nonillion),EU=>q(nonillion)},'57'=>{US=>q(octodecillion),UK=>q(thousand nonillion),EU=>q(nonilliard)},'60'=>{US=>q(novendecillion),UK=>q(decillion),EU=>q(decillion)},'63'=>{US=>q(vigintillion),UK=>q(thousand decillion),EU=>q(decilliard)},'66'=>{US=>q(unvigintillion),UK=>q(undecillion),EU=>q(undecillion)},'69'=>{US=>q(duovigintillion),UK=>q(thousand undecillion),EU=>q(undecilliard)},'72'=>{US=>q(tresvigintillion),UK=>q(duodecillion),EU=>q(duodecillion)},'75'=>{US=>q(quattuorvigintillion),UK=>q(thousand duodecillion),EU=>q(duodecilliard)},'78'=>{US=>q(quinquavigintillion),UK=>q(tredecillion),EU=>q(tredecillion)},'81'=>{US=>q(sesvigintillion),UK=>q(thousand tredecillion),EU=>q(tredecilliard)},'84'=>{US=>q(septemvigintillion),UK=>q(quattuordecillion),EU=>q(quattuordecillion)},'87'=>{US=>q(octovigintillion),UK=>q(thousand quattuordecillion),EU=>q(quattuordecilliard)},'90'=>{US=>q(novemvigintillion),UK=>q(quindecillion),EU=>q(quindecillion)},'93'=>{US=>q(trigintillion),UK=>q(thousand quindecillion),EU=>q(quindecilliard)},'96'=>{US=>q(untrigintillion),UK=>q(sedecillion),EU=>q(sedecillion)},'99'=>{US=>q(duotrigintillion),UK=>q(thousand sedecillion),EU=>q(sedecilliard)},'102'=>{US=>q(trestrigintillion),UK=>q(septendecillion),EU=>q(septendecillion)},'105'=>{US=>q(quattuortrigintillion),UK=>q(thousand septendecillion),EU=>q(septendecilliard)},'108'=>{US=>q(quinquatrigintillion),UK=>q(octodecillion),EU=>q(octodecillion)},'111'=>{US=>q(sestrigintillion),UK=>q(thousand octodecillion),EU=>q(octodecilliard)},'114'=>{US=>q(septentrigintillion),UK=>q(novendecillion),EU=>q(novendecillion)},'117'=>{US=>q(octotrigintillion),UK=>q(thousand novendecillion),EU=>q(novendecilliard)},'120'=>{US=>q(noventrigintillion),UK=>q(vigintillion),EU=>q(vigintillion)},'123'=>{US=>q(quadragintillion),UK=>q(thousand vigintillion),EU=>q(vigintilliard)},'153'=>{US=>q(quinquagintillion),UK=>q(thousand quinquavigintillion),EU=>q(quinquavigintilliard) },'183'=>{US=>q(sexagintillion),UK=>q(thousand trigintillion),EU=>q(trigintilliard) },'213'=>{US=>q(septuagintillion),UK=>q(thousand quinquatrigintillion),EU=>q(quinquatrigintilliard) },'243'=>{US=>q(octogintillion),UK=>q(thousand quadragintillion),EU=>q(quadragintilliard) },'273'=>{US=>q(nonagintillion),UK=>q(thousand quinquaquadragintillion),EU=>q(quinquaquadragintilliard) },'303'=>{US=>q(centillion),UK=>q(thousand quinquagintillion),EU=>q(quinquagintilliard) },'306'=>{US=>q(uncentillion),UK=>q(unquinquagintillion),EU=>q(unquinquagintillion) },'309'=>{US=>q(duocentillion),UK=>q(thousand unquinquagintillion),EU=>q(unquinquagintilliard) },'312'=>{US=>q(trescentillion),UK=>q(duoquinquagintillion),EU=>q(duoquinquagintillion) },'333'=>{US=>q(decicentillion),UK=>q(thousand quinquaquinquagintillion),EU=>q(quinquaquinquagintilliard) },'336'=>{US=>q(undecicentillion),UK=>q(sesquinquagintillion),EU=>q(sesquinquagintillion) },'363'=>{US=>q(viginticentillion),UK=>q(thousand sexagintillion),EU=>q(sexagintilliard) },'366'=>{US=>q(unviginticentillion),UK=>q(unsexagintillion),EU=>q(unsexagintillion) },'393'=>{US=>q(trigintacentillion),UK=>q(thousand quinquasexagintillion),EU=>q(quinquasexagintilliard) },'423'=>{US=>q(quadragintacentillion),UK=>q(thousand septuagintillion),EU=>q(septuagintilliard) },'453'=>{US=>q(quinquagintacentillion),UK=>q(thousand quinquaseptuagintillion),EU=>q(quinquaseptuagintilliard) },'483'=>{US=>q(sexagintacentillion),UK=>q(thousand octogintillion),EU=>q(octogintilliard) },'513'=>{US=>q(septuagintacentillion),UK=>q(thousand quinquaoctogintillion),EU=>q(quinquaoctogintilliard) },'543'=>{US=>q(octogintacentillion),UK=>q(thousand nonagintillion),EU=>q(nonagintilliard) },'573'=>{US=>q(nonagintacentillion),UK=>q(thousand quinquanonagintillion),EU=>q(quinquanonagintilliard) },'603'=>{US=>q(ducentillion),UK=>q(thousand centillion),EU=>q(centilliard) },'903'=>{US=>q(trecentillion),UK=>q(thousand quinquagintacentillion),EU=>q(quinquagintacentilliard) },'1203'=>{US=>q(quadringentillion),UK=>q(thousand ducentillion),EU=>q(ducentilliard) },'1503'=>{US=>q(quingentillion),UK=>q(thousand quinquagintaducentillion),EU=>q(quinquagintaducentilliard) },'1803'=>{US=>q(sescentillion),UK=>q(thousand trecentillion),EU=>q(trecentilliard) },'2103'=>{US=>q(septingentillion),UK=>q(thousand quinquagintatrecentillion),EU=>q(quinquagintatrecentilliard) },'2403'=>{US=>q(octingentillion),UK=>q(thousand quadringentillion),EU=>q(quadringentilliard) },'2703'=>{US=>q(nongentillion),UK=>q(thousand quinquagintaquadringentillion),EU=>q(quinquagintaquadringentilliard) },'3003'=>{US=>q(millinillion),UK=>q(thousand quingentillion),EU=>q(quingentilliard) },);my$millchoice='US';my@millkeys=sort {$a <=> $b}keys%millmap;my$maxmill=(sort {$a <=> $b}keys%millmap)[-1];our$millast=undef;our@mill;for my$numZeros (0..$maxmill){next if$numZeros%3!=0;my$arraySlot=$numZeros/3;if(defined($millmap{$numZeros})){$mill[$arraySlot]=" $millmap{$numZeros}->{$millchoice}";$millast=$arraySlot}else {my$missing=$arraySlot - $millast;$mill[$arraySlot]=$mill[$missing].$mill[$millast]}}sub mill {my$ind=$_[0]||0;die "Number out of range\n" if$ind > $#mill;return$ind<@mill ? $mill[$ind]: ' ???illion'}sub unit {return$unit[$_[0]].mill($_[1])}sub ten {return$ten[$_[0]].($_[0]&&$_[1]?'-':'').$unit[$_[1]].mill($_[2])if $_[0]ne '1';return$teen[$_[1]].$mill[$_[2]||0]}sub hund {return unit($_[0])." hundred" .($_[1]|| $_[2]? " $_[4] " : '').ten($_[1],$_[2]).mill($_[3]).', ' if $_[0];return ten($_[1],$_[2]).mill($_[3]).', ' if $_[1]|| $_[2];return ''}sub enword {my ($num,$group,$zero,$one,$comma,$and)=@_;if ($group==1){$num =~ s/(\d)/ ($1==1 ? " $one" : $1 ? unit($1) :" $zero")."$comma " /eg}elsif ($group==2){$num =~ s/(\d)(\d)/ ($1 ? ten($1,$2) : $2 ? " $zero " . unit($2) : " $zero $zero") . "$comma " /eg;$num =~ s/(\d)/ ($1 ? unit($1) :" $zero")."$comma " /e}elsif ($group==3){$num =~ s/(\d)(\d)(\d)/ ($1==1 ? " $one" : $1 ? unit($1) :" $zero")." ".($2 ? ten($2,$3) : $3 ? " $zero " . unit($3) : " $zero $zero") . "$comma " /eg;$num =~ s/(\d)(\d)/ ($1 ? ten($1,$2) : $2 ? " $zero " . unit($2) : " $zero $zero") . "$comma " /e;$num =~ s/(\d)/ ($1==1 ? " $one" : $1 ? unit($1) :" $zero")."$comma " /e}elsif ($num+0==0){$num=$zero}elsif ($num+0==1){$num=$one}else {$num =~ s/\A\s*0+//;my$mill=0;1 while$num =~ s/(\d)(\d)(\d)(?=\D*\Z)/ hund($1,$2,$3,$mill++,$and) /e;$num =~ s/(\d)(\d)(?=\D*\Z)/ ten($1,$2,$mill)."$comma " /e;$num =~ s/(\d)(?=\D*\Z)/ unit($1,$mill) . "$comma "/e}return$num}sub NUMWORDS {my$num=shift;if (@_ % 2 and require Carp){die "Missing value in option list (odd number of option args) at" .join ' line ',(caller)[1,2]}my%arg=(%default_args,@_);my$group=$arg{group};if (exists$arg{threshold}&& $num > $arg{threshold}){my ($whole,$frac)=split /[.]/,$num;while ($arg{comma}){$whole =~ s{ (\d) ( \d{3}(?:,|\z) ) }{$1,$2}xms or last}return$frac ? "$whole.$frac" : $whole}die "Bad chunking option: $group\n" unless$group =~ /\A[0-3]\Z/;my$sign=($num =~ /\A\s*\+/)? "plus" : ($num =~ /\A\s*\-/)? "minus" : '';my ($zero,$one)=@arg{'zero','one'};my$comma=$arg{comma};my$and=$arg{'and'};my$ord=$num =~ s/(st|nd|rd|th)\Z//;my@chunks=($arg{decimal})? $group ? split(/\./,$num): split(/\./,$num,2): ($num);my$first=1;if ($chunks[0]eq ''){$first=0;shift@chunks}for (@chunks){s/\D//g;$_='0' unless $_;if (!$group &&!$first){$_=enword($_,1,$zero,$one,$comma,$and)}else {$_=enword($_,$group,$zero,$one,$comma,$and)}s/, \Z//;s/\s+,/,/g;s/, (\S+)\s+\Z/ $and $1/ if!$group and $first;s/\s+/ /g;s/(\A\s|\s\Z)//g;$first='' if$first}my@numchunks=();if ($first =~ /0/){unshift@chunks,''}else {@numchunks=split /\Q$comma /,$chunks[0]}$numchunks[-1]=~ s/($ordinal_suff)\Z/$ordinal{$1}/ if$ord and @numchunks;for (@chunks[1..$#chunks]){push@numchunks,$arg{decimal};push@numchunks,split /\Q$comma /}if (wantarray){unshift@numchunks,$sign if$sign;return@numchunks}elsif ($group){return ($sign?"$sign ":'').join ", ",@numchunks}else {$num=($sign?"$sign ":'').shift@numchunks;$first=($num !~ /$arg{decimal}\Z/);for (@numchunks){if (/\A$arg{decimal}\Z/){$num .= " $_";$first=0}elsif ($first){$num .= "$comma $_"}else {$num .= " $_"}}return$num}}sub WORDLIST {my%opt;my@words;for my$arg (@_){if (ref$arg eq 'HASH'){%opt=(%opt,%{$arg})}else {push@words,$arg}}return "" if@words==0;return "$words[0]" if@words==1;my$conj=exists($opt{conj})? $opt{conj}: 'and';if (@words==2){$conj =~ s/^ (?=\S)  |  (?<=\S) $/ /gxms;return "$words[0]$conj$words[1]"}my$sep=exists$opt{sep}? $opt{sep}: grep(/,/,@words)? q{; } : q{, } ;my$final_sep=!exists$opt{final_sep}? "$sep $conj" : length($opt{final_sep})==0 ? $conj : "$opt{final_sep} $conj" ;$final_sep =~ s/\s+/ /gmxs;$final_sep =~ s/^ (?=[^\W\d_])  |  (?<=\S) $/ /gxms;return join($sep,@words[0..@words-2])."$final_sep$words[-1]"}1;
LINGUA_EN_INFLECT

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;use 5.008_001;use strict;use warnings;my$have_xs;BEGIN {our$VERSION='0.01';unless (defined($have_xs)){eval {require List::MoreUtils::XS}unless$ENV{LIST_MOREUTILS_PP};die $@ if $@ && defined$ENV{LIST_MOREUTILS_PP}&& $ENV{LIST_MOREUTILS_PP}==0;$have_xs=0+defined($INC{'List/MoreUtils/XS.pm'})}use List::MoreUtils::PP qw()}use Exporter::Tiny qw();my@junctions=qw(any all none notall);my@v0_22=qw(true false firstidx lastidx insert_after insert_after_string apply indexes after after_incl before before_incl firstval lastval each_array each_arrayref pairwise natatime mesh uniq minmax part _XScompiled);my@v0_24=qw(bsearch);my@v0_33=qw(sort_by nsort_by);my@v0_400=qw(one any_u all_u none_u notall_u one_u firstres onlyidx onlyval onlyres lastres singleton bsearchidx);my@all_functions=(@junctions,@v0_22,@v0_24,@v0_33,@v0_400);no strict "refs";if ($have_xs){my$x;for (@all_functions){List::MoreUtils->can($_)or *$_=$x if ($x=List::MoreUtils::XS->can($_))}}List::MoreUtils->can($_)or *$_=List::MoreUtils::PP->can($_)for (@all_functions);use strict;my%alias_list=(v0_22=>{first_index=>"firstidx",last_index=>"lastidx",first_value=>"firstval",last_value=>"lastval",zip=>"mesh",},v0_33=>{distinct=>"uniq",},v0_400=>{first_result=>"firstres",only_index=>"onlyidx",only_value=>"onlyval",only_result=>"onlyres",last_result=>"lastres",bsearch_index=>"bsearchidx",},);our@ISA=qw(Exporter::Tiny);our@EXPORT_OK=(@all_functions,map {keys %$_}values%alias_list);our%EXPORT_TAGS=(all=>\@EXPORT_OK,'like_0.22'=>[any_u=>{-as=>'any'},all_u=>{-as=>'all'},none_u=>{-as=>'none'},notall_u=>{-as=>'notall'},@v0_22,keys %{$alias_list{v0_22}},],'like_0.24'=>[any_u=>{-as=>'any'},all_u=>{-as=>'all'},notall_u=>{-as=>'notall'},'none',@v0_22,@v0_24,keys %{$alias_list{v0_22}},],'like_0.33'=>[@junctions,@v0_22,@v0_33,keys %{$alias_list{v0_22}},keys %{$alias_list{v0_33}},],);for my$set (values%alias_list){for my$alias (keys %$set){no strict qw(refs);*$alias=__PACKAGE__->can($set->{$alias})}}1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;use 5.008_001;use strict;use warnings;our$VERSION='0.01';sub any (&@) {my$f=shift;for (@_){return 1 if$f->()}return 0}sub all (&@) {my$f=shift;for (@_){return 0 unless$f->()}return 1}sub none (&@) {my$f=shift;for (@_){return 0 if$f->()}return 1}sub notall (&@) {my$f=shift;for (@_){return 1 unless$f->()}return 0}sub one (&@) {my$f=shift;my$found=0;for (@_){$f->()and $found++ and return 0}$found}sub any_u (&@) {my$f=shift;return if!@_;$f->()and return 1 foreach (@_);return 0}sub all_u (&@) {my$f=shift;return if!@_;$f->()or return 0 foreach (@_);return 1}sub none_u (&@) {my$f=shift;return if!@_;$f->()and return 0 foreach (@_);return 1}sub notall_u (&@) {my$f=shift;return if!@_;$f->()or return 1 foreach (@_);return 0}sub one_u (&@) {my$f=shift;return if!@_;my$found=0;for (@_){$f->()and $found++ and return 0}$found}sub true (&@) {my$f=shift;my$count=0;$f->()and ++$count foreach (@_);return$count}sub false (&@) {my$f=shift;my$count=0;$f->()or ++$count foreach (@_);return$count}sub firstidx (&@) {my$f=shift;for my$i (0 .. $#_){local*_=\$_[$i];return$i if$f->()}return -1}sub firstval (&@) {my$test=shift;for (@_){return $_ if$test->()}return undef}sub firstres (&@) {my$test=shift;for (@_){my$testval=$test->();$testval and return$testval}return undef}sub onlyidx (&@) {my$f=shift;my$found;for my$i (0 .. $#_){local*_=\$_[$i];$f->()or next;defined$found and return -1;$found=$i}return defined$found ? $found : -1}sub onlyval (&@) {my$test=shift;my$result=undef;my$found=0;for (@_){$test->()or next;$result=$_;$found++ and return undef}return$result}sub onlyres (&@) {my$test=shift;my$result=undef;my$found=0;for (@_){my$rv=$test->()or next;$result=$rv;$found++ and return undef}return$found ? $result : undef}sub lastidx (&@) {my$f=shift;for my$i (reverse 0 .. $#_){local*_=\$_[$i];return$i if$f->()}return -1}sub lastval (&@) {my$test=shift;my$ix;for ($ix=$#_;$ix >= 0;$ix-- ){local*_=\$_[$ix];my$testval=$test->();$_[$ix]=$_;return $_ if$testval}return undef}sub lastres (&@) {my$test=shift;my$ix;for ($ix=$#_;$ix >= 0;$ix-- ){local*_=\$_[$ix];my$testval=$test->();$_[$ix]=$_;return$testval if$testval}return undef}sub insert_after (&$\@) {my ($f,$val,$list)=@_;my$c=&firstidx($f,@$list);@$list=(@{$list}[0 .. $c ],$val,@{$list}[$c + 1 .. $#$list ],)and return 1 if$c!=-1;return 0}sub insert_after_string ($$\@) {my ($string,$val,$list)=@_;my$c=firstidx {defined $_ and $string eq $_}@$list;@$list=(@{$list}[0 .. $c ],$val,@{$list}[$c + 1 .. $#$list ],)and return 1 if$c!=-1;return 0}sub apply (&@) {my$action=shift;&$action foreach my@values=@_;wantarray ? @values : $values[-1]}sub after (&@) {my$test=shift;my$started;my$lag;grep$started ||= do {my$x=$lag;$lag=$test->();$x},@_}sub after_incl (&@) {my$test=shift;my$started;grep$started ||= $test->(),@_}sub before (&@) {my$test=shift;my$more=1;grep$more &&=!$test->(),@_}sub before_incl (&@) {my$test=shift;my$more=1;my$lag=1;grep$more &&= do {my$x=$lag;$lag=!$test->();$x},@_}sub indexes (&@) {my$test=shift;grep {local*_=\$_[$_];$test->()}0 .. $#_}sub pairwise (&\@\@) {my$op=shift;use vars qw{@A @B};local (*A,*B)=@_;my ($caller_a,$caller_b)=do {my$pkg=caller();no strict 'refs';\*{$pkg .'::a'},\*{$pkg .'::b'}};my$limit=$#A > $#B ? $#A : $#B;local (*$caller_a,*$caller_b);map {(*$caller_a,*$caller_b)=\($A[$_],$B[$_]);$op->()}0 .. $limit}sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {return each_arrayref(@_)}sub each_arrayref {my@list=@_;my$index=0;my$max=0;for (@list){unless (ref $_ eq 'ARRAY'){require Carp;Carp::croak("each_arrayref: argument is not an array reference\n")}$max=@$_ if @$_ > $max}return sub {if (@_){my$method=shift;unless ($method eq 'index'){require Carp;Carp::croak("each_array: unknown argument '$method' passed to iterator.")}return undef if$index==0 || $index > $max;return$index - 1}return if$index >= $max;my$i=$index++;return map $_->[$i],@list}}sub natatime ($@) {my$n=shift;my@list=@_;return sub {return splice@list,0,$n}}sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {my$max=-1;$max < $#$_ && ($max=$#$_)foreach @_;map {my$ix=$_;map $_->[$ix],@_}0 .. $max}sub uniq (@) {my%seen=();my$k;my$seen_undef;grep {defined $_ ? not $seen{$k=$_ }++ : not $seen_undef++}@_}sub singleton (@) {my%seen=();my$k;my$seen_undef;grep {1==(defined $_ ? $seen{$k=$_ }: $seen_undef)}grep {defined $_ ? not $seen{$k=$_ }++ : not $seen_undef++}@_}sub minmax (@) {return unless @_;my$min=my$max=$_[0];for (my$i=1;$i < @_;$i += 2 ){if ($_[$i - 1 ]<= $_[$i]){$min=$_[$i - 1 ]if$min > $_[$i - 1 ];$max=$_[$i]if$max < $_[$i]}else {$min=$_[$i]if$min > $_[$i];$max=$_[$i - 1 ]if$max < $_[$i - 1 ]}}if (@_ & 1){my$i=$#_;if ($_[$i - 1 ]<= $_[$i]){$min=$_[$i - 1 ]if$min > $_[$i - 1 ];$max=$_[$i]if$max < $_[$i]}else {$min=$_[$i]if$min > $_[$i];$max=$_[$i - 1 ]if$max < $_[$i - 1 ]}}return ($min,$max)}sub part (&@) {my ($code,@list)=@_;my@parts;push @{$parts[$code->($_)]},$_ foreach@list;return@parts}sub bsearch(&@) {my$code=shift;my$rc;my$i=0;my$j=@_;do {my$k=int(($i + $j)/ 2);$k >= @_ and return;local*_=\$_[$k];$rc=$code->();$rc==0 and return wantarray ? $_ : 1;if ($rc < 0){$i=$k + 1}else {$j=$k - 1}}until$i > $j;return}sub bsearchidx(&@) {my$code=shift;my$rc;my$i=0;my$j=@_;do {my$k=int(($i + $j)/ 2);$k >= @_ and return -1;local*_=\$_[$k];$rc=$code->();$rc==0 and return$k;if ($rc < 0){$i=$k + 1}else {$j=$k - 1}}until$i > $j;return -1}sub sort_by(&@) {my ($code,@list)=@_;return map {$_->[0]}sort {$a->[1]cmp $b->[1]}map {[$_,scalar($code->())]}@list}sub nsort_by(&@) {my ($code,@list)=@_;return map {$_->[0]}sort {$a->[1]<=> $b->[1]}map {[$_,scalar($code->())]}@list}sub _XScompiled {0}1;
LIST_MOREUTILS_PP

$fatpacked{"Mac/SystemDirectory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MAC_SYSTEMDIRECTORY';
  package Mac::SystemDirectory;use 5.006000;use strict;use warnings;BEGIN {our$VERSION='0.01';our@EXPORT_OK=('FindDirectory','HomeDirectory','TemporaryDirectory');require XSLoader;XSLoader::load('Mac::SystemDirectory',$VERSION);our%EXPORT_TAGS=('all'=>[@EXPORT_OK ],'DomainMask'=>[grep {/^NS.*DomainMask/}@EXPORT_OK ],'Directory'=>[grep {/^NS.*Directory/}@EXPORT_OK ],);require Exporter;*import=\&Exporter::import}1;
MAC_SYSTEMDIRECTORY

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use Moo::_strictures;use Moo::_Utils qw(_load_module _maybe_load_module _install_coderef);use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);use Scalar::Util 'blessed';use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::_Utils)}use overload ();BEGIN {*_CAN_WEAKEN_READONLY=("$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583})? sub(){0}: sub(){1};our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')});our$CAN_HAZ_XS_PRED=$CAN_HAZ_XS && (eval {Class::XSAccessor->VERSION('1.17')})}BEGIN {package Method::Generate::Accessor::_Generated;$Carp::Internal{+__PACKAGE__}=1}my$module_name_only=qr/\A$Module::Runtime::module_name_rx\z/;sub _die_overwrite {my ($pkg,$method,$type)=@_;croak "You cannot overwrite a locally defined method ($method) with " .($type || 'an accessor')}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={no_defer=>1,package=>'Method::Generate::Accessor::_Generated',%{$quote_opts||{}},};$spec->{allow_overwrite}++ if$name =~ s/^\+//;croak "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||= '_build_'.$name unless exists$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){croak "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;croak "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ $module_name_only}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}if (($spec->{coerce}||0)eq 1){my$isa=$spec->{isa};if (blessed$isa and $isa->can('coercion')){$spec->{coerce}=$isa->coercion}elsif (blessed$isa and $isa->can('coerce')){$spec->{coerce}=sub {$isa->coerce(@_)}}else {croak "Invalid coercion for $into->$name - no appropriate type constraint"}}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& defined &{"${into}::${reader}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& defined &{"${into}::${accessor}"};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& defined &{"${into}::${writer}"};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}=>$quote_opts }}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& defined &{"${into}::${pred}"};if (our$CAN_HAZ_XS && our$CAN_HAZ_XS_PRED){$methods{$pred}=$self->_generate_xs(exists_predicates=>$into,$pred,$name,$spec)}else {$self->{captures}={};$methods{$pred}=quote_sub "${into}::${pred}" =>$self->_generate_simple_has('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }}if (my$builder=delete$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$builder)}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& defined &{"${into}::${cl}"};$self->{captures}={};$methods{$cl}=quote_sub "${into}::${cl}" =>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" =>delete$self->{captures}=>$quote_opts }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||= '_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){require Moo::Role;_load_module$hspec;map [$_=>$_ ],Moo::Role->methods_provided_by($hspec)}else {croak "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& defined &{"${into}::${proxy}"};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}" =>$self->_generate_delegation($asserter,$target,\@args)=>delete$self->{captures}=>$quote_opts }}if (my$asserter=$spec->{asserter}){_die_overwrite($into,$asserter,'an asserter')if!$spec->{allow_overwrite}&& defined &{"${into}::${asserter}"};local$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}" =>$self->_generate_asserter($name,$spec)=>delete$self->{captures}=>$quote_opts }\%methods}sub merge_specs {my ($self,@specs)=@_;my$spec=shift@specs;for my$old_spec (@specs){for my$key (keys %$old_spec){if ($key eq 'handles'){}elsif ($key eq 'moosify'){$spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}grep defined,($old_spec->{$key},$spec->{$key})]}elsif (!exists$spec->{$key}){$spec->{$key}=$old_spec->{$key}}}}$spec}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_default {my ($self,$name,$spec)=@_;$spec->{builder}or exists$spec->{default}or (($spec->{is}||'')eq 'lazy')}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\quotify $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\quotify $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): quotify$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_simple_get(@args);($code,delete$self->{captures})}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=quotify$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;my ($me,$source)=('$_[0]','$_[1]');if ($self->is_simple_set($name,$spec)){return$self->_generate_simple_set($me,$name,$spec,$source)}my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};if ($coerce){$source=$self->_generate_coerce($name,$source,$coerce)}if ($isa_check){'scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$isa_check)."),\n" .'  ('.$self->_generate_simple_set($me,$name,$spec,'$value')."),\n" .($trigger ? '('.$self->_generate_trigger($name,$me,'$value',$trigger)."),\n" : '').'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" ."}"}elsif ($trigger){my$set=$self->_generate_simple_set($me,$name,$spec,$source);"scalar (\n" .'  ('.$self->_generate_trigger($name,$me,"($set)",$trigger)."),\n" .'  ('.$self->_generate_simple_get($me,$name,$spec)."),\n" .")"}else {'('.$self->_generate_simple_set($me,$name,$spec,$source).')'}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return quotify($name)if!defined($init_arg)or $init_arg eq $name;return quotify($name).' (constructor argument: '.quotify($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_wrap_attr_exception($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce),1,)}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _wrap_attr_exception {my ($self,$name,$step,$arg,$code,$want_return)=@_;my$prefix=quotify("${step} for "._attr_desc($name,$arg).' failed: ');"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n" .'    init_arg => '.quotify($arg).",\n" .'    name     => '.quotify($name).",\n" .'    step     => '.quotify($step).",\n" ."  };\n" .($want_return ? '  (my $_return),'."\n" : '').'  (my $_error), (my $_old_error = $@);'."\n" ."  (eval {\n" .'    ($@ = $_old_error),'."\n" .'    (' .($want_return ? '$_return ='."\n" : '').$code."),\n" ."    1\n" ."  } or\n" .'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n" .'  ($@ = $_old_error),'."\n" .'  (defined $_error and CORE::die $_error);'."\n" .($want_return ? '  $_return;'."\n" : '')."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_wrap_attr_exception($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_}.sanitize_identifier($name);$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub _sanitize_name {sanitize_identifier($_[1])}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;my$has_default=$self->has_eager_default($name,$spec);if (!($has_default || $test)){return ''}if ($has_default){my$get_default=$self->_generate_get_default($me,$name,$spec);$source=$test ? "(\n  ${test}\n" ."   ? ${source}\n   : " .$get_default .")" : $get_default}if ($spec->{coerce}){$source=$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg)}if ($spec->{isa}){$source='scalar do { my $value = '.$source.";\n" .'  ('.$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg)."),\n" ."  \$value\n" ."}\n"}my$set=$self->_generate_simple_set($me,$name,$spec,$source);my$trigger=$spec->{trigger}? $self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}): undef;if ($has_default){"($set)," .($trigger && $test ? "($test and $trigger)," : '')."\n"}else {"($test and ($set)" .($trigger ? ", ($trigger)" : '')."),\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple=_CAN_WEAKEN_READONLY ? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }" : <<"EOC"}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;my$name_str=quotify($name);"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  ".$self->_generate_simple_has('$_[0]',$name,$spec)."\n" ."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$invalid="Invalid $setting '" .overload::StrVal($value)."' for $into not a coderef";$invalid .= " $appended" if$appended;unless (ref$value and (ref$value eq 'CODE' or blessed($value))){croak "$invalid or code-convertible object"}unless (eval {\&$value}){croak "$invalid and could not be converted to a coderef: $@"}1}1;
          ( eval { Scalar::Util::weaken($simple); 1 }
            ? do { no warnings 'void'; $get }
            : do {
              if( \$@ =~ /Modification of a read-only value attempted/) {
                require Carp;
                Carp::croak( sprintf (
                  'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                  $name_str,
                ) );
              } else {
                die \$@;
              }
            }
          )
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;sub generate_method {my ($self,$into)=@_;quote_sub "${into}::BUILDALL" =>join('',$self->_handle_subbuild($into),qq{    my \$self = shift;\n},$self->buildall_body_for($into,'$self','@_'),qq{    return \$self\n},)=>{}=>{no_defer=>1 }}sub _handle_subbuild {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n".'      return shift->Moo::Object::BUILDALL(@_)'.";\n".'    }'."\n"}sub buildall_body_for {my ($self,$into,$me,$args)=@_;my@builds=grep *{_getglob($_)}{CODE},map "${_}::BUILD",reverse @{mro::get_linear_isa($into)};'    (('.$args.')[0]->{__no_BUILD__} or ('."\n" .join('',map qq{      ${me}->${_}(${args}),\n},@builds)."    )),\n"}1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use Moo::_strictures;use Sub::Quote qw(quote_sub quotify);use Sub::Defer;use Moo::_Utils qw(_getstash _getglob);use Moo::_mro;use Scalar::Util qw(weaken);use Carp qw(croak);use Carp::Heavy ();BEGIN {our@CARP_NOT=qw(Sub::Defer)}BEGIN {local$Moo::sification::disabled=1;require Moo;Moo->import}sub register_attribute_specs {my ($self,@new_specs)=@_;$self->assert_constructor;my$specs=$self->{attribute_specs}||={};my$ag=$self->accessor_generator;while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){croak "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};$ag->merge_specs($new_spec,$old_spec)}if ($new_spec->{required}&&!($ag->has_default($name,$new_spec)||!exists$new_spec->{init_arg}|| defined$new_spec->{init_arg})){croak "You cannot have a required attribute (${name})" ." without a default, builder, or an init_arg"}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||= $self->_build_construction_string}sub buildall_generator {require Method::Generate::BuildAll;Method::Generate::BuildAll->new}sub _build_construction_string {my ($self)=@_;my$builder=$self->{construction_builder};$builder ? $self->$builder : 'bless(' .$self->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;$self->assert_constructor;my$package=$self->{package};my (undef,@isa)=@{mro::get_linear_isa($package)};my$isa=join ',',@isa;my (undef,$from_file,$from_line)=caller(Carp::short_error_loc());my$constructor=defer_sub "${package}::new"=>sub {my (undef,@new_isa)=@{mro::get_linear_isa($package)};if (join(',',@new_isa)ne $isa){my ($expected_new)=grep {*{_getglob($_.'::new')}{CODE}}@isa;my ($found_new)=grep {*{_getglob($_.'::new')}{CODE}}@new_isa;if (($found_new||'')ne ($expected_new||'')){$found_new ||= 'none';$expected_new ||= 'none';croak "Expected parent constructor of $package to be" ." $expected_new, but found $found_new: changing the inheritance" ." chain (\@ISA) at runtime (after $from_file line $from_line) is unsupported"}}my$constructor=$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1,no_defer=>1 });$self->{inlined}=1;weaken($self->{constructor}=$constructor);$constructor};$self->{inlined}=0;weaken($self->{constructor}=$constructor);$self}sub current_constructor {my ($self,$package)=@_;return *{_getglob("${package}::new")}{CODE}}sub assert_constructor {my ($self)=@_;my$package=$self->{package}or return 1;my$current=$self->current_constructor($package)or return 1;my$constructor=$self->{constructor}or croak "Unknown constructor for $package already exists";croak "Constructor for $package has been replaced with an unknown sub" if$constructor!=$current;croak "Constructor for $package has been inlined and cannot be updated" if$self->{inlined}}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$quote_opts={%{$quote_opts||{}},package=>$into,};for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$into_buildargs=$into->can('BUILDARGS');my$body ='    my $invoker = CORE::shift();'."\n" .'    my $class = CORE::ref($invoker) ? CORE::ref($invoker) : $invoker;'."\n" .$self->_handle_subconstructor($into,$name).($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS ? $self->_generate_args_via_buildargs : $self->_generate_args).$self->_check_required($spec).'    my $new = '.$self->construction_string.";\n" .$self->_assign_new($spec).($into->can('BUILD')? $self->buildall_generator->buildall_body_for($into,'$new','$args'): '').'    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.quotify($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    Carp::croak("BUILDARGS did not return a hashref") unless CORE::ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg=$test{$_};my$arg_key=quotify($arg);my$test=defined$arg ? "exists \$args->{$arg_key}" : undef;my$source=defined$arg ? "\$args->{$arg_key}" : undef;my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$arg,))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my%s=%{$spec->{$_}};$s{required}and not($s{builder}or exists$s{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, ' .join(', ',map quotify($_),@required_init).') {'."\n" .q{      Carp::croak("Missing required arguments: ".CORE::join(', ', sort @missing));}."\n" ."    }\n"}sub new {my$class=shift;delete _getstash(__PACKAGE__)->{new};bless$class->BUILDARGS(@_),$class}Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },construction_builder=>{is=>'bare' },subconstructor_handler=>{is=>'ro' },package=>{is=>'bare' },);if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for(__PACKAGE__)}1;
      my $args = scalar @_ == 1
        ? CORE::ref $_[0] eq 'HASH'
          ? { %{ $_[0] } }
          : Carp::croak("Single parameters to new() must be a HASH ref"
              . " data => ". $_[0])
        : @_ % 2
          ? Carp::croak("The new() method for $class expects a hash reference or a"
              . " key/value list. You passed an odd number of arguments")
          : {@_}
      ;
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;use Moo::_strictures;use Moo::Object ();BEGIN {our@ISA=qw(Moo::Object)}use Sub::Quote qw(quote_sub quotify);use Moo::_Utils qw(_getglob);use Moo::_mro;sub generate_method {my ($self,$into)=@_;quote_sub "${into}::DEMOLISHALL",join '',$self->_handle_subdemolish($into),qq{    my \$self = shift;\n},$self->demolishall_body_for($into,'$self','@_'),qq{    return \$self\n};quote_sub "${into}::DESTROY",join '',q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !}sub demolishall_body_for {my ($self,$into,$me,$args)=@_;my@demolishers=grep *{_getglob($_)}{CODE},map "${_}::DEMOLISH",@{mro::get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@demolishers}sub _handle_subdemolish {my ($self,$into)=@_;'    if (ref($_[0]) ne '.quotify($into).') {'."\n".'      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".'    }'."\n"}1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.01';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;$Module::Implementation::VERSION='0.01';use strict;use warnings;use Module::Runtime 0.012 qw(require_module);use Try::Tiny;unless (exists$Module::Implementation::{VERSION}&& ${$Module::Implementation::{VERSION}}){$Module::Implementation::{VERSION}=\42}my%Implementation;sub build_loader_sub {my$caller=caller();return _build_loader($caller,@_)}sub _build_loader {my$package=shift;my%args=@_;my@implementations=@{$args{implementations}};my@symbols=@{$args{symbols}|| []};my$implementation;my$env_var=uc$package;$env_var =~ s/::/_/g;$env_var .= '_IMPLEMENTATION';return sub {my ($implementation,$loaded)=_load_implementation($package,$ENV{$env_var},\@implementations,);$Implementation{$package}=$implementation;_copy_symbols($loaded,$package,\@symbols);return$loaded}}sub implementation_for {my$package=shift;return$Implementation{$package}}sub _load_implementation {my$package=shift;my$env_value=shift;my$implementations=shift;if ($env_value){die "$env_value is not a valid implementation for $package" unless grep {$_ eq $env_value}@{$implementations};my$requested="${package}::$env_value";($requested)=$requested =~ /^(.+)$/;try {require_module($requested)}catch {require Carp;Carp::croak("Could not load $requested: $_")};return ($env_value,$requested)}else {my$err;for my$possible (@{$implementations}){my$try="${package}::$possible";my$ok;try {require_module($try);$ok=1}catch {$err .= $_ if defined $_};return ($possible,$try)if$ok}require Carp;if (defined$err && length$err){Carp::croak("Could not find a suitable $package implementation: $err")}else {Carp::croak('Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken')}}}sub _copy_symbols {my$from_package=shift;my$to_package=shift;my$symbols=shift;for my$sym (@{$symbols}){my$type=$sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';my$from="${from_package}::$sym";my$to="${to_package}::$sym";{no strict 'refs';no warnings 'once';*{$to}=$type eq '&' ? \&{$from}: $type eq '$' ? \${$from}: $type eq '@' ? \@{$from}: $type eq '%' ? \%{$from}: $type eq '*' ? *{$from}: die "Can't copy symbol from $from_package to $to_package: $type$sym"}}}1;
MODULE_IMPLEMENTATION

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;use strict;use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);use Module::Pluggable::Object;use if $] > 5.017,'deprecate';$VERSION='0.01';$FORCE_SEARCH_ALL_PATHS=0;sub import {my$class=shift;my%opts=@_;my ($pkg,$file)=caller;my$sub=$opts{'sub_name'}|| 'plugins';my ($package)=$opts{'package'}|| $pkg;$opts{filename}=$file;$opts{package}=$package;$opts{force_search_all_paths}=$FORCE_SEARCH_ALL_PATHS unless exists$opts{force_search_all_paths};my$finder=Module::Pluggable::Object->new(%opts);my$subroutine=sub {my$self=shift;return$finder->plugins(@_)};my$searchsub=sub {my$self=shift;my ($action,@paths)=@_;$finder->{'search_path'}=["${package}::Plugin"]if ($action eq 'add' and not $finder->{'search_path'});push @{$finder->{'search_path'}},@paths if ($action eq 'add');$finder->{'search_path'}=\@paths if ($action eq 'new');return$finder->{'search_path'}};my$onlysub=sub {my ($self,$only)=@_;if (defined$only){$finder->{'only'}=$only};return$finder->{'only'}};my$exceptsub=sub {my ($self,$except)=@_;if (defined$except){$finder->{'except'}=$except};return$finder->{'except'}};no strict 'refs';no warnings qw(redefine prototype);*{"$package\::$sub"}=$subroutine;*{"$package\::search_path"}=$searchsub;*{"$package\::only"}=$onlysub;*{"$package\::except"}=$exceptsub}1;
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;use strict;use File::Find ();use File::Basename;use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);use Carp qw(croak carp confess);use Devel::InnerPackage;use vars qw($VERSION $MR);use if $] > 5.017,'deprecate';$VERSION='0.01';BEGIN {eval {require Module::Runtime};unless ($@){Module::Runtime->import('require_module')}else {*require_module=sub {my$module=shift;my$path=$module .".pm";$path =~ s{::}{/}g;require$path}}}sub new {my$class=shift;my%opts=@_;return bless \%opts,$class}sub plugins {my$self=shift;my@args=@_;$self->{'require'}=1 if$self->{'inner'};my$filename=$self->{'filename'};my$pkg=$self->{'package'};$self->_setup_exceptions;for (qw(search_path search_dirs)){$self->{$_}=[$self->{$_}]if exists$self->{$_}&&!ref($self->{$_})}$self->{'search_path'}||= ["${pkg}::Plugin"];$self->{'on_require_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't require $plugin : $err";return 0};$self->{'on_instantiate_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't instantiate $plugin: $err";return 0};$self->{'follow_symlinks'}=1 unless exists$self->{'follow_symlinks'};my@SEARCHDIR=exists$INC{"blib.pm"}&& defined$filename && $filename =~ m!(^|/)blib/! &&!$self->{'force_search_all_paths'}? grep {/blib/}@INC : @INC;unshift@SEARCHDIR,@{$self->{'search_dirs'}}if defined$self->{'search_dirs'};my@tmp=@INC;unshift@tmp,@{$self->{'search_dirs'}|| []};local@INC=@tmp if defined$self->{'search_dirs'};my@plugins=$self->search_directories(@SEARCHDIR);push(@plugins,$self->handle_inc_hooks($_,@SEARCHDIR))for @{$self->{'search_path'}};push(@plugins,$self->handle_innerpackages($_))for @{$self->{'search_path'}};return ()unless@plugins;my%plugins;for(@plugins){next unless$self->_is_legit($_);$plugins{$_}=1}if (defined$self->{'instantiate'}){my$method=$self->{'instantiate'};my@objs=();for my$package (sort keys%plugins){next unless$package->can($method);my$obj=eval {$package->$method(@_)};$self->{'on_instantiate_error'}->($package,$@)if $@;push@objs,$obj if$obj}return@objs}else {my@objs=sort keys%plugins;return@objs}}sub _setup_exceptions {my$self=shift;my%only;my%except;my$only;my$except;if (defined$self->{'only'}){if (ref($self->{'only'})eq 'ARRAY'){%only=map {$_=>1}@{$self->{'only'}}}elsif (ref($self->{'only'})eq 'Regexp'){$only=$self->{'only'}}elsif (ref($self->{'only'})eq ''){$only{$self->{'only'}}=1}}if (defined$self->{'except'}){if (ref($self->{'except'})eq 'ARRAY'){%except=map {$_=>1}@{$self->{'except'}}}elsif (ref($self->{'except'})eq 'Regexp'){$except=$self->{'except'}}elsif (ref($self->{'except'})eq ''){$except{$self->{'except'}}=1}}$self->{_exceptions}->{only_hash}=\%only;$self->{_exceptions}->{only}=$only;$self->{_exceptions}->{except_hash}=\%except;$self->{_exceptions}->{except}=$except}sub _is_legit {my$self=shift;my$plugin=shift;my%only=%{$self->{_exceptions}->{only_hash}||{}};my%except=%{$self->{_exceptions}->{except_hash}||{}};my$only=$self->{_exceptions}->{only};my$except=$self->{_exceptions}->{except};my$depth=()=split '::',$plugin,-1;return 0 if (keys%only &&!$only{$plugin});return 0 unless (!defined$only || $plugin =~ m!$only!);return 0 if (keys%except && $except{$plugin});return 0 if (defined$except && $plugin =~ m!$except!);return 0 if defined$self->{max_depth}&& $depth>$self->{max_depth};return 0 if defined$self->{min_depth}&& $depth<$self->{min_depth};return 1}sub search_directories {my$self=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){push@plugins,$self->search_paths($dir)}return@plugins}sub search_paths {my$self=shift;my$dir=shift;my@plugins;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;for my$searchpath (@{$self->{'search_path'}}){my$sp=catdir($dir,(split /::/,$searchpath));next unless (-e $sp && -d _);my@files=$self->find_files($sp);for my$file (@files){next unless ($file)=($file =~ /(.*$file_regex)$/);my ($name,$directory,$suffix)=fileparse($file,$file_regex);next if (!$self->{include_editor_junk}&& $self->_is_editor_junk($name));$directory=abs2rel($directory,$sp);my@pkg_dirs=();if ($name eq lc($name)|| $name eq uc($name)){my$pkg_file=catfile($sp,$directory,"$name$suffix");open PKGFILE,"<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";my$in_pod=0;while (my$line=<PKGFILE>){$in_pod=1 if$line =~ m/^=\w/;$in_pod=0 if$line =~ /^=cut/;next if ($in_pod || $line =~ /^=cut/);next if$line =~ /^\s*#/;if ($line =~ m/^\s*package\s+(.*::)?($name)\s*;/i){@pkg_dirs=split /::/,$1 if defined $1;;$name=$2;last}}close PKGFILE}$directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);my@dirs=();if ($directory){($directory)=($directory =~ /(.*)/);@dirs=grep(length($_),splitdir($directory))unless$directory eq curdir();for my$d (reverse@dirs){my$pkg_dir=pop@pkg_dirs;last unless defined$pkg_dir;$d =~ s/\Q$pkg_dir\E/$pkg_dir/i}}else {$directory=""}my$plugin=join '::',$searchpath,@dirs,$name;next unless$plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;$self->handle_finding_plugin($plugin,\@plugins)}push@plugins,$self->handle_innerpackages($searchpath)}return@plugins}sub _is_editor_junk {my$self=shift;my$name=shift;return 1 if$name =~ /~$/;return 1 if$name =~ /^\.#/;return 1 if$name =~ /\.sw[po]$/;return 0}sub handle_finding_plugin {my$self=shift;my$plugin=shift;my$plugins=shift;my$no_req=shift || 0;return unless$self->_is_legit($plugin);unless (defined$self->{'instantiate'}|| $self->{'require'}){push @$plugins,$plugin;return}$self->{before_require}->($plugin)|| return if defined$self->{before_require};unless ($no_req){my$tmp=$@;my$res=eval {require_module($plugin)};my$err=$@;$@=$tmp;if ($err){if (defined$self->{on_require_error}){$self->{on_require_error}->($plugin,$err)|| return}else {return}}}$self->{after_require}->($plugin)|| return if defined$self->{after_require};push @$plugins,$plugin}sub find_files {my$self=shift;my$search_path=shift;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;my@files=();{local $_;File::Find::find({no_chdir=>1,follow=>$self->{'follow_symlinks'},wanted=>sub {return unless$File::Find::name =~ /$file_regex/;(my$path=$File::Find::name)=~ s#^\\./##;push@files,$path}},$search_path)}return@files}sub handle_inc_hooks {my$self=shift;my$path=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){next unless ref$dir && eval {$dir->can('files')};for my$plugin ($dir->files){$plugin =~ s/\.pm$//;$plugin =~ s{/}{::}g;next unless$plugin =~ m!^${path}::!;$self->handle_finding_plugin($plugin,\@plugins)}}return@plugins}sub handle_innerpackages {my$self=shift;return ()if (exists$self->{inner}&&!$self->{inner});my$path=shift;my@plugins;for my$plugin (Devel::InnerPackage::list_packages($path)){$self->handle_finding_plugin($plugin,\@plugins,1)}return@plugins}1;
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.01";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=CORE::require($notional_filename);pop @$guard;return$result}else {return scalar(CORE::require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);$name->VERSION($version)if @_ >= 2;return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;my$fn=module_notional_filename($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && ($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s || $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);$name->VERSION($version)if @_ >= 2;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use Moo::_strictures;use Moo::_mro;use Moo::_Utils qw(_getglob _getstash _install_coderef _install_modifier _load_module _set_loaded _unimport_coderefs);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Method::Generate::Constructor Method::Generate::Accessor Moo::sification Moo::_Utils Moo::Role)}our$VERSION='0.01';$VERSION=eval$VERSION;require Moo::sification;Moo::sification->import;our%MAKERS;sub _install_tracked {my ($target,$name,$code)=@_;$MAKERS{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::${name}"=>$code}sub import {my$target=caller;my$class=shift;_set_loaded(caller);strict->import;warnings->import;if ($INC{'Role/Tiny.pm'}and Role::Tiny->is_role($target)){croak "Cannot import Moo into a role"}$MAKERS{$target}||= {};_install_tracked$target=>extends=>sub {$class->_set_superclasses($target,@_);$class->_maybe_reset_handlemoose($target);return};_install_tracked$target=>with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$class->_maybe_reset_handlemoose($target)};_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak "Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$class->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$class->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$class->_maybe_reset_handlemoose($target)}return};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {_install_modifier($target,$type,@_);return}}return if$MAKERS{$target}{is_class};my$stash=_getstash($target);my@not_methods=map {*$_{CODE}||()}grep!ref($_),values %$stash;@{$MAKERS{$target}{not_methods}={}}{@not_methods}=@not_methods;$MAKERS{$target}{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub unimport {my$target=caller;_unimport_coderefs($target,$MAKERS{$target})}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{'Role/Tiny.pm'}&& Role::Tiny->is_role($superclass)){croak "Can't extend role '$superclass'"}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){$old->assert_constructor;delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||= do {my$maker_class=do {if (my$m=do {require Sub::Defer;if (my$defer_target=(Sub::Defer::defer_info($target->can('new'))||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);$MAKERS{$pkg}&& $MAKERS{$pkg}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||= do {require Method::Generate::Constructor;my%construct_opts=(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n" .'          package '.$target.';'."\n" .'          return $invoker->SUPER::new(@_);'."\n" .'        }'."\n" .'        '.$class.'->_constructor_maker_for($class);'."\n" .'        return $invoker->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object('."\n" .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n" .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n" .'        );'."\n" .'      }'."\n"),);my$con;my@isa=@{mro::get_linear_isa($target)};shift@isa;if (my ($parent_new)=grep {*{_getglob($_.'::new')}{CODE}}@isa){if ($parent_new eq 'Moo::Object'){}elsif (my$makers=$MAKERS{$parent_new}){$con=$makers->{constructor};$construct_opts{construction_string}=$con->construction_string if$con}elsif ($parent_new->can('BUILDALL')){$construct_opts{construction_builder}=sub {my$inv=$target->can('BUILDARGS')? '' : 'Moo::Object::';'do {' .'  my $args = $class->'.$inv.'BUILDARGS(@_);' .'  $args->{__no_BUILD__} = 1;' .'  $invoker->'.$target.'::SUPER::new($args);' .'}'}}else {$construct_opts{construction_builder}=sub {'$invoker->'.$target.'::SUPER::new(' .($target->can('FOREIGNBUILDARGS')? '$class->FOREIGNBUILDARGS(@_)' : '@_').')'}}}($con ? ref($con): 'Method::Generate::Constructor')->new(%construct_opts)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}sub _concrete_methods_of {my ($me,$role)=@_;my$makers=$MAKERS{$role};my$stash=_getstash($role);my$not_methods={reverse %{$makers->{not_methods}||{}}};+{map {my$code=*{$stash->{$_}}{CODE};(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep!ref($stash->{$_}),keys %$stash }}1;
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;use Moo::_strictures;use Moo::_Utils qw(_getstash);use Sub::Quote qw(quotify);use Carp qw(croak);our%TYPE_MAP;our$SETUP_DONE;sub import {return if$SETUP_DONE;inject_all();$SETUP_DONE=1}sub inject_all {croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Class::MOP;inject_fake_metaclass_for($_)for grep $_ ne 'Moo::Object',keys%Moo::MAKERS;inject_fake_metaclass_for($_)for keys%Moo::Role::INFO;require Moose::Meta::Method::Constructor;@Moo::HandleMoose::FakeConstructor::ISA='Moose::Meta::Method::Constructor';@Moo::HandleMoose::FakeMeta::ISA='Moose::Meta::Method::Meta'}sub maybe_reinject_fake_metaclass_for {my ($name)=@_;our%DID_INJECT;if (delete$DID_INJECT{$name}){unless ($Moo::Role::INFO{$name}){Moo->_constructor_maker_for($name)->install_delayed}inject_fake_metaclass_for($name)}}sub inject_fake_metaclass_for {my ($name)=@_;require Class::MOP;require Moo::HandleMoose::FakeMetaClass;Class::MOP::store_metaclass_by_name($name,bless({name=>$name },'Moo::HandleMoose::FakeMetaClass'));require Moose::Util::TypeConstraints;if ($Moo::Role::INFO{$name}){Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name)}else {Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name)}}{package Moo::HandleMoose::FakeConstructor;sub _uninlined_body {\&Moose::Object::new}}sub inject_real_metaclass_for {my ($name)=@_;our%DID_INJECT;return Class::MOP::get_metaclass_by_name($name)if$DID_INJECT{$name};require Moose;require Moo;require Moo::Role;require Scalar::Util;require Sub::Defer;Class::MOP::remove_metaclass_by_name($name);my ($am_role,$am_class,$meta,$attr_specs,$attr_order)=do {if (my$info=$Moo::Role::INFO{$name}){my@attr_info=@{$info->{attributes}||[]};(1,0,Moose::Meta::Role->initialize($name),{@attr_info },[@attr_info[grep!($_ % 2),0..$#attr_info]])}elsif (my$cmaker=Moo->_constructor_maker_for($name)){my$specs=$cmaker->all_attribute_specs;(0,1,Moose::Meta::Class->initialize($name),$specs,[sort {$specs->{$a}{index}<=> $specs->{$b}{index}}keys %$specs ])}else {(0,0,Moose::Meta::Class->initialize($name),{},[])}};{local$DID_INJECT{$name}=1;for my$spec (values %$attr_specs){if (my$inflators=delete$spec->{moosify}){$_->($spec)for @$inflators}}my%methods =%{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};if (my$info=$Moo::Role::INFO{$name}){delete$info->{methods}}$methods{$_}=Sub::Defer::undefer_sub($methods{$_})for grep $_ ne 'new',keys%methods;my@attrs;{local @{_getstash($name)}{keys%methods};my%seen_name;for my$attr_name (@$attr_order){$seen_name{$attr_name}=1;my%spec=%{$attr_specs->{$attr_name}};my%spec_map=(map {$_->name=>$_->init_arg||$_->name}((grep {$_->has_init_arg}$meta->attribute_metaclass->meta->get_all_attributes),grep {exists($_->{init_arg})? defined($_->init_arg): 1}map {my$meta=Moose::Util::resolve_metatrait_alias('Attribute',$_)->meta;map$meta->get_attribute($_),$meta->get_attribute_list}@{$spec{traits}||[]}));$spec_map{traits}||= 'traits';$spec{is}='ro' if$spec{is}eq 'lazy' or $spec{is}eq 'rwp';my$coerce=$spec{coerce};if (my$isa=$spec{isa}){my$tc=$spec{isa}=do {if (my$mapped=$TYPE_MAP{$isa}){my$type=$mapped->();unless (Scalar::Util::blessed($type)&& $type->isa("Moose::Meta::TypeConstraint")){croak "error inflating attribute '$attr_name' for package '$name': " ."\$TYPE_MAP{$isa} did not return a valid type constraint'"}$coerce ? $type->create_child_type(name=>$type->name): $type}else {Moose::Meta::TypeConstraint->new(constraint=>sub {eval {&$isa;1}})}};if ($coerce){$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{coerce}=1}}elsif ($coerce){my$attr=quotify($attr_name);my$tc=Moose::Meta::TypeConstraint->new(constraint=>sub {die "This is not going to work"},inlined=>sub {'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'},);$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{isa}=$tc;$spec{coerce}=1}%spec=map {$spec_map{$_}=>$spec{$_}}grep {exists$spec_map{$_}}keys%spec;push@attrs,$meta->add_attribute($attr_name=>%spec)}for my$mouse (do {our%MOUSE;@{$MOUSE{$name}||[]}}){for my$attr ($mouse->get_all_attributes){my%spec=%{$attr};delete@spec{qw(associated_class associated_methods __METACLASS__ provides curries)};my$attr_name=delete$spec{name};next if$seen_name{$attr_name}++;push@attrs,$meta->add_attribute($attr_name=>%spec)}}}for my$meth_name (keys%methods){my$meth_code=$methods{$meth_name};$meta->add_method($meth_name,$meth_code)}if ($am_role){my$info=$Moo::Role::INFO{$name};$meta->add_required_methods(@{$info->{requires}});for my$modifier (@{$info->{modifiers}}){my ($type,@args)=@$modifier;my$code=pop@args;$meta->${\"add_${type}_method_modifier"}($_,$code)for@args}}elsif ($am_class){for my$attr (@attrs){for my$method (@{$attr->associated_methods}){$method->{body}=$name->can($method->name)}}bless($meta->find_method_by_name('new'),'Moo::HandleMoose::FakeConstructor',);my$meta_meth;if ($meta_meth=$meta->find_method_by_name('meta')and $meta_meth->body==\&Moo::Object::meta){bless($meta_meth,'Moo::HandleMoose::FakeMeta')}require Method::Generate::DemolishAll}$meta->add_role(Class::MOP::class_of($_))for grep!/\|/ && $_ ne $name,keys %{$Moo::Role::APPLIED_TO{$name}}}$DID_INJECT{$name}=1;$meta}1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;use Moo::_strictures;use Carp ();BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub DESTROY {}sub AUTOLOAD {my ($meth)=(our$AUTOLOAD =~ /([^:]+)$/);my$self=shift;Carp::croak "Can't call $meth without object instance" if!ref$self;Carp::croak "Can't inflate Moose metaclass with Moo::sification disabled" if$Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)}sub can {my$self=shift;return$self->SUPER::can(@_)if!ref$self or $Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)}sub isa {my$self=shift;return$self->SUPER::isa(@_)if!ref$self or $Moo::sification::disabled;require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)}sub make_immutable {$_[0]}1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;use Moo::_strictures;package Moo::HandleMoose;our%TYPE_MAP;package Moo::HandleMoose::_TypeMap;use Scalar::Util ();use Config;our%WEAK_TYPES;sub _str_to_ref {my$in=shift;return$in if ref$in;if ($in =~ /(?:^|=)([A-Z]+)\(0x([0-9a-zA-Z]+)\)$/){my$type=$1;my$id=do {no warnings 'portable';hex "$2"};require B;my$sv=bless \$id,'B::SV';my$ref=eval {$sv->object_2svref};if (!defined$ref or Scalar::Util::reftype($ref)ne $type){die <<'END_ERROR'}return$ref}return$in}sub TIEHASH {bless {},$_[0]}sub STORE {my ($self,$key,$value)=@_;my$type=_str_to_ref($key);$WEAK_TYPES{$type}=$type;Scalar::Util::weaken($WEAK_TYPES{$type})if ref$type;$self->{$key}=$value}sub FETCH {$_[0]->{$_[1]}}sub FIRSTKEY {my$a=scalar keys %{$_[0]};each %{$_[0]}}sub NEXTKEY {each %{$_[0]}}sub EXISTS {exists $_[0]->{$_[1]}}sub DELETE {delete $_[0]->{$_[1]}}sub CLEAR {%{$_[0]}=()}sub SCALAR {scalar %{$_[0]}}sub CLONE {my@types=map {defined$WEAK_TYPES{$_}? ($WEAK_TYPES{$_}=>$TYPE_MAP{$_}): ()}keys%TYPE_MAP;%WEAK_TYPES=();%TYPE_MAP=@types}sub DESTROY {my%types=%{$_[0]};untie%TYPE_MAP;%TYPE_MAP=%types}if ($Config{useithreads}){my@types=%TYPE_MAP;tie%TYPE_MAP,__PACKAGE__;%TYPE_MAP=@types}1;
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use Moo::_strictures;use Carp ();our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}my$proto=$class->BUILDARGS(@_);$NO_BUILD{$class}and return bless({},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({},$class): bless({},$class)->BUILDALL($proto)}sub BUILDARGS {my$class=shift;scalar @_==1 ? ref $_[0]eq 'HASH' ? {%{$_[0]}}: Carp::croak("Single parameters to new() must be a HASH ref" ." data => ".$_[0]): @_ % 2 ? Carp::croak("The new() method for $class expects a hash reference or a" ." key/value list. You passed an odd number of arguments"): {@_}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||= do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||= do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {return!!0 unless ($INC{'Moose/Role.pm'}|| $INC{'Role/Tiny.pm'});require Moo::Role;my$does=Moo::Role->can("does_role");{no warnings 'redefine';*does=$does}goto &$does}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;use Moo::_strictures;use Moo::_Utils qw(_getglob _getstash _install_coderef _install_modifier _load_module _name_coderef _set_loaded _unimport_coderefs);use Carp qw(croak);use Role::Tiny ();BEGIN {our@ISA=qw(Role::Tiny)}BEGIN {our@CARP_NOT=qw(Method::Generate::Accessor Method::Generate::Constructor Moo::sification Moo::_Utils)}our$VERSION='0.01';$VERSION=eval$VERSION;require Moo::sification;Moo::sification->import;BEGIN {*INFO=\%Role::Tiny::INFO;*APPLIED_TO=\%Role::Tiny::APPLIED_TO;*COMPOSED=\%Role::Tiny::COMPOSED;*ON_ROLE_CREATE=\@Role::Tiny::ON_ROLE_CREATE}our%INFO;our%APPLIED_TO;our%APPLY_DEFAULTS;our%COMPOSED;our@ON_ROLE_CREATE;sub _install_tracked {my ($target,$name,$code)=@_;$INFO{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::Role::${name}"=>$code}sub import {my$target=caller;if ($Moo::MAKERS{$target}and $Moo::MAKERS{$target}{is_class}){croak "Cannot import Moo::Role into a Moo class"}_set_loaded(caller);goto&Role::Tiny::import}sub _install_subs {my ($me,$target)=@_;_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;($INFO{$target}{accessor_maker}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new})->generate_method($target,$name,$spec_ref);push @{$INFO{$target}{attributes}||=[]},$name,$spec_ref;$me->_maybe_reset_handlemoose($target)}};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];$me->_maybe_reset_handlemoose($target)}}_install_tracked$target=>requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;$me->_maybe_reset_handlemoose($target)};_install_tracked$target=>with=>sub {$me->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)};*{_getglob("${target}::meta")}=$me->can('meta')}push@ON_ROLE_CREATE,sub {my$target=shift;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($target)}};sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}sub unimport {my$target=caller;_unimport_coderefs($target,$INFO{$target})}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub methods_provided_by {my ($self,$role)=@_;_load_module($role);$self->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$self->is_role($role);return$self->SUPER::methods_provided_by($role)}sub is_role {my ($self,$role)=@_;$self->_inhale_if_moose($role);$self->SUPER::is_role($role)}sub _inhale_if_moose {my ($self,$role)=@_;my$meta;if (!$self->SUPER::is_role($role)and ($INC{"Moose.pm"}and $meta=Class::MOP::class_of($role)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->isa('Moose::Meta::Role'))or (Mouse::Util->can('find_meta')and $meta=Mouse::Util::find_meta($role)and $meta->isa('Mouse::Meta::Role'))){my$is_mouse=$meta->isa('Mouse::Meta::Role');$INFO{$role}{methods}={map +($_=>$role->can($_)),grep$role->can($_),grep!($is_mouse && $_ eq 'meta'),grep!$meta->get_method($_)->isa('Class::MOP::Method::Meta'),$meta->get_method_list };$APPLIED_TO{$role}={map +($_->name=>1),$meta->calculate_all_roles };$INFO{$role}{requires}=[$meta->get_required_method_list ];$INFO{$role}{attributes}=[map +($_=>do {my$attr=$meta->get_attribute($_);my$spec={%{$is_mouse ? $attr : $attr->original_options}};if ($spec->{isa}){require Sub::Quote;my$get_constraint=do {my$pkg=$is_mouse ? 'Mouse::Util::TypeConstraints' : 'Moose::Util::TypeConstraints';_load_module($pkg);$pkg->can('find_or_create_isa_type_constraint')};my$tc=$get_constraint->($spec->{isa});my$check=$tc->_compiled_type_constraint;my$tc_var='$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);$spec->{isa}=Sub::Quote::quote_sub(qq{
                &${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
              },{$tc_var=>\$check },{package=>$role,},);if ($spec->{coerce}){$spec->{coerce}=$tc->${\($tc->can('coercion')||sub {$_[0]})}->_compiled_type_coercion}}$spec}),$meta->get_attribute_list ];my$mods=$INFO{$role}{modifiers}=[];for my$type (qw(before after around)){my$map=$meta->${\($meta->can("get_${type}_method_modifiers_map")or sub {shift->{"${type}_method_modifiers"}})};for my$method (keys %$map){for my$mod (@{$map->{$method}}){push @$mods,[$type=>$method=>$mod ]}}}$INFO{$role}{inhaled_from_moose}=1;$INFO{$role}{is_role}=1}}sub _maybe_make_accessors {my ($self,$target,$role)=@_;my$m;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}or $INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($target)and ref($m)ne 'Method::Generate::Accessor'){$self->_make_accessors($target,$role)}}sub _make_accessors_if_moose {my ($self,$target,$role)=@_;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}){$self->_make_accessors($target,$role)}}sub _make_accessors {my ($self,$target,$role)=@_;my$acc_gen=($Moo::MAKERS{$target}{accessor}||= do {require Method::Generate::Accessor;Method::Generate::Accessor->new});my$con_gen=$Moo::MAKERS{$target}{constructor};my@attrs=@{$INFO{$role}{attributes}||[]};while (my ($name,$spec)=splice@attrs,0,2){if ($con_gen){$spec=$con_gen->all_attribute_specs->{$name}}$acc_gen->generate_method($target,$name,$spec)}}sub _undefer_subs {my ($self,$target,$role)=@_;if ($INC{'Sub/Defer.pm'}){Sub::Defer::undefer_package($role)}}sub role_application_steps {qw(_handle_constructor _undefer_subs _maybe_make_accessors),$_[0]->SUPER::role_application_steps}sub apply_roles_to_package {my ($me,$to,@roles)=@_;for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}$me->SUPER::apply_roles_to_package($to,@roles)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role);$me->SUPER::apply_single_role_to_package($to,$role)}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);$me->_inhale_if_moose($role);croak "${role} is not a Moo::Role" unless$me->is_role($role)}my$m;if ($INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($superclass)and ref($m)ne 'Method::Generate::Accessor'){@{*{_getglob("${new_name}::ISA")}{ARRAY}}=($superclass);$Moo::MAKERS{$new_name}={is_class=>1};$me->apply_roles_to_package($new_name,@roles)}else {$me->SUPER::create_class_with_roles($superclass,@roles);$Moo::MAKERS{$new_name}={is_class=>1};$me->_handle_constructor($new_name,$_)for@roles}if ($INC{'Moo/HandleMoose.pm'}&&!$Moo::sification::disabled){Moo::HandleMoose::inject_fake_metaclass_for($new_name)}$COMPOSED{class}{$new_name}=1;_set_loaded($new_name,(caller)[1]);return$new_name}sub apply_roles_to_object {my ($me,$object,@roles)=@_;my$new=$me->SUPER::apply_roles_to_object($object,@roles);my$class=ref$new;_set_loaded($class,(caller)[1]);my$apply_defaults=exists$APPLY_DEFAULTS{$class}? $APPLY_DEFAULTS{$class}: $APPLY_DEFAULTS{$class}=do {my%attrs=map {@{$INFO{$_}{attributes}||[]}}@roles;if ($INC{'Moo.pm'}and keys%attrs and my$con_gen=Moo->_constructor_maker_for($class)and my$m=Moo->_accessor_maker_for($class)){my$specs=$con_gen->all_attribute_specs;my%captures;my$code=join('',(map {my$name=$_;my$spec=$specs->{$name};if ($m->has_eager_default($name,$spec)){my ($has,$has_cap)=$m->generate_simple_has('$_[0]',$name,$spec);my ($set,$pop_cap)=$m->generate_use_default('$_[0]',$name,$spec,$has);@captures{keys %$has_cap,keys %$pop_cap}=(values %$has_cap,values %$pop_cap);"($set),"}else {()}}sort keys%attrs),);if ($code){require Sub::Quote;Sub::Quote::quote_sub("${class}::_apply_defaults","no warnings 'void';\n$code",\%captures,{package=>$class,no_install=>1,})}else {0}}else {0}};if ($apply_defaults){local$Carp::Internal{+__PACKAGE__}=1;local$Carp::Internal{$class}=1;$new->$apply_defaults}return$new}sub _composable_package_for {my ($self,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$self->_make_accessors_if_moose($composed_name,$role);$self->SUPER::_composable_package_for($role)}sub _install_single_modifier {my ($me,@args)=@_;_install_modifier(@args)}sub _install_does {my ($me,$to)=@_;my$new=$me->SUPER::_install_does($to)or return;return _name_coderef("${to}::DOES",$new)}sub does_role {my ($proto,$role)=@_;return 1 if Role::Tiny::does_role($proto,$role);my$meta;if ($INC{'Moose.pm'}and $meta=Class::MOP::class_of($proto)and ref$meta ne 'Moo::HandleMoose::FakeMetaClass' and $meta->can('does_role')){return$meta->does_role($role)}return 0}sub _handle_constructor {my ($me,$to,$role)=@_;my$attr_info=$INFO{$role}&& $INFO{$role}{attributes};return unless$attr_info && @$attr_info;my$info=$INFO{$to};my$con=$INC{"Moo.pm"}&& Moo->_constructor_maker_for($to);my%existing =$info ? @{$info->{attributes}|| []}: $con ? %{$con->all_attribute_specs || {}}: ();my@attr_info=map {@{$attr_info}[$_,$_+1]}grep {!$existing{$attr_info->[$_]}}map {2 * $_}0..@$attr_info/2-1;if ($info){push @{$info->{attributes}||=[]},@attr_info}elsif ($con){$con->register_attribute_specs(map ref()? {%$_ }: $_,@attr_info)}}1;
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;use Moo::_strictures;{no strict 'refs';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}}BEGIN {my ($su,$sn);$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname or $sn=$INC{'Sub/Name.pm'}or $su=eval {require Sub::Util}&& defined&Sub::Util::set_subname or $sn=eval {require Sub::Name};*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_CAN_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}use Module::Runtime qw(use_package_optimistically module_notional_filename);use Devel::GlobalDestruction ();use Exporter qw(import);use Config;use Carp qw(croak);our@EXPORT=qw(_getglob _install_modifier _load_module _maybe_load_module _getstash _install_coderef _name_coderef _unimport_coderefs _set_loaded);sub _install_modifier {my ($into,$type,$name,$code)=@_;if ($INC{'Sub/Defer.pm'}and my$to_modify=$into->can($name)){Sub::Defer::undefer_sub($to_modify)}require Class::Method::Modifiers;Class::Method::Modifiers::install_modifier(@_)}sub _load_module {my$module=$_[0];my$file=eval {module_notional_filename($module)}or croak $@;use_package_optimistically($module);return 1 if$INC{$file};my$error=$@ || "Can't locate $file";my$stash=_getstash($module)||{};return 1 if grep +(!ref($_)and *$_{CODE}),values %$stash;return 1 if$INC{"Moose.pm"}&& Class::MOP::class_of($module)or Mouse::Util->can('find_meta')&& Mouse::Util::find_meta($module);croak$error}our%MAYBE_LOADED;sub _maybe_load_module {my$module=$_[0];return$MAYBE_LOADED{$module}if exists$MAYBE_LOADED{$module};if(!eval {use_package_optimistically($module)}){warn "$module exists but failed to load with error: $@"}elsif ($INC{module_notional_filename($module)}){return$MAYBE_LOADED{$module}=1}return$MAYBE_LOADED{$module}=0}sub _set_loaded {$INC{Module::Runtime::module_notional_filename($_[0])}||= $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _unimport_coderefs {my ($target,$info)=@_;return unless$info and my$exports=$info->{exports};my%rev=reverse %$exports;my$stash=_getstash($target);for my$name (keys %$exports){if ($stash->{$name}and defined(&{$stash->{$name}})){if ($rev{$target->can($name)}){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}}}if ($Config{useithreads}){require Moo::HandleMoose::_TypeMap}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;use Moo::_strictures;if ("$]" >= 5.010_000){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;use strict;use warnings;sub import {if ($ENV{MOO_FATAL_WARNINGS}){require strictures;strictures->VERSION(2);@_=('strictures');goto&strictures::import}else {strict->import;warnings->import;warnings->unimport('once')}}1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use Moo::_strictures;no warnings 'once';use Devel::GlobalDestruction qw(in_global_destruction);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Moo::HandleMoose)}sub unimport {croak "Can't disable Moo::sification after inflation has been done" if$Moo::HandleMoose::SETUP_DONE;our$disabled=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disabled or in_global_destruction){require Moo::HandleMoose;Moo::HandleMoose->import}}sub import {return if our$setup_done;if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}$setup_done=1}1;
MOO_SIFICATION

$fatpacked{"Number/Bytes/Human.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_BYTES_HUMAN';
  package Number::Bytes::Human;use strict;use warnings;our$VERSION='0.01';require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(format_bytes parse_bytes);require POSIX;use Carp qw(croak carp);my%DEFAULT_SUFFIXES=(1024=>['','K','M','G','T','P','E','Z','Y'],1000=>['','k','M','G','T','P','E','Z','Y'],1024000=>['','M','T','E','Y'],si_1024=>['B','KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB'],si_1000=>['B','kB','MB','GB','TB','PB','EB','ZB','YB'],);my@DEFAULT_PREFIXES=@{$DEFAULT_SUFFIXES{1024}};sub _default_suffixes {my$set=shift || 1024;if (exists$DEFAULT_SUFFIXES{$set}){return @{$DEFAULT_SUFFIXES{$set}}if wantarray;return [@{$DEFAULT_SUFFIXES{$set}}]}croak "unknown suffix set '$set'"}my%ROUND_FUNCTIONS=(ceil=>sub {return POSIX::ceil($_[0]* (10 ** $_[1]))/ 10**$_[1]},floor=>sub {return POSIX::floor($_[0]* (10 ** $_[1]))/ 10**$_[1]},round=>sub {return sprintf("%." .($_[1]|| 0)."f",$_[0])},trunc=>sub {return sprintf("%d",$_[0]* (10 ** $_[1]))/ 10**$_[1]},);sub _round_function {my$style=shift;if (exists$ROUND_FUNCTIONS{$style}){return$ROUND_FUNCTIONS{$style}}croak "unknown round style '$style'"}sub _parse_args {my$seed=shift;my%args;my%options;unless (defined$seed){$options{BLOCK}=1024;$options{ROUND_STYLE}='ceil';$options{ROUND_FUNCTION}=_round_function($options{ROUND_STYLE});$options{ZERO}='0';$options{SI}=undef;$options{PRECISION}=1;$options{PRECISION_CUTOFF}=1;$options{UNIT}=undef}if (@_==0){return (defined$seed)? $seed : \%options}elsif (@_==1 && ref $_[0]){%args=%{$_[0]}}else {%args=@_}%options=%$seed unless%options;if ($args{block}|| $args{block_size}|| $args{base}|| $args{bs}){my$block=$args{block}|| $args{block_size}|| $args{base}|| $args{bs};unless ($block==1000 || $block==1024 || $block==1_024_000){croak "invalid base: $block (should be 1024, 1000 or 1024000)"}$options{BLOCK}=$block}elsif ($args{block_1024}|| $args{base_1024}|| $args{1024}){$options{BLOCK}=1024}elsif ($args{block_1000}|| $args{base_1000}|| $args{1000}){$options{BLOCK}=1000}if ($args{round_function}){unless (ref$args{round_function}eq 'CODE'){croak "round function ($args{round_function}) should be a code ref"}$options{ROUND_FUNCTION}=$args{round_function};$options{ROUND_STYLE}=$args{round_style}|| 'unknown'}elsif ($args{round_style}){$options{ROUND_FUNCTION}=_round_function($args{round_style});$options{ROUND_STYLE}=$args{round_style}}if ($args{si}){$options{SI}=1}if ($args{suffixes}){if (ref$args{suffixes}eq 'ARRAY'){$options{SUFFIXES}=$args{suffixes}}elsif ($args{suffixes}=~ /^(si_)?(1000|1024)$/){$options{SUFFIXES}=_default_suffixes($args{suffixes})}else {croak "suffixes ($args{suffixes}) should be 1024, 1000, si_1024, si_1000, 1024000 or an array ref"}}if (defined$args{unit}){$options{UNIT}=$args{unit}}if (exists$args{zero}){$options{ZERO}=$args{zero};if (defined$options{ZERO}){$options{ZERO}=~ s/%S/$options{SUFFIXES}->[0]/g}}if (exists$args{precision}and $args{precision}=~ /\A\d+\z/){$options{PRECISION}=$args{precision}}if (exists$args{precision_cutoff}and ($args{precision_cutoff}=~ /\A\d+\z/ or $args{precision_cutoff}='-1')){$options{PRECISION_CUTOFF}=$args{precision_cutoff}}if ($args{quiet}){$options{QUIET}=1}if (defined$seed){%$seed=%options;return$seed}return \%options}sub _format_bytes {my$bytes=shift;return undef unless defined$bytes;my$options=shift;my%options=%$options;local*human_round=$options{ROUND_FUNCTION};return$options{ZERO}if ($bytes==0 && defined$options{ZERO});my$block=$options{BLOCK};my@suffixes=$options{SUFFIXES}? @{$options{SUFFIXES}}: _default_suffixes(($options{SI}? 'si_' : '').$block);my$sign='';if ($bytes<0){$bytes=-$bytes;$sign='-'}my$suffix=$suffixes[0];my$x=$bytes;my$magnitude=0;if($bytes >= $block){do {$x /= $block;$magnitude++}while (human_round($x,$options{PRECISION})>= $block);if($magnitude >= (0 + @suffixes)){carp "number too large (>= $block**$magnitude)" unless ($options{QUIET})}$suffix=$suffixes[$magnitude]}$x=_precision_cutoff($x,$options);if($x >= $block){$x /= $block;$magnitude++;if($magnitude >= (0 + @suffixes)){carp "number too large (>= $block**$magnitude)" unless ($options{QUIET})}$suffix=$suffixes[$magnitude];$x=_precision_cutoff($x,$options)}my$unit=$options{UNIT}|| '';return$sign .$x .$suffix .$unit}sub _precision_cutoff {my$bytes=shift;my$options=shift;my%options=%$options;if ($options{PRECISION_CUTOFF}!=-1 and (length(sprintf("%d",$bytes))> $options{PRECISION_CUTOFF})){$bytes=sprintf("%d",human_round($bytes,0))}else {$bytes=sprintf("%." .$options{PRECISION}."f",human_round($bytes,$options{PRECISION}))}return$bytes}sub _parse_bytes {my$human=shift;my$options=shift;my%options=%$options;return 0 if(exists$options{ZERO}&& ((!defined$options{ZERO}&&!defined$human)|| (defined$human && $human eq $options{ZERO})));return undef unless defined$human;my%suffix_mult;my%suffix_block;my$m;if($options{SUFFIXES}){$m=1;for my$s (@{$options{SUFFIXES}}){$suffix_mult{$s}=$m;$suffix_block{$s}=$options{BLOCK};$m *= $suffix_block{$s}}}else {if(!defined$options{SI}|| $options{SI}==1){$m=1;for my$s (@{$DEFAULT_SUFFIXES{si_1000}}){$suffix_mult{$s}=$m;$suffix_block{$s}=1000;$m *= $suffix_block{$s}}$m=1;for my$s (@{$DEFAULT_SUFFIXES{si_1024}}){$suffix_mult{$s}=$m;$suffix_block{$s}=1024;$m *= $suffix_block{$s}}}if(!defined$options{SI}){$m=1;for my$s (_default_suffixes($options{BLOCK})){$suffix_mult{$s}=$m;$suffix_block{$s}=$options{BLOCK};$m *= $suffix_block{$s}}}}my ($sign,$k,$unit)=($human =~ /^\s*(-?)\s*(\d*(?:\.\d*)?)\s*(\D*)$/);my$mult;my$u=$options{UNIT}|| '';for my$s (keys%suffix_block){if($unit =~ /^${s}${u}$/i){$mult=($sign eq '-' ? -1 : 1)* $suffix_mult{$s};last}}if(!defined$mult){carp "Could not parse human readable byte value '$human'";return undef}my$bytes=int($k * $mult);return$bytes}sub format_bytes {my$bytes=shift;my$options=_parse_args(undef,@_);return _format_bytes($bytes,$options)}sub parse_bytes {my$human=shift;my$options=_parse_args(undef,@_);return _parse_bytes($human,$options)}sub new {my$proto=shift;my$class=ref$proto || $proto;my$opts=_parse_args(undef,@_);return bless$opts,$class}sub set_options {my$self=shift;return$self->_parse_args(@_)}sub format {my$self=shift;my$bytes=shift;return _format_bytes($bytes,$self)}sub parse {my$self=shift;my$human=shift;return _parse_bytes($human,$self)}1;
NUMBER_BYTES_HUMAN

$fatpacked{"Number/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_COMPARE';
  package Number::Compare;use strict;use Carp qw(croak);use vars qw/$VERSION/;$VERSION='0.01';sub new {my$referent=shift;my$class=ref$referent || $referent;my$expr=$class->parse_to_perl(shift);bless eval "sub { \$_[0] $expr }",$class}sub parse_to_perl {shift;my$test=shift;$test =~ m{^
                 ([<>]=?)?   # comparison
                 (.*?)       # value
                 ([kmg]i?)?  # magnitude
                $}ix or croak "don't understand '$test' as a test";my$comparison=$1 || '==';my$target=$2;my$magnitude=$3 || '';$target *= 1000 if lc$magnitude eq 'k';$target *= 1024 if lc$magnitude eq 'ki';$target *= 1000000 if lc$magnitude eq 'm';$target *= 1024*1024 if lc$magnitude eq 'mi';$target *= 1000000000 if lc$magnitude eq 'g';$target *= 1024*1024*1024 if lc$magnitude eq 'gi';return "$comparison $target"}sub test {$_[0]->($_[1])}1;
NUMBER_COMPARE

$fatpacked{"PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI';
  package PPI;use 5.006;use strict;use vars qw{$VERSION $XS_COMPATIBLE @XS_EXCLUDE};BEGIN {$VERSION='0.01';$XS_COMPATIBLE='0.845';@XS_EXCLUDE=()}use PPI::Util ();use PPI::Exception ();use PPI::Element ();use PPI::Token ();use PPI::Statement ();use PPI::Structure ();use PPI::Document ();use PPI::Document::File ();use PPI::Document::Fragment ();use PPI::Document::Normalized ();use PPI::Normal ();use PPI::Tokenizer ();use PPI::Lexer ();die if!$PPI::XS_DISABLE and!eval {require PPI::XS;1}and $@ !~ /^Can't locate .*? at /;1;
PPI

$fatpacked{"PPI/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_CACHE';
  package PPI::Cache;use strict;use Carp ();use File::Spec ();use File::Path ();use Storable ();use Digest::MD5 ();use Params::Util qw{_INSTANCE _SCALAR};use PPI::Document ();use vars qw{$VERSION};BEGIN {$VERSION='0.01'}use constant VMS=>!!($^O eq 'VMS');sub import {my$class=ref $_[0]? ref shift : shift;return 1 unless @_;my$cache=$class->new(@_);unless (PPI::Document->set_cache($cache)){Carp::croak("Failed to set cache in PPI::Document")}1}sub new {my$class=shift;my%params=@_;my$path=$params{path}or Carp::croak("Cannot create PPI::Cache, no path provided");unless (-d $path){Carp::croak("Cannot create PPI::Cache, path does not exist")}unless (-r $path and -x $path){Carp::croak("Cannot create PPI::Cache, no read permissions for path")}if (!$params{readonly}and!-w $path){Carp::croak("Cannot create PPI::Cache, no write permissions for path")}my$self=bless {path=>$path,readonly=>!!$params{readonly},},$class;$self}sub path {$_[0]->{path}}sub readonly {$_[0]->{readonly}}sub get_document {my$self=ref $_[0]? shift : Carp::croak('PPI::Cache::get_document called as static method');my$md5hex=$self->_md5hex(shift)or return undef;$self->_load($md5hex)}sub store_document {my$self=shift;my$Document=_INSTANCE(shift,'PPI::Document')or return undef;return 1 if$self->readonly;my$md5hex=$Document->hex_id or return undef;$self->_store($md5hex,$Document)}sub _store {my ($self,$md5hex,$object)=@_;my ($dir,$file)=$self->_paths($md5hex);File::Path::mkpath($dir,0,0755)unless -d $dir;if (VMS){Storable::lock_nstore($object,$file)}else {Storable::nstore($object,$file)}}sub _load {my ($self,$md5hex)=@_;my (undef,$file)=$self->_paths($md5hex);return '' unless -f $file;my$object=VMS ? Storable::retrieve($file): Storable::lock_retrieve($file);unless (_INSTANCE($object,'PPI::Document')){Carp::croak("Security Violation: Object in '$file' is not a PPI::Document")}$object}sub _paths {my$self=shift;my$md5hex=lc shift;my$dir=File::Spec->catdir($self->path,substr($md5hex,0,1),substr($md5hex,0,2));my$file=File::Spec->catfile($dir,$md5hex .'.ppi');return ($dir,$file)}sub _md5hex {my$either=shift;my$it=_SCALAR($_[0])? PPI::Util::md5hex(${$_[0]}): $_[0];return (defined$it and!ref$it and $it =~ /^[a-f0-9]{32}\z/si)? lc$it : undef}1;
PPI_CACHE

$fatpacked{"PPI/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT';
  package PPI::Document;use strict;use Carp ();use List::MoreUtils ();use Params::Util qw{_SCALAR0 _ARRAY0 _INSTANCE};use Digest::MD5 ();use PPI::Util ();use PPI ();use PPI::Node ();use PPI::Exception::ParserTimeout ();use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';use vars qw{$VERSION @ISA $errstr};BEGIN {$VERSION='0.01';@ISA='PPI::Node';$errstr=''}use PPI::Document::Fragment ();my$CACHE;use constant LOCATION_LINE=>0;use constant LOCATION_CHARACTER=>1;use constant LOCATION_COLUMN=>2;use constant LOCATION_LOGICAL_LINE=>3;use constant LOCATION_LOGICAL_FILE=>4;sub new {local $_;my$class=ref $_[0]? ref shift : shift;unless (@_){my$self=$class->SUPER::new;$self->{readonly}=!1;$self->{tab_width}=1;return$self}my$source=shift;my%attr=@_;my$timeout=delete$attr{timeout};if ($timeout and!PPI::Util::HAVE_ALARM()){Carp::croak("This platform does not support PPI parser timeouts")}if (!defined$source){$class->_error("An undefined value was passed to PPI::Document::new")}elsif (!ref$source){if ($source =~ /(?:\012|\015)/){Carp::croak("API CHANGE: Source code should only be passed to PPI::Document->new as a SCALAR reference")}if ($CACHE){my$file_contents=PPI::Util::_slurp($source);return$class->_error($file_contents)if!ref$file_contents;my$document=$CACHE->get_document($file_contents);return$class->_setattr($document,%attr)if$document;if ($timeout){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm($timeout);$document=PPI::Lexer->lex_source($$file_contents);alarm(0)}}else {$document=PPI::Lexer->lex_source($$file_contents)}if ($document){$CACHE->store_document($document);return$class->_setattr($document,%attr)}}else {if ($timeout){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm($timeout);my$document=PPI::Lexer->lex_file($source);return$class->_setattr($document,%attr)if$document;alarm(0)}}else {my$document=PPI::Lexer->lex_file($source);return$class->_setattr($document,%attr)if$document}}}elsif (_SCALAR0($source)){if ($timeout){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm($timeout);my$document=PPI::Lexer->lex_source($$source);return$class->_setattr($document,%attr)if$document;alarm(0)}}else {my$document=PPI::Lexer->lex_source($$source);return$class->_setattr($document,%attr)if$document}}elsif (_ARRAY0($source)){$source=join '',map {"$_\n"}@$source;if ($timeout){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm($timeout);my$document=PPI::Lexer->lex_source($source);return$class->_setattr($document,%attr)if$document;alarm(0)}}else {my$document=PPI::Lexer->lex_source($source);return$class->_setattr($document,%attr)if$document}}else {$class->_error("Unknown object or reference was passed to PPI::Document::new")}my$errstr;if (_INSTANCE($@,'PPI::Exception::Timeout')){$errstr='Timed out while parsing document'}elsif (_INSTANCE($@,'PPI::Exception')){$errstr=$@->message}elsif ($@){$errstr=$@;$errstr =~ s/\sat line\s.+$//}elsif (PPI::Lexer->errstr){$errstr=PPI::Lexer->errstr}else {$errstr="Unknown error parsing Perl document"}PPI::Lexer->_clear;$class->_error($errstr)}sub load {Carp::croak("API CHANGE: File names should now be passed to PPI::Document->new to load a file")}sub _setattr {my ($class,$document,%attr)=@_;$document->{readonly}=!!$attr{readonly};return$document}sub set_cache {my$class=ref $_[0]? ref shift : shift;if (defined $_[0]){my$object=_INSTANCE(shift,'PPI::Cache')or return undef;$CACHE=$object}else {$CACHE=undef}1}sub get_cache {$CACHE}sub readonly {$_[0]->{readonly}}sub tab_width {my$self=shift;return$self->{tab_width}unless @_;$self->{tab_width}=shift}sub save {my$self=shift;local*FILE;open(FILE,'>',$_[0])or return undef;print FILE$self->serialize or return undef;close FILE or return undef;return 1}sub serialize {my$self=shift;my@tokens=$self->tokens;my$heredoc='';my$output='';for my$i (0 .. $#tokens){my$Token=$tokens[$i];unless ($Token->isa('PPI::Token::HereDoc')){my$content=$Token->content;unless ($heredoc ne '' and $content =~ /\n/){$output .= $content;next}if ($content eq "\n"){$output .= $content .$heredoc}else {$content =~ s/\n/\n$heredoc/;$output .= $content}$heredoc='';next}$output .= $Token->content;for my$line ($Token->heredoc){$heredoc .= $line}if ($Token->{_damaged}){my$last_index=$#tokens;if ($tokens[$last_index]->{content}=~ /^[^\n]*\n$/){$last_index--}my$last_line=List::MoreUtils::none {$tokens[$_]and $tokens[$_]->{content}=~ /\n/}(($i + 1).. $last_index);if (!defined$last_line){$last_line=1}my$any_after=List::MoreUtils::any {$tokens[$_]->isa('PPI::Token::HereDoc')and (scalar(@{$tokens[$_]->{_heredoc}})or defined$tokens[$_]->{_terminator_line})}(($i + 1).. $#tokens);if (!defined$any_after){$any_after=''}unless ($last_line and!$any_after){unless (defined$Token->{_terminator_line}){$Token->{_terminator_line}=$Token->{_terminator}}unless ($Token->{_terminator_line}=~ /\n$/){$Token->{_terminator_line}.= "\n"}}}if (defined$Token->{_terminator_line}){$heredoc .= $Token->{_terminator_line}}}if ($heredoc ne ''){unless ($output =~ /\n$/){$output .= "\n"}$output .= $heredoc}$output}sub hex_id {PPI::Util::md5hex($_[0]->serialize)}sub index_locations {my$self=shift;my@tokens=$self->tokens;my$heredoc=0;my ($first,$location)=();for (0 .. $#tokens){my$Token=$tokens[$_];next if$Token->{_location};if ($_){$location=$self->_add_location($location,$tokens[$_ - 1],\$heredoc)}else {my$logical_file=$self->can('filename')? $self->filename : undef;$location=[1,1,1,1,$logical_file ]}$first=$_;last}if (defined$first){for ($first .. $#tokens){my$Token=$tokens[$_];$Token->{_location}=$location;$location=$self->_add_location($location,$Token,\$heredoc);if ($Token->isa('PPI::Token::HereDoc')){$heredoc += $Token->heredoc + 1}}}1}sub _add_location {my ($self,$start,$Token,$heredoc)=@_;my$content=$Token->{content};my$newlines=()=$content =~ /\n/g;my ($logical_line,$logical_file)=$self->_logical_line_and_file($start,$Token,$newlines);unless ($newlines){return [$start->[LOCATION_LINE],$start->[LOCATION_CHARACTER]+ length($content),$start->[LOCATION_COLUMN]+ $self->_visual_length($content,$start->[LOCATION_COLUMN]),$logical_line,$logical_file,]}my$physical_line=$start->[LOCATION_LINE]+ $newlines;my$location=[$physical_line,1,1,$logical_line,$logical_file ];if ($heredoc and $$heredoc){$location->[LOCATION_LINE]+= $$heredoc;$location->[LOCATION_LOGICAL_LINE]+= $$heredoc;$$heredoc=0}if ($content =~ /\n([^\n]+?)\z/){$location->[LOCATION_CHARACTER]+= length($1);$location->[LOCATION_COLUMN]+= $self->_visual_length($1,$location->[LOCATION_COLUMN],)}$location}sub _logical_line_and_file {my ($self,$start,$Token,$newlines)=@_;if ($start->[LOCATION_CHARACTER]==1){if ($Token->isa('PPI::Token::Comment')){if ($Token->content =~ m<
  					\A
  					\#      \s*
  					line    \s+
  					(\d+)   \s*
  					(?: (\"?) ([^\"]* [^\s\"]) \2 )?
  					\s*
  					\z
  				>xms){return $1,($3 || $start->[LOCATION_LOGICAL_FILE])}}elsif ($Token->isa('PPI::Token::Pod')){my$content=$Token->content;my$line;my$file=$start->[LOCATION_LOGICAL_FILE];my$end_of_directive;while ($content =~ m<
  					^
  					\#      \s*?
  					line    \s+?
  					(\d+)   (?: (?! \n) \s)*
  					(?: (\"?) ([^\"]*? [^\s\"]) \2 )??
  					\s*?
  					$
  				>xmsg){($line,$file)=($1,($3 || $file));$end_of_directive=pos$content}if (defined$line){pos$content=$end_of_directive;my$post_directive_newlines=()=$content =~ m< \G [^\n]* \n >xmsg;return$line + $post_directive_newlines - 1,$file}}}return $start->[LOCATION_LOGICAL_LINE]+ $newlines,$start->[LOCATION_LOGICAL_FILE]}sub _visual_length {my ($self,$content,$pos)=@_;my$tab_width=$self->tab_width;my ($length,$vis_inc);return length$content if$content !~ /\t/;for my$part (split(/(\t)/,$content)){if ($part eq "\t"){$vis_inc=$tab_width - ($pos-1)% $tab_width}else {$vis_inc=length$part}$length += $vis_inc;$pos += $vis_inc}$length}sub flush_locations {shift->_flush_locations(@_)}sub normalized {PPI::Normal->process($_[0]->clone)}sub complete {my$self=shift;$self->find_any(sub {$_[1]->isa('PPI::Structure')and !$_[1]->complete})and return '';my@child=$self->children;while (@child and not $child[-1]->isa('PPI::Statement')){pop@child}return '' unless@child;return$child[-1]->_complete}sub scope() {1}sub insert_before {return undef}sub insert_after {return undef}sub replace {return undef}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}sub STORABLE_freeze {my$self=shift;my$class=ref$self;my%hash=%$self;return ($class,\%hash)}sub STORABLE_thaw {my ($self,undef,$class,$hash)=@_;bless$self,$class;for (keys %$hash){$self->{$_}=delete$hash->{$_}}$self->__link_children}1;
PPI_DOCUMENT

$fatpacked{"PPI/Document/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FILE';
  package PPI::Document::File;use strict;use Carp ();use Params::Util qw{_STRING _INSTANCE};use PPI::Document ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Document'}sub new {my$class=shift;my$filename=_STRING(shift);unless (defined$filename){return$class->_error("Did not provide a file name to load")}my$self=$class->SUPER::new($filename,@_)or return undef;if (_INSTANCE($self,'PPI::Document')){bless$self,'PPI::Document::File'}else {die "PPI::Document::File SUPER call returned an object of the wrong type"}$self->{filename}=$filename;$self}sub filename {$_[0]->{filename}}sub save {my$self=shift;my$filename=shift;unless (defined$filename){$filename=$self->filename}$self->SUPER::save($filename,@_)}1;
PPI_DOCUMENT_FILE

$fatpacked{"PPI/Document/Fragment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FRAGMENT';
  package PPI::Document::Fragment;use strict;use PPI::Document ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Document'}sub index_locations {warn "Useless attempt to index the locations of a document fragment";undef}sub scope() {''}1;
PPI_DOCUMENT_FRAGMENT

$fatpacked{"PPI/Document/Normalized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_NORMALIZED';
  package PPI::Document::Normalized;use strict;use Scalar::Util qw{refaddr reftype blessed};use Params::Util qw{_INSTANCE _ARRAY};use PPI::Util ();use vars qw{$VERSION};BEGIN {$VERSION='0.01'}use overload 'bool'=>\&PPI::Util::TRUE;use overload '=='=>'equal';sub new {my$class=shift;my%args=@_;my$Document=_INSTANCE($args{Document},'PPI::Document')or return undef;my$version=$args{version}or return undef;my$functions=_ARRAY($args{functions})or return undef;my$self=bless {Document=>$Document,version=>$version,functions=>$functions,},$class;$self}sub _Document {$_[0]->{Document}}sub version {$_[0]->{version}}sub functions {$_[0]->{functions}}sub equal {my$self=shift;my$other=_INSTANCE(shift,'PPI::Document::Normalized')or return undef;return undef if$self->{processing};return '' unless$self->version eq $other->version;$self->_equal_ARRAY($self->functions,$other->functions)or return '';$self->{seen}={};my$rv=$self->_equal_blessed($self->_Document,$other->_Document);delete$self->{seen};$rv}sub _equal_blessed {my ($self,$this,$that)=@_;my ($bthis,$bthat)=(blessed$this,blessed$that);$bthis and $bthat and $bthis eq $bthat or return '';$self->_equal_reference($this,$that)}sub _equal_reference {my ($self,$this,$that)=@_;my ($rthis,$rthat)=(refaddr$this,refaddr$that);$rthis and $rthat or return undef;my$seen=$self->{seen}->{$rthis};if ($seen and $seen ne $rthat){return ''}my ($tthis,$tthat)=(reftype$this,reftype$that);$tthis and $tthat and $tthis eq $tthat or return undef;$self->{seen}->{$rthis}=$rthat;my$method="_equal_$tthat";my$rv=$self->$method($this,$that);delete$self->{seen}->{$rthis};$rv}sub _equal_SCALAR {my ($self,$this,$that)=@_;my ($cthis,$cthat)=($$this,$$that);return$self->_equal_blessed($cthis,$cthat)if blessed$cthis;return$self->_equal_reference($cthis,$cthat)if ref$cthis;return (defined$cthat and $cthis eq $cthat)if defined$cthis;!defined$cthat}sub _equal_REF {shift->_equal_SCALAR(@_)}sub _equal_ARRAY {my ($self,$this,$that)=@_;scalar(@$this)==scalar(@$that)or return '';for my$i (0 .. scalar(@$this)){my ($cthis,$cthat)=($this->[$i],$that->[$i]);if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_HASH {my ($self,$this,$that)=@_;return '' unless scalar(keys %$this)==scalar(keys %$that);for my$k (keys %$this){return '' unless exists$that->{$k};my ($cthis,$cthat)=($this->{$k},$that->{$k});if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_GLOB {my ($self,$this,$that)=@_;warn('GLOB comparisons are not supported');''}sub _equal_CODE {my ($self,$this,$that)=@_;refaddr$this==refaddr$that}sub _equal_IO {my ($self,$this,$that)=@_;warn('IO comparisons are not supported');''}sub DESTROY {if ($_[0]->{Document}){$_[0]->{Document}->DESTROY;delete $_[0]->{Document}}}1;
PPI_DOCUMENT_NORMALIZED

$fatpacked{"PPI/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DUMPER';
  package PPI::Dumper;use strict;use Params::Util qw{_INSTANCE};use vars qw{$VERSION};BEGIN {$VERSION='0.01'}sub new {my$class=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;my$self=bless {root=>$Element,display=>{memaddr=>'',indent=>2,class=>1,content=>1,whitespace=>1,comments=>1,locations=>0,},},$class;my%options=map {lc $_}@_;for (keys %{$self->{display}}){if (exists$options{$_}){if ($_ eq 'indent'){$self->{display}->{indent}=$options{$_}}else {$self->{display}->{$_}=!!$options{$_}}}}$self->{indent_string}=join '',(' ' x $self->{display}->{indent});$self}sub print {CORE::print(shift->string)}sub string {my$array_ref=shift->_dump or return undef;join '',map {"$_\n"}@$array_ref}sub list {my$array_ref=shift->_dump or return ();@$array_ref}sub _dump {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$output=shift || [];my$show=1;if ($Element->isa('PPI::Token::Whitespace')){$show=0 unless$self->{display}->{whitespace}}elsif ($Element->isa('PPI::Token::Comment')){$show=0 unless$self->{display}->{comments}}push @$output,$self->_element_string($Element,$indent)if$show;if ($Element->isa('PPI::Node')){my$child_indent=$indent .$self->{indent_string};for my$child (@{$Element->{children}}){$self->_dump($child,$child_indent,$output)}}$output}sub _element_string {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$string='';if ($self->{display}->{memaddr}){$string .= $Element->refaddr .'  '}if ($self->{display}->{locations}){my$loc_string;if ($Element->isa('PPI::Token')){my$location=$Element->location;if ($location){$loc_string=sprintf("[ % 4d, % 3d, % 3d ] ",@$location)}}$string .= $loc_string || " " x 20}if ($self->{display}->{indent}){$string .= $indent}if ($self->{display}->{class}){$string .= ref$Element}if ($Element->isa('PPI::Token')){if ($self->{display}->{content}){my$content=$Element->content;$content =~ s/\n/\\n/g;$content =~ s/\t/\\t/g;$content =~ s/\f/\\f/g;$string .= "  \t'$content'"}}elsif ($Element->isa('PPI::Structure')){if ($self->{display}->{content}){my$start=$Element->start ? $Element->start->content : '???';my$finish=$Element->finish ? $Element->finish->content : '???';$string .= "  \t$start ... $finish"}}$string}1;
PPI_DUMPER

$fatpacked{"PPI/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_ELEMENT';
  package PPI::Element;use strict;use Clone ();use Scalar::Util qw{refaddr};use Params::Util qw{_INSTANCE _ARRAY};use List::MoreUtils ();use PPI::Util ();use PPI::Node ();use vars qw{$VERSION $errstr %_PARENT};BEGIN {$VERSION='0.01';$errstr='';%_PARENT=()}use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';use overload '=='=>'__equals';use overload '!='=>'__nequals';use overload 'eq'=>'__eq';use overload 'ne'=>'__ne';sub significant() {1}sub class {ref($_[0])}sub tokens {$_[0]}sub content() {''}sub parent {$_PARENT{refaddr $_[0]}}sub descendant_of {my$cursor=shift;my$parent=shift or return undef;while (refaddr$cursor!=refaddr$parent){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub ancestor_of {my$self=shift;my$cursor=shift or return undef;while (refaddr$cursor!=refaddr$self){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub statement {my$cursor=shift;while (!_INSTANCE($cursor,'PPI::Statement')){$cursor=$_PARENT{refaddr$cursor}or return ''}$cursor}sub top {my$cursor=shift;while (my$parent=$_PARENT{refaddr$cursor}){$cursor=$parent}$cursor}sub document {my$top=shift->top;_INSTANCE($top,'PPI::Document')and $top}sub next_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::MoreUtils::firstidx {refaddr $_==$key}@$elements;$elements->[$position + 1]|| ''}sub snext_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::MoreUtils::firstidx {refaddr $_==$key}@$elements;while (defined(my$it=$elements->[++$position])){return$it if$it->significant}''}sub previous_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::MoreUtils::firstidx {refaddr $_==$key}@$elements;$position and $elements->[$position - 1]or ''}sub sprevious_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::MoreUtils::firstidx {refaddr $_==$key}@$elements;while ($position-- and defined(my$it=$elements->[$position])){return$it if$it->significant}''}sub first_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->first_element or die "Found empty PPI::Node while getting first token"}$cursor}sub last_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->last_element or die "Found empty PPI::Node while getting first token"}$cursor}sub next_token {my$cursor=shift;while (1){my$element=$cursor->next_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->first_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->finish){return$cursor->finish}}}sub previous_token {my$cursor=shift;while (1){my$element=$cursor->previous_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->last_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->start){return$cursor->start}}}sub clone {Clone::clone(shift)}sub __insert_before {my$self=shift;$self->parent->__insert_before_child($self,@_)}sub __insert_after {my$self=shift;$self->parent->__insert_after_child($self,@_)}sub remove {my$self=shift;my$parent=$self->parent or return$self;$parent->remove_child($self)}sub delete {$_[0]->remove or return undef;$_[0]->DESTROY;1}sub replace {my$self=ref $_[0]? shift : return undef;_INSTANCE(shift,ref$self)or return undef;die "The ->replace method has not yet been implemented"}sub location {my$self=shift;$self->_ensure_location_present or return undef;return [@{$self->{_location}}]}sub line_number {my$self=shift;my$location=$self->location()or return undef;return$location->[0]}sub column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[1]}sub visual_column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[2]}sub logical_line_number {my$self=shift;return$self->location()->[3]}sub logical_filename {my$self=shift;my$location=$self->location()or return undef;return$location->[4]}sub _ensure_location_present {my$self=shift;unless (exists$self->{_location}){my$Document=$self->document or return undef;if ($Document->isa('PPI::Document::Fragment')){return undef}$Document->index_locations or return undef;unless (exists$self->{_location}){return undef}}return 1}sub _flush_locations {my$self=shift;unless ($self==$self->top){return$self->top->_flush_locations($self)}my@Tokens=$self->tokens;if (_INSTANCE($_[0],'PPI::Element')){my$start=shift->first_token;while (my$Token=shift@Tokens){return 1 unless$Token->{_location};next unless refaddr($Token)==refaddr($start);delete $$Token->{_location};last}}for my$Token (@Tokens){delete$Token->{_location}}1}sub _xml_name {my$class=ref $_[0]|| $_[0];my$name=lc join('_',split /::/,$class);substr($name,4)}sub _xml_attr {return {}}sub _xml_content {defined $_[0]->{content}? $_[0]->{content}: ''}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub DESTROY {delete$_PARENT{refaddr $_[0]}}sub __equals {ref $_[1]and refaddr($_[0])==refaddr($_[1])}sub __nequals {!__equals(@_)}sub __eq {my$self=_INSTANCE($_[0],'PPI::Element')? $_[0]->content : $_[0];my$other=_INSTANCE($_[1],'PPI::Element')? $_[1]->content : $_[1];$self eq $other}sub __ne {!__eq(@_)}1;
PPI_ELEMENT

$fatpacked{"PPI/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION';
  package PPI::Exception;use strict;use Params::Util qw{_INSTANCE};use vars qw{$VERSION};BEGIN {$VERSION='0.01'}sub new {my$class=shift;return bless {@_ },$class if @_ > 1;return bless {message=>$_[0]},$class if @_;return bless {message=>'Unknown Exception' },$class}sub message {$_[0]->{message}}sub callers {@{$_[0]->{callers}|| []}}sub throw {my$it=shift;if (_INSTANCE($it,'PPI::Exception')){if ($it->{callers}){push @{$it->{callers}},[caller(0)]}else {$it->{callers}||= []}}else {my$message=$_[0]|| 'Unknown Exception';$it=$it->new(message=>$message,callers=>[[caller(0)],],)}die$it}1;
PPI_EXCEPTION

$fatpacked{"PPI/Exception/ParserRejection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION_PARSERREJECTION';
  package PPI::Exception::ParserRejection;use strict;use PPI::Exception ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Exception'}1;
PPI_EXCEPTION_PARSERREJECTION

$fatpacked{"PPI/Exception/ParserTimeout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION_PARSERTIMEOUT';
  package PPI::Exception::ParserTimeout;use strict;use PPI::Exception ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Exception'}1;
PPI_EXCEPTION_PARSERTIMEOUT

$fatpacked{"PPI/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_FIND';
  package PPI::Find;use strict;use Params::Util qw{_INSTANCE};use vars qw{$VERSION};BEGIN {$VERSION='0.01'}sub new {my$class=ref $_[0]? ref shift : shift;my$wanted=ref $_[0]eq 'CODE' ? shift : return undef;my$self=bless {wanted=>$wanted,},$class;$self}sub clone {my$self=ref $_[0]? shift : die "->clone can only be called as an object method";my$class=ref$self;my$clone=bless {wanted=>$self->{wanted},},$class;$clone}sub in {my$self=shift;my$Element=shift;my%params=@_;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress',%params)}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object',%params)}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;return$self->_error("Error while searching: $errstr",%params)}delete$self->{in};if ($params{array_ref}){if (@{$self->{matches}}){return delete$self->{matches}}delete$self->{matches};return ''}my$matches=delete$self->{matches};@$matches}sub start {my$self=shift;my$Element=shift;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress')}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object')}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;$self->_error("Error while searching: $errstr");return undef}1}sub match {my$self=shift;return undef unless$self->{matches};my$match=shift @{$self->{matches}};return$match if$match;$self->finish;undef}sub finish {my$self=shift;delete$self->{in};delete$self->{matches};delete$self->{errstr};1}sub _execute {my$self=shift;my$wanted=$self->{wanted};my@queue=($self->{in});while (my$Element=shift@queue){my$rv=&$wanted($Element,$self->{in});push @{$self->{matches}},$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,$Element->children;unshift@queue,$Element->start if$Element->start}else {unshift@queue,$Element->children}}1}sub errstr {shift->{errstr}}sub _error {my$self=shift;$self->{errstr}=shift;my%params=@_;$params{array_ref}? undef : ()}1;
PPI_FIND

$fatpacked{"PPI/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_LEXER';
  package PPI::Lexer;use strict;use Scalar::Util ();use Params::Util qw{_STRING _INSTANCE};use List::MoreUtils ();use PPI ();use PPI::Exception ();use vars qw{$VERSION $errstr *_PARENT %ROUND %RESOLVE};BEGIN {$VERSION='0.01';$errstr='';*_PARENT=*PPI::Element::_PARENT;%ROUND=('if'=>'PPI::Structure::Condition','elsif'=>'PPI::Structure::Condition','unless'=>'PPI::Structure::Condition','while'=>'PPI::Structure::Condition','until'=>'PPI::Structure::Condition','for'=>'PPI::Structure::For','foreach'=>'PPI::Structure::For',);%RESOLVE=('('=>'_round','['=>'_square','{'=>'_curly',)}use vars qw{$X_TOKENIZER};BEGIN {$X_TOKENIZER ||= 'PPI::Tokenizer'}use constant X_TOKENIZER=>$X_TOKENIZER;sub new {my$class=shift->_clear;bless {Tokenizer=>undef,buffer=>[],delayed=>[],},$class}sub lex_file {my$self=ref $_[0]? shift : shift->new;my$file=_STRING(shift);unless (defined$file){return$self->_error("Did not pass a filename to PPI::Lexer::lex_file")}my$Tokenizer=eval {X_TOKENIZER->new($file)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_source {my$self=ref $_[0]? shift : shift->new;my$source=shift;unless (defined$source and not ref$source){return$self->_error("Did not pass a string to PPI::Lexer::lex_source")}my$Tokenizer=eval {X_TOKENIZER->new(\$source)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_tokenizer {my$self=ref $_[0]? shift : shift->new;my$Tokenizer=_INSTANCE(shift,'PPI::Tokenizer');return$self->_error("Did not pass a PPI::Tokenizer object to PPI::Lexer::lex_tokenizer")unless$Tokenizer;my$Document=PPI::Document->new;$self->{Tokenizer}=$Tokenizer;if (!eval {$self->_lex_document($Document);1}){undef$Document;if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}else {return$self->_error($errstr)}}return$Document}sub _lex_document {my ($self,$Document)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){$self->_add_element($Document,$Token);next}if ($Token->content eq ';'){$self->_add_element($Document,PPI::Statement::Null->new($Token),);next}unless (ref$Token eq 'PPI::Token::Structure'){my$Statement=$self->_statement($Document,$Token)->new($Token);$self->_add_delayed($Document);$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){$self->_add_element($Document,PPI::Statement::UnmatchedBrace->new($Token));next}PPI::Exception->throw('Lexer reached an illegal state')}unless (defined$Token){my$errstr=$self->{Tokenizer}? $self->{Tokenizer}->errstr : '';$errstr ||= 'Unknown Tokenizer Error';PPI::Exception->throw($errstr)}$self->_add_delayed($Document);my$perl6=$self->{Tokenizer}->{'perl6'};if (@$perl6){my$includes=$Document->find('PPI::Statement::Include::Perl6');for my$include (@$includes){unless (@$perl6){PPI::Exception->throw('Failed to find a perl6 section')}$include->{perl6}=shift @$perl6}}return 1}use vars qw{%STATEMENT_CLASSES};BEGIN {%STATEMENT_CLASSES=('BEGIN'=>'PPI::Statement::Scheduled','CHECK'=>'PPI::Statement::Scheduled','UNITCHECK'=>'PPI::Statement::Scheduled','INIT'=>'PPI::Statement::Scheduled','END'=>'PPI::Statement::Scheduled','AUTOLOAD'=>'PPI::Statement::Sub','DESTROY'=>'PPI::Statement::Sub','package'=>'PPI::Statement::Package','no'=>'PPI::Statement::Include','require'=>'PPI::Statement::Include','my'=>'PPI::Statement::Variable','local'=>'PPI::Statement::Variable','our'=>'PPI::Statement::Variable','state'=>'PPI::Statement::Variable','if'=>'PPI::Statement::Compound','unless'=>'PPI::Statement::Compound','for'=>'PPI::Statement::Compound','foreach'=>'PPI::Statement::Compound','while'=>'PPI::Statement::Compound','until'=>'PPI::Statement::Compound','given'=>'PPI::Statement::Given','when'=>'PPI::Statement::When','default'=>'PPI::Statement::When','redo'=>'PPI::Statement::Break','next'=>'PPI::Statement::Break','last'=>'PPI::Statement::Break','return'=>'PPI::Statement::Break','goto'=>'PPI::Statement::Break','__DATA__'=>'PPI::Statement::Data','__END__'=>'PPI::Statement::End',)}sub _statement {my ($self,$Parent,$Token)=@_;if ($Parent->isa('PPI::Structure::List')or $Parent->isa('PPI::Structure::Constructor')){if ($Token->isa('PPI::Token::Word')){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {last}}$self->_rollback($Next)}}my$class=$STATEMENT_CLASSES{$Token->content};if ($Parent->isa('PPI::Structure::Subscript')){unless ($class and $class->isa('PPI::Statement::Expression')){return 'PPI::Statement::Expression'}my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->content eq '}'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {$self->_rollback($Next);return$class}}$self->_rollback($Next);return 'PPI::Statement::Expression'}return$class if$class;if ($Token->content eq 'sub'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}my$sclass=$STATEMENT_CLASSES{$Next->content};if ($sclass and $sclass eq 'PPI::Statement::Scheduled'){$self->_rollback($Next);return 'PPI::Statement::Scheduled'}if ($Next->isa('PPI::Token::Word')){$self->_rollback($Next);return 'PPI::Statement::Sub'}$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next);return 'PPI::Statement::Sub'}if ($Token->content eq 'use'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->content eq 'v6'){$self->_rollback($Next);return 'PPI::Statement::Include::Perl6'}else {$self->_rollback($Next);return 'PPI::Statement::Include'}}$self->_rollback($Next);return 'PPI::Statement::Include'}if ($Parent->isa('PPI::Structure::Condition')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::List')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::Given')or $Parent->isa('PPI::Structure::When')){return 'PPI::Statement::Expression'}if (_INSTANCE($Token,'PPI::Token::Label')){return 'PPI::Statement::Compound'}return 'PPI::Statement'}sub _lex_statement {my ($self,$Statement)=@_;if ($Statement->isa('PPI::Statement::End')){return$self->_lex_end($Statement)}my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}if ($Token->__LEXER__closes or $Token->isa('PPI::Token::Separator')){return$self->_rollback($Token)}unless ($Statement->__LEXER__normal){unless ($self->_continues($Statement,$Token)){return$self->_rollback($Token)}}unless ($Token->isa('PPI::Token::Structure')){$self->_add_element($Statement,$Token);next}if ($Token->content eq ';'){$self->_add_element($Statement,$Token);return 1}my$method=$RESOLVE{$Token->content};my$Structure=$self->$method($Statement)->new($Token);$self->_add_delayed($Statement);$self->_add_element($Statement,$Structure);$self->_lex_structure($Structure)}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _lex_end {my ($self,$Statement)=@_;my$Token;while ($Token=$self->_get_token){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Statement);push @{$Statement->{children}},$Token}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _continues {my ($self,$Statement,$Token)=@_;if ($Statement->schildren==1 and $Statement->schild(0)->isa('PPI::Structure::Block')){return ''}unless (ref($Statement)=~ /\b(?:Scheduled|Sub|Compound|Given|When)$/){return 1}my@part=$Statement->schildren;my$LastChild=$part[-1];unless ($Statement->isa('PPI::Statement::Compound')){return!$LastChild->isa('PPI::Structure::Block')}my$type=$Statement->type;if ($type eq 'if'){unless ($LastChild->isa('PPI::Structure::Block')){return 1}my$NextLast=$Statement->schild(-2);if ($NextLast and $NextLast->isa('PPI::Token')and $NextLast->isa('PPI::Token::Word')and $NextLast->content eq 'else'){return ''}if ($Token->isa('PPI::Token::Word')and ($Token->content eq 'else' or $Token->content eq 'elsif')){return 1}return ''}if ($type eq 'label'){if ($Token->isa('PPI::Token::Word')and $Token->content =~ /^(?:while|until|for|foreach)$/){return 1}if ($Token->isa('PPI::Token::Structure')&& $Token->content eq '{'){return 1}return ''}if ($LastChild->isa('PPI::Structure')and $LastChild->braces eq '()'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($type eq 'for'){if ($LastChild->isa('PPI::Token::Word')and $LastChild->content =~ /^for(?:each)?\z/){if (($Token->isa('PPI::Token::Structure')and $Token->content eq '(')or $Token->isa('PPI::Token::QuoteLike::Words')){return 1}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}$type='foreach'}elsif ($LastChild->isa('PPI::Structure::Block')){return ''}elsif ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}if ($LastChild->isa('PPI::Token::Word')and $LastChild->content eq 'continue'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($LastChild->isa('PPI::Structure::Block')){if (_INSTANCE($part[-2],'PPI::Token::Word')and $part[-2]->content eq 'continue'){return ''}return$Token->isa('PPI::Token::Word')&& $Token->content eq 'continue'}if ($type eq 'block'){}if ($type eq 'while'){if ($LastChild->isa('PPI::Token::Word')and ($LastChild->content eq 'while' or $LastChild->content eq 'until')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '('}}if ($type eq 'foreach'){if ($LastChild->isa('PPI::Token::Symbol')){return 1 if$Token->isa('PPI::Token::Structure')&& $Token->content eq '(';return 1 if$Token->isa('PPI::Token::QuoteLike::Words');return ''}if ($LastChild->content eq 'foreach' or $LastChild->content eq 'for'){if ($Token->isa('PPI::Token::Word')and (($STATEMENT_CLASSES{$Token->content }|| '')eq 'PPI::Statement::Variable')){return 1}elsif ($Token->content =~ /^\$/){return 1}elsif ($Token->isa('PPI::Token::Structure')and $Token->content eq '('){return 1}elsif ($Token->isa('PPI::Token::QuoteLike::Words')){return 1}else {return ''}}if (($STATEMENT_CLASSES{$LastChild->content }|| '')eq 'PPI::Statement::Variable'){return$Token->content =~ /^\$/}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}PPI::Exception->throw("Illegal state in '$type' compound statement")}sub _round {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if (_INSTANCE($Element,'PPI::Token::Word')){my$rclass=$ROUND{$Element->content};return$rclass if$rclass}if ($Parent->isa('PPI::Statement::Compound')){if ($Parent->type =~ /^for(?:each)?$/){return 'PPI::Structure::For'}}elsif ($Parent->isa('PPI::Statement::Given')){return 'PPI::Structure::Given'}elsif ($Parent->isa('PPI::Statement::When')){return 'PPI::Structure::When'}if (_INSTANCE($Element,'PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1}'PPI::Structure::List'}sub _square {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if ($Element){if ($Element->isa('PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Symbol')and $Element->content =~ /^(?:\$|\@)/){return 'PPI::Structure::Subscript'}}'PPI::Structure::Constructor'}use vars qw{%CURLY_CLASSES @CURLY_LOOKAHEAD_CLASSES};BEGIN {%CURLY_CLASSES=('sub'=>'PPI::Structure::Block','grep'=>'PPI::Structure::Block','map'=>'PPI::Structure::Block','sort'=>'PPI::Structure::Block','do'=>'PPI::Structure::Block','scalar'=>'PPI::Structure::Constructor','='=>'PPI::Structure::Constructor','||='=>'PPI::Structure::Constructor','&&='=>'PPI::Structure::Constructor','//='=>'PPI::Structure::Constructor','||'=>'PPI::Structure::Constructor','&&'=>'PPI::Structure::Constructor','//'=>'PPI::Structure::Constructor','?'=>'PPI::Structure::Constructor',':'=>'PPI::Structure::Constructor',','=>'PPI::Structure::Constructor','=>'=>'PPI::Structure::Constructor','+'=>'PPI::Structure::Constructor','return'=>'PPI::Structure::Constructor','bless'=>'PPI::Structure::Constructor',);@CURLY_LOOKAHEAD_CLASSES=({},{';'=>'PPI::Structure::Block','}'=>'PPI::Structure::Constructor',},{'=>'=>'PPI::Structure::Constructor',},)}sub _curly {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);my$content=$Element ? $Element->content : '';if ($Element){if ($content eq '->' and $Element->isa('PPI::Token::Operator')){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($content =~ /^(?:\$|\@)/ and $Element->isa('PPI::Token::Symbol')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Block')){if (my$prior=$Parent->schild(-2)){my$prior_content=$prior->content();$prior->isa('PPI::Token::Cast')and ($prior_content eq '@' || $prior_content eq '$')and return 'PPI::Structure::Subscript'}}if ($CURLY_CLASSES{$content}){return$CURLY_CLASSES{$content}}}if ($Parent->isa('PPI::Statement::Compound')){return 'PPI::Structure::Block'}if ($Parent->isa('PPI::Statement::Include')){if ($Parent->schildren==2 || $Parent->schildren==3 && $Parent->schild(2)->isa('PPI::Token::Number')){return 'PPI::Structure::Constructor'}}return 'PPI::Structure::Block' if$Element;if ($Parent->isa('PPI::Statement')and _INSTANCE($Parent->parent,'PPI::Structure::List')){my$function=$Parent->parent->parent->schild(-2);if ($function and $function->content =~ /^(?:map|grep|sort)$/){return 'PPI::Structure::Block'}}my$Next;my$position=0;my@delayed;while ($Next=$self->_get_token){unless ($Next->significant){push@delayed,$Next;next}if (++$position >= @CURLY_LOOKAHEAD_CLASSES){$self->_buffer(splice(@delayed),$Next);last}elsif (my$class=$CURLY_LOOKAHEAD_CLASSES[$position]{$Next->content}){$self->_buffer(splice(@delayed),$Next);return$class}push@delayed,$Next}$self->_buffer(splice(@delayed));if (ref$Parent eq 'PPI::Statement'){bless$Parent,'PPI::Statement::Compound'}return 'PPI::Structure::Block'}sub _lex_structure {my ($self,$Structure)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}unless ($Token->isa('PPI::Token::Structure')){$self->_add_delayed($Structure);my$Statement=$self->_statement($Structure,$Token)->new($Token);$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){if ($Token->content eq $Structure->start->__LEXER__opposite){$self->_add_delayed($Structure);$Structure->{finish}=$Token;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Structure);if ($Structure->isa('PPI::Structure::For')){if (2 > scalar grep {$_->isa('PPI::Statement')}$Structure->children){bless($Structure,'PPI::Structure::List')}}return 1}return$self->_rollback($Token)}$self->_add_element($Structure,PPI::Statement::Null->new($Token),)}unless (defined$Token){PPI::Exception->throw}$self->_add_delayed($Structure)}sub _get_token {shift(@{$_[0]->{buffer}})or $_[0]->{Tokenizer}->get_token}sub _add_element {my ($self,$Parent,$Element)=@_;if (ref$Parent eq 'PPI::Statement' and my$first=$Parent->schild(0)){if ($first->isa('PPI::Token::Label')and!(my$second=$Parent->schild(1))){my$new_class=$STATEMENT_CLASSES{$second->content};bless$Parent,$new_class if$new_class}}for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Element}=$Parent);push @{$Parent->{children}},@{$self->{delayed}},$Element;$self->{delayed}=[]}sub _add_delayed {my ($self,$Parent)=@_;for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}push @{$Parent->{children}},@{$self->{delayed}};$self->{delayed}=[]}sub _rollback {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}if (@{$self->{delayed}}){unshift @{$self->{buffer}},splice @{$self->{delayed}}}1}sub _buffer {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}1}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}1;
PPI_LEXER

$fatpacked{"PPI/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NODE';
  package PPI::Node;use strict;use Carp ();use Scalar::Util qw{refaddr};use List::MoreUtils ();use Params::Util qw{_INSTANCE _CLASS _CODELIKE};use PPI::Element ();use vars qw{$VERSION @ISA *_PARENT};BEGIN {$VERSION='0.01';@ISA='PPI::Element';*_PARENT=*PPI::Element::_PARENT}sub new {my$class=ref $_[0]|| $_[0];bless {children=>[]},$class}sub scope() {''}sub add_element {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;$_PARENT{refaddr$Element}and return undef;push @{$self->{children}},$Element;Scalar::Util::weaken($_PARENT{refaddr$Element}=$self);1}sub __add_element {Scalar::Util::weaken($_PARENT{refaddr $_[1]}=$_[0]);push @{$_[0]->{children}},$_[1]}sub elements {if (wantarray){return @{$_[0]->{children}}}else {return scalar @{$_[0]->{children}}}}sub first_element {$_[0]->{children}->[0]}sub last_element {$_[0]->{children}->[-1]}sub children {wantarray ? @{$_[0]->{children}}: scalar @{$_[0]->{children}}}sub schildren {return grep {$_->significant}@{$_[0]->{children}}if wantarray;my$count=0;for (@{$_[0]->{children}}){$count++ if $_->significant}return$count}sub child {$_[0]->{children}->[$_[1]]}sub schild {my$self=shift;my$idx=0 + shift;my$el=$self->{children};if ($idx < 0){my$cursor=0;while (exists$el->[--$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and ++$idx >= 0}}else {my$cursor=-1;while (exists$el->[++$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and --$idx < 0}}undef}sub contains {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;while ($Element=$Element->parent){return 1 if refaddr($self)==refaddr($Element)}''}sub find {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@found;my@queue=@{$self->{children}};my$ok=eval {while (@queue){my$Element=shift@queue;my$rv=&$wanted($self,$Element);push@found,$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if$Element->start}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}@found ? \@found : ''}sub find_first {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@queue=@{$self->{children}};my$rv;my$ok=eval {while (@queue){my$Element=shift@queue;my$element_rv=$wanted->($self,$Element);if ($element_rv){$rv=$Element;last}next if!defined$element_rv;next if!$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if defined($Element->finish);unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if defined($Element->start)}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}$rv or ''}sub find_any {my$self=shift;my$rv=$self->find_first(@_);$rv ? 1 : $rv}sub remove_child {my$self=shift;my$child=_INSTANCE(shift,'PPI::Element')or return undef;my$key=refaddr$child;my$p=List::MoreUtils::firstidx {refaddr $_==$key}@{$self->{children}};return undef unless defined$p;splice(@{$self->{children}},$p,1);delete$_PARENT{refaddr$child};$child}sub prune {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my$pruned=0;my@queue=$self->children;my$ok=eval {while (my$element=shift@queue){my$rv=&$wanted($self,$element);if ($rv){$element->delete or return undef;$pruned++;next}next unless defined$rv;if (_INSTANCE($element,'PPI::Node')){unshift@queue,$element->children}}1};if (!$ok){return undef}$pruned}sub _wanted {my$either=shift;my$it=defined($_[0])? shift : do {Carp::carp('Undefined value passed as search condition')if $^W;return undef};return$it if _CODELIKE($it);if (ref$it){Carp::carp('Illegal non-CODE reference passed as search condition')if $^W;return undef}$it="PPI::$it" unless substr($it,0,5)eq 'PPI::';unless (_CLASS($it)and $it->isa('PPI::Element')){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}my$wanted_class="\n\treturn '' unless \$_[1]->isa('$it');";my$wanted_content='';if (defined $_[0]){my$content=shift;if (ref$content eq 'Regexp'){$content="$content"}elsif (ref$content){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}else {$content=quotemeta$content}$wanted_content .= "\n\treturn '' unless defined \$_[1]->{content};";$wanted_content .= "\n\treturn '' unless \$_[1]->{content} =~ /$content/;"}my$code="sub {" .$wanted_class .$wanted_content ."\n\t1;" ."\n}";$code=eval$code;(ref$code eq 'CODE')? $code : undef}sub tokens {map {$_->tokens}@{$_[0]->{children}}}sub content {join '',map {$_->content}@{$_[0]->{children}}}sub clone {my$self=shift;my$clone=$self->SUPER::clone;$clone->__link_children;$clone}sub location {my$self=shift;my$first=$self->{children}->[0]or return undef;$first->location}sub DESTROY {local $_;if ($_[0]->{children}){my@queue=$_[0];while (defined($_=shift@queue)){unshift@queue,@{delete $_->{children}}if $_->{children};%$_=()}}delete$_PARENT{refaddr $_[0]}}sub __position {my$key=refaddr $_[1];List::MoreUtils::firstidx {refaddr $_==$key}@{$_[0]->{children}}}sub __insert_before_child {my$self=shift;my$key=refaddr shift;my$p=List::MoreUtils::firstidx {refaddr $_==$key}@{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,0,@_);1}sub __insert_after_child {my$self=shift;my$key=refaddr shift;my$p=List::MoreUtils::firstidx {refaddr $_==$key}@{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p + 1,0,@_);1}sub __replace_child {my$self=shift;my$key=refaddr shift;my$p=List::MoreUtils::firstidx {refaddr $_==$key}@{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,1,@_);1}sub __link_children {my$self=shift;my@queue=($self);while (my$Node=shift@queue){for my$Element (@{$Node->{children}}){Scalar::Util::weaken($_PARENT{refaddr($Element)}=$Node);unshift@queue,$Element if$Element->isa('PPI::Node')}next unless$Node->isa('PPI::Structure');Scalar::Util::weaken($_PARENT{refaddr($Node->start)}=$Node)if$Node->start;Scalar::Util::weaken($_PARENT{refaddr($Node->finish)}=$Node)if$Node->finish}1}1;
PPI_NODE

$fatpacked{"PPI/Normal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL';
  package PPI::Normal;use strict;use Carp ();use List::MoreUtils ();use PPI::Util '_Document';use PPI::Document::Normalized ();use vars qw{$VERSION %LAYER};BEGIN {$VERSION='0.01';%LAYER=(1=>[],2=>[],)}sub register {my$class=shift;while (@_){my$function=shift;SCOPE: {no strict 'refs';defined$function and defined &{"$function"}or Carp::croak("Bad function name provided to PPI::Normal")}if (List::MoreUtils::any {$_ eq $function}){return 1}my$layer=shift;defined$layer and $layer =~ /^(?:1|2)$/ or Carp::croak("Bad layer provided to PPI::Normal");push @{$LAYER{$layer}},$function}1}use PPI::Normal::Standard;sub new {my$class=shift;my$layer=@_ ? (defined $_[0]and!ref $_[0]and $_[0]=~ /^[12]$/)? shift : return undef : 1;my$object=bless {layer=>$layer,},$class;$object}sub layer {$_[0]->{layer}}sub process {my$self=ref $_[0]? shift : shift->new;return undef if$self->{Document};$self->{Document}=_Document(shift)or return undef;my@functions=map {@{$LAYER{$_}}}(1 .. $self->layer);for my$function (@functions){no strict 'refs';&{"$function"}($self->{Document})}my$Normalized=PPI::Document::Normalized->new(Document=>$self->{Document},version=>$VERSION,functions=>\@functions,)or return undef;delete$self->{Document};return$Normalized}1;
PPI_NORMAL

$fatpacked{"PPI/Normal/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL_STANDARD';
  package PPI::Normal::Standard;use strict;use vars qw{$VERSION};BEGIN {$VERSION='0.01'}my@METHODS=(remove_insignificant_elements=>1,remove_useless_attributes=>1,remove_useless_pragma=>2,remove_statement_separator=>2,remove_useless_return=>2,);sub import {PPI::Normal->register(map {/\D/ ? "PPI::Normal::Standard::$_" : $_}@METHODS)or die "Failed to register PPI::Normal::Standard transforms"}sub remove_insignificant_elements {my$Document=shift;$Document->prune(sub {!$_[1]->significant})}sub remove_useless_attributes {my$Document=shift;delete$Document->{tab_width}}my$remove_pragma=map {$_=>1}qw{strict warnings diagnostics less};sub remove_useless_pragma {my$Document=shift;$Document->prune(sub {return '' unless $_[1]->isa('PPI::Statement::Include');return 1 if $_[1]->version;return 1 if$remove_pragma->{$_[1]->pragma};''})}sub remove_statement_separator {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Structure')or return '';$_[1]->content eq ';' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement')or return '';$_[1]->next_sibling and return '';1})}sub remove_useless_return {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Word')or return '';$_[1]->content eq 'return' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement::Break')or return '';$stmt->children==2 or return '';$stmt->next_sibling and return '';my$block=$stmt->parent or return '';$block->isa('PPI::Structure::Block')or return '';1})}1;
PPI_NORMAL_STANDARD

$fatpacked{"PPI/Statement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT';
  package PPI::Statement;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use vars qw{$VERSION @ISA *_PARENT};BEGIN {$VERSION='0.01';@ISA='PPI::Node';*_PARENT=*PPI::Element::_PARENT}use PPI::Statement::Break ();use PPI::Statement::Compound ();use PPI::Statement::Data ();use PPI::Statement::End ();use PPI::Statement::Expression ();use PPI::Statement::Include ();use PPI::Statement::Null ();use PPI::Statement::Package ();use PPI::Statement::Scheduled ();use PPI::Statement::Sub ();use PPI::Statement::Given ();use PPI::Statement::UnmatchedBrace ();use PPI::Statement::Unknown ();use PPI::Statement::Variable ();use PPI::Statement::When ();sub __LEXER__normal() {1}sub new {my$class=shift;if (ref$class){PPI::Exception->throw}my$self=bless {children=>[],},$class;my$token=shift;if (_INSTANCE($token,'PPI::Token')){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$token}=$self);push @{$self->{children}},$token}$self}sub label {my$first=shift->schild(1)or return '';$first->isa('PPI::Token::Label')? substr($first,0,length($first)- 1): ''}sub specialized {__PACKAGE__ ne ref $_[0]}sub stable {die "The ->stable method has not yet been implemented"}sub _complete {my$self=shift;my$semi=$self->schild(-1);return!!(defined$semi and $semi->isa('PPI::Token::Structure')and $semi->content eq ';')}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_after($Element)}''}1;
PPI_STATEMENT

$fatpacked{"PPI/Statement/Break.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_BREAK';
  package PPI::Statement::Break;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}1;
PPI_STATEMENT_BREAK

$fatpacked{"PPI/Statement/Compound.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_COMPOUND';
  package PPI::Statement::Compound;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA %TYPES};BEGIN {$VERSION='0.01';@ISA='PPI::Statement';%TYPES=('if'=>'if','unless'=>'if','while'=>'while','until'=>'while','for'=>'for','foreach'=>'foreach',)}sub __LEXER__normal() {''}sub type {my$self=shift;my$p=0;my$Element=$self->schild($p)or return undef;if ($Element->isa('PPI::Token::Label')){$Element=$self->schild(++$p)or return 'label'}my$content=$Element->content;if ($content =~ /^for(?:each)?\z/){$Element=$self->schild(++$p)or return$content;if ($Element->isa('PPI::Token')){return 'foreach' if$Element->content =~ /^my|our|state\z/;return 'foreach' if$Element->isa('PPI::Token::Symbol');return 'foreach' if$Element->isa('PPI::Token::QuoteLike::Words')}if ($Element->isa('PPI::Structure::List')){return 'foreach'}return 'for'}return$TYPES{$content}if$Element->isa('PPI::Token::Word');return 'continue' if$Element->isa('PPI::Structure::Block');undef}sub scope() {1}sub _complete {my$self=shift;my$type=$self->type or die "Illegal compound statement type";if ($type eq 'if'){my$child=$self->schild(-1)or return '';$child->isa('PPI::Structure')or return '';$child->braces eq '{}' or return '';$child->_complete or return ''}elsif ($type eq 'while'){die "CODE INCOMPLETE"}else {die "CODE INCOMPLETE"}}1;
PPI_STATEMENT_COMPOUND

$fatpacked{"PPI/Statement/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_DATA';
  package PPI::Statement::Data;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub _complete () {''}1;
PPI_STATEMENT_DATA

$fatpacked{"PPI/Statement/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_END';
  package PPI::Statement::End;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub _complete () {1}1;
PPI_STATEMENT_END

$fatpacked{"PPI/Statement/Expression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_EXPRESSION';
  package PPI::Statement::Expression;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}1;
PPI_STATEMENT_EXPRESSION

$fatpacked{"PPI/Statement/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_GIVEN';
  package PPI::Statement::Given;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_GIVEN

$fatpacked{"PPI/Statement/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE';
  package PPI::Statement::Include;use strict;use PPI::Statement ();use PPI::Statement::Include::Perl6 ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub type {my$self=shift;my$keyword=$self->schild(0)or return undef;$keyword->isa('PPI::Token::Word')and $keyword->content}sub module {my$self=shift;my$module=$self->schild(1)or return undef;$module->isa('PPI::Token::Word')and $module->content}sub module_version {my$self=shift;my$argument=$self->schild(3);if ($argument and $argument->isa('PPI::Token::Operator')){return undef}my$version=$self->schild(2)or return undef;return undef unless$version->isa('PPI::Token::Number');return$version}sub pragma {my$self=shift;my$module=$self->module or return '';$module =~ /^[a-z][a-z\d]*$/ ? $module : ''}sub version {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->content : ''}sub version_literal {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->literal : ''}sub arguments {my$self=shift;my@args=$self->schildren;shift@args;if ($args[-1]->isa('PPI::Token::Structure')and $args[-1]->content eq ';'){pop@args}shift@args;return unless@args;if ($args[0]->isa('PPI::Token::Number')){my$after=$args[1]or return;$after->isa('PPI::Token::Operator')or shift@args}return@args}1;
PPI_STATEMENT_INCLUDE

$fatpacked{"PPI/Statement/Include/Perl6.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE_PERL6';
  package PPI::Statement::Include::Perl6;use strict;use PPI::Statement::Include ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement::Include'}sub perl6 {$_[0]->{perl6}}1;
PPI_STATEMENT_INCLUDE_PERL6

$fatpacked{"PPI/Statement/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_NULL';
  package PPI::Statement::Null;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub significant() {''}1;
PPI_STATEMENT_NULL

$fatpacked{"PPI/Statement/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_PACKAGE';
  package PPI::Statement::Package;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub namespace {my$self=shift;my$namespace=$self->schild(1)or return '';$namespace->isa('PPI::Token::Word')? $namespace->content : ''}sub file_scoped {my$self=shift;my ($Parent,$Document)=($self->parent,$self->top);$Parent and $Document and $Parent==$Document and $Document->isa('PPI::Document')and!$Document->isa('PPI::Document::Fragment')}1;
PPI_STATEMENT_PACKAGE

$fatpacked{"PPI/Statement/Scheduled.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SCHEDULED';
  package PPI::Statement::Scheduled;use strict;use PPI::Statement::Sub ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement::Sub'}sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub type {my$self=shift;my@children=$self->schildren or return undef;$children[0]->content eq 'sub' ? $children[1]->content : $children[0]->content}sub name {shift->type(@_)}1;
PPI_STATEMENT_SCHEDULED

$fatpacked{"PPI/Statement/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SUB';
  package PPI::Statement::Sub;use strict;use List::Util ();use Params::Util qw{_INSTANCE};use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub name {my ($self)=@_;my$token=$self->schild(1);return$token->content if defined$token and $token->isa('PPI::Token::Word');$token=$self->schild(0);return$token->content if defined$token and $token->isa('PPI::Token::Word');return ''}sub prototype {my$self=shift;my$Prototype=List::Util::first {_INSTANCE($_,'PPI::Token::Prototype')}$self->children;defined($Prototype)? $Prototype->prototype : undef}sub block {my$self=shift;my$lastchild=$self->schild(-1)or return '';$lastchild->isa('PPI::Structure::Block')and $lastchild}sub forward {!shift->block}sub reserved {my$self=shift;my$name=$self->name or return '';$name eq uc$name}1;
PPI_STATEMENT_SUB

$fatpacked{"PPI/Statement/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNKNOWN';
  package PPI::Statement::Unknown;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub _complete () {1}1;
PPI_STATEMENT_UNKNOWN

$fatpacked{"PPI/Statement/UnmatchedBrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNMATCHEDBRACE';
  package PPI::Statement::UnmatchedBrace;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub _complete () {1}1;
PPI_STATEMENT_UNMATCHEDBRACE

$fatpacked{"PPI/Statement/Variable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_VARIABLE';
  package PPI::Statement::Variable;use strict;use Params::Util qw{_INSTANCE};use PPI::Statement::Expression ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement::Expression'}sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|local|our|state)$/)? $schild[0]->content : undef}sub variables {map {$_->canonical}$_[0]->symbols}sub symbols {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');if (_INSTANCE($schild[1],'PPI::Token::Symbol')){return$schild[1]}if (_INSTANCE($schild[1],'PPI::Structure::List')){my$Expression=$schild[1]->schild(0);$Expression and $Expression->isa('PPI::Statement::Expression')or return ();if ($self->type eq 'my' or $self->type eq 'our' or $self->type eq 'state'){return grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}return grep {$self->_local_variable($_)}grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}()}sub _local_variable {my ($self,$el)=@_;my$n=$el->snext_sibling or return 1;my$p=$el->sprevious_sibling;if (!$p or $p eq ','){return 1 if$n eq ',';return 1 if$n eq '='}return ''}1;
PPI_STATEMENT_VARIABLE

$fatpacked{"PPI/Statement/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_WHEN';
  package PPI::Statement::When;use strict;use PPI::Statement ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Statement'}sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_WHEN

$fatpacked{"PPI/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE';
  package PPI::Structure;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use vars qw{$VERSION @ISA *_PARENT};BEGIN {$VERSION='0.01';@ISA='PPI::Node';*_PARENT=*PPI::Element::_PARENT}use PPI::Structure::Block ();use PPI::Structure::Condition ();use PPI::Structure::Constructor ();use PPI::Structure::For ();use PPI::Structure::Given ();use PPI::Structure::List ();use PPI::Structure::Subscript ();use PPI::Structure::Unknown ();use PPI::Structure::When ();sub new {my$class=shift;my$Token=PPI::Token::__LEXER__opens($_[0])? shift : return undef;my$self=bless {children=>[],start=>$Token,},$class;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$self);$self}sub start {$_[0]->{start}}sub finish {$_[0]->{finish}}sub braces {my$self=$_[0]->{start}? shift : return undef;return {'['=>'[]','('=>'()','{'=>'{}',}->{$self->{start}->{content}}}sub complete {!!($_[0]->{start}and $_[0]->{finish})}sub elements {my$self=shift;if (wantarray){return ($self->{start}|| (),@{$self->{children}},$self->{finish}|| ())}else {return scalar(@{$self->{children}})+ ($self->{start}? 1 : 0)+ ($self->{finish}? 1 : 0)}}sub first_element {$_[0]->{start}or $_[0]->{children}->[0]or $_[0]->{finish}}sub last_element {$_[0]->{finish}or $_[0]->{children}->[-1]or $_[0]->{start}}sub location {my$self=shift;my$first=$self->first_element or return undef;$first->location}sub tokens {my$self=shift;my@tokens=($self->{start}|| (),$self->SUPER::tokens(@_),$self->{finish}|| (),);@tokens}sub content {my$self=shift;my$content=$self->{start}? $self->{start}->content : '';for my$child (@{$self->{children}}){$content .= $child->content}$content .= $self->{finish}->content if$self->{finish};$content}sub _complete {!!(defined $_[0]->{finish})}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}1;
PPI_STRUCTURE

$fatpacked{"PPI/Structure/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_BLOCK';
  package PPI::Structure::Block;use strict;use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}sub scope() {1}1;
PPI_STRUCTURE_BLOCK

$fatpacked{"PPI/Structure/Condition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONDITION';
  package PPI::Structure::Condition;use strict;use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}1;
PPI_STRUCTURE_CONDITION

$fatpacked{"PPI/Structure/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONSTRUCTOR';
  package PPI::Structure::Constructor;use strict;use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}1;
PPI_STRUCTURE_CONSTRUCTOR

$fatpacked{"PPI/Structure/For.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_FOR';
  package PPI::Structure::For;use strict;use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){unless ($has_warned){warn("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_FOR

$fatpacked{"PPI/Structure/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_GIVEN';
  package PPI::Structure::Given;use strict;use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}1;
PPI_STRUCTURE_GIVEN

$fatpacked{"PPI/Structure/List.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_LIST';
  package PPI::Structure::List;use strict;use Carp ();use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){if ($_[0]->parent->isa('PPI::Statement::Compound')and $_[0]->parent->type =~ /^for/){unless ($has_warned){local$Carp::CarpLevel=$Carp::CarpLevel + 1;Carp::carp("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_LIST

$fatpacked{"PPI/Structure/Subscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_SUBSCRIPT';
  package PPI::Structure::Subscript;use strict;use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}1;
PPI_STRUCTURE_SUBSCRIPT

$fatpacked{"PPI/Structure/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_UNKNOWN';
  package PPI::Structure::Unknown;use strict;use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}1;
PPI_STRUCTURE_UNKNOWN

$fatpacked{"PPI/Structure/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_WHEN';
  package PPI::Structure::When;use strict;use PPI::Structure ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Structure'}1;
PPI_STRUCTURE_WHEN

$fatpacked{"PPI/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN';
  package PPI::Token;use strict;use Params::Util qw{_INSTANCE};use PPI::Element ();use PPI::Exception ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Element'}use PPI::Token::BOM ();use PPI::Token::Whitespace ();use PPI::Token::Comment ();use PPI::Token::Pod ();use PPI::Token::Number ();use PPI::Token::Number::Binary ();use PPI::Token::Number::Octal ();use PPI::Token::Number::Hex ();use PPI::Token::Number::Float ();use PPI::Token::Number::Exp ();use PPI::Token::Number::Version ();use PPI::Token::Word ();use PPI::Token::DashedWord ();use PPI::Token::Symbol ();use PPI::Token::ArrayIndex ();use PPI::Token::Magic ();use PPI::Token::Quote::Single ();use PPI::Token::Quote::Double ();use PPI::Token::Quote::Literal ();use PPI::Token::Quote::Interpolate ();use PPI::Token::QuoteLike::Backtick ();use PPI::Token::QuoteLike::Command ();use PPI::Token::QuoteLike::Regexp ();use PPI::Token::QuoteLike::Words ();use PPI::Token::QuoteLike::Readline ();use PPI::Token::Regexp::Match ();use PPI::Token::Regexp::Substitute ();use PPI::Token::Regexp::Transliterate ();use PPI::Token::Operator ();use PPI::Token::Cast ();use PPI::Token::Structure ();use PPI::Token::Label ();use PPI::Token::HereDoc ();use PPI::Token::Separator ();use PPI::Token::Data ();use PPI::Token::End ();use PPI::Token::Prototype ();use PPI::Token::Attribute ();use PPI::Token::Unknown ();sub new {bless {content=>(defined $_[1]? "$_[1]" : '')},$_[0]}sub set_class {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;my$old_quote=(ref($self)=~ /\b(?:Quote|Regex)\b/o)? 1 : 0;my$new_quote=($class =~ /\b(?:Quote|Regex)\b/o)? 1 : 0;bless$self,$class;return$class if ($old_quote - $new_quote)==0;my$token=$class->new($self->{content});%$self=%$token;return$class}sub set_content {$_[0]->{content}=$_[1]}sub add_content {$_[0]->{content}.= $_[1]}sub length {CORE::length($_[0]->{content})}sub content {$_[0]->{content}}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}sub __TOKENIZER__on_line_start() {1}sub __TOKENIZER__on_line_end() {1}sub __TOKENIZER__on_char() {'Unknown'}sub __LEXER__opens {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\(|\[|\{)/}sub __LEXER__closes {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\)|\]|\})/}1;
PPI_TOKEN

$fatpacked{"PPI/Token/ArrayIndex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ARRAYINDEX';
  package PPI::Token::ArrayIndex;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_ARRAYINDEX

$fatpacked{"PPI/Token/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ATTRIBUTE';
  package PPI::Token::Attribute;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub identifier {my$self=shift;$self->{content}=~ /^(.+?)\(/ ? $1 : $self->{content}}sub parameters {my$self=shift;$self->{content}=~ /\((.+)\)$/ ? $1 : undef}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);unless ($char eq '('){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$string=$class->__TOKENIZER__scan_for_end($t);if (ref$string){$t->{token}->{content}.= $$string;$t->_finalize_token;return 0}$t->{token}->{content}.= $string;$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__scan_for_end {my$t=$_[1];my$string='';my$depth=0;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /\G((?:\\.|[^()])*?[()])/gc){$string .= substr($t->{line},$t->{line_cursor});$t->_fill_line(1)or return \$string;$t->{line_cursor}=0;next}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /\($/)? 1 : -1 and next;return$string}\$string}1;
PPI_TOKEN_ATTRIBUTE

$fatpacked{"PPI/Token/BOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_BOM';
  package PPI::Token::BOM;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub significant() {''}my%bom_types=("\x00\x00\xfe\xff"=>'UTF-32',"\xff\xfe\x00\x00"=>'UTF-32',"\xfe\xff"=>'UTF-16',"\xff\xfe"=>'UTF-16',"\xef\xbb\xbf"=>'UTF-8',);sub __TOKENIZER__on_line_start {my$t=$_[1];$_=$t->{line};if (m/^(\x00\x00\xfe\xff |  # UTF-32, big-endian
  		\xff\xfe\x00\x00 |  # UTF-32, little-endian
  		\xfe\xff         |  # UTF-16, big-endian
  		\xff\xfe         |  # UTF-16, little-endian
  		\xef\xbb\xbf)       # UTF-8
  	    /xs){my$bom=$1;if ($bom_types{$bom}ne 'UTF-8'){return$t->_error("$bom_types{$bom} is not supported")}$t->_new_token('BOM',$bom)or return undef;$t->{line_cursor}+= length$bom}$t->{class}='PPI::Token::Whitespace';return$t->{class}->__TOKENIZER__on_line_start($t)}1;
PPI_TOKEN_BOM

$fatpacked{"PPI/Token/Cast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_CAST';
  package PPI::Token::Cast;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub __TOKENIZER__on_char {$_[1]->_finalize_token->__TOKENIZER__on_char($_[1])}1;
PPI_TOKEN_CAST

$fatpacked{"PPI/Token/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_COMMENT';
  package PPI::Token::Comment;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub significant() {''}sub __TOKENIZER__on_char {my$t=$_[1];if (substr($t->{line},$t->{line_cursor},1)eq "\n"){return$t->_finalize_token->__TOKENIZER__on_char($t)}1}sub __TOKENIZER__commit {my$t=$_[1];my$rest=substr($t->{line},$t->{line_cursor});if (chomp$rest){$t->_new_token('Comment',$rest);$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$rest)}$t->{line_cursor}=$t->{line_length}- 1;0}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token};1}sub line {$_[0]->{content}=~ /\n$/ ? 1 : 0}1;
PPI_TOKEN_COMMENT

$fatpacked{"PPI/Token/DashedWord.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DASHEDWORD';
  package PPI::Token::DashedWord;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}*literal=*PPI::Token::Word::literal;sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}if ($t->{token}->{content}=~ /^\-[rwxoRWXOezsfdlpSbctugkTBMAC]$/){$t->{class}=$t->{token}->set_class('Operator')}else {$t->{class}=$t->{token}->set_class('Word')}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_DASHEDWORD

$fatpacked{"PPI/Token/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DATA';
  package PPI::Token::Data;use strict;use IO::String ();use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub handle {my$self=shift;IO::String->new(\$self->{content})}sub __TOKENIZER__on_line_start {my ($self,$t)=@_;if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {defined($t->{token}=$t->{class}->new($t->{line}))or return undef}return 0}1;
PPI_TOKEN_DATA

$fatpacked{"PPI/Token/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_END';
  package PPI::Token::End;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub significant() {''}sub __TOKENIZER__on_char() {1}sub __TOKENIZER__on_line_start {my$t=$_[1];if ($t->{line}=~ /^=(\w+)/){$t->_new_token('Pod',$t->{line});unless ($1 eq 'cut'){$t->{class}='PPI::Token::Pod'}}else {if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {$t->_new_token('End',$t->{line})}}0}1;
PPI_TOKEN_END

$fatpacked{"PPI/Token/HereDoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_HEREDOC';
  package PPI::Token::HereDoc;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub heredoc {wantarray ? @{shift->{_heredoc}}: scalar @{shift->{_heredoc}}}sub terminator {shift->{_terminator}}sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}!~ m/\G( \s* (?: "[^"]*" | '[^']*' | `[^`]*` | \\?\w+ ) )/gcx){$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}my$token=$t->{token};$token->{content}.= $1;$t->{line_cursor}+= length $1;my$content=$token->{content};if ($content =~ /^\<\<(\w+)$/){$token->{_mode}='interpolate';$token->{_terminator}=$1}elsif ($content =~ /^\<\<\s*\'(.*)\'$/){$token->{_mode}='literal';$token->{_terminator}=$1;$token->{_terminator}=~ s/\\'/'/g}elsif ($content =~ /^\<\<\s*\"(.*)\"$/){$token->{_mode}='interpolate';$token->{_terminator}=$1;$token->{_terminator}=~ s/\\"/"/g}elsif ($content =~ /^\<\<\s*\`(.*)\`$/){$token->{_mode}='command';$token->{_terminator}=$1;$token->{_terminator}=~ s/\\`/`/g}elsif ($content =~ /^\<\<\\(\w+)$/){$token->{_mode}='literal';$token->{_terminator}=$1}else {return undef}my$line;$token->{_heredoc}=[];my$terminator=$token->{_terminator}."\n";while (defined($line=$t->_get_line)){if ($line eq $terminator){$token->{_terminator_line}=$line;return$t->_finalize_token->__TOKENIZER__on_char($t)}push @{$token->{_heredoc}},$line}if (defined$line and $line eq $token->{_terminator}){pop @{$token->{_heredoc}};$token->{_terminator_line}=$line}else {$token->{_terminator_line}=undef;if (defined$token->{_heredoc}->[-1]and $t->{source_eof_chop}){chop$token->{_heredoc}->[-1];$t->{source_eof_chop}=''}}$token->{_damaged}=1;$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_HEREDOC

$fatpacked{"PPI/Token/Label.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_LABEL';
  package PPI::Token::Label;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}1;
PPI_TOKEN_LABEL

$fatpacked{"PPI/Token/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_MAGIC';
  package PPI::Token::Magic;use strict;use PPI::Token::Symbol ();use PPI::Token::Unknown ();use vars qw{$VERSION @ISA %magic};BEGIN {$VERSION='0.01';@ISA='PPI::Token::Symbol';for (qw{$1 $2 $3 $4 $5 $6 $7 $8 $9 $_ $& $` $' $+ @+ %+ $* $. $/ $| $\\ $" $; $% $= $- @- %- $) $~ $^ $: $? $! %! $@ $$ $< $> $( $0 $[ $] @_ @* $^L $^A $^E $^C $^D $^F $^H $^I $^M $^N $^O $^P $^R $^S $^T $^V $^W $^X %^H $::|},'$}','$,','$#','$#+','$#-'){$magic{$_}=1}}sub __TOKENIZER__on_char {my$t=$_[1];my$c=$t->{token}->{content}.substr($t->{line},$t->{line_cursor},1);if ($c =~ /^  \$  .*  [  \w  :  \$  \{  ]  $/x){if ($c =~ /^(\$(?:\_[\w:]|::))/ or $c =~ /^\$\'[\w]/){if ($c =~ /^\$\'\d$/){return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Symbol');return PPI::Token::Symbol->__TOKENIZER__on_char($t)}if ($c =~ /^\$\$\w/){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Symbol','$')}if ($c eq '$${'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$PPI::Token::Unknown::CURLY_SYMBOL/gc){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Magic','$')}}if ($c eq '$#$' or $c eq '$#{'){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($c =~ /^(\$\#)\w/){$t->{token}=PPI::Token::ArrayIndex->new("$1");return PPI::Token::ArrayIndex->__TOKENIZER__on_char($t)}if ($c =~ /^\$\^\w+$/o){my$next=substr($t->{line},$t->{line_cursor}+1,1);if ($magic{$c}&& (!$next || $next !~ /\w/)){$t->{token}->{content}=$c;$t->{line_cursor}++}else {return 1}}if ($c =~ /^\$\#\{/){$t->{token}=PPI::Token::Cast->new('$#');$t->_finalize_token;return$t->_new_token('Structure','{')}}elsif ($c =~ /^%\^/){return 1 if$c eq '%^';if ($magic{$c}){$t->{token}->{content}=$c;$t->{line_cursor}++}else {chop$t->{token}->{content};bless$t->{token},$t->{class}='PPI::Token::Operator';$t->{line_cursor}--}}if ($magic{$c}){$t->{line_cursor}+= length($c)- length($t->{token}->{content});$t->{token}->{content}=$c}else {pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/($PPI::Token::Unknown::CURLY_SYMBOL)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}elsif ($c =~ /^\$\d+$/ and $t->{line}=~ /\G(\d+)/gc){$t->{token}{content}.= $1;$t->{line_cursor}+= length $1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub canonical {$_[0]->content}1;
PPI_TOKEN_MAGIC

$fatpacked{"PPI/Token/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER';
  package PPI::Token::Number;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub base() {10}sub literal {return 0 + $_[0]->_literal}sub _literal {my$self=shift;my$string=$self->content;$string =~ s/^\+//;$string =~ s/_//g;return$string}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';my$token=$t->{token};if ($token->{content}=~ /^-?0_*$/){if ($char eq 'x' || $char eq 'X'){$t->{class}=$t->{token}->set_class('Number::Hex');return 1}elsif ($char eq 'b' || $char eq 'B'){$t->{class}=$t->{token}->set_class('Number::Binary');return 1}elsif ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$token->{_error}="Illegal character in octal number '$char'"}$t->{class}=$t->{token}->set_class('Number::Octal');return 1}}return 1 if$char =~ /\d/o;if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char eq 'e' || $char eq 'E'){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER

$fatpacked{"PPI/Token/Number/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_BINARY';
  package PPI::Token::Number::Binary;use strict;use PPI::Token::Number ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token::Number'}sub base() {2}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^0[bB]//;my$val=0;for my$bit ($str =~ m/(.)/g){$val=$val * 2 + $bit}return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[\w\d]/){unless ($char eq '1' or $char eq '0'){$t->{token}->{_error}="Illegal character in binary number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_BINARY

$fatpacked{"PPI/Token/Number/Exp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_EXP';
  package PPI::Token::Number::Exp;use strict;use PPI::Token::Number::Float ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token::Number::Float'}sub literal {my$self=shift;return if$self->{_error};my ($mantissa,$exponent)=split m/e/i,$self->_literal;my$neg=$mantissa =~ s/^\-//;$mantissa =~ s/^\./0./;$exponent =~ s/^\+//;my$val=$mantissa * 10 ** $exponent;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($t->{token}->{content}=~ /e$/i){return 1 if$char eq '-' || $char eq '+';if ($t->{token}->{content}=~ s/\.(e)$//i){my$word=$1;$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$word);return$t->{class}->__TOKENIZER__on_char($t)}else {$t->{token}->{_error}="Illegal character in exponent '$char'"}}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_EXP

$fatpacked{"PPI/Token/Number/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_FLOAT';
  package PPI::Token::Number::Float;use strict;use PPI::Token::Number ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token::Number'}sub base() {10}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^\./0./;my$val=0+$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($char eq '.'){if ($t->{token}->{content}=~ /\.$/){chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','..');return 0}elsif ($t->{token}->{content}!~ /_/){$t->{class}=$t->{token}->set_class('Number::Version');return 1}}if ($char eq 'e' || $char eq 'E'){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_FLOAT

$fatpacked{"PPI/Token/Number/Hex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_HEX';
  package PPI::Token::Number::Hex;use strict;use PPI::Token::Number ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token::Number'}sub base() {16}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=hex lc($str);return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[\da-f]/i){return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_HEX

$fatpacked{"PPI/Token/Number/Octal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_OCTAL';
  package PPI::Token::Number::Octal;use strict;use PPI::Token::Number ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token::Number'}sub base() {8}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=oct$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$t->{token}->{_error}="Illegal character in octal number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_OCTAL

$fatpacked{"PPI/Token/Number/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_VERSION';
  package PPI::Token::Number::Version;use strict;use PPI::Token::Number ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token::Number'}sub base() {256}sub literal {my$self=shift;my$content=$self->{content};$content =~ s/^v//;return join '',map {chr $_}(split /\./,$content)}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char =~ /\d/o;if ($char eq '.'){if ($t->{token}->{content}=~ /\.$/){chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float');$t->_new_token('Operator','..');return 0}else {return 1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}!~ m/\G(v\d+(?:\.\d+)*)/gc){return PPI::Token::Word->__TOKENIZER__commit($t)}my$vstring=$1;$t->{line_cursor}+= length($vstring);$t->_new_token('Number::Version',$vstring);$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_VERSION

$fatpacked{"PPI/Token/Operator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_OPERATOR';
  package PPI::Token::Operator;use strict;use PPI::Token ();use vars qw{$VERSION @ISA %OPERATOR};BEGIN {$VERSION='0.01';@ISA='PPI::Token';%OPERATOR=map {$_=>1}(qw{-> ++ -- ** ! ~ + - =~ !~ * / % x . << >> < > <= >= lt gt le ge == != <=> eq ne cmp ~~ & | ^ && || // .. ... ? : = **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //= => <> and or xor not},',')}sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};return 1 if$OPERATOR{$content .$char };if ($content eq '.'){if ($char =~ /^[0-9]$/){$t->{class}=$t->{token}->set_class('Number::Float');return$t->{class}->__TOKENIZER__on_char($t)}}if ($content eq '<<'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(?: (?!\d)\w | \s*['"`] | \\\w ) /gcx){$t->{class}=$t->{token}->set_class('HereDoc');return$t->{class}->__TOKENIZER__on_char($t)}}if ($content eq '<>'){$t->{class}=$t->{token}->set_class('QuoteLike::Readline')}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_OPERATOR

$fatpacked{"PPI/Token/Pod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_POD';
  package PPI::Token::Pod;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub merge {my$class=(!ref $_[0])? shift : return undef;if (grep {!_INSTANCE($_,'PPI::Token::Pod')}@_){return undef}my@content=(map {[$_->lines ]}@_)or return undef;for my$pod (@content){if (@$pod and $pod->[0]=~ /^=pod\b/o){shift @$pod}if (@$pod and $pod->[-1]=~ /^=cut\b/o){pop @$pod}while (@$pod and $pod->[0]eq ''){shift @$pod}while (@$pod and $pod->[-1]eq ''){pop @$pod}}@content=(['=pod' ],grep {@$_}@content,['=cut' ]);$class->new(join "\n",map {join("\n",@$_)."\n"}@content)}sub lines {split /(?:\015{1,2}\012|\015|\012)/,$_[0]->{content}}sub significant() {''}sub __TOKENIZER__on_line_start {my$t=$_[1];$t->{token}->{content}.= $t->{line};if ($t->{line}=~ /^=(\w+)/){$t->_finalize_token if $1 eq 'cut'}0}1;
PPI_TOKEN_POD

$fatpacked{"PPI/Token/Prototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_PROTOTYPE';
  package PPI::Token::Prototype;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};die "regex should always match" if$t->{line}!~ m/\G(.*?(?:\)|$))/gc;$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1;return 0 unless $1 =~ /\)$/;$t->_finalize_token->__TOKENIZER__on_char($t)}sub prototype {my$self=shift;my$proto=$self->content;$proto =~ s/(^\(|\)$|\s+)//g;$proto}1;
PPI_TOKEN_PROTOTYPE

$fatpacked{"PPI/Token/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE';
  package PPI::Token::Quote;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}1;
PPI_TOKEN_QUOTE

$fatpacked{"PPI/Token/Quote/Double.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_DOUBLE';
  package PPI::Token::Quote::Double;use strict;use Params::Util qw{_INSTANCE};use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote}}sub interpolations {!!($_[0]->content =~ /(?<!\\)(?:\\\\)*[\$\@]/)}sub simplify {my$self=_INSTANCE(shift,'PPI::Token::Quote::Double')or return undef;my$content=$self->content;my$value=substr($content,1,length($content)- 2);return$self if$value =~ /[\\\$@\'\"]/;$self->{content}="'$value'";bless$self,'PPI::Token::Quote::Single'}sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}1;
PPI_TOKEN_QUOTE_DOUBLE

$fatpacked{"PPI/Token/Quote/Interpolate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_INTERPOLATE';
  package PPI::Token::Quote::Interpolate;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote}}sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}1;
PPI_TOKEN_QUOTE_INTERPOLATE

$fatpacked{"PPI/Token/Quote/Literal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_LITERAL';
  package PPI::Token::Quote::Literal;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote}}sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}*literal=*PPI::Token::Quote::Single::literal;1;
PPI_TOKEN_QUOTE_LITERAL

$fatpacked{"PPI/Token/Quote/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_SINGLE';
  package PPI::Token::Quote::Single;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote}}sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}my%UNESCAPE=("\\'"=>"'","\\\\"=>"\\",);sub literal {my$str=$_[0]->string;$str =~ s/(\\.)/$UNESCAPE{$1} || $1/ge;return$str}1;
PPI_TOKEN_QUOTE_SINGLE

$fatpacked{"PPI/Token/QuoteLike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE';
  package PPI::Token::QuoteLike;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}1;
PPI_TOKEN_QUOTELIKE

$fatpacked{"PPI/Token/QuoteLike/Backtick.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_BACKTICK';
  package PPI::Token::QuoteLike::Backtick;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Simple ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::QuoteLike}}1;
PPI_TOKEN_QUOTELIKE_BACKTICK

$fatpacked{"PPI/Token/QuoteLike/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_COMMAND';
  package PPI::Token::QuoteLike::Command;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike}}1;
PPI_TOKEN_QUOTELIKE_COMMAND

$fatpacked{"PPI/Token/QuoteLike/Readline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_READLINE';
  package PPI::Token::QuoteLike::Readline;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike}}1;
PPI_TOKEN_QUOTELIKE_READLINE

$fatpacked{"PPI/Token/QuoteLike/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_REGEXP';
  package PPI::Token::QuoteLike::Regexp;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike}}sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return undef}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_QUOTELIKE_REGEXP

$fatpacked{"PPI/Token/QuoteLike/Words.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_WORDS';
  package PPI::Token::QuoteLike::Words;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike}}sub literal {my$self=shift;my$section=$self->{sections}->[0];return split ' ',substr($self->{content},$section->{position},$section->{size},)}1;
PPI_TOKEN_QUOTELIKE_WORDS

$fatpacked{"PPI/Token/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP';
  package PPI::Token::Regexp;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return $_[0]->_section_content(1)}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_REGEXP

$fatpacked{"PPI/Token/Regexp/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_MATCH';
  package PPI::Token::Regexp::Match;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp}}1;
PPI_TOKEN_REGEXP_MATCH

$fatpacked{"PPI/Token/Regexp/Substitute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_SUBSTITUTE';
  package PPI::Token::Regexp::Substitute;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp}}1;
PPI_TOKEN_REGEXP_SUBSTITUTE

$fatpacked{"PPI/Token/Regexp/Transliterate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_TRANSLITERATE';
  package PPI::Token::Regexp::Transliterate;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp}}1;
PPI_TOKEN_REGEXP_TRANSLITERATE

$fatpacked{"PPI/Token/Separator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SEPARATOR';
  package PPI::Token::Separator;use strict;use PPI::Token::Word ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token::Word'}1;
PPI_TOKEN_SEPARATOR

$fatpacked{"PPI/Token/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_STRUCTURE';
  package PPI::Token::Structure;use strict;use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}use vars qw{@MATCH @OPENS @CLOSES};BEGIN {$MATCH[ord '{']='}';$MATCH[ord '}']='{';$MATCH[ord '[']=']';$MATCH[ord ']']='[';$MATCH[ord '(']=')';$MATCH[ord ')']='(';$OPENS[ord '{']=1;$OPENS[ord '[']=1;$OPENS[ord '(']=1;$CLOSES[ord '}']=1;$CLOSES[ord ']']=1;$CLOSES[ord ')']=1}sub __TOKENIZER__on_char {$_[1]->_finalize_token->__TOKENIZER__on_char($_[1])}sub __TOKENIZER__commit {my$t=$_[1];$t->_new_token('Structure',substr($t->{line},$t->{line_cursor},1));$t->_finalize_token;0}sub __LEXER__opposite {$MATCH[ord $_[0]->{content}]}sub next_sibling {return $_[0]->SUPER::next_sibling if $_[0]->{content}eq ';';return ''}sub snext_sibling {return $_[0]->SUPER::snext_sibling if $_[0]->{content}eq ';';return ''}sub previous_sibling {return $_[0]->SUPER::previous_sibling if $_[0]->{content}eq ';';return ''}sub sprevious_sibling {return $_[0]->SUPER::sprevious_sibling if $_[0]->{content}eq ';';return ''}sub next_token {my$self=shift;return$self->SUPER::next_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($OPENS[ord$self->{content}]){my$child=$structure->child(0);if ($child){return$child->isa('PPI::Token')? $child : $child->first_token}elsif ($structure->finish){return$structure->finish}}$structure->next_token}sub previous_token {my$self=shift;return$self->SUPER::previous_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($CLOSES[ord$self->{content}]){my$child=$structure->child(-1);if ($child){return$child->isa('PPI::Token')? $child : $child->last_token}elsif ($structure->start){return$structure->start}}$structure->previous_token}1;
PPI_TOKEN_STRUCTURE

$fatpacked{"PPI/Token/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SYMBOL';
  package PPI::Token::Symbol;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}sub canonical {my$symbol=shift->content;$symbol =~ s/\s+//;$symbol =~ s/(?<=[\$\@\%\&\*])::/main::/;$symbol =~ s/\'/::/g;$symbol}my%cast_which_trumps_braces=map {$_=>1}qw{$ @};sub symbol {my$self=shift;my$symbol=$self->canonical;my$type=substr($symbol,0,1);return$symbol if$type eq '%';return$symbol if$type eq '&';my$after=$self->snext_sibling;return$symbol unless _INSTANCE($after,'PPI::Structure');my$braces=$after->braces;return$symbol unless defined$braces;if ($type eq '$'){my$before=$self->sprevious_sibling;return$symbol if$before && $before->isa('PPI::Token::Cast')&& $cast_which_trumps_braces{$before->content };substr($symbol,0,1,'@')if$braces eq '[]';substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '@'){substr($symbol,0,1,'%')if$braces eq '{}'}$symbol}sub raw_type {substr($_[0]->content,0,1)}sub symbol_type {substr($_[0]->symbol,0,1)}sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:\']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}my$content=$t->{token}->{content};if ($content eq '@_' or $content eq '$_'){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content eq '$::'){my$nextchar=substr($t->{line},$t->{line_cursor},1);if ($nextchar eq '|'){$t->{token}->{content}.= $nextchar;$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Magic')}return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^[\$%*@&]::(?:[^\w]|$)/){my$current=substr($content,0,3,'');$t->{token}->{content}=$current;$t->{line_cursor}-= length($content);return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^(?:\$|\@)\d+/){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}$content =~ /^(
  		[\$@%&*]
  		(?: : (?!:) | # Allow single-colon non-magic vars
  			(?: \w+ | \' (?!\d) \w+ | \:: \w+ )
  			(?:
  				# Allow both :: and ' in namespace separators
  				(?: \' (?!\d) \w+ | \:: \w+ )
  			)*
  			(?: :: )? # Technically a compiler-magic hash, but keep it here
  		)
  	)/x or return undef;unless (length $1 eq length$content){$t->{line_cursor}+= length($1)- length($content);$t->{token}->{content}=$1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_SYMBOL

$fatpacked{"PPI/Token/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_UNKNOWN';
  package PPI::Token::Unknown;use strict;use PPI::Token ();use PPI::Exception ();use vars qw{$VERSION @ISA $CURLY_SYMBOL};BEGIN {$VERSION='0.01';@ISA='PPI::Token';$CURLY_SYMBOL=qr{\G\^[[:upper:]_]\w+\}}}sub __TOKENIZER__on_char {my$t=$_[1];my$c=$t->{token}->{content};my$char=substr($t->{line},$t->{line_cursor},1);if ($c eq '*'){if ($char =~ /(?:(?!\d)\w|\:)/){my$tokens=$t->_previous_significant_tokens(1);my$p0=$tokens->[0];if ($p0 and!$p0->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}else {$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}}if ($char eq '$'){my$_class;my$tokens=$t->_previous_significant_tokens(1);my$p0=$tokens->[0];if ($p0){if ($p0->isa('PPI::Token::Symbol')){$_class='Operator'}elsif ($p0->isa('PPI::Token::Number')){$_class='Operator'}elsif ($p0->isa('PPI::Token::Structure')and $p0->content =~ /^(?:\)|\])$/){$_class='Operator'}else {$_class='Cast'}}else {$_class='Cast'}$t->{class}=$t->{token}->set_class($_class);return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char eq '*' || $char eq '='){$t->{class}=$t->{token}->set_class('Operator');return 1}$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '$'){if ($char =~ /[a-z_]/i){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($PPI::Token::Magic::magic{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '@'){if ($char =~ /[\w:]/){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($PPI::Token::Magic::magic{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '%'){if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char eq '^' || $PPI::Token::Magic::magic{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char =~ /[\w:]/){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}if ($char =~ /[\$@%*{]/){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '&'){if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($char =~ /[\$@%{]/){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '-'){if ($char =~ /\d/o){$t->{class}=$t->{token}->set_class('Number');return 1}if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char =~ /[a-zA-Z]/){$t->{class}=$t->{token}->set_class('DashedWord');return 1}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq ':'){if ($char eq ':'){$t->{class}=$t->{token}->set_class('Word');return 1}if ($_[0]->__TOKENIZER__is_an_attribute($t)){$t->{class}=$t->{token}->set_class('Operator');$t->{token}->{_attribute}=1;return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}PPI::Exception->throw('Unknown value in PPI::Token::Unknown token')}sub __TOKENIZER__is_an_attribute {my$t=$_[1];my$tokens=$t->_previous_significant_tokens(3);my$p0=$tokens->[0];return 1 if$p0->isa('PPI::Token::Attribute');return 1 if$p0->isa('PPI::Token::Prototype');return '' unless$p0->isa('PPI::Token::Word');if ($p0->isa('PPI::Token::Word')and $p0->content eq 'sub'){return 1}my$p1=$tokens->[1];my$p2=$tokens->[2];if ($p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and ($p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq ''))){return 1}''}1;
PPI_TOKEN_UNKNOWN

$fatpacked{"PPI/Token/Whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WHITESPACE';
  package PPI::Token::Whitespace;use strict;use Clone ();use PPI::Token ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token'}my$null;sub null {$null ||= $_[0]->new('');Clone::clone($null)}sub significant() {''}sub tidy {$_[0]->{content}=~ s/^\s+?(?>\n)//;1}use vars qw{@CLASSMAP @COMMITMAP %MATCHWORD};BEGIN {@CLASSMAP=();@COMMITMAP=();for ('a' .. 'u','w','y','z','A' .. 'Z','_'){$COMMITMAP[ord $_]='PPI::Token::Word'}for (qw!; [ ] { } )!){$COMMITMAP[ord $_]='PPI::Token::Structure'}for (0 .. 9){$CLASSMAP[ord $_]='Number'}for (qw{= ? | + > . ! ~ ^}){$CLASSMAP[ord $_]='Operator'}for (qw{* $ @ & : %}){$CLASSMAP[ord $_]='Unknown'}$COMMITMAP[ord '#']='PPI::Token::Comment';$COMMITMAP[ord 'v']='PPI::Token::Number::Version';$CLASSMAP[ord ',']='PPI::Token::Operator';$CLASSMAP[ord "'"]='Quote::Single';$CLASSMAP[ord '"']='Quote::Double';$CLASSMAP[ord '`']='QuoteLike::Backtick';$CLASSMAP[ord '\\']='Cast';$CLASSMAP[ord '_']='Word';$CLASSMAP[9]='Whitespace';$CLASSMAP[10]='Whitespace';$CLASSMAP[12]='Whitespace';$CLASSMAP[13]='Whitespace';$CLASSMAP[32]='Whitespace';%MATCHWORD=map {$_=>1}qw{return split if unless grep map}}sub __TOKENIZER__on_line_start {my$t=$_[1];my$line=$t->{line};if ($line =~ /^\s*$/){$t->_new_token('Whitespace',$line);return 0}elsif ($line =~ /^\s*#/){$t->_new_token('Comment',$line);$t->_finalize_token;return 0}elsif ($line =~ /^=(\w+)/){$t->_new_token('Pod',$line);if ($1 eq 'cut'){}else {$t->{class}='PPI::Token::Pod'}return 0}elsif ($line =~ /^use v6\-alpha\;/){my@perl6;while (1){my$line6=$t->_get_line;last unless defined$line6;push@perl6,$line6}push @{$t->{perl6}},join '',@perl6;return 1}1}sub __TOKENIZER__on_char {my$t=$_[1];my$char=ord substr$t->{line},$t->{line_cursor},1;return$COMMITMAP[$char]->__TOKENIZER__commit($t)if$COMMITMAP[$char];return$CLASSMAP[$char]if$CLASSMAP[$char];if ($char==40){$t->_finalize_token if$t->{token};my$tokens=$t->_previous_significant_tokens(3);if ($tokens){my$p1=$tokens->[1];my$p2=$tokens->[2];if ($tokens->[0]->isa('PPI::Token::Word')and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and ($p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq ''))){return 'Prototype'}my$p0=$tokens->[0];if ($p0->isa('PPI::Token::Word')and $p0->content eq 'sub' and not ($p1 and $p1->isa('PPI::Token::Operator')and $p1->content eq '->')){return 'Prototype'}}return 'Structure'}elsif ($char==60){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Operator' if$prev->isa('PPI::Token::Symbol');return 'Operator' if$prev->isa('PPI::Token::Magic');return 'Operator' if$prev->isa('PPI::Token::Number');return 'Operator' if$prev->isa('PPI::Token::ArrayIndex');my$next_char=substr($t->{line},$t->{line_cursor}+ 1,1);if ($next_char eq '<'){return 'Operator'}my$prec=$prev->content;if ($prev->isa('PPI::Token::Structure')and $prec eq '('){return 'QuoteLike::Readline'}if ($prev->isa('PPI::Token::Word')and $prec eq 'while'){return 'QuoteLike::Readline'}if ($prev->isa('PPI::Token::Operator')and $prec eq '='){return 'QuoteLike::Readline'}if ($prev->isa('PPI::Token::Operator')and $prec eq ','){return 'QuoteLike::Readline'}if ($prev->isa('PPI::Token::Structure')and $prec eq '}'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G<(?!\d)\w+>/gc){return 'QuoteLike::Readline'}}return 'Operator'}elsif ($char==47){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;my$prec=$prev->content;return 'Regexp::Match' if$prev->isa('PPI::Token::Operator');return 'Operator' if$prev->isa('PPI::Token::Symbol');if ($prec eq ']' and $prev->isa('PPI::Token::Structure')){return 'Operator'}return 'Operator' if$prev->isa('PPI::Token::Number');if ($prev->isa('PPI::Token::Structure')and ($prec eq '(' or $prec eq '{' or $prec eq ';')){return 'Regexp::Match'}if ($MATCHWORD{$prec}and $prev->isa('PPI::Token::Word')){return 'Regexp::Match'}return 'Regexp::Match' if$prec eq '';my$next_char=substr$t->{line},$t->{line_cursor}+ 1,1;if (defined$next_char and length$next_char){if ($next_char =~ /(?:\^|\[|\\)/){return 'Regexp::Match'}}return 'Operator'}elsif ($char==120){pos$t->{line}=$t->{line_cursor}+ 1;return 'Operator' if$t->_current_x_is_operator and $t->{line}=~ m/\G(?:\d|(?!(=>|[\w\s])))/gc;return PPI::Token::Word->__TOKENIZER__commit($t)}elsif ($char==45){my$context=$t->_opcontext;if ($context eq 'operator'){return 'Operator'}else {return 'Unknown'}}elsif ($char >= 128){return 'PPI::Token::Word'->__TOKENIZER__commit($t)if$t =~ /\w/;return 'Whitespace' if$t =~ /\s/}PPI::Exception->throw("Encountered unexpected character '$char'")}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token}}1;
PPI_TOKEN_WHITESPACE

$fatpacked{"PPI/Token/Word.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WORD';
  package PPI::Token::Word;use strict;use PPI::Token ();use vars qw{$VERSION @ISA %OPERATOR %QUOTELIKE %KEYWORDS};BEGIN {$VERSION='0.01';@ISA='PPI::Token';*OPERATOR=*PPI::Token::Operator::OPERATOR;%QUOTELIKE=('q'=>'Quote::Literal','qq'=>'Quote::Interpolate','qx'=>'QuoteLike::Command','qw'=>'QuoteLike::Words','qr'=>'QuoteLike::Regexp','m'=>'Regexp::Match','s'=>'Regexp::Substitute','tr'=>'Regexp::Transliterate','y'=>'Regexp::Transliterate',);%KEYWORDS=map {$_=>1}qw{abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir cmp connect continue cos crypt dbmclose dbmopen default defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eq eval evalbytes exec exists exit exp fc fcntl fileno flock for foreach fork format formline ge getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst le length link listen local localtime lock log lstat lt m map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q qq qr quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir s say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x xor y}}sub literal {my$self=shift;my$word=$self->content;$word =~ s/\'/::/g;return$word}sub method_call {my$self=shift;my$previous=$self->sprevious_sibling;if ($previous and $previous->isa('PPI::Token::Operator')and $previous->content eq '->'){return 1}my$snext=$self->snext_sibling;return 0 unless$snext;if ($snext->isa('PPI::Structure::List')or $snext->isa('PPI::Token::Structure')or $snext->isa('PPI::Token::Operator')and ($snext->content eq ',' or $snext->content eq '=>')){return 0}if ($snext->isa('PPI::Token::Word')and $snext->content =~ m< \w :: \z >xms){return 1}return}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{token}->{content}.= $word;$t->{line_cursor}+= length$word}my$tokens=$t->_previous_significant_tokens(1);if ($tokens and $tokens->[0]->{_attribute}){$t->{class}=$t->{token}->set_class('Attribute');return$t->{class}->__TOKENIZER__commit($t)}my$word=$t->{token}->{content};if ($QUOTELIKE{$word}and!$class->__TOKENIZER__literal($t,$word,$tokens)){$t->{class}=$t->{token}->set_class($QUOTELIKE{$word});return$t->{class}->__TOKENIZER__on_char($t)}if ($OPERATOR{$word}and!$class->__TOKENIZER__literal($t,$word,$tokens)){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($word =~ /\:/){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$char=substr($t->{line},$t->{line_cursor},1);if ($char eq ':'){$t->{token}->{content}.= ':';$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Label')}elsif ($word eq '_'){$t->{class}=$t->{token}->set_class('Magic')}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my ($class,$t)=@_;pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ m/\G((?!\d)\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){die sprintf "Fatal error... regex failed to match in '%s' when expected",substr$t->{line},$t->{line_cursor}}my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{line_cursor}+= length$word;my$tokens=$t->_previous_significant_tokens(1);if ($tokens and $tokens->[0]->{_attribute}){$t->_new_token('Attribute',$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}if ($word eq '__END__'){$t->_new_token('Separator',$1);$t->_finalize_token;$t->{zone}='PPI::Token::End';my$end_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($end_rest =~ /\n$/){chomp$end_rest;$t->_new_token('Comment',$end_rest)if length$end_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$end_rest)if length$end_rest}$t->_finalize_token;return 0}if ($word eq '__DATA__'){$t->_new_token('Separator',"$1");$t->_finalize_token;$t->{zone}='PPI::Token::Data';my$data_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($data_rest =~ /\n$/){chomp$data_rest;$t->_new_token('Comment',$data_rest)if length$data_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$data_rest)if length$data_rest}$t->_finalize_token;return 0}my$token_class;if ($word =~ /\:/){$token_class='Word'}elsif ($class->__TOKENIZER__literal($t,$word,$tokens)){$token_class='Word'}elsif ($QUOTELIKE{$word}){$t->_new_token($QUOTELIKE{$word},$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}elsif ($OPERATOR{$word}&& ($word ne 'x' || $t->_current_x_is_operator)){$token_class='Operator'}else {pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\s*:)(?!:)/gc){if ($tokens and $tokens->[0]->{content}eq 'sub'){$token_class='Word'}else {$word .= $1;$t->{line_cursor}+= length($1);$token_class='Label'}}elsif ($word eq '_'){$token_class='Magic'}else {$token_class='Word'}}$t->_new_token($token_class,$word);if ($t->{line_cursor}>= $t->{line_length}){$t->_finalize_token;return 0}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__literal {my ($class,$t,$word,$tokens)=@_;unless ($QUOTELIKE{$word}or $PPI::Token::Operator::OPERATOR{$word}){return ''}pos$t->{line}=$t->{line_cursor};if ($tokens){my$token=$tokens->[0]or return '';return 1 if$token->{content}eq '->';return 1 if$token->isa('PPI::Token::Word')&& $token->{content}eq 'sub';if ($token->{content}eq '{' and $t->{line}=~ /\G\s*\}/gc){return 1}}if ($t->{line}=~ /\G\s*=>/gc){return 1}''}1;
PPI_TOKEN_WORD

$fatpacked{"PPI/Token/_QuoteEngine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE';
  package PPI::Token::_QuoteEngine;use strict;use Carp ();use vars qw{$VERSION};BEGIN {$VERSION='0.01'}sub __TOKENIZER__on_char {my$class=shift;my$t=$_[0]->{token}? shift : return undef;my$rv=$t->{token}->_fill($t);return undef unless defined$rv;$t->_finalize_token;0}sub _scan_for_unescaped_character {my$class=shift;my$t=shift;my$char=(length $_[0]==1)? quotemeta shift : return undef;my$search=qr/(.*?(?<!\\)(?:\\\\)*$char)/;my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G$search/gc){$t->{line_cursor}+= length($1)- 1;return$string .$1}$string .= substr$t->{line},$t->{line_cursor};my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}sub _scan_for_brace_character {my$class=shift;my$t=shift;my$close_brace=$_[0]=~ /^(?:\>|\)|\}|\])$/ ? shift : Carp::confess('');my$open_brace=$close_brace;$open_brace =~ tr/\>\)\}\]/\<\(\{\[/;$close_brace=quotemeta$close_brace;$open_brace=quotemeta$open_brace;my$search=qr/\G(.*?(?<!\\)(?:\\\\)*(?:$open_brace|$close_brace))/;my$string='';my$depth=1;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /$search/gc){$string .= substr($t->{line},$t->{line_cursor});my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0;next}if (defined$rv){return \$string}return undef}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /$open_brace$/)? 1 : -1 and next;$t->{line_cursor}-= 1;return$string}\$string}sub _scan_quote_like_operator_gap {my$t=$_[1];my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};$t->{line}=~ /\G(\s*(?:\#.*)?)/gc or return undef;$string .= $1;unless ($t->{line_cursor}+ length $1==length$t->{line}){$t->{line_cursor}+= length $1;return$string}my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}1;
PPI_TOKEN__QUOTEENGINE

$fatpacked{"PPI/Token/_QuoteEngine/Full.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_FULL';
  package PPI::Token::_QuoteEngine::Full;use strict;use Clone ();use Carp ();use PPI::Token::_QuoteEngine ();use vars qw{$VERSION @ISA %quotes %sections};BEGIN {$VERSION='0.01';@ISA='PPI::Token::_QuoteEngine';%sections=('('=>{type=>'()',_close=>')' },'<'=>{type=>'<>',_close=>'>' },'['=>{type=>'[]',_close=>']' },'{'=>{type=>'{}',_close=>'}' },);%quotes=('q'=>{operator=>'q',braced=>undef,separator=>undef,_sections=>1 },'qq'=>{operator=>'qq',braced=>undef,separator=>undef,_sections=>1 },'qx'=>{operator=>'qx',braced=>undef,separator=>undef,_sections=>1 },'qw'=>{operator=>'qw',braced=>undef,separator=>undef,_sections=>1 },'qr'=>{operator=>'qr',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'m'=>{operator=>'m',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'s'=>{operator=>'s',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'tr'=>{operator=>'tr',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'y'=>{operator=>'y',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'/'=>{operator=>undef,braced=>0,separator=>'/',_sections=>1,modifiers=>1 },'<'=>{operator=>undef,braced=>1,separator=>undef,_sections=>1,},'?'=>{operator=>undef,braced=>0,separator=>'?',_sections=>1,modifiers=>1 },)}sub new {my$class=shift;my$init=defined $_[0]? shift : Carp::croak("::Full->new called without init string");my$self=PPI::Token::new($class,$init)or return undef;my$options=$quotes{$init}or return$self->_error("Unknown quote type '$init'");for (keys %$options){$self->{$_}=$options->{$_}}$self->{modifiers}={}if$self->{modifiers};if ($init eq '<'){$self->{sections}->[0]=Clone::clone($sections{'<'})}$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or Carp::croak("::Full->_fill called without current token");if ($self->{operator}){if (substr($t->{line},$t->{line_cursor},1)=~ /\s/){my$gap=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap;if (ref$gap){$self->{content}.= $$gap;return 0}$self->{content}.= $gap}my$sep=substr($t->{line},$t->{line_cursor}++,1);$self->{content}.= $sep;if (my$section=$sections{$sep}){$self->{braced}=1;$self->{sections}->[0]=Clone::clone($section)}else {$self->{braced}=0;$self->{separator}=$sep}}my$rv=$self->{braced}? $self->_fill_braced($t): $self->_fill_normal($t);return$rv if!$rv;return 1 unless$self->{modifiers};my$char;my$len=0;while (($char=substr($t->{line},$t->{line_cursor}+ 1,1))=~ /[^\W\d_]/){$len++;$self->{content}.= $char;$self->{modifiers}->{lc$char}=1;$t->{line_cursor}++}}sub _fill_normal {my$self=shift;my$t=shift;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$string;return 0}$self->{sections}->[0]={position=>length$self->{content},size=>length($string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{content}.= $string;return 1 if$self->{_sections}==1;$t->{line_cursor}++;$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1 };$self->{content}.= $string;1}sub _fill_braced {my$self=shift;my$t=shift;my$section=$self->{sections}->[0];my$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$brace_str;return 0}$section->{position}=length$self->{content};$section->{size}=length($brace_str)- 1;$self->{content}.= $brace_str;delete$section->{_close};return 1 if$self->{_sections}==1;my$char=substr($t->{line},++$t->{line_cursor},1);if ($char =~ /\s/){my$gap_str=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap_str;if (ref$gap_str){$self->{content}.= $$gap_str;return 0}$self->{content}.= $gap_str;$char=substr($t->{line},$t->{line_cursor},1)}$section=$sections{$char};if ($section){$self->{content}.= $char;$section={%$section };$t->{line_cursor}++;$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=2}else {$self->{_sections}=1}$self->{content}.= $$brace_str;return 0}else {$self->{sections}->[1]={position=>length($self->{content}),size=>length($brace_str)- 1,type=>$section->{type},};$self->{content}.= $brace_str}}elsif ($char =~ m/ \A [^\w\s] \z /smx){$self->{content}.= $char;$t->{line_cursor}++;my$string=$self->_scan_for_unescaped_character($t,$char);return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$char$char",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1,type=>"$char$char",};$self->{content}.= $string}else {$self->{sections}->[1]={position=>length($self->{content}),size=>0,type=>'',};$self->{_error}="No second section of regexp, or does not start with a balanced character";$t->{line_cursor}--;return 0}1}sub _sections {wantarray ? @{$_[0]->{sections}}: scalar @{$_[0]->{sections}}}sub _section_content {my$self=shift;my$i=shift;$self->{sections}or return;my$section=$self->{sections}->[$i]or return;return substr($self->content,$section->{position},$section->{size})}sub _modifiers {my$self=shift;$self->{modifiers}or return;wantarray and return %{$self->{modifiers}};return +{%{$self->{modifiers}}}}sub _delimiters {my$self=shift;$self->{sections}or return;my@delims;for my$sect (@{$self->{sections}}){if (exists$sect->{type}){push@delims,$sect->{type}}else {my$content=$self->content;push@delims,substr($content,$sect->{position}- 1,1).substr($content,$sect->{position}+ $sect->{size},1)}}return@delims}1;
PPI_TOKEN__QUOTEENGINE_FULL

$fatpacked{"PPI/Token/_QuoteEngine/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_SIMPLE';
  package PPI::Token::_QuoteEngine::Simple;use strict;use PPI::Token::_QuoteEngine ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.01';@ISA='PPI::Token::_QuoteEngine'}sub new {my$class=shift;my$separator=shift or return undef;my$self=PPI::Token::new($class,$separator)or return undef;$self->{separator}=$separator;$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or return undef;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){$self->{content}.= $$string;return 0}else {$self->{content}.= $string;return$self}}1;
PPI_TOKEN__QUOTEENGINE_SIMPLE

$fatpacked{"PPI/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKENIZER';
  package PPI::Tokenizer;use strict;use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};use List::MoreUtils ();use PPI::Util ();use PPI::Element ();use PPI::Token ();use PPI::Exception ();use PPI::Exception::ParserRejection ();use vars qw{$VERSION};BEGIN {$VERSION='0.01'}my%X_CAN_FOLLOW_OPERATOR=map {$_=>1}qw(-- ++);my%X_CAN_FOLLOW_STRUCTURE=map {$_=>1}qw(} ] \));sub new {my$class=ref($_[0])|| $_[0];my$self=bless {source=>undef,source_bytes=>undef,line=>undef,line_length=>undef,line_cursor=>undef,line_count=>0,token=>undef,class=>'PPI::Token::BOM',zone=>'PPI::Token::Whitespace',tokens=>[],token_cursor=>0,token_eof=>0,perl6=>[],},$class;if (!defined $_[1]){PPI::Exception->throw("No source provided to Tokenizer")}elsif (!ref $_[1]){my$source=PPI::Util::_slurp($_[1]);if (ref$source){$self->{source}=$$source}else {return($source)}}elsif (_SCALAR0($_[1])){$self->{source}=${$_[1]}}elsif (_ARRAY0($_[1])){$self->{source}=join '',map {"\n"}@{$_[1]}}else {PPI::Exception->throw(ref($_[1])." is not supported as a source provider")}$self->{source_bytes}=length$self->{source};if ($self->{source_bytes}){$self->{source}=~ s/(?:\015{1,2}\012|\015|\012)/\n/g;$self->{source}=[split /(?<=\n)/,$self->{source}]}else {$self->{source}=[]}if (List::MoreUtils::any {/^__(?:DATA|END)__\s*$/}@{$self->{source}}){$self->{source_eof_chop}=''}elsif (!defined$self->{source}->[0]){$self->{source_eof_chop}=''}elsif ($self->{source}->[-1]=~ /\s$/){$self->{source_eof_chop}=''}else {$self->{source_eof_chop}=1;$self->{source}->[-1].= ' '}$self}sub get_token {my$self=shift;if ($self->{token_eof}and $self->{token_cursor}> scalar @{$self->{tokens}}){return 0}if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}my$line_rv;my$rv=eval {while ($line_rv=$self->_process_next_line){if (defined(my$token=$self->{tokens}->[$self->{token_cursor}])){$self->{token_cursor}++;return$token}}return undef};if ($@){if (_INSTANCE($@,'PPI::Exception')){$@->throw}else {my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}}elsif ($rv){return$rv}if (defined$line_rv){if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}$self->{token_eof}=1;return 0}undef}sub all_tokens {my$self=shift;my$ok=eval {unless ($self->{token_eof}){my$rv;while ($rv=$self->_process_next_line){}unless (defined$rv){PPI::Exception->throw("Error while processing source")}$self->_clean_eof}1};if (!$ok){my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}return [@{$self->{tokens}}]}sub increment_cursor {$_[0]->get_token and 1}sub decrement_cursor {my$self=shift;return 0 unless$self->{token_cursor};$self->{token_eof}=0;--$self->{token_cursor}}sub _get_line {my$self=shift;return undef unless$self->{source};my$line=shift @{$self->{source}};$self->{source}=undef unless defined$line;return$line}sub _fill_line {my$self=shift;my$inscan=shift;my$line=$self->_get_line;unless (defined$line){unless ($inscan){delete$self->{line};delete$self->{line_cursor};delete$self->{line_length};return 0}$self->{line_cursor}=$self->{line_length};return 0}$self->{line}=$line;$self->{line_cursor}=-1;$self->{line_length}=length$line;$self->{line_count}++;1}sub _char {my$self=shift;substr($self->{line},$self->{line_cursor},1)}sub _process_next_line {my$self=shift;my$rv;unless ($rv=$self->_fill_line){return undef unless defined$rv;$self->_finalize_token;return 0}$rv=$self->{class}->__TOKENIZER__on_line_start($self);unless ($rv){if (ref$self->{source}eq 'ARRAY' and!@{$self->{source}}){$self->_clean_eof}return 1 if defined$rv;PPI::Exception->throw("Error at line $self->{line_count}")}while ($rv=$self->_process_next_char){}unless (defined$rv){PPI::Exception->throw("Error at line $self->{line_count}, character $self->{line_cursor}")}$self->{class}->__TOKENIZER__on_line_end($self);unless (ref($self->{source})eq 'ARRAY' and @{$self->{source}}){return$self->_clean_eof}return 1}sub _process_next_char {my$self=shift;if (!defined$self->{line_cursor}or!defined$self->{line_length}){return undef}return 0 if ++$self->{line_cursor}>= $self->{line_length};my$result;unless ($result=$self->{class}->__TOKENIZER__on_char($self)){return defined$result ? 1 : undef}my$char=substr($self->{line},$self->{line_cursor},1);if ($result eq '1'){if (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}return 1}if ($self->{class}ne "PPI::Token::$result"){$self->_new_token($result,$char)}elsif (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}1}sub _finalize_token {my$self=shift;return$self->{class}unless defined$self->{token};push @{$self->{tokens}},$self->{token};$self->{token}=undef;$self->{class}=$self->{zone}}sub _new_token {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;$self->_finalize_token if defined$self->{token};defined($self->{token}=$class->new($_[0]))or PPI::Exception->throw;$self->{class}=$class;1}sub _clean_eof {my$self=shift;$self->_finalize_token if$self->{token};my$last_token=$self->{tokens}->[-1 ];unless (length$last_token->{content}){pop @{$self->{tokens}}}if ($self->{source_eof_chop}){$last_token=$self->{tokens}->[-1 ];$last_token->{content}=~ s/ $//;unless (length$last_token->{content}){pop @{$self->{tokens}}}$self->{source_eof_chop}=''}1}sub _last_token {$_[0]->{tokens}->[-1]}sub _last_significant_token {my$self=shift;my$cursor=$#{$self->{tokens}};while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];return$token if$token->significant}PPI::Token::Whitespace->null}sub _previous_significant_tokens {my$self=shift;my$count=shift || 1;my$cursor=$#{$self->{tokens}};my ($token,@tokens);while ($cursor >= 0){$token=$self->{tokens}->[$cursor--];if ($token->significant){push@tokens,$token;return \@tokens if scalar@tokens >= $count}}for (1 .. ($count - scalar@tokens)){push@tokens,PPI::Token::Whitespace->null}\@tokens}my%OBVIOUS_CLASS=('PPI::Token::Symbol'=>'operator','PPI::Token::Magic'=>'operator','PPI::Token::Number'=>'operator','PPI::Token::ArrayIndex'=>'operator','PPI::Token::Quote::Double'=>'operator','PPI::Token::Quote::Interpolate'=>'operator','PPI::Token::Quote::Literal'=>'operator','PPI::Token::Quote::Single'=>'operator','PPI::Token::QuoteLike::Backtick'=>'operator','PPI::Token::QuoteLike::Command'=>'operator','PPI::Token::QuoteLike::Readline'=>'operator','PPI::Token::QuoteLike::Regexp'=>'operator','PPI::Token::QuoteLike::Words'=>'operator',);my%OBVIOUS_CONTENT=('('=>'operand','{'=>'operand','['=>'operand',';'=>'operand','}'=>'operator',);sub _opcontext {my$self=shift;my$tokens=$self->_previous_significant_tokens(1);my$p0=$tokens->[0];my$c0=ref$p0;return$OBVIOUS_CLASS{$c0}if defined$OBVIOUS_CLASS{$c0};return$OBVIOUS_CONTENT{$p0}if defined$OBVIOUS_CONTENT{$p0};return 'operand' if$p0->isa('PPI::Token::Operator');return 'operand' if$p0->content eq '';return ''}sub _current_x_is_operator {my$self=shift;my$prev=$self->_last_significant_token;return $prev && (!$prev->isa('PPI::Token::Operator')|| $X_CAN_FOLLOW_OPERATOR{$prev})&& (!$prev->isa('PPI::Token::Structure')|| $X_CAN_FOLLOW_STRUCTURE{$prev})}1;
PPI_TOKENIZER

$fatpacked{"PPI/Transform.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM';
  package PPI::Transform;use strict;use Carp ();use List::Util ();use PPI::Document ();use Params::Util qw{_INSTANCE _CLASS _CODE _SCALAR0};use vars qw{$VERSION};BEGIN {$VERSION='0.01'}my%HANDLER;my@ORDER;sub register_apply_handler {my$class=shift;my$handler=_CLASS(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$get=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$set=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");if ($HANDLER{$handler}){Carp::croak("PPI::Transform->apply handler '$handler' already exists")}$HANDLER{$handler}=[$get,$set ];unshift@ORDER,$handler}__PACKAGE__->register_apply_handler('SCALAR',\&_SCALAR_get,\&_SCALAR_set);__PACKAGE__->register_apply_handler('PPI::Document',sub {$_[0]},sub() {1});sub new {my$class=shift;bless {@_ },$class}sub document {my$class=shift;die "$class does not implement the required ->document method"}sub apply {my$self=_SELF(shift);my$it=defined $_[0]? shift : return undef;my$class=_SCALAR0($it)? 'SCALAR' : List::Util::first {_INSTANCE($it,$_)}@ORDER or return undef;my$handler=$HANDLER{$class}or die("->apply handler for $class missing! Panic");my$Document=_INSTANCE($handler->[0]->($it),'PPI::Document')or Carp::croak("->apply handler for $class failed to get a PPI::Document");$self->document($Document)or return undef;$handler->[1]->($it,$Document)or Carp::croak("->apply handler for $class failed to save the changed document");1}sub file {my$self=_SELF(shift);my$input=defined $_[0]? shift : return undef;my$output=@_ ? defined $_[0]? "$_[0]" : undef : $input or return undef;my$Document=PPI::Document->new("$input")or return undef;$self->document($Document)or return undef;$Document->save($output)}sub _SCALAR_get {PPI::Document->new($_[0])}sub _SCALAR_set {my$it=shift;$$it=$_[0]->serialize;1}sub _SELF {return shift if ref $_[0];my$self=$_[0]->new or Carp::croak("Failed to auto-instantiate new $_[0] object");$self}1;
PPI_TRANSFORM

$fatpacked{"PPI/Transform/UpdateCopyright.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM_UPDATECOPYRIGHT';
  package PPI::Transform::UpdateCopyright;use strict;use Params::Util qw{_STRING};use PPI::Transform ();use vars qw{$VERSION};BEGIN {$VERSION='0.01'}sub new {my$self=shift->SUPER::new(@_);unless (defined _STRING($self->name)){PPI::Exception->throw("Did not provide a valid name param")}return$self}sub name {$_[0]->{name}}sub document {my$self=shift;my$document=_INSTANCE(shift,'PPI::Document')or return undef;my$name=quotemeta$self->name;my$regexp=qr/\bcopyright\b.*$name/m;my$elements=$document->find(sub {$_[1]->isa('PPI::Token::Pod')or return '';$_[1]->content =~ $regexp or return '';return 1});return undef unless defined$elements;return 0 unless$elements;my$changes=0;my$change=sub {my$copyright=shift;my$thisyear=(localtime time)[5]+ 1900;my@year=$copyright =~ m/(\d{4})/g;if (@year==1){if ($year[0]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/(\d{4})/$1 - $thisyear/;return$copyright}}if (@year==2){if ($year[1]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/$year[1]/$thisyear/;return$copyright}}die "Invalid or unknown copyright line '$copyright'"};my$pattern=qr/\b(copyright.*\d)({4}(?:\s*-\s*\d{4})?)(.*$name)/mi;for my$element (@$elements){$element =~ s/$pattern/$1 . $change->($2) . $2/eg}return$changes}1;
PPI_TRANSFORM_UPDATECOPYRIGHT

$fatpacked{"PPI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_UTIL';
  package PPI::Util;use strict;use Exporter ();use Digest::MD5 ();use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};use vars qw{$VERSION @ISA @EXPORT_OK};BEGIN {$VERSION='0.01';@ISA='Exporter';@EXPORT_OK=qw{_Document _slurp}}use constant HAVE_ALARM=>!($^O eq 'MSWin32' or $^O eq 'cygwin');use constant HAVE_UNICODE=>!!($] >= 5.008007);sub TRUE () {1}sub FALSE () {''}sub _Document {shift if @_ > 1;return undef unless defined $_[0];require PPI::Document;return PPI::Document->new(shift)unless ref $_[0];return PPI::Document->new(shift)if _SCALAR0($_[0]);return PPI::Document->new(shift)if _ARRAY0($_[0]);return shift if _INSTANCE($_[0],'PPI::Document');return undef}sub _slurp {my$file=shift;local $/=undef;local*FILE;open(FILE,'<',$file)or return "open($file) failed: $!";my$source=<FILE>;close(FILE)or return "close($file) failed: $!";return \$source}sub md5hex {my$string=shift;$string =~ s/(?:\015{1,2}\012|\015|\012)/\015/gs;Digest::MD5::md5_hex($string)}sub md5hex_file {my$file=shift;my$content=_slurp($file);return undef unless ref$content;$$content =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;md5hex($$content)}1;
PPI_UTIL

$fatpacked{"PPI/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_XSACCESSOR';
  package PPI::XSAccessor;use 5.006;use strict;use PPI ();use vars qw{$VERSION};BEGIN {$VERSION='0.01'}package PPI::Document;use Class::XSAccessor replace=>1,getters=>{readonly=>'readonly',},true=>['scope' ];package PPI::Document::File;use Class::XSAccessor replace=>1,getters=>{filename=>'filename',};package PPI::Document::Fragment;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Document::Normalized;use Class::XSAccessor replace=>1,getters=>{'_Document'=>'Document','version'=>'version','functions'=>'functions',};package PPI::Element;use Class::XSAccessor replace=>1,true=>['significant',];package PPI::Exception;use Class::XSAccessor replace=>1,getters=>{message=>'message',};package PPI::Node;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Normal;use Class::XSAccessor replace=>1,getters=>{'layer'=>'layer',};package PPI::Statement;use Class::XSAccessor replace=>1,true=>['__LEXER__normal',];package PPI::Statement::Compound;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Statement::Data;use Class::XSAccessor replace=>1,false=>['_complete',];package PPI::Statement::End;use Class::XSAccessor replace=>1,true=>['_complete',];package PPI::Statement::Given;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Token;use Class::XSAccessor replace=>1,getters=>{content=>'content',},setters=>{set_content=>'content',},true=>['__TOKENIZER__on_line_start','__TOKENIZER__on_line_end',];1;
PPI_XSACCESSOR

$fatpacked{"PPIx/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP';
  package PPIx::Regexp;use strict;use warnings;use base qw{PPIx::Regexp::Node};use PPIx::Regexp::Lexer ();use PPIx::Regexp::StringTokenizer;use PPIx::Regexp::Token::Modifier ();use PPIx::Regexp::Tokenizer;use PPIx::Regexp::Util qw{__choose_tokenizer_class __instance};use Scalar::Util qw{refaddr};our$VERSION='0.01';{my$errstr;sub new {my ($class,$content,%args)=@_;ref$class and $class=ref$class;$errstr=undef;my$tokenizer_class=__choose_tokenizer_class($content,\%args)or do {$errstr=ref$content ? sprintf '%s not supported',ref$content : "Unknown parse type '$args{parse}'";return};my$tokenizer=$tokenizer_class->new($content,%args)or do {$errstr=PPIx::Regexp::Tokenizer->errstr();return};my$lexer=PPIx::Regexp::Lexer->new($tokenizer,%args);my@nodes=$lexer->lex();my$self=$class->SUPER::__new(@nodes);$self->{source}=$content;$self->{failures}=$lexer->failures();$self->{effective_modifiers}=$tokenizer->__effective_modifiers();return$self}sub errstr {return$errstr}}{my%cache;our$DISABLE_CACHE;sub __cache_size {return scalar keys%cache}sub new_from_cache {my ($class,$content,%args)=@_;__instance($content,'PPI::Element')or return$class->new($content,%args);$DISABLE_CACHE and return$class->new($content,%args);my$addr=refaddr($content);exists$cache{$addr}and return$cache{$addr};my$self=$class->new($content,%args)or return;$cache{$addr}=$self;return$self}sub flush_cache {my@args=@_;ref$args[0]or shift@args;if (@args){for my$obj (@args){if (__instance($obj,__PACKAGE__)&& __instance((my$parent=$obj->source()),'PPI::Element')){delete$cache{refaddr($parent)}}}}else {%cache=()}return}}sub can_be_quantified {return}sub capture_names {my ($self)=@_;my$re=$self->regular_expression()or return;return$re->capture_names()}sub delimiters {my ($self,$inx)=@_;my@rslt;for my$method (qw{regular_expression replacement}){defined (my$obj=$self->$method())or next;push@rslt,$obj->delimiters()}defined$inx and return$rslt[$inx];wantarray and return@rslt;defined wantarray and return$rslt[0];return}sub explain {return}sub failures {my ($self)=@_;return$self->{failures}}sub max_capture_number {my ($self)=@_;my$re=$self->regular_expression()or return;return$re->max_capture_number()}sub modifier {my ($self)=@_;return$self->_component('PPIx::Regexp::Token::Modifier')}sub modifier_asserted {my ($self,$modifier)=@_;return PPIx::Regexp::Token::Modifier::__asserts($self->{effective_modifiers},$modifier,)}*__ducktype_modifier_asserted=\&modifier_asserted;sub perl_version_removed {my ($self)=@_;my$v=$self->SUPER::perl_version_removed();defined$v and $v <= 5.021001 and return$v;defined(my$delim=$self->delimiters())or return$v;'??' eq $delim and '' eq $self->type()->content()and return '5.021001';return$v}sub regular_expression {my ($self)=@_;return$self->_component('PPIx::Regexp::Structure::Regexp')}sub replacement {my ($self)=@_;return$self->_component('PPIx::Regexp::Structure::Replacement')}sub source {my ($self)=@_;return$self->{source}}sub type {my ($self)=@_;return$self->_component('PPIx::Regexp::Token::Structure')}sub _component {my ($self,$class)=@_;for my$elem ($self->children()){$elem->isa($class)and return$elem}return}1;
PPIX_REGEXP

$fatpacked{"PPIx/Regexp/Constant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_CONSTANT';
  package PPIx::Regexp::Constant;use strict;use warnings;our$VERSION='0.01';use base qw{Exporter};our@EXPORT_OK=qw{COOKIE_CLASS COOKIE_QUANT COOKIE_QUOTE COOKIE_REGEX_SET LITERAL_LEFT_CURLY_ALLOWED LITERAL_LEFT_CURLY_REMOVED_PHASE_1 LITERAL_LEFT_CURLY_REMOVED_PHASE_2 MINIMUM_PERL MODIFIER_GROUP_MATCH_SEMANTICS MSG_PROHIBITED_BY_STRICT NODE_UNKNOWN RE_CAPTURE_NAME STRUCTURE_UNKNOWN TOKEN_LITERAL TOKEN_UNKNOWN};use constant COOKIE_CLASS=>']';use constant COOKIE_QUANT=>'}';use constant COOKIE_QUOTE=>'\\E';use constant COOKIE_REGEX_SET=>'])';use constant LITERAL_LEFT_CURLY_ALLOWED=>undef;use constant LITERAL_LEFT_CURLY_REMOVED_PHASE_1=>'5.025001';use constant LITERAL_LEFT_CURLY_REMOVED_PHASE_2=>undef;use constant MINIMUM_PERL=>'5.000';use constant MODIFIER_GROUP_MATCH_SEMANTICS=>'match_semantics';use constant MSG_PROHIBITED_BY_STRICT=>q<prohibited by "use re 'strict'">;use constant NODE_UNKNOWN=>'PPIx::Regexp::Node::Unknown';use constant RE_CAPTURE_NAME=>' [_[:alpha:]] \w* ';use constant STRUCTURE_UNKNOWN=>'PPIx::Regexp::Structure::Unknown';use constant TOKEN_LITERAL=>'PPIx::Regexp::Token::Literal';use constant TOKEN_UNKNOWN=>'PPIx::Regexp::Token::Unknown';1;
PPIX_REGEXP_CONSTANT

$fatpacked{"PPIx/Regexp/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_DUMPER';
  package PPIx::Regexp::Dumper;use strict;use warnings;use base qw{PPIx::Regexp::Support};use Carp;use Scalar::Util qw{blessed looks_like_number};use PPIx::Regexp;use PPIx::Regexp::Tokenizer;use PPIx::Regexp::Util qw{__choose_tokenizer_class __instance};our$VERSION='0.01';{my%default=(explain=>0,indent=>2,margin=>0,ordinal=>0,perl_version=>0,significant=>0,test=>0,tokens=>0,verbose=>0,);sub new {my ($class,$re,%args)=@_;ref$class and $class=ref$class;my$self={encoding=>$args{encoding},lister=>undef,object=>undef,source=>$re,strict=>$args{strict},};for my$key (qw{default_modifiers parse postderef}){exists$args{$key}and $self->{$key}=$args{$key}}for my$key (keys%default){$self->{$key}=exists$args{$key}? delete$args{$key}: $default{$key}}$self->{ordinal}||= $self->{verbose};if (__instance($re,'PPIx::Regexp::Tokenizer')){$self->{object}=$re;$self->{tokens}=1}elsif (__instance($re,'PPIx::Regexp::Element')){$self->{object}=$re}elsif (ref$re eq 'ARRAY'){$self->{object}=$re}elsif (ref$re &&!__instance($re,'PPI::Element')){croak "Do not know how to dump ",ref$re}elsif ($self->{tokens}){my$tokenizer_class=__choose_tokenizer_class($re,\%args)or croak 'Unsupported data type';$self->{object}=$tokenizer_class->new($re,%args)or Carp::croak($tokenizer_class->errstr())}else {$self->{object}=PPIx::Regexp->new($re,%args)or Carp::croak(PPIx::Regexp->errstr())}bless$self,$class;return$self}}sub list {my ($self)=@_;my$lister=$self->{test}? '__PPIX_DUMPER__test' : '__PPIX_DUMPER__dump';ref$self->{object}eq 'ARRAY' and return (map {$_->$lister($self)}@{$self->{object}});return$self->{object}->$lister($self)}sub print : method {my ($self)=@_;print$self->string();return}sub string {my ($self)=@_;my$margin=' ' x $self->{margin};return join('',map {$margin .$_ ."\n"}$self->list())}sub _safe {my ($self,@args)=@_;my@rslt;for my$item (@args){if (blessed($item)){$item=$self->encode($item->content())}if (!defined$item){push@rslt,'undef'}elsif (ref$item eq 'ARRAY'){push@rslt,join(' ','[',$self->_safe(@{$item}),']')}elsif (looks_like_number($item)){push@rslt,$item}else {$item =~ s/ ( [\\'] ) /\\$1/smxg;push@rslt,"'$item'"}}my$rslt=join(', ',@rslt);return$rslt}sub _safe_version {my (undef,$version)=@_;return defined$version ? "'$version'" : 'undef'}sub __nav {my ($self,@args)=@_;my$rslt=$self->_safe(@args);$rslt =~ s/ ' (\w+) ' , /$1 =>/smxg;$rslt =~ s/ \[ \s+ \] /[]/smxg;$rslt =~ s/ \[ \s* ( \d+ ) \s* \] /$1/smxg;return$rslt}sub _perl_version {my (undef,$elem)=@_;my$rslt=$elem->perl_version_introduced().' <= $]';if (my$max=$elem->perl_version_removed()){$rslt .= ' < ' .$max}return$rslt}sub _content {my ($self,$elem,$dflt)=@_;defined$dflt or $dflt='';defined$elem or return$dflt;if (ref$elem eq 'ARRAY'){my$rslt=join '',map {$self->_content($_)}grep {!$self->{significant}|| $_->significant()}@{$elem};return$rslt eq '' ? $dflt : $rslt}blessed($elem)or return$dflt;return$self->encode($elem->content())}sub _tokens_dump {my ($self,$elem)=@_;not $self->{significant}or $elem->significant()or return;my@rslt;for my$token ($elem->tokens()){not $self->{significant}or $token->significant()or next;push@rslt,$token->__PPIX_DUMPER__dump($self)}return@rslt}sub _format_default_modifiers {my ($self,$subr,$elem)=@_;my@arg=$self->_safe($elem);for my$attr (qw{default_modifiers parse postderef strict}){defined (my$val=$self->{$attr})or next;'ARRAY' eq ref$val and not @{$val}and next;push@arg,"$attr => @{[ $self->_safe( $val ) ]}"}return sprintf '%-8s( %s );',$subr,join ', ',@arg}sub _format_modifiers_dump {my (undef,$elem)=@_;my%mods=$elem->modifiers();my@accum;$mods{match_semantics}and push@accum,'match_semantics=' .delete $mods{match_semantics};for my$modifier (sort keys%mods){push@accum,$mods{$modifier}? $modifier : "-$modifier"}@accum and return join ' ',@accum;return}sub _tokens_test {my ($self,$elem)=@_;not $self->{significant}or $elem->significant()or return;my@tokens=$elem->tokens();my@rslt=($self->_format_default_modifiers(tokenize=>$elem),sprintf('count   ( %d );',scalar@tokens),);my$inx=0;for my$token (@tokens){not $self->{significant}or $token->significant()or next;push@rslt,$token->__PPIX_DUMPER__test($self,$inx++)}return@rslt}sub PPIx::Regexp::Element::__PPIX_DUMPER__dump_explanation {my ($self,undef,$line)=@_;my@expl=$self->explain()or return$line;1==@expl and return "$line\t$expl[0]";wantarray or return sprintf "%s\t%s",$line,join '; ',@expl;(my$blank=$line)=~ s/\S/ /smxg;my@rslt;for my$splain (@expl){push@rslt,"$line\t$splain";$line=$blank}return@rslt}sub PPIx::Regexp::__PPIX_DUMPER__test {my ($self,$dumper)=@_;$dumper->{tokens}and return$dumper->_tokens_test($self);not $dumper->{significant}or $self->significant()or return;my$parse=$dumper->_format_default_modifiers(parse=>$self);my$fail='value   ( failures => [], ' .$self->failures().' );';my@rslt=PPIx::Regexp::Node::__PPIX_DUMPER__test($self,$dumper);shift@rslt;return ($parse,$fail,@rslt)}sub PPIx::Regexp::Node::__PPIX_DUMPER__dump {my ($self,$dumper)=@_;$dumper->{tokens}and return$dumper->_tokens_dump($self);not $dumper->{significant}or $self->significant()or return;my@rslt=ref$self;$self->isa('PPIx::Regexp')and $rslt[-1].= $dumper->{verbose}? sprintf "\tfailures=%d\tmax_capture_number=%d",$self->failures(),$self->max_capture_number(): sprintf "\tfailures=%d",$self->failures();$dumper->{perl_version}and $rslt[-1].= "\t" .$dumper->_perl_version($self);if (defined (my$err=$self->error())){$rslt[-1].= "\t$err"}else {$dumper->{explain}and push@rslt,$self->__PPIX_DUMPER__dump_explanation($dumper,pop@rslt)}my$indent=' ' x $dumper->{indent};for my$elem ($self->children()){push@rslt,map {$indent .$_}$elem->__PPIX_DUMPER__dump($dumper)}return@rslt}sub PPIx::Regexp::Node::__PPIX_DUMPER__test {my ($self,$dumper)=@_;not $dumper->{significant}or $self->significant()or return;my@rslt;@rslt=('choose  ( ' .$dumper->__nav($self->nav()).' );','class   ( ' .$dumper->_safe(ref$self).' );','count   ( ' .scalar$self->children().' );',);if (defined(my$err=$self->error())){push@rslt,'error   ( ' .$dumper->_safe($err).' );'}if ($dumper->{perl_version}){for my$method (qw{perl_version_introduced perl_version_removed}){push@rslt,"value   ( $method => [], " .$dumper->_safe_version($self->$method()).' );'}}for my$elem ($self->children()){push@rslt,$elem->__PPIX_DUMPER__test($dumper)}return@rslt}sub _format_value {my ($val)=@_;defined$val or return 'undef';$val =~ m/ \A [0-9]+ \z /smx and return$val;$val =~ s/ (?= [\\"] ) /\\/smxg;return qq{"$val"}}{my%dflt=(start=>'???',type=>'',finish=>'???',);sub PPIx::Regexp::Structure::__PPIX_DUMPER__dump {my ($self,$dumper)=@_;not $dumper->{significant}or $self->significant()or return;my@delim;for my$method (qw{start type finish}){my@elem=$self->$method();push@delim,@elem ? $dumper->_content(\@elem): $dflt{$method}}my@rslt=(ref$self,"$delim[0]$delim[1] ... $delim[2]");$dumper->{perl_version}and push@rslt,$dumper->_perl_version($self);if ($dumper->{verbose}){for my$method (qw{number name max_capture_number}){$self->can($method)or next;push@rslt,sprintf '%s=%s',$method,_format_value($self->$method())}for my$method (qw{can_be_quantified is_quantifier}){$self->can($method)or next;$self->$method()and push@rslt,$method}$self->isa('PPIx::Regexp::Structure::Modifier')and push@rslt,$dumper->_format_modifiers_dump($self->type(0))}for my$method ('start',undef,'finish'){my$ele=defined$method ? $self->$method(): $self or next;if (defined (my$err=$ele->error())){push@rslt,$err}}@rslt=(join "\t",@rslt);$dumper->{explain}and not defined$self->error()and push@rslt,$self->__PPIX_DUMPER__dump_explanation($dumper,pop@rslt);my$indent=' ' x $dumper->{indent};for my$elem ($self->children()){push@rslt,map {$indent .$_}$elem->__PPIX_DUMPER__dump($dumper)}return@rslt}}sub PPIx::Regexp::Structure::__PPIX_DUMPER__test {my ($self,$dumper)=@_;not $dumper->{significant}or $self->significant()or return;my@nav=$self->nav();my@rslt=('choose  ( ' .$dumper->__nav(@nav).' );','class   ( ' .$dumper->_safe(ref$self).' );','count   ( ' .scalar$self->children().' );',);if ($dumper->{verbose}){for my$method (qw{number name}){$self->can($method)or next;push@rslt,'value   ( ' .$method .' => [], ' .$dumper->_safe($self->$method()).' );'}}for my$method (qw{start type finish}){my@eles=$self->$method();push@rslt,'choose  ( ' .$dumper->__nav(@nav,$method,[]).' );','count   ( ' .scalar@eles .' );';for my$inx (0 .. $#eles){my$elem=$eles[$inx];push@rslt,'choose  ( ' .$dumper->__nav(@nav,$method,$inx).' );','class   ( ' .$dumper->_safe(ref$elem || $elem).' );','content ( ' .$dumper->_safe($elem).' );'}}for my$elem ($self->children()){push@rslt,$elem->__PPIX_DUMPER__test($dumper)}return@rslt}sub PPIx::Regexp::Tokenizer::__PPIX_DUMPER__dump {my ($self,$dumper)=@_;return$dumper->_tokens_dump($self)}sub PPIx::Regexp::Tokenizer::__PPIX_DUMPER__test {my ($self,$dumper)=@_;return$dumper->_tokens_test($self)}sub PPIx::Regexp::Token::__PPIX_DUMPER__dump {my ($self,$dumper)=@_;not $dumper->{significant}or $self->significant()or return;my@rslt=(ref$self,$dumper->_safe($self));$dumper->{perl_version}and push@rslt,$dumper->_perl_version($self);if (defined(my$err=$self->error())){return join "\t",@rslt,$err}else {if ($dumper->{ordinal}&& $self->can('ordinal')&& defined (my$ord=$self->ordinal())){push@rslt,sprintf '0x%02x',$ord}if ($dumper->{verbose}){if ($self->isa('PPIx::Regexp::Token::Reference')){for my$method (qw{absolute name number}){defined(my$val=$self->$method())or next;push@rslt,"$method=$val"}}for my$method (qw{significant can_be_quantified is_quantifier}){$self->can($method)and $self->$method()and push@rslt,$method}$self->can('ppi')and push@rslt,$self->ppi()->content();if ($self->isa('PPIx::Regexp::Token::Modifier')|| $self->isa('PPIx::Regexp::Token::GroupType::Modifier')){push@rslt,$dumper->_format_modifiers_dump($self)}}@rslt=(join "\t",@rslt);$dumper->{explain}and push@rslt,$self->__PPIX_DUMPER__dump_explanation($dumper,pop@rslt);return@rslt}}sub PPIx::Regexp::Token::__PPIX_DUMPER__test {my ($self,$dumper,@nav)=@_;not $dumper->{significant}or $self->significant()or return;@nav or @nav=$self->nav();my@rslt=('choose  ( ' .join(', ',$dumper->__nav(@nav)).' );','class   ( ' .$dumper->_safe(ref$self).' );','content ( ' .$dumper->_safe($self).' );',);if (defined(my$err=$self->error())){push@rslt,'error   ( ' .$dumper->_safe($err).' );'}else {if ($dumper->{perl_version}){for my$method (qw{perl_version_introduced perl_version_removed}){push@rslt,"value   ( $method => [], " .$dumper->_safe_version($self->$method()).' );'}}if ($dumper->{verbose}){for my$method (qw{significant can_be_quantified is_quantifier}){$self->can($method)or next;push@rslt,$self->$method()? "true    ( $method => [] );" : "false   ( $method => [] );"}$self->can('ppi')and push@rslt,"value   ( ppi => [], " .$dumper->_safe($self->ppi()).' );'}}return@rslt}1;
PPIX_REGEXP_DUMPER

$fatpacked{"PPIx/Regexp/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_ELEMENT';
  package PPIx::Regexp::Element;use strict;use warnings;use 5.006;use Carp;use List::MoreUtils qw{firstidx};use PPIx::Regexp::Util qw{__instance};use Scalar::Util qw{refaddr weaken};use PPIx::Regexp::Constant qw{LITERAL_LEFT_CURLY_REMOVED_PHASE_1 MINIMUM_PERL TOKEN_UNKNOWN};our$VERSION='0.01';sub ancestor_of {my ($self,$elem)=@_;__instance($elem,__PACKAGE__)or return;my$addr=refaddr($self);while ($addr!=refaddr($elem)){$elem=$elem->_parent()or return}return 1}sub can_be_quantified {return 1}sub class {my ($self)=@_;return ref$self}sub comment {return}sub content {return}sub descendant_of {my ($self,$node)=@_;__instance($node,__PACKAGE__)or return;return$node->ancestor_of($self)}sub explain {my ($self)=@_;my$explanation=$self->__explanation();my$content=$self->content();if (my$main=$self->main_structure()){my$delim=$main->delimiters();$delim=qr{ \\ (?= [\Q$delim\E] ) }smx;$content =~ s/$delim//smxg}if (defined(my$splain=$explanation->{$content})){return$splain}return$self->__no_explanation()}sub __explanation {$PPIx::Regexp::NO_EXPLANATION_FATAL and confess 'Neither explain() nor __explanation() overridden';return {}}sub __no_explanation {my$msg=sprintf q<No explanation>;$PPIx::Regexp::NO_EXPLANATION_FATAL and confess$msg;return$msg}sub error {my ($self)=@_;return$self->{error}}sub in_regex_set {my ($self)=@_;my$ele=$self;while (1){$ele->isa('PPIx::Regexp::Structure::RegexSet')and return 1;$ele=$ele->parent()or last}return 0}sub is_quantifier {return}sub main_structure {my ($self)=@_;while ($self=$self->parent()and not $self->isa('PPIx::Regexp::Structure::Main')){}return$self}sub modifier_asserted {my ($self,$modifier)=@_;defined$modifier or croak 'Modifier must be defined';my$elem=$self;while ($elem){if ($elem->can('__ducktype_modifier_asserted')){my$val;defined($val=$elem->__ducktype_modifier_asserted($modifier))and return$val}if (my$prev=$elem->sprevious_sibling()){$elem=$prev}else {$elem=$elem->parent()}}return}sub next_sibling {my ($self)=@_;my ($method,$inx)=$self->_my_inx()or return;return$self->_parent()->$method($inx + 1)}sub parent {my ($self)=@_;return$self->_parent()}sub perl_version_introduced {return MINIMUM_PERL}sub perl_version_removed {return undef}sub previous_sibling {my ($self)=@_;my ($method,$inx)=$self->_my_inx()or return;$inx or return;return$self->_parent()->$method($inx - 1)}sub significant {return 1}sub snext_sibling {my ($self)=@_;my$sib=$self;while (defined ($sib=$sib->next_sibling())){$sib->significant()and return$sib}return}sub sprevious_sibling {my ($self)=@_;my$sib=$self;while (defined ($sib=$sib->previous_sibling())){$sib->significant()and return$sib}return}sub tokens {my ($self)=@_;return$self}sub top {my ($self)=@_;my$kid=$self;while (defined (my$parent=$kid->_parent())){$kid=$parent}return$kid}sub unescaped_content {return}sub whitespace {return}sub nav {my ($self)=@_;__instance($self,__PACKAGE__)or return;my$parent=$self->_parent()or return;return ($parent->nav(),$parent->__nav($self))}{my%method_map=(children=>'child',);sub _my_inx {my ($self)=@_;my$parent=$self->_parent()or return;my$addr=refaddr($self);for my$method (qw{children start type finish}){$parent->can($method)or next;my$inx=firstidx {refaddr $_==$addr}$parent->$method();$inx < 0 and next;return ($method_map{$method}|| $method,$inx)}return}}{my%parent;sub _parent {my ($self,@arg)=@_;my$addr=refaddr($self);if (@arg){my$parent=shift@arg;if (defined$parent){__instance($parent,__PACKAGE__)or return;weaken($parent{$addr}=$parent)}else {delete$parent{$addr}}}return$parent{$addr}}sub __parent_keys {return scalar keys%parent}}sub __error {my ($self,$msg)=@_;defined$msg or $msg='Was ' .ref$self;$self->{error}=$msg;bless$self,TOKEN_UNKNOWN;return 1}sub __following_literal_left_curly_disallowed_in {return LITERAL_LEFT_CURLY_REMOVED_PHASE_1}sub __PPIX_LEXER__record_capture_number {my (undef,$number)=@_;return$number}sub __PPIX_ELEM__rebless {my ($class,$self)=@_;$self ||= {};bless$self,$class;delete$self->{error};defined$self->{error}and return 1;delete$self->{error};return 0}sub DESTROY {$_[0]->_parent(undef);return}1;
PPIX_REGEXP_ELEMENT

$fatpacked{"PPIx/Regexp/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_LEXER';
  package PPIx::Regexp::Lexer;use strict;use warnings;use base qw{PPIx::Regexp::Support};use Carp qw{confess};use PPIx::Regexp::Constant qw{TOKEN_LITERAL TOKEN_UNKNOWN};use PPIx::Regexp::Node::Range ();use PPIx::Regexp::Node::Unknown ();use PPIx::Regexp::Structure ();use PPIx::Regexp::Structure::Assertion ();use PPIx::Regexp::Structure::BranchReset ();use PPIx::Regexp::Structure::Code ();use PPIx::Regexp::Structure::Capture ();use PPIx::Regexp::Structure::CharClass ();use PPIx::Regexp::Structure::Subexpression ();use PPIx::Regexp::Structure::Main ();use PPIx::Regexp::Structure::Modifier ();use PPIx::Regexp::Structure::NamedCapture ();use PPIx::Regexp::Structure::Quantifier ();use PPIx::Regexp::Structure::Regexp ();use PPIx::Regexp::Structure::RegexSet ();use PPIx::Regexp::Structure::Replacement ();use PPIx::Regexp::Structure::Switch ();use PPIx::Regexp::Structure::Unknown ();use PPIx::Regexp::Token::Unmatched ();use PPIx::Regexp::Tokenizer ();use PPIx::Regexp::Util qw{__choose_tokenizer_class __instance};our$VERSION='0.01';{my$errstr;sub new {my ($class,$tokenizer,%args)=@_;ref$class and $class=ref$class;unless (__instance($tokenizer,'PPIx::Regexp::Tokenizer')){my$tokenizer_class=__choose_tokenizer_class($tokenizer,\%args)or do {$errstr='Data not supported';return};$tokenizer=$tokenizer_class->new($tokenizer,%args)or do {$errstr=$tokenizer_class->errstr();return}}my$self={deferred=>[],failures=>0,strict=>$args{strict},tokenizer=>$tokenizer,};bless$self,$class;return$self}sub errstr {return$errstr}}sub failures {my ($self)=@_;return$self->{failures}}sub lex {my ($self)=@_;my@content;$self->{failures}=0;my$kind;{my$token=$self->_get_token()or return$self->_finalize(@content);$token->isa('PPIx::Regexp::Token::Delimiter')or do {not $kind and $token->isa('PPIx::Regexp::Token::Structure')and $kind=$token;push@content,$token;redo};$self->_unget_token($token)}my ($part_0_class,$part_1_class)=$self->{tokenizer}->__part_classes();push@content,(my$part_0=$self->_get_delimited($part_0_class));if (defined$part_1_class){while (my$token=$self->_get_token()){if ($token->significant()){$self->_unget_token($token);last}else {push@content,$token}}my$expect_open_bracket=$self->close_bracket($part_0->start(0))|| 0;push@content,$self->_get_delimited($part_1_class,$expect_open_bracket,)}while (my$token=$self->_get_token()){push@content,$token}$self->_finalize(@content);if ($part_0 && $part_0->can('max_capture_number')){my$max_capture=$part_0->max_capture_number();my$capture_name={map {$_=>1}$part_0->capture_names(),};for my$elem (@{$part_0->find('PPIx::Regexp::Token::Backreference')|| []}){$self->{failures}+= $elem->__PPIX_LEXER__rebless(capture_name=>$capture_name,max_capture=>$max_capture,)}}return@content}sub strict {my ($self)=@_;return$self->{strict}}sub _finalize {my ($self,@content)=@_;for my$elem (@content){$self->{failures}+= $elem->__PPIX_LEXER__finalize($self)}defined wantarray and return@content;return}{my%bracket=('{'=>'}','('=>')','['=>']','(?['=>'])',);my%unclosed=('{'=>'_recover_curly',);sub _get_delimited {my ($self,$class,$expect_open_bracket)=@_;defined$expect_open_bracket or $expect_open_bracket=1;my@rslt;$self->{_rslt}=\@rslt;if ($expect_open_bracket){if (my$token=$self->_get_token()){push@rslt,[];if ($token->isa('PPIx::Regexp::Token::Delimiter')){push @{$rslt[-1]},'',$token}else {push @{$rslt[-1]},'',undef;$self->_unget_token($token)}}else {return}}else {push@rslt,['',undef ]}while (my$token=$self->_get_token()){if ($token->isa('PPIx::Regexp::Token::Delimiter')){$self->_unget_token($token);last}if ($token->isa('PPIx::Regexp::Token::Structure')){my$content=$token->content();if (my$finish=$bracket{$content}){push@rslt,[$finish,$token ]}elsif ($content eq $rslt[-1][0]){$self->_make_node($token)}elsif ($content ne ')'){TOKEN_LITERAL->__PPIX_ELEM__rebless($token);push @{$rslt[-1]},$token}elsif ($content eq ')' and @rslt > 1 and my$recover=$unclosed{$rslt[-1][1]->content()}){$self->$recover($token)}else {$self->{failures}++;PPIx::Regexp::Token::Unmatched-> __PPIX_ELEM__rebless($token);push @{$rslt[-1]},$token}}else {push @{$rslt[-1]},$token}if (__instance($rslt[-1][-2],'PPIx::Regexp::Token::Operator')&& $rslt[-1][-2]->content()eq '-' && $rslt[-1][0]eq ']'){my@tokens=splice @{$rslt[-1]},-3;push @{$rslt[-1]},PPIx::Regexp::Node::Range->__new(@tokens)}}while (@rslt > 1){if (my$recover=$unclosed{$rslt[-1][1]->content()}){$self->$recover()}else {$self->{failures}++;$self->_make_node(undef)}}if (@rslt==1){my@last=@{pop@rslt};shift@last;push@last,$self->_get_token();return$class->__new(@last)}else {confess "Missing data"}}}sub _get_token {my ($self)=@_;if (@{$self->{deferred}}){return shift @{$self->{deferred}}}my$token=$self->{tokenizer}->next_token()or return;return$token}{my%handler=('('=>'_round','['=>'_square','{'=>'_curly','(?['=>'_regex_set',);sub _make_node {my ($self,$token)=@_;my@args=@{pop @{$self->{_rslt}}};shift@args;push@args,$token;my@node;if (my$method=$handler{$args[0]->content()}){@node=$self->$method(\@args)}@node or @node=PPIx::Regexp::Structure->__new(@args);push @{$self->{_rslt}[-1]},@node;return}}sub _curly {my ($self,$args)=@_;if ($args->[-1]&& $args->[-1]->is_quantifier()){return PPIx::Regexp::Structure::Quantifier->__new(@{$args})}elsif ($args->[-1]){for my$inx (0,-1){TOKEN_LITERAL->__PPIX_ELEM__rebless($args->[$inx])}$self->_recover_curly_quantifiers($args);return @{$args}}else {return PPIx::Regexp::Structure->__new(@{$args})}}sub _recover_curly {my ($self,$token)=@_;my@content=@{pop @{$self->{_rslt}}};shift@content;if ($self->{_rslt}[0][-1]->isa('PPIx::Regexp::Token::Assertion')&& q<\b> eq $self->{_rslt}[0][-1]->content()){TOKEN_UNKNOWN->__PPIX_ELEM__rebless($content[0],error=>'Unterminated bound type',)}else {TOKEN_LITERAL->__PPIX_ELEM__rebless($content[0])}$self->_recover_curly_quantifiers(\@content);'ARRAY' eq ref$self->{_rslt}or confess 'Programming error - $self->{_rslt} not array ref, ',"parsing '",$self->{tokenizer}->content(),"' at ",$token->content();@{$self->{_rslt}}or confess 'Programming error - $self->{_rslt} empty, ',"parsing '",$self->{tokenizer}->content(),"' at ",$token->content();push @{$self->{_rslt}[-1]},@content;$token and $self->_unget_token($token);return}sub _recover_curly_quantifiers {my (undef,$args)=@_;if (__instance($args->[0],TOKEN_LITERAL)&& __instance($args->[1],TOKEN_UNKNOWN)&& PPIx::Regexp::Token::Quantifier->could_be_quantifier($args->[1]->content())){PPIx::Regexp::Token::Quantifier-> __PPIX_ELEM__rebless($args->[1]);if (__instance($args->[2],TOKEN_UNKNOWN)&& PPIx::Regexp::Token::Greediness->could_be_greediness($args->[2]->content())){PPIx::Regexp::Token::Greediness ->__PPIX_ELEM__rebless($args->[2])}}return}sub _in_regex_set {my ($self)=@_;for my$stack_entry (reverse @{$self->{_rslt}}){$stack_entry->[0]eq '])' and return 1}return 0}sub _round {my ($self,$args)=@_;$self->_in_regex_set()and return PPIx::Regexp::Structure->__new(@{$args});$self->{tokenizer}->modifier('n')and return PPIx::Regexp::Structure->__new(@{$args});return PPIx::Regexp::Structure::Capture->__new(@{$args})}sub _square {my (undef,$args)=@_;return PPIx::Regexp::Structure::CharClass->__new(@{$args})}sub _regex_set {my (undef,$args)=@_;return PPIx::Regexp::Structure::RegexSet->__new(@{$args})}sub _unget_token {my ($self,@args)=@_;unshift @{$self->{deferred}},@args;return$self}1;
PPIX_REGEXP_LEXER

$fatpacked{"PPIx/Regexp/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_NODE';
  package PPIx::Regexp::Node;use strict;use warnings;use base qw{PPIx::Regexp::Element};use Carp;use List::Util qw{max};use PPIx::Regexp::Constant qw{MINIMUM_PERL NODE_UNKNOWN};use PPIx::Regexp::Util qw{__instance};use Scalar::Util qw{refaddr};our$VERSION='0.01';use constant ELEMENT_UNKNOWN=>NODE_UNKNOWN;sub __new {my ($class,@children)=@_;ref$class and $class=ref$class;for my$elem (@children){__instance($elem,'PPIx::Regexp::Element')or return}my$self={children=>\@children,};bless$self,$class;for my$elem (@children){$elem->_parent($self)}return$self}sub child {my ($self,$inx)=@_;defined$inx or $inx=0;return$self->{children}[$inx]}sub children {my ($self)=@_;return @{$self->{children}}}sub contains {my ($self,$elem)=@_;__instance($elem,'PPIx::Regexp::Element')or return;my$addr=refaddr($self);while ($elem=$elem->parent()){$addr==refaddr($elem)and return 1}return}sub content {my ($self)=@_;return join('',map{$_->content()}$self->elements())}{no warnings qw{once};*elements=\&children}sub _find_routine {my ($want)=@_;ref$want eq 'CODE' and return$want;ref$want and return;$want =~ m/ \A PPIx::Regexp:: /smx or $want='PPIx::Regexp::' .$want;return sub {return __instance($_[1],$want)? 1 : 0}}sub find {my ($self,$want)=@_;$want=_find_routine($want)or return;my@found;for my$elem ($self->elements()){my$rslt=eval {$want->($self,$elem)}and push@found,$elem;$@ and return;__instance($elem,'PPIx::Regexp::Node')or next;defined$rslt or next;$rslt=$elem->find($want)and push@found,@{$rslt}}return@found ? \@found : 0}sub find_parents {my ($self,$want)=@_;my$found;$found=$self->find($want)or return$found;my%parents;my@rslt;for my$elem (@{$found}){my$dad=$elem->parent()or next;$parents{refaddr($dad)}++ or push@rslt,$dad}return \@rslt}sub find_first {my ($self,$want)=@_;$want=_find_routine($want)or return;for my$elem ($self->elements()){my$rslt=eval {$want->($self,$elem)}and return$elem;$@ and return;__instance($elem,'PPIx::Regexp::Node')or next;defined$rslt or next;defined($rslt=$elem->find_first($want))or return;$rslt and return$rslt}return 0}sub first_element {my ($self)=@_;return$self->{children}[0]}sub last_element {my ($self)=@_;return$self->{children}[-1]}sub perl_version_introduced {my ($self)=@_;return max(grep {defined $_}MINIMUM_PERL,$self->{perl_version_introduced},map {$_->perl_version_introduced()}$self->elements())}sub perl_version_removed {my ($self)=@_;my$max;for my$elem ($self->elements()){if (defined (my$ver=$elem->perl_version_removed())){if (defined$max){$ver < $max and $max=$ver}else {$max=$ver}}}return$max}sub schild {my ($self,$inx)=@_;defined$inx or $inx=0;my$kids=$self->{children};if ($inx >= 0){my$loc=0;while (exists$kids->[$loc]){$kids->[$loc]->significant()or next;--$inx >= 0 and next;return$kids->[$loc]}continue {$loc++}}else {my$loc=-1;while (exists$kids->[$loc]){$kids->[$loc]->significant()or next;$inx++ < -1 and next;return$kids->[$loc]}continue {--$loc}}return}sub schildren {my ($self)=@_;if (wantarray){return (grep {$_->significant()}@{$self->{children}})}elsif (defined wantarray){my$kids=0;for (@{$self->{children}}){$_->significant()and $kids++}return$kids}else {return}}sub tokens {my ($self)=@_;return (map {$_->tokens()}$self->elements())}sub unescaped_content {my ($self)=@_;return join '',map {$_->unescaped_content()}$self->elements()}sub __nav {my ($self,$child)=@_;refaddr($child->parent())==refaddr($self)or return;my ($method,$inx)=$child->_my_inx()or return;return ($method=>[$inx ])}sub __error {my ($self,$msg,%arg)=@_;defined$msg or $msg='Was class ' .ref$self;$self->{error}=$msg;bless$self,$self->ELEMENT_UNKNOWN();for my$key (keys%arg){$self->{$key}=$arg{$key}}return 1}sub __PPIX_LEXER__finalize {my ($self,$lexer)=@_;my$rslt=0;for my$elem ($self->elements()){$rslt += $elem->__PPIX_LEXER__finalize($lexer)}return$rslt}sub __PPIX_LEXER__record_capture_number {my ($self,$number)=@_;for my$kid ($self->children()){$number=$kid->__PPIX_LEXER__record_capture_number($number)}return$number}1;
PPIX_REGEXP_NODE

$fatpacked{"PPIx/Regexp/Node/Range.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_NODE_RANGE';
  package PPIx::Regexp::Node::Range;use strict;use warnings;use base qw{PPIx::Regexp::Node};use PPIx::Regexp::Constant qw{MSG_PROHIBITED_BY_STRICT};our$VERSION='0.01';sub explain {my ($self)=@_;my$first=$self->schild(0)or return$self->__no_explanation();my$last=$self->schild(-1)or return$self->__no_explanation();return sprintf q<Characters between '%s' and '%s' inclusive>,$first->content(),$last->content()}sub __PPIX_LEXER__finalize {my ($self,$lexer)=@_;my$rslt=$self->SUPER::__PPIX_LEXER__finalize($lexer);if ($lexer->strict()){my@kids=$self->schildren();delete$self->{_range_start};for my$inx (0,-1){my$kid=$kids[$inx];$kid->isa('PPIx::Regexp::Token::Literal')or next;my$content=$kid->content();$content =~ m/ \A (?: [[:alnum:]] | \\N\{ .* \} ) \z /smx and $self->_range_ends_compatible($content)or return$self->_prohibited_by_strict($rslt)}}return$rslt}sub _prohibited_by_strict {my ($self,$rslt)=@_;delete$self->{_range_start};$rslt += $self->__error(join(' ','Non-portable range ends',MSG_PROHIBITED_BY_STRICT),perl_version_introduced=>'5.023008',);return$rslt}sub _range_ends_compatible {my ($self,$content)=@_;if (defined(my$start=$self->{_range_start})){for my$re (qr{ \A [[:upper:]] \z }smx,qr{ \A [[:lower:]] \z }smx,qr{ \A [0-9] \z }smx,qr{ \A \\N \{ .* \} }smx,){$start =~ $re or next;return$content =~ $re}return}else {$self->{_range_start}=$content;return 1}}1;
PPIX_REGEXP_NODE_RANGE

$fatpacked{"PPIx/Regexp/Node/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_NODE_UNKNOWN';
  package PPIx::Regexp::Node::Unknown;use 5.006;use strict;use warnings;use base qw{PPIx::Regexp::Node};our$VERSION='0.01';1;
PPIX_REGEXP_NODE_UNKNOWN

$fatpacked{"PPIx/Regexp/StringTokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRINGTOKENIZER';
  package PPIx::Regexp::StringTokenizer;use 5.006;use strict;use warnings;use base qw{PPIx::Regexp::Tokenizer};use Carp;use PPIx::Regexp::Constant qw{TOKEN_UNKNOWN};our$VERSION='0.01';{my@classes=('PPIx::Regexp::Token::Literal','PPIx::Regexp::Token::Interpolation','PPIx::Regexp::Token::Control',);sub __tokenizer_classes {return@classes}}my%bare_delim=map {$_=>1}qw{' " `};sub __PPIX_TOKENIZER__init {my ($self)=@_;my@tokens;if ($self->find_regexp(qr{ \A \s* << }smx)){my ($leading_white,$next_white,$delim);if ($self->find_regexp(qr{ \A ( \s* ) << ( \w+ \n ) }smx)){($leading_white,$delim)=$self->capture();$next_white=''}elsif ($self->find_regexp(qr{ \A ( \s* ) << ( \s+ ) ( ( ["'] ) .*? \4 \n ) }smx)){($leading_white,$next_white,$delim)=$self->capture()}else {return$self->__init_error()}$self->{type}='<<';$self->{delimiter_start}=$delim;if ($delim =~ s/ \A ( ["'] ) ( .* ) \1 \n \z /$2\n/smx){my$quote=$1;$delim =~ s/ \\ (?= \Q$quote\E ) //smxg}'' ne $leading_white and push@tokens,$self->make_token(length$leading_white,'PPIx::Regexp::Token::Whitespace');push@tokens,$self->make_token(length$self->{type},'PPIx::Regexp::Token::Structure');'' ne $next_white and push@tokens,$self->make_token(length$next_white,'PPIx::Regexp::Token::Whitespace');push@tokens,$self->make_token(length$self->{delimiter_start},'PPIx::Regexp::Token::Delimiter');my ($offset)=$self->find_regexp(qr{ \Q$delim\E }smx)or return$self->__init_error();my$cursor_limit=$self->{cursor_curr}+ $offset;$self->{trace}and warn "Tokenizer found here doc end delimiter at $cursor_limit\n";$self->{cursor_limit}=$cursor_limit;$self->{cursor_modifiers}=$cursor_limit + length$delim;$self->{delimiter_finish}=$delim}elsif ($self->find_regexp(qr{ \A ( \s* ) ( qq | q | qx )? ( \s* ) ( [^\w\s] ) }smx)){my ($leading_white,$type,$next_white,$delim)=$self->capture();unless (defined$type){$bare_delim{$delim}or return$self->__init_error();$type=''}$self->{type}=$type;'' ne $leading_white and push@tokens,$self->make_token(length$leading_white,'PPIx::Regexp::Token::Whitespace');push@tokens,$self->make_token(length$type,'PPIx::Regexp::Token::Structure');'' ne $next_white and push@tokens,$self->make_token(length$next_white,'PPIx::Regexp::Token::Whitespace');$self->{delimiter_start}=substr $self->{content},$self->{cursor_curr},1;$self->{trace}and warn "Tokenizer found string start delimiter '$self->{delimiter_start}' at $self->{cursor_curr}\n";my$offset=$self->find_matching_delimiter()or return$self->__init_error('Tokenizer found mismatched string delimiters');my$cursor_limit=$self->{cursor_curr}+ $offset;$self->{trace}and warn "Tokenizer found string end delimiter at $cursor_limit\n";$self->{cursor_limit}=$cursor_limit;$self->{cursor_modifiers}=$cursor_limit + 1;$self->{delimiter_finish}=substr $self->{content},$self->{cursor_limit},1;push@tokens,$self->make_token(1,'PPIx::Regexp::Token::Delimiter')}else {return$self->__init_error()}{pos$self->{content}=$self->{cursor_modifiers};local$self->{cursor_curr}=$self->{cursor_modifiers};local$self->{cursor_limit}=length$self->{content};my@trailing;if (my$len=$self->find_regexp(qr{ \A \s+ }smx)){push@trailing,$self->make_token($len,'PPIx::Regexp::Token::Whitespace')}if (my$len=$self->find_regexp(qr{ \A .+ }smx)){push@trailing,$self->make_token($len,TOKEN_UNKNOWN,{error=>'Trailing characters after expression',})}$self->{trailing_tokens}=\@trailing;$self->{effective_modifiers}=undef;$self->{modifiers}=[{}]}$self->{find}=undef;$self->_set_mode('repl');return@tokens}sub __number_of_extra_parts {return 0}sub __part_classes {return ('PPIx::Regexp::Structure::Replacement')}{my%from_delim=map {$_=>1}'','qx','<<';my%from_type=map {$_=>1}qw{qq qx};sub interpolates {my ($self)=@_;$from_delim{$self->{type}}and return$self->{delimiter_start}!~ m/ \A ' /smx;return$from_type{$self->{type}}}}1;
PPIX_REGEXP_STRINGTOKENIZER

$fatpacked{"PPIx/Regexp/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE';
  package PPIx::Regexp::Structure;use strict;use warnings;use base qw{PPIx::Regexp::Node};use Carp qw{confess};use PPIx::Regexp::Constant qw{STRUCTURE_UNKNOWN};use PPIx::Regexp::Util qw{__instance};use Scalar::Util qw{refaddr};our$VERSION='0.01';use constant ELEMENT_UNKNOWN=>STRUCTURE_UNKNOWN;sub __new {my ($class,@args)=@_;my%brkt;if (ref$args[0]eq 'HASH'){%brkt=%{shift@args};for my$key (qw{start type finish}){ref$brkt{$key}eq 'ARRAY' or $brkt{$key}=[$brkt{$key}]}}else {$brkt{finish}=[@args ? pop@args : ()];$brkt{start}=[@args ? shift@args : ()];while (@args &&!$args[0]->significant()){push @{$brkt{start}},shift@args}$brkt{type}=[];if (__instance($args[0],'PPIx::Regexp::Token::GroupType')){push @{$brkt{type}},shift@args;while (@args &&!$args[0]->significant()){push @{$brkt{type}},shift@args}}}$class->_check_for_interpolated_match(\%brkt,\@args);my$self=$class->SUPER::__new(@args)or return;if (__instance($brkt{type}[0],'PPIx::Regexp::Token::GroupType')){(my$reclass=ref$brkt{type}[0])=~ s/ Token::GroupType /Structure/smx;$reclass->can('start')or confess "Programming error - $reclass not loaded";bless$self,$reclass}for my$key (qw{start type finish}){$self->{$key}=[];ref$brkt{$key}eq 'ARRAY' or confess "Programming error - '$brkt{$key}' not an ARRAY";for my$val (@{$brkt{$key}}){defined$val or next;__instance($val,'PPIx::Regexp::Element')or confess "Programming error - '$val' not a ","PPIx::Regexp::Element";push @{$self->{$key}},$val;$val->_parent($self)}}@{$self->{finish}}or $self->{error}='Missing end delimiter';return$self}sub elements {my ($self)=@_;if (wantarray){return (@{$self->{start}},@{$self->{type}},@{$self->{children}},@{$self->{finish}},)}elsif (defined wantarray){my$size=scalar @{$self->{start}};$size += scalar @{$self->{type}};$size += scalar @{$self->{children}};$size += scalar @{$self->{finish}};return$size}else {return}}sub explain {my ($self)=@_;if (my$type=$self->type()){return$type->explain()}if (my$start=$self->start()){return$start->explain()}return$self->__no_explanation()}sub finish {my ($self,$inx)=@_;wantarray and return @{$self->{finish}};return$self->{finish}[defined$inx ? $inx : 0 ]}sub first_element {my ($self)=@_;$self->{start}[0]and return$self->{start}[0];$self->{type}[0]and return$self->{type}[0];if (my$elem=$self->SUPER::first_element()){return$elem}$self->{finish}[0]and return$self->{finish}[0];return}sub last_element {my ($self)=@_;$self->{finish}[-1]and return$self->{finish}[-1];if (my$elem=$self->SUPER::last_element()){return$elem}$self->{type}[-1]and return$self->{type}[-1];$self->{start}[-1]and return$self->{start}[-1];return}sub start {my ($self,$inx)=@_;wantarray and return @{$self->{start}};return$self->{start}[defined$inx ? $inx : 0 ]}sub type {my ($self,$inx)=@_;wantarray and return @{$self->{type}};return$self->{type}[defined$inx ? $inx : 0 ]}sub _check_for_interpolated_match {my (undef,$brkt,$args)=@_;__instance($args->[0],'PPIx::Regexp::Token::Unknown')and $args->[0]->content()eq '?' and __instance($args->[1],'PPIx::Regexp::Token::Interpolation')or return;my$hiwater=2;if (__instance($args->[2],'PPIx::Regexp::Token::Literal')&& $args->[2]->content()eq ':'){PPIx::Regexp::Token::GroupType::Modifier->__PPIX_ELEM__rebless($args->[0]);PPIx::Regexp::Token::GroupType->__PPIX_ELEM__rebless($args->[2]);push @{$brkt->{type}},splice @{$args},0,3;while (@{$args}&&!$args->[0]->significant()){push @{$brkt->{type}},shift @{$args}}return}if (__instance($args->[2],'PPIx::Regexp::Token::Literal')&& $args->[2]->content()eq '-' && __instance($args->[3],'PPIx::Regexp::Token::Interpolation')){$hiwater=4;if (__instance($args->[4],'PPIx::Regexp::Token::Literal')&& $args->[4]->content()eq ':'){PPIx::Regexp::Token::GroupType::Modifier->__PPIX_ELEM__rebless($args->[0]);PPIx::Regexp::Token::GroupType->__PPIX_ELEM__rebless($args->[2]);PPIx::Regexp::Token::GroupType->__PPIX_ELEM__rebless($args->[4]);push @{$brkt->{type}},splice @{$args},0,5;while (@{$args}&&!$args->[0]->significant()){push @{$brkt->{type}},shift @{$args}}return}}for my$inx ($hiwater .. $#$args){$args->[$inx]->significant()and return}PPIx::Regexp::Token::GroupType::Modifier->__PPIX_ELEM__rebless($args->[0]);push @{$brkt->{type}},splice @{$args};return}1;
PPIX_REGEXP_STRUCTURE

$fatpacked{"PPIx/Regexp/Structure/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_ASSERTION';
  package PPIx::Regexp::Structure::Assertion;use strict;use warnings;use base qw{PPIx::Regexp::Structure};our$VERSION='0.01';use PPIx::Regexp::Constant qw{LITERAL_LEFT_CURLY_ALLOWED};sub __following_literal_left_curly_disallowed_in {return LITERAL_LEFT_CURLY_ALLOWED}1;
PPIX_REGEXP_STRUCTURE_ASSERTION

$fatpacked{"PPIx/Regexp/Structure/BranchReset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_BRANCHRESET';
  package PPIx::Regexp::Structure::BranchReset;use strict;use warnings;use base qw{PPIx::Regexp::Structure};use Carp qw{confess};our$VERSION='0.01';sub __PPIX_LEXER__record_capture_number {my ($self,$number)=@_;defined$number or confess 'Programming error - initial $number is undef';my$original=$number;my$hiwater=$number;for my$kid ($self->children()){if ($kid->isa('PPIx::Regexp::Token::Operator')&& $kid->content()eq '|'){$number > $hiwater and $hiwater=$number;$number=$original}else {$number=$kid->__PPIX_LEXER__record_capture_number($number)}}return$number > $hiwater ? $number : $hiwater}1;
PPIX_REGEXP_STRUCTURE_BRANCHRESET

$fatpacked{"PPIx/Regexp/Structure/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_CAPTURE';
  package PPIx::Regexp::Structure::Capture;use strict;use warnings;use base qw{PPIx::Regexp::Structure};our$VERSION='0.01';sub explain {my ($self)=@_;return sprintf q<Capture group number %s>,$self->number()}sub name {return}sub number {my ($self)=@_;return$self->{number}}sub __PPIX_LEXER__record_capture_number {my ($self,$number)=@_;$self->{number}=$number++;return$self->SUPER::__PPIX_LEXER__record_capture_number($number)}1;
PPIX_REGEXP_STRUCTURE_CAPTURE

$fatpacked{"PPIx/Regexp/Structure/CharClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_CHARCLASS';
  package PPIx::Regexp::Structure::CharClass;use strict;use warnings;use base qw{PPIx::Regexp::Structure};use PPIx::Regexp::Constant qw{LITERAL_LEFT_CURLY_REMOVED_PHASE_2};use PPIx::Regexp::Util qw{__instance};our$VERSION='0.01';sub __new {my ($class,@args)=@_;ref$class and $class=ref$class;my%brkt;$brkt{finish}=pop@args;$brkt{start}=shift@args;__instance($args[0],'PPIx::Regexp::Token::Operator')and $args[0]->content()eq '^' and $brkt{type}=shift@args;return$class->SUPER::__new(\%brkt,@args)}sub explain {my ($self)=@_;$self->negated()and return 'Inverted character class';return 'Character class'}sub negated {my ($self)=@_;return$self->type()? 1 : 0}sub __following_literal_left_curly_disallowed_in {return LITERAL_LEFT_CURLY_REMOVED_PHASE_2}sub __PPIX_LEXER__record_capture_number {my (undef,$number)=@_;return$number}1;
PPIX_REGEXP_STRUCTURE_CHARCLASS

$fatpacked{"PPIx/Regexp/Structure/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_CODE';
  package PPIx::Regexp::Structure::Code;use strict;use warnings;use base qw{PPIx::Regexp::Structure};our$VERSION='0.01';sub __PPIX_LEXER__finalize {my ($self)=@_;my$count;my$errors=0;for my$kid ($self->children()){if ($kid->isa('PPIx::Regexp::Token::Code')){$count++ or next;$errors++;$kid->__error('Code structure can contain only one code token')}else {$errors++;$kid->__error('Code structure may not contain a ' .ref$kid)}}return$errors}1;
PPIX_REGEXP_STRUCTURE_CODE

$fatpacked{"PPIx/Regexp/Structure/Main.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_MAIN';
  package PPIx::Regexp::Structure::Main;use strict;use warnings;use base qw{PPIx::Regexp::Structure};our$VERSION='0.01';sub delimiters {my ($self)=@_;my@delims;for my$method (qw{start finish}){push@delims,undef;defined (my$obj=$self->$method())or next;defined (my$str=$obj->content())or next;$delims[-1]=$str}defined ($delims[0])or $delims[0]=$delims[1];return$delims[0].$delims[1]}sub interpolates {my ($self)=@_;my$finish=$self->finish(0)or return 1;return q<'> ne $finish->content()}1;
PPIX_REGEXP_STRUCTURE_MAIN

$fatpacked{"PPIx/Regexp/Structure/Modifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_MODIFIER';
  package PPIx::Regexp::Structure::Modifier;use strict;use warnings;use base qw{PPIx::Regexp::Structure};our$VERSION='0.01';sub __ducktype_modifier_asserted {my ($self,$modifier)=@_;for my$type (reverse$self->type()){$type->can('__ducktype_modifier_asserted')or next;defined(my$val=$type->__ducktype_modifier_asserted($modifier))or next;return$val}return}1;
PPIX_REGEXP_STRUCTURE_MODIFIER

$fatpacked{"PPIx/Regexp/Structure/NamedCapture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_NAMEDCAPTURE';
  package PPIx::Regexp::Structure::NamedCapture;use strict;use warnings;use Carp;use base qw{PPIx::Regexp::Structure::Capture};our$VERSION='0.01';sub explain {my ($self)=@_;return sprintf q<Named capture group '%s' (number %d)>,$self->name(),$self->number()}sub name {my ($self)=@_;my$type=$self->type()or croak 'Programming error - ',__PACKAGE__,' without type object';return$type->name()}1;
PPIX_REGEXP_STRUCTURE_NAMEDCAPTURE

$fatpacked{"PPIx/Regexp/Structure/Quantifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_QUANTIFIER';
  package PPIx::Regexp::Structure::Quantifier;use strict;use warnings;use base qw{PPIx::Regexp::Structure};use PPIx::Regexp::Constant qw{LITERAL_LEFT_CURLY_ALLOWED};our$VERSION='0.01';sub can_be_quantified {return}sub explain {my ($self)=@_;my$content=$self->content();if ($content =~ m/ \A [{] ( .*? ) [}] \z /smx){my$quant=$1;my ($lo,$hi)=split qr{ , }smx,$quant;defined$hi and '' ne $hi and return "match $lo to $hi times";$quant =~ m/ , \z /smx and return "match $lo or more times";$lo =~ m/ [^0-9] /smx and return "match $lo times";return "match exactly $lo times"}return$self->SUPER::explain()}sub is_quantifier {return 1}sub __following_literal_left_curly_disallowed_in {return LITERAL_LEFT_CURLY_ALLOWED}sub __PPIX_LEXER__record_capture_number {my (undef,$number)=@_;return$number}1;
PPIX_REGEXP_STRUCTURE_QUANTIFIER

$fatpacked{"PPIx/Regexp/Structure/RegexSet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_REGEXSET';
  package PPIx::Regexp::Structure::RegexSet;use strict;use warnings;use base qw{PPIx::Regexp::Structure};use PPIx::Regexp::Constant qw{LITERAL_LEFT_CURLY_REMOVED_PHASE_2};our$VERSION='0.01';sub __following_literal_left_curly_disallowed_in {return LITERAL_LEFT_CURLY_REMOVED_PHASE_2}1;
PPIX_REGEXP_STRUCTURE_REGEXSET

$fatpacked{"PPIx/Regexp/Structure/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_REGEXP';
  package PPIx::Regexp::Structure::Regexp;use strict;use warnings;use base qw{PPIx::Regexp::Structure::Main};our$VERSION='0.01';sub can_be_quantified {return}sub capture_names {my ($self)=@_;my%name;my$captures=$self->find('PPIx::Regexp::Structure::NamedCapture')or return;for my$grab (@{$captures}){$name{$grab->name()}++}return (sort keys%name)}sub explain {return 'Regular expression'}sub max_capture_number {my ($self)=@_;return$self->{max_capture_number}}sub __PPIX_LEXER__finalize {my ($self,$lexer)=@_;my$rslt=0;for my$elem ($self->elements()){$rslt += $elem->__PPIX_LEXER__finalize($lexer)}$self->{max_capture_number}=$self->__PPIX_LEXER__record_capture_number(1)- 1;return$rslt}1;
PPIX_REGEXP_STRUCTURE_REGEXP

$fatpacked{"PPIx/Regexp/Structure/Replacement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_REPLACEMENT';
  package PPIx::Regexp::Structure::Replacement;use strict;use warnings;use base qw{PPIx::Regexp::Structure::Main};our$VERSION='0.01';sub can_be_quantified {return}sub explain {return 'Replacement string or expression'}1;
PPIX_REGEXP_STRUCTURE_REPLACEMENT

$fatpacked{"PPIx/Regexp/Structure/Subexpression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_SUBEXPRESSION';
  package PPIx::Regexp::Structure::Subexpression;use strict;use warnings;use base qw{PPIx::Regexp::Structure};our$VERSION='0.01';1;
PPIX_REGEXP_STRUCTURE_SUBEXPRESSION

$fatpacked{"PPIx/Regexp/Structure/Switch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_SWITCH';
  package PPIx::Regexp::Structure::Switch;use strict;use warnings;use base qw{PPIx::Regexp::Structure};our$VERSION='0.01';sub __PPIX_LEXER__finalize {my ($self,$lexer)=@_;my$rslt=0;my$alternations;if (my$condition=$self->child(0)){for my$class (qw{PPIx::Regexp::Structure::Assertion PPIx::Regexp::Structure::Code PPIx::Regexp::Token::Condition}){$condition->isa($class)or next;$alternations=$condition->content()eq '(DEFINE)' ? 0 : 1;last}}if (defined$alternations){for my$kid ($self->children ()){$kid->isa('PPIx::Regexp::Token::Operator')or next;$kid->content()eq '|' or next;--$alternations >= 0 and next;$kid->__error('Too many alternatives for switch')}}else {$self->__error('Switch condition not understood');$rslt++}$rslt += $self->SUPER::__PPIX_LEXER__finalize($lexer);return$rslt}1;
PPIX_REGEXP_STRUCTURE_SWITCH

$fatpacked{"PPIx/Regexp/Structure/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_STRUCTURE_UNKNOWN';
  package PPIx::Regexp::Structure::Unknown;use strict;use warnings;use base qw{PPIx::Regexp::Structure};our$VERSION='0.01';1;
PPIX_REGEXP_STRUCTURE_UNKNOWN

$fatpacked{"PPIx/Regexp/Support.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_SUPPORT';
  package PPIx::Regexp::Support;use strict;use warnings;use PPIx::Regexp::Util qw{__instance};our$VERSION='0.01';{my%bracket=('('=>')','{'=>'}','<'=>'>','['=>']',);sub close_bracket {my (undef,$char)=@_;defined$char or return;__instance($char,'PPIx::Regexp::Element')and $char=$char->content();return$bracket{$char}}}sub decode {my ($self,$data)=@_;defined$self->{encoding}or return$data;encode_available()or return$data;return Encode::decode($self->{encoding},$data)}sub encode {my ($self,$data)=@_;defined$self->{encoding}or return$data;encode_available()or return$data;return Encode::encode($self->{encoding},$data)}{my$encode_available;sub encode_available {defined$encode_available and return$encode_available;return ($encode_available=eval {require Encode;1}? 1 : 0)}}sub __defined_or {my (undef,@args)=@_;for my$arg (@args){defined$arg and return$arg}return}1;
PPIX_REGEXP_SUPPORT

$fatpacked{"PPIx/Regexp/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN';
  package PPIx::Regexp::Token;use strict;use warnings;use base qw{PPIx::Regexp::Element};use Carp qw{confess};use PPIx::Regexp::Constant qw{MINIMUM_PERL};our$VERSION='0.01';use constant TOKENIZER_ARGUMENT_REQUIRED=>0;sub __new {my ($class,$content,%arg)=@_;not $class->TOKENIZER_ARGUMENT_REQUIRED()or $arg{tokenizer}or confess 'Programming error - tokenizer not provided';my$self={content=>$content,};for my$key (qw{perl_version_introduced}){defined$arg{$key}and $self->{$key}=$arg{$key}}bless$self,ref$class || $class;return$self}sub content {my ($self)=@_;return$self->{content}}sub perl_version_introduced {my ($self)=@_;return defined$self->{perl_version_introduced}? $self->{perl_version_introduced}: MINIMUM_PERL}sub unescaped_content {my ($self)=@_;my$content=$self->content();$content =~ s/ \\ (?= . ) //smxg;return$content}sub __PPIX_LEXER__finalize {return 0}1;
PPIX_REGEXP_TOKEN

$fatpacked{"PPIx/Regexp/Token/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_ASSERTION';
  package PPIx::Regexp::Token::Assertion;use strict;use warnings;use base qw{PPIx::Regexp::Token};use PPIx::Regexp::Constant qw{COOKIE_CLASS LITERAL_LEFT_CURLY_ALLOWED MINIMUM_PERL TOKEN_LITERAL TOKEN_UNKNOWN};our$VERSION='0.01';my@braced_assertions=([qr< \\ [bB] [{] (?: g | gcb | wb | sb ) [}] >smx,'5.021009' ],[qr< \\ [bB] [{] (?: lb ) [}] >smx,'5.023007' ],[qr< \\ [bB] [{] .*? [}] >smx,undef,TOKEN_UNKNOWN,{error=>'Unknown bound type' },],);sub perl_version_introduced {my ($self)=@_;return ($self->{perl_version_introduced}||= $self->_perl_version_introduced())}{my%perl_version_introduced=('\\K'=>'5.009005','\\z'=>'5.005',);sub _perl_version_introduced {my ($self)=@_;my$content=$self->content();for my$item (@braced_assertions){$content =~ m/ \A $item->[0] \z /smx and return$item->[1]}return$perl_version_introduced{$content }|| MINIMUM_PERL}}{my%explanation=('$'=>'Assert position is at end of string or newline','\\A'=>'Assert position is at beginning of string','\\B'=>'Assert position is not at word/nonword boundary','\\B{gcb}'=>'Assert position is not at grapheme cluster boundary','\\B{g}'=>'Assert position is not at grapheme cluster boundary','\\B{lb}'=>'Assert position is not at line boundary','\\B{sb}'=>'Assert position is not at sentence boundary','\\B{wb}'=>'Assert position is not at word boundary','\\G'=>'Assert position is at pos()','\\K'=>'In s///, keep everything before the \\K','\\Z'=>'Assert position is at end of string, or newline before end','\\b'=>'Assert position is at word/nonword boundary','\\b{gcb}'=>'Assert position is at grapheme cluster boundary','\\b{g}'=>'Assert position is at grapheme cluster boundary','\\b{lb}'=>'Assert position is at line boundary','\\b{sb}'=>'Assert position is at sentence boundary','\\b{wb}'=>'Assert position is at word boundary','\\z'=>'Assert position is at end of string','^'=>'Assert position is at beginning of string or after newline',);sub __explanation {return \%explanation}}sub __following_literal_left_curly_disallowed_in {return LITERAL_LEFT_CURLY_ALLOWED}my%assertion=map {$_=>1}qw{^};my%escaped=map {$_=>1}qw{b B A Z z G K};sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;my$make=$tokenizer->cookie(COOKIE_CLASS)? TOKEN_LITERAL : __PACKAGE__;$assertion{$character}and return$tokenizer->make_token(1,$make);$character eq '\\' or return;defined (my$next=$tokenizer->peek(1))or return;if (__PACKAGE__ eq $make){for my$item (@braced_assertions){my$end=$tokenizer->find_regexp(qr/ \A $item->[0] /smx)or next;$item->[2]or return$end;return$tokenizer->make_token($end,$item->[2],$item->[3])}}$escaped{$next}and return$tokenizer->make_token(2,$make);return}1;
PPIX_REGEXP_TOKEN_ASSERTION

$fatpacked{"PPIx/Regexp/Token/Backreference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_BACKREFERENCE';
  package PPIx::Regexp::Token::Backreference;use strict;use warnings;use base qw{PPIx::Regexp::Token::Reference};use Carp qw{confess};use PPIx::Regexp::Constant qw{MINIMUM_PERL RE_CAPTURE_NAME TOKEN_LITERAL TOKEN_UNKNOWN};use PPIx::Regexp::Util qw{__to_ordinal_en};our$VERSION='0.01';sub explain {my ($self)=@_;$self->is_named()and return sprintf q<Back reference to capture group '%s'>,$self->name();$self->is_relative()and return sprintf q<Back reference to %s previous capture group (%d in this regexp)>,__to_ordinal_en(- $self->number()),$self->absolute();return sprintf q<Back reference to capture group %d>,$self->absolute()}{my%perl_version_introduced=(g=>'5.009005',k=>'5.009005','?'=>'5.009005',);sub perl_version_introduced {my ($self)=@_;return$perl_version_introduced{substr($self->content(),1,1)}|| MINIMUM_PERL}}my@external=([qr{ \A \( \? P = ( @{[ RE_CAPTURE_NAME ]} ) \) }smxo,{is_named=>1 },],);my@recognize_regexp=([qr{ \A \\ (?:		# numbered (including relative)
  	    ( \d+ )	|
  	    g (?: ( -? \d+ ) | \{ ( -? \d+ ) \} )
  	)
  	}smx,{is_named=>0 },],[qr{ \A \\ (?:		# named
  	    g [{] ( @{[ RE_CAPTURE_NAME ]} ) [}] |
  	    k (?: \< ( @{[ RE_CAPTURE_NAME ]} ) \> |	# named with angles
  		' ( @{[ RE_CAPTURE_NAME ]} ) ' )	#   or quotes
  	)
  	}smxo,{is_named=>1 },],);my%recognize=(regexp=>\@recognize_regexp,repl=>[[qr{ \A \\ ( \d+ ) }smx,{is_named=>0 }],],);sub __PPIX_TOKEN__recognize {return __PACKAGE__->isa(scalar caller)? (@external,@recognize_regexp): (@external)}sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;$character eq '\\' or return;for (@{$recognize{$tokenizer->get_mode()}}){my ($re,$arg)=@{$_};my$accept=$tokenizer->find_regexp($re)or next;my%arg=(%{$arg},tokenizer=>$tokenizer);return$tokenizer->make_token($accept,__PACKAGE__,\%arg)}return}sub __PPIX_TOKENIZER__repl {my (undef,$tokenizer)=@_;$tokenizer->interpolates()or return;goto&__PPIX_TOKENIZER__regexp}sub __PPIX_LEXER__rebless {my ($self,%arg)=@_;if ($self->is_named()){$arg{capture_name}{$self->name()}and return 0;return$self->__error()}my$absolute=$self->absolute();$absolute <= 0 and return$self->__error();$absolute <= $arg{max_capture}and return 0;my$content=$self->content();if ($content =~ m/ \A \\ [0-7]{2,} \z /smx){bless$self,TOKEN_LITERAL;return 0}return$self->__error()}sub __error {my ($self,$msg)=@_;defined$msg or $msg='No corresponding capture group';$self->{error}=$msg;bless$self,TOKEN_UNKNOWN;return 1}1;
PPIX_REGEXP_TOKEN_BACKREFERENCE

$fatpacked{"PPIx/Regexp/Token/Backtrack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_BACKTRACK';
  package PPIx::Regexp::Token::Backtrack;use strict;use warnings;use base qw{PPIx::Regexp::Token};our$VERSION='0.01';sub can_be_quantified {return};{my%explanation=(ACCEPT=>'Causes match to succeed at the point of the (*ACCEPT)',COMMIT=>'Causes match failure when backtracked into on failure',FAIL=>'Always fails, forcing backtrack',MARK=>'Name branches of alternation, target for (*SKIP)',PRUNE=>'Prevent backtracking past here on failure',SKIP=>'Like (*PRUNE) but also discards match to this point',THEN=>'Force next alternation on failure',);sub explain {my ($self)=@_;my$verb=$self->verb();defined(my$expl=$explanation{$verb})or return$self->__no_explanation();return$expl}my%synonym=(''=>'MARK',F=>'FAIL',);sub arg {my ($self)=@_;my$content=$self->content();$content =~ s/ [^:]* //smx;$content =~ s/ \) //smx;return$content}sub verb {my ($self)=@_;my$content=$self->content();$content =~ s/ \( \* //smx;$content =~ s/ [:)] .* //smx;defined(my$syn=$synonym{$content})or return$content;return$syn}}sub perl_version_introduced {return '5.009005'}sub __PPIX_TOKEN__recognize {return ([qr{ \A \( \* [^\)]* \) }smx ])}1;
PPIX_REGEXP_TOKEN_BACKTRACK

$fatpacked{"PPIx/Regexp/Token/CharClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_CHARCLASS';
  package PPIx::Regexp::Token::CharClass;use strict;use warnings;use base qw{PPIx::Regexp::Token};our$VERSION='0.01';1;
PPIX_REGEXP_TOKEN_CHARCLASS

$fatpacked{"PPIx/Regexp/Token/CharClass/POSIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_CHARCLASS_POSIX';
  package PPIx::Regexp::Token::CharClass::POSIX;use strict;use warnings;use base qw{PPIx::Regexp::Token::CharClass};use PPIx::Regexp::Constant qw{COOKIE_CLASS COOKIE_REGEX_SET MINIMUM_PERL};our$VERSION='0.01';sub perl_version_introduced {return '5.006'}{my%explanation=('[:alnum:]'=>'Any alphanumeric character','[:alpha:]'=>'Match alphabetic','[:ascii:]'=>'Any character in the ASCII character set','[:blank:]'=>'A GNU extension, equal to a space or a horizontal tab ("\\t")','[:cntrl:]'=>'Any control character','[:digit:]'=>'Any decimal digit ("[0-9]")','[:graph:]'=>'Any printable character, excluding a space','[:lower:]'=>'Any lowercase character','[:print:]'=>'Any printable character','[:punct:]'=>'Any graphical character excluding "word" characters','[:space:]'=>'Any whitespace character','[:upper:]'=>'Any uppercase character','[:word:]'=>'A Perl extension, equivalent to "\\w"','[:xdigit:]'=>'Any hexadecimal digit',);sub __explanation {return \%explanation}sub __no_explanation {my$msg=sprintf q<Unknown POSIX character class>;return$msg}}{my%class=(':'=>__PACKAGE__,);sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer)=@_;$tokenizer->cookie(COOKIE_CLASS)or $tokenizer->cookie(COOKIE_REGEX_SET)or return;if (my$accept=$tokenizer->find_regexp(qr{ \A [[] ( [.=:] ) \^? .*? \1 []] }smx)){my ($punc)=$tokenizer->capture();return$tokenizer->make_token($accept,$class{$punc}|| __PACKAGE__ .'::Unknown')}return}}1;
PPIX_REGEXP_TOKEN_CHARCLASS_POSIX

$fatpacked{"PPIx/Regexp/Token/CharClass/POSIX/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_CHARCLASS_POSIX_UNKNOWN';
  package PPIx::Regexp::Token::CharClass::POSIX::Unknown;use 5.006;use strict;use warnings;use base qw{PPIx::Regexp::Token::CharClass::POSIX};use PPIx::Regexp::Constant qw{MINIMUM_PERL};our$VERSION='0.01';sub perl_version_introduced {return MINIMUM_PERL}sub __PPIX_LEXER__finalize {return 1}1;
PPIX_REGEXP_TOKEN_CHARCLASS_POSIX_UNKNOWN

$fatpacked{"PPIx/Regexp/Token/CharClass/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_CHARCLASS_SIMPLE';
  package PPIx::Regexp::Token::CharClass::Simple;use strict;use warnings;use base qw{PPIx::Regexp::Token::CharClass};use PPIx::Regexp::Constant qw{COOKIE_CLASS LITERAL_LEFT_CURLY_REMOVED_PHASE_1 LITERAL_LEFT_CURLY_REMOVED_PHASE_2 MINIMUM_PERL TOKEN_LITERAL TOKEN_UNKNOWN};our$VERSION='0.01';{my%kind_of_match=(p=>'with',P=>'without',);my%explanation=('.'=>'Match any character','\\C'=>'Match a single octet (removed in 5.23.0)','\\D'=>'Match any character but a decimal digit','\\H'=>'Match a non-horizontal-white-space character','\\N'=>'Match any character but a new-line character','\\R'=>'Match a generic new-line character','\\S'=>'Match non-white-space character','\\V'=>'Match a non-vertical-white-space character','\\W'=>'Match non-word character','\\X'=>'Match a Unicode extended grapheme cluster','\\d'=>'Match decimal digit','\\h'=>'Match a horizontal-white-space character','\\s'=>'Match white-space character','\\v'=>'Match a vertical-white-space character','\\w'=>'Match word character',);sub __explanation {return \%explanation}sub explain {my ($self)=@_;if ($self->content()=~ m/ \A \\ ( [Pp] ) [{] ( .* ) [}] \z /smx){return sprintf q<Match character %s Unicode or custom property '%s'>,$kind_of_match{$1},$2}return$self->SUPER::explain()}}{my%introduced=('\\h'=>'5.009005','\\v'=>'5.009005','\\H'=>'5.009005','\\N'=>'5.011','\\V'=>'5.009005','\\R'=>'5.009005','\\C'=>'5.006','\\X'=>'5.006',);sub perl_version_introduced {my ($self)=@_;my$content=$self->content();if (defined(my$minver=$introduced{$content})){return$minver}if ($content =~ m/ \A \\ [Pp] /smxg){return '5.006001'}return MINIMUM_PERL}}{my%removed=('\\C'=>'5.023',);sub perl_version_removed {my ($self)=@_;return$removed{$self->content()}}}sub __following_literal_left_curly_disallowed_in {my ($self)=@_;q<.> eq (my$content=$self->content())and return LITERAL_LEFT_CURLY_REMOVED_PHASE_2;$content =~ m/ \A \\ p \{ /smxi and return LITERAL_LEFT_CURLY_REMOVED_PHASE_2;return LITERAL_LEFT_CURLY_REMOVED_PHASE_1}sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;my$in_class=$tokenizer->cookie(COOKIE_CLASS);if ($character eq '.'){$in_class and return$tokenizer->make_token(1,TOKEN_LITERAL);return 1}if (my$accept=$tokenizer->find_regexp(qr{ \A \\ (?:
  		[wWsSdDvVhHXRNC] |
  		[Pp] \{ \s* \^? [\w:=\s-]+ \}
  	    ) }smx)){if ($in_class){my$match=$tokenizer->match();'\\N' eq $match and return$tokenizer->make_token($accept,TOKEN_UNKNOWN,{error=>'\\N invalid inside character class',},);'\\R' eq $match and return}return$accept}return}1;
PPIX_REGEXP_TOKEN_CHARCLASS_SIMPLE

$fatpacked{"PPIx/Regexp/Token/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_CODE';
  package PPIx::Regexp::Token::Code;use strict;use warnings;use base qw{PPIx::Regexp::Token};use PPI::Document;use PPIx::Regexp::Constant qw{COOKIE_REGEX_SET};use PPIx::Regexp::Util qw{__instance};our$VERSION='0.01';use constant TOKENIZER_ARGUMENT_REQUIRED=>1;use constant VERSION_WHEN_IN_REGEX_SET=>undef;sub __new {my ($class,$content,%arg)=@_;defined$arg{perl_version_introduced}or $arg{perl_version_introduced}='5.005';my$self=$class->SUPER::__new($content,%arg);if ($arg{tokenizer}->cookie(COOKIE_REGEX_SET)){my$ver=$self->VERSION_WHEN_IN_REGEX_SET()or return$self->__error('Code token not valid in Regex set');$self->{perl_version_introduced}< $ver and $self->{perl_version_introduced}=$ver}$arg{tokenizer}->__recognize_postderef($self)and $self->{perl_version_introduced}< 5.019005 and $self->{perl_version_introduced}='5.019005';return$self}sub content {my ($self)=@_;if (exists$self->{content}){return$self->{content}}elsif (exists$self->{ppi}){return ($self->{content}=$self->{ppi}->content())}else {return}}sub explain {return 'Perl expression'}sub ppi {my ($self)=@_;if (exists$self->{ppi}){return$self->{ppi}}elsif (exists$self->{content}){return ($self->{ppi}=PPI::Document->new(\($self->{content}),readonly=>1))}else {return}}{no warnings qw{qw};my%accept=map {$_=>1}qw{$ $# @ % & *};sub __postderef_accept_cast {return \%accept}}sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;$character eq '{' or return;my$offset=$tokenizer->find_matching_delimiter()or return;return$offset + 1}1;
PPIX_REGEXP_TOKEN_CODE

$fatpacked{"PPIx/Regexp/Token/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_COMMENT';
  package PPIx::Regexp::Token::Comment;use strict;use warnings;use base qw{PPIx::Regexp::Token};our$VERSION='0.01';sub can_be_quantified {return};sub significant {return}sub comment {return 1}sub explain {return 'Comment'}sub __PPIX_TOKEN__recognize {return ([qr{ \A \( \? \# [^\)]* \) }smx ])}1;
PPIX_REGEXP_TOKEN_COMMENT

$fatpacked{"PPIx/Regexp/Token/Condition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_CONDITION';
  package PPIx::Regexp::Token::Condition;use strict;use warnings;use base qw{PPIx::Regexp::Token::Reference};use PPIx::Regexp::Constant qw{RE_CAPTURE_NAME};our$VERSION='0.01';{my%explanation=('(DEFINE)'=>'Define a group to be recursed into','(R)'=>'True if recursing',);sub explain {my ($self)=@_;my$content=$self->content();if (defined(my$expl=$explanation{$content})){return$expl}if ($content =~ m/ \A [(] R /smx){$self->is_named()and return sprintf q<True if recursing directly inside capture group '%s'>,$self->name();return sprintf q<True if recursing directly inside capture group %d>,$self->absolute()}$self->is_named()and return sprintf q<True if capture group '%s' matched>,$self->name();return sprintf q<True if capture group %d matched>,$self->absolute()}}sub perl_version_introduced {my ($self)=@_;$self->content()=~ m/ \A [(] \d+ [)] \z /smx and return '5.005';return '5.009005'}my@recognize=([qr{ \A \( (?: ( \d+ ) | R (\d+) ) \) }smx,{is_named=>0 }],[qr{ \A \( R \) }smx,{is_named=>0,capture=>'0' }],[qr{ \A \( (?: < ( @{[ RE_CAPTURE_NAME ]} ) > |
  	    ' ( @{[ RE_CAPTURE_NAME ]} ) ' |
  	    R & ( @{[ RE_CAPTURE_NAME ]} ) ) \) }smxo,{is_named=>1}],[qr{ \A \( DEFINE \) }smx,{is_named=>0,capture=>'0' }],);sub __PPIX_TOKEN__recognize {return@recognize}sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer)=@_;for (@recognize){my ($re,$arg)=@{$_};my$accept=$tokenizer->find_regexp($re)or next;return$tokenizer->make_token($accept,__PACKAGE__,$arg)}return}1;
PPIX_REGEXP_TOKEN_CONDITION

$fatpacked{"PPIx/Regexp/Token/Control.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_CONTROL';
  package PPIx::Regexp::Token::Control;use strict;use warnings;use base qw{PPIx::Regexp::Token};use PPIx::Regexp::Constant qw{COOKIE_QUOTE MINIMUM_PERL TOKEN_LITERAL TOKEN_UNKNOWN};our$VERSION='0.01';{my%explanation=('\\E'=>'End of interpolation control','\\F'=>'Fold case until \\E','\\L'=>'Lowercase until \\E','\\Q'=>'Quote metacharacters until \\E','\\U'=>'Uppercase until \\E','\\l'=>'Lowercase next character','\\u'=>'Uppercase next character',);sub __explanation {return \%explanation}}{my%version_introduced=('\\F'=>'5.015008',);sub perl_version_introduced {my ($self)=@_;my$content=$self->content();defined$version_introduced{$content}and return$version_introduced{$content};return MINIMUM_PERL}}my%is_control=map {$_=>1}qw{l u L U Q E F};my%cookie_slot=(Q=>'quote',E=>'end',U=>'case',L=>'case',F=>'case',);use constant CONTROL_MASK_QUOTE=>1 << 1;my%cookie_mask=(case=>1 << 0,end=>0,quote=>CONTROL_MASK_QUOTE,);sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;my$in_quote=$tokenizer->cookie(COOKIE_QUOTE)|| do {my@stack=({mask=>0,reject=>sub {return}});$tokenizer->cookie(COOKIE_QUOTE,sub {return \@stack})};my$cookie_stack=$in_quote->($tokenizer);my$reject=$cookie_stack->[-1]{reject};$character eq '\\' or return$reject->(1);my$control=$tokenizer->peek(1)or return$reject->(1,TOKEN_UNKNOWN,{error=>'Trailing back slash' },);$is_control{$control}or return$reject->(2);my$token=$tokenizer->make_token(2);if (my$slot=$cookie_slot{$control}){if (my$mask=$cookie_mask{$slot}){unless ($mask & $cookie_stack->[-1]{mask}){push @{$cookie_stack},{%{$cookie_stack->[-1]}};$cookie_stack->[-1]{mask}|= $mask;$cookie_stack->[-1]{reject}=($mask & CONTROL_MASK_QUOTE)? sub {my ($size,$class)=@_;return$tokenizer->make_token($size,$class || TOKEN_LITERAL)}: $cookie_stack->[0]{reject}}}else {@{$cookie_stack}> 1 and pop @{$cookie_stack}}}return$token}sub __PPIX_TOKENIZER__repl {my (undef,$tokenizer)=@_;$tokenizer->interpolates()and goto&__PPIX_TOKENIZER__regexp;return}1;
PPIX_REGEXP_TOKEN_CONTROL

$fatpacked{"PPIx/Regexp/Token/Delimiter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_DELIMITER';
  package PPIx::Regexp::Token::Delimiter;use strict;use warnings;use base qw{PPIx::Regexp::Token::Structure};our$VERSION='0.01';sub explain {return 'Regular expression or replacement string delimiter'}1;
PPIX_REGEXP_TOKEN_DELIMITER

$fatpacked{"PPIx/Regexp/Token/Greediness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GREEDINESS';
  package PPIx::Regexp::Token::Greediness;use strict;use warnings;use base qw{PPIx::Regexp::Token};use PPIx::Regexp::Constant qw{MINIMUM_PERL};our$VERSION='0.01';sub can_be_quantified {return};{my%explanation=('+'=>'match longest string and give nothing back','?'=>'match shortest string first',);sub __explanation {return \%explanation}}my%greediness=('?'=>MINIMUM_PERL,'+'=>'5.009005',);sub could_be_greediness {my (undef,$string)=@_;return$greediness{$string}}sub perl_version_introduced {my ($self)=@_;return$greediness{$self->content()}|| MINIMUM_PERL}sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;$tokenizer->prior_significant_token('is_quantifier')or return;$greediness{$character}or return;return length$character}1;
PPIX_REGEXP_TOKEN_GREEDINESS

$fatpacked{"PPIx/Regexp/Token/GroupType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GROUPTYPE';
  package PPIx::Regexp::Token::GroupType;use strict;use warnings;use base qw{PPIx::Regexp::Token};our$VERSION='0.01';sub can_be_quantified {return};sub __defining_string {require Carp;Carp::confess('Programming error - __defining_string() must be overridden')}sub __make_group_type_matcher {my ($class)=@_;my@defs=$class->__defining_string();my$opt=ref$defs[0]? shift@defs : {};my$suffix=defined$opt->{suffix}? qr/ (?= \Q$opt->{suffix}\E ) /smx : '';my%seen;my@chars=grep {!$seen{$_}++}split qr{}smx,join '',@defs;my%rslt;for my$str (@defs){push @{$rslt{''}||= []},qr{ \A \Q$str\E $suffix }smx;for my$chr (@chars){(my$expr=$str)=~ s/ (?= \Q$chr\E ) /\\/smxg;push @{$rslt{$chr}||= []},qr{ \A \Q$expr\E $suffix }smx}}return \%rslt}sub __match_setup {return}my%matcher;sub __PPIX_TOKENIZER__regexp {my ($class,$tokenizer)=@_;my$mtch=$matcher{$class}||= $class->__make_group_type_matcher();my$re_list=$mtch->{$tokenizer->get_start_delimiter()}|| $mtch->{''};for my$re (@{$re_list}){my$accept=$tokenizer->find_regexp($re)or next;$class->__match_setup($tokenizer);return$accept}return}1;
PPIX_REGEXP_TOKEN_GROUPTYPE

$fatpacked{"PPIx/Regexp/Token/GroupType/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GROUPTYPE_ASSERTION';
  package PPIx::Regexp::Token::GroupType::Assertion;use strict;use warnings;use base qw{PPIx::Regexp::Token::GroupType};use PPIx::Regexp::Constant qw{MINIMUM_PERL};our$VERSION='0.01';{my%explanation=('?!'=>'Negative look-ahead assertion','?<!'=>'Negative look-behind assertion','?<='=>'Positive look-behind assertion','?='=>'Positive look-ahead assertion',);sub __explanation {return \%explanation}}{my%perl_version_introduced=('?<='=>'5.005','?<!'=>'5.005',);sub perl_version_introduced {my ($self)=@_;return$perl_version_introduced{$self->unescaped_content()}|| MINIMUM_PERL}}sub __defining_string {return ('?=','?<=','?!','?<!')}1;
PPIX_REGEXP_TOKEN_GROUPTYPE_ASSERTION

$fatpacked{"PPIx/Regexp/Token/GroupType/BranchReset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GROUPTYPE_BRANCHRESET';
  package PPIx::Regexp::Token::GroupType::BranchReset;use strict;use warnings;use base qw{PPIx::Regexp::Token::GroupType};our$VERSION='0.01';{my%explanation=('?|'=>'Re-use capture group numbers',);sub __explanation {return \%explanation}}sub perl_version_introduced {return '5.009005'}sub __defining_string {return '?|'}1;
PPIX_REGEXP_TOKEN_GROUPTYPE_BRANCHRESET

$fatpacked{"PPIx/Regexp/Token/GroupType/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GROUPTYPE_CODE';
  package PPIx::Regexp::Token::GroupType::Code;use strict;use warnings;use base qw{PPIx::Regexp::Token::GroupType};use PPIx::Regexp::Constant qw{MINIMUM_PERL};our$VERSION='0.01';{my%explanation=('??'=>'Evaluate code, use as regexp at this point','?p'=>'Evaluate code, use as regexp at this point (removed in 5.9.5)','?'=>'Evaluate code. Always matches.',);sub __explanation {return \%explanation}}{my%perl_version_introduced=('?'=>'5.005','?p'=>'5.005','??'=>'5.006',);sub perl_version_introduced {my ($self)=@_;return$perl_version_introduced{$self->unescaped_content()}|| '5.005'}}{my%perl_version_removed=('?p'=>'5.009005',);sub perl_version_removed {my ($self)=@_;return$perl_version_removed{$self->content()}}}sub __defining_string {return ({suffix=>'{' },'?','??','?p',)}sub __match_setup {my (undef,$tokenizer)=@_;$tokenizer->expect(qw{PPIx::Regexp::Token::Code});return}1;
PPIX_REGEXP_TOKEN_GROUPTYPE_CODE

$fatpacked{"PPIx/Regexp/Token/GroupType/Modifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GROUPTYPE_MODIFIER';
  package PPIx::Regexp::Token::GroupType::Modifier;use strict;use warnings;use base qw{PPIx::Regexp::Token::Modifier PPIx::Regexp::Token::GroupType};use PPIx::Regexp::Constant qw{MINIMUM_PERL};our$VERSION='0.01';{my%perl_version_introduced=('?:'=>MINIMUM_PERL,);sub perl_version_introduced {my ($self)=@_;my$content=$self->unescaped_content();exists$perl_version_introduced{$content}and return$perl_version_introduced{$content};my$ver=$self->SUPER::perl_version_introduced();$ver > 5.005 and return$ver;return '5.005'}}sub __make_group_type_matcher {return {''=>[qr{ \A [?] [[:lower:]]* -? [[:lower:]]* : }smx,qr{ \A [?] \^ [[:lower:]]* : }smx,],'?'=>[qr{ \A \\ [?] [[:lower:]]* -? [[:lower:]]* : }smx,qr{ \A \\ [?] \^ [[:lower:]]* : }smx,],'-'=>[qr{ \A [?] [[:lower:]]* (?: \\ - )? [[:lower:]]* : }smx,qr{ \A [?] \^ [[:lower:]]* : }smx,],':'=>[qr{ \A [?] [[:lower:]]*  -? [[:lower:]]* \\ : }smx,qr{ \A [?] \^ [[:lower:]]* \\ : }smx,],}}1;
PPIX_REGEXP_TOKEN_GROUPTYPE_MODIFIER

$fatpacked{"PPIx/Regexp/Token/GroupType/NamedCapture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GROUPTYPE_NAMEDCAPTURE';
  package PPIx::Regexp::Token::GroupType::NamedCapture;use strict;use warnings;use base qw{PPIx::Regexp::Token::GroupType};use Carp qw{confess};use PPIx::Regexp::Constant qw{RE_CAPTURE_NAME};our$VERSION='0.01';use constant TOKENIZER_ARGUMENT_REQUIRED=>1;sub __new {my ($class,$content,%arg)=@_;defined$arg{perl_version_introduced}or $arg{perl_version_introduced}='5.009005';my$self=$class->SUPER::__new($content,%arg);for my$name ($arg{tokenizer}->capture()){defined$name or next;$self->{name}=$name;return$self}confess 'Programming error - can not figure out capture name'}sub explain {my ($self)=@_;return sprintf q<Capture match into '%s'>,$self->name()}sub name {my ($self)=@_;return$self->{name}}sub __make_group_type_matcher {return {''=>[qr/ \A [?] P? < ( @{[ RE_CAPTURE_NAME ]} ) > /smxo,qr/ \A [?] ' ( @{[ RE_CAPTURE_NAME ]} ) ' /smxo,],'?'=>[qr/ \A \\ [?] P? < ( @{[ RE_CAPTURE_NAME ]} ) > /smxo,qr/ \A \\ [?] ' ( @{[ RE_CAPTURE_NAME ]} ) ' /smxo,],q{'}=>[qr/ \A [?] P? < ( @{[ RE_CAPTURE_NAME ]} ) > /smxo,qr/ \A [?] \\ ' ( @{[ RE_CAPTURE_NAME ]} ) \\ ' /smxo,],}}1;
PPIX_REGEXP_TOKEN_GROUPTYPE_NAMEDCAPTURE

$fatpacked{"PPIx/Regexp/Token/GroupType/Subexpression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GROUPTYPE_SUBEXPRESSION';
  package PPIx::Regexp::Token::GroupType::Subexpression;use strict;use warnings;use base qw{PPIx::Regexp::Token::GroupType};our$VERSION='0.01';{my%explanation=('?>'=>'Match subexpression without backtracking',);sub __explanation {return \%explanation}}sub perl_version_introduced {return '5.005'}sub __defining_string {return '?>'}1;
PPIX_REGEXP_TOKEN_GROUPTYPE_SUBEXPRESSION

$fatpacked{"PPIx/Regexp/Token/GroupType/Switch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_GROUPTYPE_SWITCH';
  package PPIx::Regexp::Token::GroupType::Switch;use strict;use warnings;use base qw{PPIx::Regexp::Token::GroupType};our$VERSION='0.01';{my%explanation=('?'=>q<Match one of the following '|'-delimited alternatives>,);sub __explanation {return \%explanation}}sub perl_version_introduced {return '5.005'}sub __defining_string {return ({suffix=>'(' },'?',)}sub __match_setup {my (undef,$tokenizer)=@_;$tokenizer->expect(qw{PPIx::Regexp::Token::Condition});return}1;
PPIX_REGEXP_TOKEN_GROUPTYPE_SWITCH

$fatpacked{"PPIx/Regexp/Token/Interpolation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_INTERPOLATION';
  package PPIx::Regexp::Token::Interpolation;use strict;use warnings;use base qw{PPIx::Regexp::Token::Code};use Carp qw{confess};use PPI::Document;use PPIx::Regexp::Constant qw{COOKIE_CLASS COOKIE_REGEX_SET TOKEN_LITERAL MINIMUM_PERL};our$VERSION='0.01';use constant VERSION_WHEN_IN_REGEX_SET=>'5.017009';sub __new {my ($class,$content,%arg)=@_;defined$arg{perl_version_introduced}or $arg{perl_version_introduced}=MINIMUM_PERL;my$self=$class->SUPER::__new($content,%arg);return$self}sub perl_version_introduced {my ($self)=@_;return$self->{perl_version_introduced}}sub ppi {my ($self)=@_;if (exists$self->{ppi}){return$self->{ppi}}elsif (exists$self->{content}){(my$code=$self->{content})=~ s/ \A ( [\@\$] ) [{] ( .* ) [}] \z /$1$2/smx;return ($self->{ppi}=PPI::Document->new(\$code,readonly=>1))}else {return}}my$interp_re=qr{ \A (?= [\@\$]? \$ [-\w&`'+^./\\";%=~:?!\@\$<>\[\]\{\},#] |
  		   \@ [\w\{] )
  	}smx;my$brkt_interp_re=qr{ \A (?: [\@\$] \$* [#]? \$* [\{] (?: [][\-&`'+,^./\\";%=:?\@\$<>,#] |
  		\^? \w+ (?: :: \w+ )* ) [\}] |
  	    \@ [\{] \w+ (?: :: \w+ )* [\}] )
      }smx;my%allow_subscript_based_on_cast_symbol=(q<$#>=>0,q<$>=>1,q<@>=>1,);sub _interpolation {my ($class,$tokenizer,undef,$in_regexp)=@_;$tokenizer->interpolates()or return;if (my$len=$tokenizer->find_regexp($brkt_interp_re)){return$len}defined$tokenizer->find_regexp($interp_re)or return;my$doc=$tokenizer->ppi_document()or return;my$stmt=$doc->find_first('PPI::Statement')or return;my@accum;my$allow_subscript;my$next=$stmt->schild(0)or return;if ($next->isa('PPI::Token::Symbol')){push@accum,$next;$allow_subscript=1}elsif ($next->isa('PPI::Token::Cast')){push@accum,$next;$next=$next->next_sibling()or return;if ($next->isa('PPI::Token::Symbol')){defined ($allow_subscript=$allow_subscript_based_on_cast_symbol{$accum[-1]->content()})or return;push@accum,$next}elsif ($next->isa('PPI::Structure::Block')){push@accum,$next}else {return}}elsif ($next->isa('PPI::Token::ArrayIndex')){push@accum,$next}else {return}{$allow_subscript and $next=$next->snext_sibling()or last;my@subscr;if ($next->isa('PPI::Token::Operator')){$next->content()eq '->' or last;push@subscr,$next;$next=$next->next_sibling()or last;if (my$deref=$tokenizer->__recognize_postderef(__PACKAGE__,$next)){push@accum,@subscr,$deref;last}}$next->isa('PPI::Structure::Subscript')or last;$next->finish()or last;not $in_regexp or $class->_subscript($next)or last;push@accum,@subscr,$next;redo}my$length=0;for (@accum){$length += ref $_ ? length $_->content(): $_}return$length}{no warnings qw{qw};my%accept=map {$_=>1}qw{$ $# @};sub __postderef_accept_cast {return \%accept}}{my%allowed=('['=>'_square','{'=>'_curly',);sub _subscript {my ($class,$struct)=@_;my$left=$struct->start()or return;my$lc=$left->content();my$handler=$allowed{$lc}or return;(my@kids=$struct->schildren())==1 or return;$kids[0]->isa('PPI::Statement')or return;(@kids=$kids[0]->schildren())or return;return$class->$handler(@kids)}}sub _curly {my (undef,@kids)=@_;if ($kids[0]->isa('PPI::Token::Word')){@kids==1 and return 1;$kids[1]->isa('PPI::Token::Operator')and $kids[1]->content()eq '=>' and return 1}if (@kids && $kids[0]->isa('PPI::Token::Symbol')){@kids==1 and return 1;@kids==2 and $kids[1]->isa('PPI::Structure::Subscript')and return 1}return}sub _square {my (undef,@kids)=@_;$kids[0]->isa('PPI::Token::Number')and return 1;$kids[0]->isa('PPI::Token::Symbol')and return 1;return}my%sigil_alternate=('$'=>['PPIx::Regexp::Token::Assertion',TOKEN_LITERAL ],'@'=>[TOKEN_LITERAL,TOKEN_LITERAL ],);sub __PPIX_TOKENIZER__regexp {my ($class,$tokenizer,$character)=@_;exists$sigil_alternate{$character}or return;if (my$accept=$class->_interpolation($tokenizer,$character,1)){return$accept}my$alternate=$sigil_alternate{$character}or return;return$tokenizer->make_token(1,$alternate->[$tokenizer->cookie(COOKIE_CLASS)? 1 : 0 ])}sub __PPIX_TOKENIZER__repl {my ($class,$tokenizer,$character)=@_;exists$sigil_alternate{$character}or return;if (my$accept=$class->_interpolation($tokenizer,$character,0)){return$accept}return$tokenizer->make_token(1,TOKEN_LITERAL)}1;
PPIX_REGEXP_TOKEN_INTERPOLATION

$fatpacked{"PPIx/Regexp/Token/Literal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_LITERAL';
  package PPIx::Regexp::Token::Literal;use strict;use warnings;use base qw{PPIx::Regexp::Token};use PPIx::Regexp::Constant qw{COOKIE_CLASS COOKIE_REGEX_SET LITERAL_LEFT_CURLY_ALLOWED MINIMUM_PERL MSG_PROHIBITED_BY_STRICT TOKEN_UNKNOWN};our$VERSION='0.01';sub explain {return 'Literal character'}sub perl_version_introduced {my ($self)=@_;exists$self->{perl_version_introduced}and return$self->{perl_version_introduced};(my$content=$self->content())=~ m/ \A \\ o /smx and return ($self->{perl_version_introduced}='5.013003');$content =~ m/ \A \\ N [{] U [+] /smx and return ($self->{perl_version_introduced}='5.008');$content =~ m/ \A \\ x [{] /smx and return ($self->{perl_version_introduced}='5.006');$content =~ m/ \A \\ N /smx and return ($self->{perl_version_introduced}='5.006001');return ($self->{perl_version_introduced}=MINIMUM_PERL)}{my%removed=(q<{>=>sub {my ($self)=@_;my$prev=$self->sprevious_sibling()or return LITERAL_LEFT_CURLY_ALLOWED;return$prev->__following_literal_left_curly_disallowed_in()},);sub perl_version_removed {my ($self)=@_;exists$self->{perl_version_removed}and return$self->{perl_version_removed};my$code;return ($self->{perl_version_removed}=($code=$removed{$self->content()})? scalar$code->($self): undef)}}my%double_agent=('.'=>[undef,1 ],'*'=>[undef,1 ],'?'=>[undef,1 ],'+'=>[undef,1 ],'-'=>[1,undef ],'|'=>[undef,1 ],);my%extra_ordinary=map {$_=>1}split qr{}smx,'$@*+?.\\(){}[]^|-#';my%regex_set_operator=map {$_=>1}qw{& + | - ^ !};my$white_space_re=$] >= 5.008 ? 'qr< \\A [\\t\\n\\cK\\f\\r \\N{U+0085}\\N{U+200E}\\N{U+200F}\\N{U+2028}\\N{U+2029}]+ >smx' : 'qr< \\A [\\t\\n\\cK\\f\\r ]+ >smx';$white_space_re=eval$white_space_re;my%regex_pass_on=map {$_=>1}qw{[ ] ( ) $ \};sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;if ($tokenizer->cookie(COOKIE_REGEX_SET)){$regex_set_operator{$character}and return$tokenizer->make_token(length$character,'PPIx::Regexp::Token::Operator');my$accept;$accept=$tokenizer->find_regexp($tokenizer->cookie(COOKIE_CLASS)? qr{ \A [ \t] }smx : $white_space_re)and return$tokenizer->make_token($accept,'PPIx::Regexp::Token::Whitespace');$accept=_escaped($tokenizer,$character)and return$accept;$regex_pass_on{$character}and return;return$tokenizer->cookie(COOKIE_CLASS)? length$character : $tokenizer->make_token(length$character,TOKEN_UNKNOWN,{error=>'Literal not valid in Regex set',},)}else {if (my$class=$double_agent{$character}){my$inx=$tokenizer->cookie(COOKIE_CLASS)? 1 : 0;return$class->[$inx]}}if ($tokenizer->modifier('x*')&& !$tokenizer->cookie(COOKIE_CLASS)){my$accept;$accept=$tokenizer->find_regexp($white_space_re)and return$tokenizer->make_token($accept,'PPIx::Regexp::Token::Whitespace');$accept=$tokenizer->find_regexp(qr{ \A \# [^\n]* (?: \n | \z) }smx)and return$tokenizer->make_token($accept,'PPIx::Regexp::Token::Comment')}elsif ($tokenizer->modifier('xx')&& $tokenizer->cookie(COOKIE_CLASS)){my$accept;$accept=$tokenizer->find_regexp(qr{ \A [ \t] }smx)and return$tokenizer->make_token($accept,'PPIx::Regexp::Token::Whitespace',{perl_version_introduced=>'5.025009' },)}else {($character eq '#' || $character =~ m/ \A \s \z /smx)and return 1}my$accept;$accept=_escaped($tokenizer,$character)and return$accept;$extra_ordinary{$character}or return 1;return}{my%special=('\\N{}'=>sub {my ($tokenizer,$accept)=@_;$tokenizer->strict()or return$tokenizer->make_token($accept,'PPIx::Regexp::Token::NoOp');return$tokenizer->make_token($accept,TOKEN_UNKNOWN,{error=>join(' ','Empty Unicode character name',MSG_PROHIBITED_BY_STRICT),perl_version_introduced=>'5.023008',},)},);sub _escaped {my ($tokenizer,$character)=@_;$character eq '\\' or return;if (my$accept=$tokenizer->find_regexp(qr< \A \\ (?:
  		    [^\w\s] |		# delimiters/metas
  		    [tnrfae] |		# C-style escapes
  		    0 [01234567]{0,2} |	# octal
  #		    [01234567]{1,3} |	# made from backref by lexer
  		    c [][\@[:alpha:]\\^_?] |	# control characters
  		    x (?: \{ [[:xdigit:]]* \} | [[:xdigit:]]{0,2} ) | # hex
  		    o [{] [01234567]+ [}] |	# octal as of 5.13.3
  ##		    N (?: \{ (?: [[:alpha:]] [\w\s:()-]* | # must begin w/ alpha
  ##		    U [+] [[:xdigit:]]+ ) \} ) |	# unicode
  		    N (?: [{] (?= \D ) [^\}]* [}] )	# unicode
  		) >smx)){my$match=$tokenizer->match();my$code;$code=$special{$match}and return$code->($tokenizer,$accept);return$accept}return}}{my%escapes=('\\t'=>ord "\t",'\\n'=>ord "\n",'\\r'=>ord "\r",'\\f'=>ord "\f",'\\a'=>ord "\a",'\\b'=>ord "\b",'\\e'=>ord "\e",'\\c?'=>ord "\c?",'\\c@'=>ord "\c@",'\\cA'=>ord "\cA",'\\ca'=>ord "\cA",'\\cB'=>ord "\cB",'\\cb'=>ord "\cB",'\\cC'=>ord "\cC",'\\cc'=>ord "\cC",'\\cD'=>ord "\cD",'\\cd'=>ord "\cD",'\\cE'=>ord "\cE",'\\ce'=>ord "\cE",'\\cF'=>ord "\cF",'\\cf'=>ord "\cF",'\\cG'=>ord "\cG",'\\cg'=>ord "\cG",'\\cH'=>ord "\cH",'\\ch'=>ord "\cH",'\\cI'=>ord "\cI",'\\ci'=>ord "\cI",'\\cJ'=>ord "\cJ",'\\cj'=>ord "\cJ",'\\cK'=>ord "\cK",'\\ck'=>ord "\cK",'\\cL'=>ord "\cL",'\\cl'=>ord "\cL",'\\cM'=>ord "\cM",'\\cm'=>ord "\cM",'\\cN'=>ord "\cN",'\\cn'=>ord "\cN",'\\cO'=>ord "\cO",'\\co'=>ord "\cO",'\\cP'=>ord "\cP",'\\cp'=>ord "\cP",'\\cQ'=>ord "\cQ",'\\cq'=>ord "\cQ",'\\cR'=>ord "\cR",'\\cr'=>ord "\cR",'\\cS'=>ord "\cS",'\\cs'=>ord "\cS",'\\cT'=>ord "\cT",'\\ct'=>ord "\cT",'\\cU'=>ord "\cU",'\\cu'=>ord "\cU",'\\cV'=>ord "\cV",'\\cv'=>ord "\cV",'\\cW'=>ord "\cW",'\\cw'=>ord "\cW",'\\cX'=>ord "\cX",'\\cx'=>ord "\cX",'\\cY'=>ord "\cY",'\\cy'=>ord "\cY",'\\cZ'=>ord "\cZ",'\\cz'=>ord "\cZ",'\\c['=>ord "\c[",'\\c\\\\'=>ord "\c\\",'\\c]'=>ord "\c]",'\\c^'=>ord "\c^",'\\c_'=>ord "\c_",);sub ordinal {my ($self)=@_;exists$self->{ordinal}and return$self->{ordinal};return ($self->{ordinal}=$self->_ordinal())}my%octal=map {;"$_"=>1}(0 .. 7);sub _ordinal {my ($self)=@_;my$content=$self->content();$content =~ m/ \A \\ /smx or return ord$content;exists$escapes{$content}and return$escapes{$content};my$indicator=substr$content,1,1;$octal{$indicator}and return oct substr$content,1;if ($indicator eq 'x'){$content =~ m/ \A \\ x \{ ( [[:xdigit:]]+ ) \} \z /smx and return hex $1;$content =~ m/ \A \\ x ( [[:xdigit:]]{0,2} ) \z /smx and return hex $1;return}if ($indicator eq 'o'){$content =~ m/ \A \\ o [{] ( [01234567]+ ) [}] \z /smx and return oct $1;return}if ($indicator eq 'N'){$content =~ m/ \A \\ N \{ U [+] ( [[:xdigit:]]+ ) \} \z /smx and return hex $1;$content =~ m/ \A \\ N [{] ( .+ ) [}] \z /smx and return (_have_charnames_vianame()? charnames::vianame($1): undef);return}return ord$indicator}}{my$have_charnames_vianame;sub _have_charnames_vianame {defined$have_charnames_vianame and return$have_charnames_vianame;return ($have_charnames_vianame=charnames->can('vianame')? 1 : 0)}}*__PPIX_TOKENIZER__repl=\&__PPIX_TOKENIZER__regexp;1;
PPIX_REGEXP_TOKEN_LITERAL

$fatpacked{"PPIx/Regexp/Token/Modifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_MODIFIER';
  package PPIx::Regexp::Token::Modifier;use strict;use warnings;use base qw{PPIx::Regexp::Token};use Carp;use PPIx::Regexp::Constant qw{MINIMUM_PERL MODIFIER_GROUP_MATCH_SEMANTICS};our$VERSION='0.01';my%aggregate=(a=>MODIFIER_GROUP_MATCH_SEMANTICS,aa=>MODIFIER_GROUP_MATCH_SEMANTICS,d=>MODIFIER_GROUP_MATCH_SEMANTICS,l=>MODIFIER_GROUP_MATCH_SEMANTICS,u=>MODIFIER_GROUP_MATCH_SEMANTICS,);my%de_aggregate;for my$value (values%aggregate){$de_aggregate{$value}++}use constant TOKENIZER_ARGUMENT_REQUIRED=>1;sub __new {my ($class,$content,%arg)=@_;my$self=$class->SUPER::__new($content,%arg)or return;$arg{tokenizer}->modifier_modify($self->modifiers());return$self}sub asserts {my ($self,$modifier)=@_;$self->{modifiers}||= $self->_decode();if (defined$modifier){return __asserts($self->{modifiers},$modifier)}else {return (sort grep {defined $_ && $self->{modifiers}{$_}}map {$de_aggregate{$_}? $self->{modifiers}{$_}: $_}keys %{$self->{modifiers}})}}*__ducktype_modifier_asserted=\&asserts;sub __asserts {my ($present,$modifier)=@_;if (my$bin=$aggregate{$modifier}){return defined$present->{$bin}&& $modifier eq $present->{$bin}}if ($modifier =~ s/ [*] \z //smx){$aggregate{$modifier}and croak "Can not use wild card on modifier '$modifier*'";1==length$modifier or croak "Can not use wild card on multi-character modifier '$modifier*'";return$present->{$modifier}|| 0}my$len=length$modifier;$modifier=substr$modifier,0,1;return$present->{$modifier}&& $len==$present->{$modifier}}sub can_be_quantified {return};{my%explanation=('m'=>'m: ^ and $ match within string','-m'=>'-m: ^ and $ match only at ends of string','s'=>'s: . can match newline','-s'=>'-s: . can not match newline','i'=>'i: do case-insensitive matching','-i'=>'-i: do case-sensitive matching','x'=>'x: ignore whitespace and comments','xx'=>'xx: ignore whitespace even in bracketed character classes','-x'=>'-x: regard whitespace as literal','p'=>'p: provide ${^PREMATCH} etc (pre 5.20)','-p'=>'-p: no ${^PREMATCH} etc (pre 5.20)','a'=>'a: restrict non-Unicode classes to ASCII','aa'=>'aa: restrict non-Unicode classes & ASCII-Unicode matches','d'=>'d: match using default semantics','l'=>'l: match using locale semantics','u'=>'u: match using Unicode semantics','n'=>'n: parentheses do not capture','-n'=>'-n: parentheses capture','c'=>'c: preserve current position on match failure','g'=>'g: match repeatedly','e'=>'e: substitution string is an expression','ee'=>'ee: substitution is expression to eval()','o'=>'o: only interpolate once','r'=>'r: aubstitution returns modified string',);sub explain {my ($self)=@_;my@rslt;my%mods=$self->modifiers();if (defined(my$val=delete$mods{match_semantics})){push@rslt,$explanation{$val}}for my$key (sort keys%mods){if (my$val=$mods{$key}){push@rslt,$explanation{$key x $val }}else {push@rslt,$explanation{"-$key" }}}return wantarray ? @rslt : join '; ',@rslt}}sub match_semantics {my ($self)=@_;$self->{modifiers}||= $self->_decode();return$self->{modifiers}{MODIFIER_GROUP_MATCH_SEMANTICS()}}sub modifiers {my ($self)=@_;$self->{modifiers}||= $self->_decode();my%mods=%{$self->{modifiers}};for my$bin (keys%de_aggregate){defined (my$val=delete$mods{$bin})or next;$mods{$bin}=$val}return wantarray ? %mods : \%mods}sub negates {my ($self,$modifier)=@_;$self->{modifiers}||= $self->_decode();defined$modifier or return (sort grep {!$self->{modifiers}{$_}}keys %{$self->{modifiers}});return exists$self->{modifiers}{$modifier}&&!$self->{modifiers}{$modifier}}sub perl_version_introduced {my ($self)=@_;return ($self->{perl_version_introduced}||= $self->_perl_version_introduced())}sub _perl_version_introduced {my ($self)=@_;my$content=$self->content();my$is_statement_modifier=($content !~ m/ \A [(]? [?] /smx);my$match_semantics=$self->match_semantics();$self->asserts('xx')and return '5.025009';$self->asserts('n')and return '5.021008';defined$match_semantics and $is_statement_modifier and return '5.013010';defined$match_semantics and 'aa' eq $match_semantics and return '5.013010';defined$match_semantics and not $is_statement_modifier and 'a' eq $match_semantics and return '5.013009';defined$match_semantics and not $is_statement_modifier and return '5.013006';not $is_statement_modifier and $content =~ m/ \^ /smx and return '5.013006';$self->asserts('r')and return '5.013002';$self->asserts('p')and return '5.009005';$self->content()=~ m/ \A [(]? [?] .* - /smx and return '5.005';$self->asserts('c')and return '5.004';return MINIMUM_PERL}sub __aggregate_modifiers {my (@mods)=@_;my%present;for my$content (@mods){$content =~ s{ [?/]+ }{}smxg;if ($content =~ m/ \A \^ /smx){@present{MODIFIER_GROUP_MATCH_SEMANTICS(),qw{i s m x} }=qw{d 0 0 0 0}}$content=join '-',map {join '',sort split qr{}smx}split qr{-}smx,$content;my$value=1;while ($content =~ m/ ( ( [[:alpha:]-] ) \2* ) /smxg){if ('-' eq $1){$value=0}elsif (my$bin=$aggregate{$1}){$present{$bin}=$value ? $1 : undef}else {$present{$2}=$value * length $1}}}return \%present}sub __PPIX_TOKEN__recognize {return ([qr{ \A [(] [?] [[:lower:]]* -? [[:lower:]]* [)] }smx ],[qr{ \A [(] [?] \^ [[:lower:]]* [)] }smx ],)}{sub __PPIX_TOKENIZER__modifier_modify {my (@args)=@_;my%merged;for my$hash (@args){while (my ($key,$val)=each %{$hash}){if ($val){$merged{$key}=$val}else {delete$merged{$key}}}}return \%merged}sub _decode {my ($self)=@_;return __aggregate_modifiers($self->content())}}1;
PPIX_REGEXP_TOKEN_MODIFIER

$fatpacked{"PPIx/Regexp/Token/NoOp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_NOOP';
  package PPIx::Regexp::Token::NoOp;use 5.006;use strict;use warnings;use base qw{PPIx::Regexp::Token};use Carp;use PPIx::Regexp::Constant qw{MINIMUM_PERL};our$VERSION='0.01';sub __new {my ($class,$content,%arg)=@_;defined$arg{perl_version_introduced}or $arg{perl_version_introduced}=MINIMUM_PERL;return$class->SUPER::__new($content,%arg)}sub can_be_quantified {return};sub explain {return 'Not significant'}sub perl_version_introduced {my ($self)=@_;return$self->{perl_version_introduced}}sub significant {return}1;
PPIX_REGEXP_TOKEN_NOOP

$fatpacked{"PPIx/Regexp/Token/Operator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_OPERATOR';
  package PPIx::Regexp::Token::Operator;use strict;use warnings;use base qw{PPIx::Regexp::Token};use PPIx::Regexp::Constant qw{COOKIE_CLASS COOKIE_REGEX_SET LITERAL_LEFT_CURLY_ALLOWED TOKEN_LITERAL};use PPIx::Regexp::Util qw{__instance};our$VERSION='0.01';use constant TOKENIZER_ARGUMENT_REQUIRED=>1;sub __new {my ($class,$content,%arg)=@_;my$self=$class->SUPER::__new($content,%arg)or return;$self->{operation}=$self->_compute_operation_name($arg{tokenizer})|| 'unknown';return$self}sub explain {my ($self)=@_;my$expl=ucfirst "$self->{operation} operator";$expl =~ s/ _ / /smxg;return$expl}sub operation {my ($self)=@_;return$self->{operation}}my%operator=map {$_=>1}qw{| -};sub _treat_as_literal {my ($token)=@_;return __instance($token,'PPIx::Regexp::Token::Literal')|| __instance($token,'PPIx::Regexp::Token::Interpolation')}{my%operation=(COOKIE_CLASS()=>{'-'=>'range','^'=>'inversion',},COOKIE_REGEX_SET()=>{'&'=>'intersection','+'=>'union','|'=>'union','-'=>'subtraction','^'=>'symmetric_difference','!'=>'complement',},''=>{'|'=>'alternation',},);sub _compute_operation_name {my ($self,$tokenizer)=@_;my$content=$self->content();if ($tokenizer->cookie(COOKIE_CLASS)){return$operation{COOKIE_CLASS()}{$content}}elsif ($tokenizer->cookie(COOKIE_REGEX_SET)){return$operation{COOKIE_REGEX_SET()}{$content}}else {return$operation{''}{$content}}}}{my$removed_in={'|'=>LITERAL_LEFT_CURLY_ALLOWED,};sub __following_literal_left_curly_disallowed_in {my ($self)=@_;my$content=$self->content();exists$removed_in->{$content}and return$removed_in->{$content};return$self->SUPER::__following_literal_left_curly_disallowed_in()}}sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;if ($character eq '-'){_treat_as_literal($tokenizer->prior_significant_token())or return$tokenizer->make_token(1,TOKEN_LITERAL);my@tokens=($tokenizer->make_token(1));push@tokens,$tokenizer->get_token();_treat_as_literal($tokens[1])or bless$tokens[0],TOKEN_LITERAL;return (@tokens)}return$operator{$character}}1;
PPIX_REGEXP_TOKEN_OPERATOR

$fatpacked{"PPIx/Regexp/Token/Quantifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_QUANTIFIER';
  package PPIx::Regexp::Token::Quantifier;use strict;use warnings;use base qw{PPIx::Regexp::Token};use PPIx::Regexp::Constant qw{LITERAL_LEFT_CURLY_ALLOWED};our$VERSION='0.01';sub can_be_quantified {return};sub is_quantifier {return 1};my%quantifier=map {$_=>1}qw{* + ?};sub could_be_quantifier {my (undef,$string)=@_;return$quantifier{$string}}{my%explanation=('*'=>'match zero or more times','+'=>'match one or more times','?'=>'match zero or one time',);sub __explanation {return \%explanation}}sub __following_literal_left_curly_disallowed_in {return LITERAL_LEFT_CURLY_ALLOWED}sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;$tokenizer->prior_significant_token('can_be_quantified')or return;return$quantifier{$character}}1;
PPIX_REGEXP_TOKEN_QUANTIFIER

$fatpacked{"PPIx/Regexp/Token/Recursion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_RECURSION';
  package PPIx::Regexp::Token::Recursion;use strict;use warnings;use base qw{PPIx::Regexp::Token::Reference};use Carp qw{confess};use PPIx::Regexp::Constant qw{RE_CAPTURE_NAME};our$VERSION='0.01';sub explain {my ($self)=@_;$self->is_named()and return sprintf q<Recurse into capture group '%s'>,$self->name();if ($self->is_relative()){my$number=$self->number();$number >= 0 and return sprintf q<Recurse into %s following capture group (%d in this regexp)>,PPIx::Regexp::Util::__to_ordinal_en($self->number()),$self->absolute();return sprintf q<Back reference to %s previous capture group (%d in this regexp)>,PPIx::Regexp::Util::__to_ordinal_en(- $self->number()),$self->absolute()}elsif (my$number=$self->absolute()){return sprintf q<Recurse into capture group %d>,$number}else {return q<Recurse to beginning of regular expression>}}sub perl_version_introduced {return '5.009005'}sub __PPIX_TOKEN__recognize {return ([qr{ \A \( \? (?: ( [-+]? \d+ )) \) }smx,{is_named=>0 }],[qr{ \A \( \? (?: R) \) }smx,{is_named=>0,capture=>'0' }],[qr{ \A \( \?  (?: & | P> ) ( @{[ RE_CAPTURE_NAME ]} ) \) }smxo,{is_named=>1 }],)}1;
PPIX_REGEXP_TOKEN_RECURSION

$fatpacked{"PPIx/Regexp/Token/Reference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_REFERENCE';
  package PPIx::Regexp::Token::Reference;use strict;use warnings;use base qw{PPIx::Regexp::Token};use Carp qw{confess};use List::Util qw{first};our$VERSION='0.01';sub __new {my ($class,$content,%arg)=@_;if (defined$arg{capture}){}elsif (defined$arg{tokenizer}){$arg{capture}=first {defined $_}$arg{tokenizer}->capture()}unless (defined$arg{capture}){for ($class->__PPIX_TOKEN__recognize()){my ($re,$a)=@{$_};$content =~ $re or next;@arg{keys %{$a}}=@{$a}{keys %{$a}};for my$inx (1 .. $#-){defined $-[$inx]or next;$arg{capture}=substr$content,$-[$inx],$+[$inx]- $-[$inx];last}last}}defined$arg{capture}or confess q{Programming error - reference '},$content,q{' of unknown form};my$self=$class->SUPER::__new($content,%arg)or return;$self->{is_named}=$arg{is_named};my$capture=delete$arg{capture};if ($self->{is_named}){$self->{absolute}=undef;$self->{is_relative}=undef;$self->{name}=$capture}elsif ($capture !~ m/ \A [-+] /smx){$self->{absolute}=$self->{number}=$capture;$self->{is_relative}=undef}else {$self->{number}=$capture;$self->{is_relative}=1}return$self}sub absolute {my ($self)=@_;return$self->{absolute}}sub is_named {my ($self)=@_;return$self->{is_named}}sub is_relative {my ($self)=@_;return$self->{is_relative}}sub name {my ($self)=@_;return$self->{name}}sub number {my ($self)=@_;return$self->{number}}sub __PPIX_LEXER__record_capture_number {my ($self,$number)=@_;if (!exists$self->{absolute}&& exists$self->{number}&& $self->{number}=~ m/ \A [-+] /smx){my$delta=$self->{number};$delta > 0 and --$delta;$self->{absolute}=$number + $delta}return$number}1;
PPIX_REGEXP_TOKEN_REFERENCE

$fatpacked{"PPIx/Regexp/Token/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_STRUCTURE';
  package PPIx::Regexp::Token::Structure;use strict;use warnings;use base qw{PPIx::Regexp::Token};use PPIx::Regexp::Constant qw{COOKIE_CLASS COOKIE_QUANT COOKIE_REGEX_SET MINIMUM_PERL TOKEN_LITERAL};use PPIx::Regexp::Token::Comment ();use PPIx::Regexp::Token::Modifier ();use PPIx::Regexp::Token::Backreference ();use PPIx::Regexp::Token::Backtrack ();use PPIx::Regexp::Token::Recursion ();our$VERSION='0.01';my%quant=map {$_=>1}')',']';sub can_be_quantified {my ($self)=@_;ref$self or return;return$quant{$self->content()}};{my%explanation=(''=>'Match regexp','('=>'Capture or grouping','(?['=>'Extended character class',')'=>'End capture or grouping','['=>'Character class',']'=>'End character class','])'=>'End extended character class','m'=>'Match regexp','qr'=>'Regexp object definition','s'=>'Replace regexp with string or expression','{'=>'Explicit quantifier','}'=>'End explicit quantifier',);sub __explanation {return \%explanation}}sub is_quantifier {my ($self)=@_;ref$self or return;return$self->{is_quantifier}}{my%perl_version_introduced=(qr=>'5.005','(?['=>'5.017008',);sub perl_version_introduced {my ($self)=@_;return$perl_version_introduced{$self->content()}|| MINIMUM_PERL}}{my%delim=map {$_=>1}qw/( ) { } [ ]/;my@paren_token=map {[$_=>$_->__PPIX_TOKEN__recognize()]}'PPIx::Regexp::Token::Comment','PPIx::Regexp::Token::Modifier','PPIx::Regexp::Token::Backreference','PPIx::Regexp::Token::Backtrack','PPIx::Regexp::Token::Recursion',;sub __PPIX_TOKENIZER__regexp {my (undef,$tokenizer,$character)=@_;$delim{$character}or return;if ($tokenizer->cookie(COOKIE_CLASS)){$character eq ']' or return$tokenizer->make_token(1,TOKEN_LITERAL);$tokenizer->cookie(COOKIE_CLASS,undef);return 1}if ($character eq '('){for (@paren_token){my ($class,@recognize)=@{$_};for (@recognize){my ($regexp,$arg)=@{$_};my$accept=$tokenizer->find_regexp($regexp)or next;return$tokenizer->make_token($accept,$class,$arg)}}$tokenizer->modifier_duplicate();if (my$accept=$tokenizer->find_regexp(qr{ \A [(] [?] [[] }smx)){$tokenizer->cookie(COOKIE_REGEX_SET,sub {return 1});$tokenizer->modifier_modify(x=>1);return$accept}$tokenizer->expect('PPIx::Regexp::Token::GroupType::Modifier','PPIx::Regexp::Token::GroupType::NamedCapture','PPIx::Regexp::Token::GroupType::Assertion','PPIx::Regexp::Token::GroupType::Code','PPIx::Regexp::Token::GroupType::BranchReset','PPIx::Regexp::Token::GroupType::Subexpression','PPIx::Regexp::Token::GroupType::Switch',);return 1}if ($character eq ')'){$tokenizer->modifier_pop();return 1}if ($character eq '{'){$tokenizer->prior_significant_token('can_be_quantified')or return 1;my$token=$tokenizer->make_token(1);my$commas=0;$tokenizer->cookie(COOKIE_QUANT,sub {my ($tokenizer,$token)=@_;$token or return 1;if ($token->isa(TOKEN_LITERAL)){my$character=$token->content();if ($character eq ','){$commas++ and return;return$tokenizer->prior_significant_token('content')ne '{'}return$character =~ m/ \A \d \z /smx}if ($token->isa('PPIx::Regexp::Token::Interpolation')){return 1}return},);return$token}if ($character eq '}'){$tokenizer->cookie(COOKIE_QUANT,undef)or return 1;$tokenizer->prior_significant_token('class')->isa(__PACKAGE__)and return 1;my$token=$tokenizer->make_token(1);$token->{is_quantifier}=1;return$token}if ($character eq '['){$tokenizer->cookie(COOKIE_CLASS,sub {return 1});my@tokens=$tokenizer->make_token(1);defined ($character=$tokenizer->peek())or return@tokens;if ($character eq '^'){push@tokens,$tokenizer->make_token(1,'PPIx::Regexp::Token::Operator');defined ($character=$tokenizer->peek())or return@tokens}$character eq ']' and push@tokens,$tokenizer->make_token(1,TOKEN_LITERAL);return@tokens}if ($character eq ']'){if ((my$accept=$tokenizer->find_regexp(qr{ \A []] [)] }smx))&& $tokenizer->cookie(COOKIE_REGEX_SET)){$tokenizer->cookie(COOKIE_REGEX_SET,undef);return$accept}$tokenizer->cookie(COOKIE_CLASS,undef);return 1}return 1}}sub __PPIX_LEXER__finalize {my ($self)=@_;delete$self->{is_quantifier};return 0}1;
PPIX_REGEXP_TOKEN_STRUCTURE

$fatpacked{"PPIx/Regexp/Token/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_UNKNOWN';
  package PPIx::Regexp::Token::Unknown;use strict;use warnings;use base qw{PPIx::Regexp::Token};use Carp qw{confess};our$VERSION='0.01';sub __new {my ($class,$content,%arg)=@_;defined$arg{error}or confess 'Programming error - error argument required';my$self=$class->SUPER::__new($content,%arg)or return;$self->{error}=$arg{error};return$self}sub can_be_quantified {return};sub ordinal {my ($self)=@_;return ord$self->content()}sub __PPIX_ELEM__rebless {my ($class,$self,%arg)=@_;my$rslt=$class->SUPER::__PPIX_ELEM__rebless($self,%arg);unless (defined($self->{error}=$arg{error})){Carp::cluck('Making unknown token with no error message');$self->{error}='Unspecified error';$rslt++}return$rslt}sub __PPIX_LEXER__finalize {return 1}1;
PPIX_REGEXP_TOKEN_UNKNOWN

$fatpacked{"PPIx/Regexp/Token/Unmatched.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_UNMATCHED';
  package PPIx::Regexp::Token::Unmatched;use strict;use warnings;use base qw{PPIx::Regexp::Token};our$VERSION='0.01';sub explain {return 'Unmatched token'}1;
PPIX_REGEXP_TOKEN_UNMATCHED

$fatpacked{"PPIx/Regexp/Token/Whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKEN_WHITESPACE';
  package PPIx::Regexp::Token::Whitespace;use strict;use warnings;use base qw{PPIx::Regexp::Token::NoOp};use PPIx::Regexp::Constant qw{COOKIE_REGEX_SET MINIMUM_PERL};our$VERSION='0.01';sub __new {my ($class,$content,%arg)=@_;defined$arg{perl_version_introduced}or $arg{perl_version_introduced}=(grep {127 < ord}split qr{},$content)? '5.021001' : MINIMUM_PERL;return$class->SUPER::__new($content,%arg)}sub explain {my ($self)=@_;my$parent;if ($parent=$self->parent()and $parent->isa('PPIx::Regexp')){return$self->SUPER::explain()}elsif ($self->in_regex_set()){return q<Not significant in extended character class>}elsif (my$count=$self->modifier_asserted('x*')){return q<Not significant under /> .('x' x $count)}else {return$self->SUPER::explain()}}sub whitespace {return 1}1;
PPIX_REGEXP_TOKEN_WHITESPACE

$fatpacked{"PPIx/Regexp/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_TOKENIZER';
  package PPIx::Regexp::Tokenizer;use strict;use warnings;use base qw{PPIx::Regexp::Support};use Carp qw{carp croak confess};use PPIx::Regexp::Constant qw{MINIMUM_PERL TOKEN_LITERAL TOKEN_UNKNOWN};use PPIx::Regexp::Token::Assertion ();use PPIx::Regexp::Token::Backreference ();use PPIx::Regexp::Token::Backtrack ();use PPIx::Regexp::Token::CharClass::POSIX ();use PPIx::Regexp::Token::CharClass::POSIX::Unknown ();use PPIx::Regexp::Token::CharClass::Simple ();use PPIx::Regexp::Token::Code ();use PPIx::Regexp::Token::Comment ();use PPIx::Regexp::Token::Condition ();use PPIx::Regexp::Token::Control ();use PPIx::Regexp::Token::Delimiter ();use PPIx::Regexp::Token::Greediness ();use PPIx::Regexp::Token::GroupType::Assertion ();use PPIx::Regexp::Token::GroupType::BranchReset ();use PPIx::Regexp::Token::GroupType::Code ();use PPIx::Regexp::Token::GroupType::Modifier ();use PPIx::Regexp::Token::GroupType::NamedCapture ();use PPIx::Regexp::Token::GroupType::Subexpression ();use PPIx::Regexp::Token::GroupType::Switch ();use PPIx::Regexp::Token::Interpolation ();use PPIx::Regexp::Token::Literal ();use PPIx::Regexp::Token::Modifier ();use PPIx::Regexp::Token::Operator ();use PPIx::Regexp::Token::Quantifier ();use PPIx::Regexp::Token::Recursion ();use PPIx::Regexp::Token::Structure ();use PPIx::Regexp::Token::Unknown ();use PPIx::Regexp::Token::Whitespace ();use PPIx::Regexp::Util qw{__choose_tokenizer_class __instance};use Scalar::Util qw{looks_like_number};our$VERSION='0.01';our$DEFAULT_POSTDEREF;defined$DEFAULT_POSTDEREF or $DEFAULT_POSTDEREF=1;{my@classes=('PPIx::Regexp::Token::Literal','PPIx::Regexp::Token::Interpolation','PPIx::Regexp::Token::Control','PPIx::Regexp::Token::CharClass::Simple','PPIx::Regexp::Token::Quantifier','PPIx::Regexp::Token::Greediness','PPIx::Regexp::Token::CharClass::POSIX','PPIx::Regexp::Token::Structure','PPIx::Regexp::Token::Assertion','PPIx::Regexp::Token::Backreference','PPIx::Regexp::Token::Operator',);sub __tokenizer_classes {return@classes}}{my$errstr;sub new {my ($class,$re,%args)=@_;ref$class and $class=ref$class;$errstr=undef;exists$args{default_modifiers}and 'ARRAY' ne ref$args{default_modifiers}and do {$errstr='default_modifiers must be an array reference';return};my$self={capture=>undef,content=>undef,cookie=>{},cursor_curr=>0,cursor_limit=>undef,cursor_orig=>undef,cursor_modifiers=>undef,default_modifiers=>$args{default_modifiers}|| [],delimiter_finish=>undef,delimiter_start=>undef,encoding=>$args{encoding},expect=>undef,expect_next=>undef,failures=>0,find=>undef,known=>{},match=>undef,mode=>'init',modifiers=>[{}],pending=>[],postderef=>defined$args{postderef}? $args{postderef}: $DEFAULT_POSTDEREF,prior=>TOKEN_UNKNOWN,source=>$re,strict=>$args{strict},trace=>__PACKAGE__->__defined_or($args{trace},$ENV{PPIX_REGEXP_TOKENIZER_TRACE},0),};if (__instance($re,'PPI::Element')){defined(my$tokenizer_class=__choose_tokenizer_class($re,{parse=>'guess' }))or return __set_errstr(ref$re,'not supported');$class eq $tokenizer_class or return __set_errstr(ref$re,'not supported by',$class);$self->{content}=$re->isa('PPI::Token::HereDoc')? join('',$re->content(),"\n",$re->heredoc(),$re->terminator(),"\n"): $re->content()}elsif (ref$re){return __set_errstr(ref$re,'not supported')}else {$self->{content}=$re}bless$self,$class;$self->{content}=$self->decode($self->{content});$self->{cursor_limit}=length$self->{content};$self->{trace}and warn "\ntokenizing '$self->{content}'\n";return$self}sub __set_errstr {$errstr=join ' ',@_;return}sub errstr {return$errstr}}sub capture {my ($self)=@_;$self->{capture}or return;defined wantarray or return;return wantarray ? @{$self->{capture}}: $self->{capture}}sub content {my ($self)=@_;return$self->{content}}sub cookie {my ($self,$name,@args)=@_;defined$name or confess "Programming error - undefined cookie name";@args or return$self->{cookie}{$name};my$cookie=shift@args;if (ref$cookie eq 'CODE'){return ($self->{cookie}{$name}=$cookie)}elsif (defined$cookie){confess "Programming error - cookie must be CODE ref or undef"}else {return delete$self->{cookie}{$name}}}sub default_modifiers {my ($self)=@_;return [@{$self->{default_modifiers}}]}sub __effective_modifiers {my ($self)=@_;'HASH' eq ref$self->{effective_modifiers}or return {};return {%{$self->{effective_modifiers}}}}sub encoding {my ($self)=@_;return$self->{encoding}}sub expect {my ($self,@args)=@_;@args or return;$self->{expect_next}=[map {m/ \A PPIx::Regexp:: /smx ? $_ : 'PPIx::Regexp::' .$_}@args ];$self->{expect}=undef;return}sub failures {my ($self)=@_;return$self->{failures}}sub find_matching_delimiter {my ($self)=@_;$self->{cursor_curr}||= 0;my$start=substr $self->{content},$self->{cursor_curr},1;my$inx=$self->{cursor_curr};my$finish=(my$bracketed=$self->close_bracket($start))|| $start;my$nest=0;while (++$inx < $self->{cursor_limit}){my$char=substr$self->{content},$inx,1;if ($char eq '\\' && $finish ne '\\'){++$inx}elsif ($bracketed && $char eq $start){++$nest}elsif ($char eq $finish){--$nest < 0 and return$inx - $self->{cursor_curr}}}return}sub find_regexp {my ($self,$regexp)=@_;ref$regexp eq 'Regexp' or confess 'Argument is a ',(ref$regexp || 'scalar'),' not a Regexp';defined$self->{find}or $self->_remainder();$self->{find}=~ $regexp or return;my@capture;for my$inx (0 .. $#+){if (defined $-[$inx]&& defined $+[$inx]){push@capture,$self->{capture}=substr $self->{find},$-[$inx],$+[$inx]- $-[$inx]}else {push@capture,undef}}$self->{match}=shift@capture;$self->{capture}=\@capture;return wantarray ? ($-[0]+ 0,$+[0]+ 0): $+[0]+ 0}sub get_mode {my ($self)=@_;return$self->{mode}}sub get_start_delimiter {my ($self)=@_;return$self->{delimiter_start}}sub get_token {my ($self)=@_;caller eq __PACKAGE__ or $self->{cursor_curr}> $self->{cursor_orig}or confess 'Programming error - get_token() called without ','first calling make_token()';my$handler='__PPIX_TOKENIZER__' .$self->{mode};my$code=$self->can($handler)or confess 'Programming error - ',"Getting token in mode '$self->{mode}'. ","cursor_curr = $self->{cursor_curr}; ","cursor_limit = $self->{cursor_limit}; ","length( content ) = ",length$self->{content},"; content = '$self->{content}'";my$character=substr($self->{content},$self->{cursor_curr},1);$self->{trace}and warn "get_token() got '$character' from $self->{cursor_curr}\n";return ($code->($self,$character))}sub interpolates {my ($self)=@_;return$self->{delimiter_start}ne q{'}}sub make_token {my ($self,$length,$class,$arg)=@_;defined$class or $class=caller;if ($length + $self->{cursor_curr}> $self->{cursor_limit}){$length=$self->{cursor_limit}- $self->{cursor_curr}or return}$class =~ m/ \A PPIx::Regexp:: /smx or $class='PPIx::Regexp::' .$class;my$content=substr $self->{content},$self->{cursor_curr},$length;$self->{trace}and warn "make_token( $length, '$class' ) => '$content'\n";$self->{trace}> 1 and warn "    make_token: cursor_curr = $self->{cursor_curr}; ","cursor_limit = $self->{cursor_limit}\n";my$token=$class->__new($content,tokenizer=>$self,%{$arg || {}})or return;$token->significant()and $self->{expect}=undef;$token->isa(TOKEN_UNKNOWN)and $self->{failures}++;$self->{cursor_curr}+= $length;$self->{find}=undef;$self->{match}=undef;$self->{capture}=undef;for my$name (keys %{$self->{cookie}}){my$cookie=$self->{cookie}{$name};$cookie->($self,$token)or delete$self->{cookie}{$name}}$token->significant()and $self->{prior_significant_token}=$token;return$token}sub match {my ($self)=@_;return$self->{match}}sub modifier {my ($self,$modifier)=@_;return PPIx::Regexp::Token::Modifier::__asserts($self->{modifiers}[-1],$modifier)}sub modifier_duplicate {my ($self)=@_;push @{$self->{modifiers}},{%{$self->{modifiers}[-1]}};return}sub modifier_modify {my ($self,%args)=@_;$self->{modifiers}[-1]=PPIx::Regexp::Token::Modifier::__PPIX_TOKENIZER__modifier_modify($self->{modifiers}[-1],\%args);return}sub modifier_pop {my ($self)=@_;@{$self->{modifiers}}> 1 and pop @{$self->{modifiers}};return}sub next_token {my ($self)=@_;{if (@{$self->{pending}}){return shift @{$self->{pending}}}if ($self->{cursor_curr}>= $self->{cursor_limit}){$self->{cursor_limit}>= length$self->{content}and return;$self->{mode}eq 'finish' and return;$self->_set_mode('finish');$self->{cursor_limit}+= length$self->{delimiter_finish}}if (my@tokens=$self->get_token()){push @{$self->{pending}},@tokens;redo}}return}sub peek {my ($self,$offset)=@_;defined$offset or $offset=0;$offset < 0 and return;$offset += $self->{cursor_curr};$offset >= $self->{cursor_limit}and return;return substr$self->{content},$offset,1}sub ppi_document {my ($self)=@_;defined$self->{find}or $self->_remainder();return PPI::Document->new(\"$self->{find}")}sub prior {my ($self,$method,@args)=@_;$self->_deprecation_notice(method=>'prior','prior_significant_token()');defined$method or return$self->{prior_significant_token};$self->{prior_significant_token}->can($method)or confess 'Programming error - ',(ref$self->{prior_significant_token}|| $self->{prior_significant_token}),' does not support method ',$method;return$self->{prior_significant_token}->$method(@args)}sub prior_significant_token {my ($self,$method,@args)=@_;defined$method or return$self->{prior_significant_token};$self->{prior_significant_token}->can($method)or confess 'Programming error - ',(ref$self->{prior_significant_token}|| $self->{prior_significant_token}),' does not support method ',$method;return$self->{prior_significant_token}->$method(@args)}{my%magic_var=map {$_=>1}qw{@* $*};my%magic_oper=map {$_=>1}qw{& ** %};my%sliceable=map {$_=>1}qw{@ %};my%post_slice=map {$_=>1}qw<{ [>;sub __recognize_postderef {my ($self,$token,$iterator)=@_;$self->{postderef}or return;my$ppi;if (!defined$iterator){$ppi=$token->ppi();my@ops=grep {'->' eq $_->content()}@{$ppi->find('PPI::Token::Operator')|| []};$iterator=sub {my$op=shift@ops or return;return$op->snext_sibling()}}elsif ($iterator->isa('PPI::Element')){my@eles=($iterator);$iterator=sub {return shift@eles}}elsif ('CODE' ne ref$iterator){confess 'Programming error - Iterator not understood'}my$accept=$token->__postderef_accept_cast();while (my$elem=$iterator->()){my$content=$elem->content();$content =~ m/ \A ( . \#? ) /smx and $accept->{$1}or next;my$length=length$content;if ($elem->isa('PPI::Token::Magic')){$magic_var{$content}and return$length;if ('$#' eq $content){my$next=$elem->snext_sibling()or return$length;'*' eq substr$next->content(),0,1 and return$length + 1}}if ($elem->isa('PPI::Token::Cast')|| $elem->isa('PPI::Token::Operator')&& $magic_oper{$content}){$content =~ m/ [*] \z /smx and return$length;my$next=$elem->snext_sibling()or return;my$next_content=$next->content();my$next_char=substr$next_content,0,1;'*' eq $next_char and return$length + 1;$sliceable{$content}and $post_slice{$next_char}and return$length + length$next_content}}return}}sub significant {return 1}sub strict {my ($self)=@_;return$self->{strict}}sub _known_tokenizers {my ($self)=@_;my$mode=$self->{mode};my@expect;if ($self->{expect_next}){$self->{expect}=$self->{expect_next};$self->{expect_next}=undef}if ($self->{expect}){@expect=$self->_known_tokenizer_check(@{$self->{expect}})}exists$self->{known}{$mode}and return (@expect,@{$self->{known}{$mode}});my@found=$self->_known_tokenizer_check($self->__tokenizer_classes());$self->{known}{$mode}=\@found;return (@expect,@found)}sub _known_tokenizer_check {my ($self,@args)=@_;my$handler='__PPIX_TOKENIZER__' .$self->{mode};my@found;for my$class (@args){$class->can($handler)or next;push@found,$class}return@found}sub tokens {my ($self)=@_;my@rslt;while (my$token=$self->next_token()){push@rslt,$token}return@rslt}{my%deprecate=(attribute=>{},method=>{prior=>1,},);sub _deprecation_notice {my (undef,$type,$name,$repl)=@_;$deprecate{$type}or return;$deprecate{$type}{$name}or return;my$msg=sprintf 'The %s %s is %s',$name,$type,$deprecate{$type}{$name}> 2 ? 'removed' : 'deprecated';defined$repl and $msg .= "; use $repl instead";$deprecate{$type}{$name}>= 3 and croak$msg;warnings::enabled('deprecated')and carp$msg;$deprecate{$type}{$name}==1 and $deprecate{$type}{$name}=0;return}}sub _remainder {my ($self)=@_;$self->{cursor_curr}> $self->{cursor_limit}and confess "Programming error - Trying to find past end of string";$self->{find}=substr($self->{content},$self->{cursor_curr},$self->{cursor_limit}- $self->{cursor_curr});return}sub _make_final_token {my ($self,$len,$class,$arg)=@_;my$token=$self->make_token($len,$class,$arg);$self->_set_mode('kaput');return$token}sub _set_mode {my ($self,$mode)=@_;$self->{trace}and warn "Tokenizer going from mode $self->{mode} to $mode\n";$self->{mode}=$mode;if ('kaput' eq $mode){$self->{cursor_curr}=$self->{cursor_limit}=length$self->{content}}return}sub __init_error {my ($self,$err)=@_;defined$err or $err='Tokenizer found illegal first characters';return$self->_make_final_token(length$self->{content},TOKEN_UNKNOWN,{error=>$err,},)}sub __PPIX_TOKENIZER__init {my ($self)=@_;$self->find_regexp(qr{ \A ( \s* ) ( qr | m | s )? ( \s* ) (?: [^\w\s] ) }smx)or return$self->__init_error();my ($leading_white,$type,$next_white)=$self->capture();defined$type or $type='';$self->{type}=$type;my@tokens;'' ne $leading_white and push@tokens,$self->make_token(length$leading_white,'PPIx::Regexp::Token::Whitespace');push@tokens,$self->make_token(length$type,'PPIx::Regexp::Token::Structure');'' ne $next_white and push@tokens,$self->make_token(length$next_white,'PPIx::Regexp::Token::Whitespace');$self->{delimiter_start}=substr $self->{content},$self->{cursor_curr},1;$self->{trace}and warn "Tokenizer found regexp start delimiter '$self->{delimiter_start}' at $self->{cursor_curr}\n";if (my$offset=$self->find_matching_delimiter()){my$cursor_limit=$self->{cursor_curr}+ $offset;$self->{trace}and warn "Tokenizer found regexp end delimiter at $cursor_limit\n";if ($self->__number_of_extra_parts()){if ($self->close_bracket($self->{delimiter_start})){pos$self->{content}=$self->{cursor_curr}+ $offset + 1;while ($self->{content}=~ m/ \G \s* \n \s* \# [^\n]* /smxgc){}$self->{content}=~ m/ \s* /smxgc}else {pos$self->{content}=$self->{cursor_curr}+ $offset}my$cursor_curr=$self->{cursor_curr};my$delimiter_start=$self->{delimiter_start};$self->{cursor_curr}=pos$self->{content};$self->{delimiter_start}=substr $self->{content},$self->{cursor_curr},1;$self->{trace}and warn "Tokenizer found replacement start delimiter '$self->{delimiter_start}' at $self->{cursor_curr}\n";if (my$s_off=$self->find_matching_delimiter()){$self->{cursor_modifiers}=$self->{cursor_curr}+ $s_off + 1;$self->{trace}and warn "Tokenizer found replacement end delimiter at @{[
  			$self->{cursor_curr} + $s_off ]}\n";$self->{cursor_curr}=$cursor_curr;$self->{delimiter_start}=$delimiter_start}else {$self->{trace}and warn 'Tokenizer failed to find replacement',"end delimiter starting at $self->{cursor_curr}\n";$self->{cursor_curr}=0;return$self->__init_error('Tokenizer found mismatched replacement delimiters',)}}else {$self->{cursor_modifiers}=$cursor_limit + 1}$self->{cursor_limit}=$cursor_limit}else {$self->{cursor_curr}=0;return$self->_make_final_token(length($self->{content}),TOKEN_UNKNOWN,{error=>'Tokenizer found mismatched regexp delimiters',},)}{my@mods=@{$self->{default_modifiers}};pos$self->{content}=$self->{cursor_modifiers};local$self->{cursor_curr}=$self->{cursor_modifiers};local$self->{cursor_limit}=length$self->{content};my@trailing;{my$len=$self->find_regexp(qr{ \A [[:lower:]]* }smx);push@trailing,$self->make_token($len,'PPIx::Regexp::Token::Modifier')}if (my$len=$self->find_regexp(qr{ \A \s+ }smx)){push@trailing,$self->make_token($len,'PPIx::Regexp::Token::Whitespace')}if (my$len=$self->find_regexp(qr{ \A .+ }smx)){push@trailing,$self->make_token($len,TOKEN_UNKNOWN,{error=>'Trailing characters after expression',})}$self->{trailing_tokens}=\@trailing;push@mods,$trailing[0]->content();$self->{effective_modifiers}=PPIx::Regexp::Token::Modifier::__aggregate_modifiers (@mods);$self->{modifiers}=[{%{$self->{effective_modifiers}}},]}$self->{delimiter_finish}=substr $self->{content},$self->{cursor_limit},1;push@tokens,$self->make_token(1,'PPIx::Regexp::Token::Delimiter');$self->_set_mode('regexp');$self->{find}=undef;return@tokens}sub __initial_match {my ($self)=@_;$self->find_regexp(qr{ \A ( \s* ) ( qr | m | s )? ( \s* ) (?: [^\w\s] ) }smx)or return;my ($leading_white,$type,$next_white)=$self->capture();defined$type or $type='';$self->{type}=$type;my@tokens;'' ne $leading_white and push@tokens,$self->make_token(length$leading_white,'PPIx::Regexp::Token::Whitespace');push@tokens,$self->make_token(length$type,'PPIx::Regexp::Token::Structure');'' ne $next_white and push@tokens,$self->make_token(length$next_white,'PPIx::Regexp::Token::Whitespace');return@tokens}{my%extra_parts=(s=>1,);sub __number_of_extra_parts {my ($self)=@_;return$extra_parts{$self->{type}}|| 0}}{my@part_class=qw{PPIx::Regexp::Structure::Regexp PPIx::Regexp::Structure::Replacement};sub __part_classes {my ($self)=@_;my$max=$self->__number_of_extra_parts();return@part_class[0 .. $max ]}}sub __PPIX_TOKENIZER__regexp {my ($self,$character)=@_;my$mode=$self->{mode};my$handler='__PPIX_TOKENIZER__' .$mode;$self->{cursor_orig}=$self->{cursor_curr};for my$class ($self->_known_tokenizers()){my@tokens=grep {$_}$class->$handler($self,$character);$self->{trace}and warn$class,"->$handler( \$self, '$character' )"," => (@tokens)\n";@tokens and return (map {ref $_ ? $_ : $self->make_token($_,$class)}@tokens)}my$fallback=__PACKAGE__->can('__PPIX_TOKEN_FALLBACK__' .$mode)|| __PACKAGE__->can('__PPIX_TOKEN_FALLBACK__regexp')|| confess "Programming error - unable to find fallback for $mode";return$fallback->($self,$character)}*__PPIX_TOKENIZER__repl=\&__PPIX_TOKENIZER__regexp;sub __PPIX_TOKEN_FALLBACK__regexp {my ($self,$character)=@_;if ($character eq '\\' && $self->{cursor_limit}- $self->{cursor_curr}> 1){return$self->make_token(2,TOKEN_LITERAL)}return$self->make_token(1,TOKEN_UNKNOWN,{error=>'Tokenizer found unexpected literal',},)}sub __PPIX_TOKEN_FALLBACK__repl {my ($self,$character)=@_;if ($character eq '\\' && defined (my$next=$self->peek(1))){if ($self->interpolates()|| $next eq q<'> || $next eq '\\'){return$self->make_token(2,TOKEN_LITERAL)}return$self->make_token(1,TOKEN_LITERAL)}return$self->make_token(1,TOKEN_LITERAL)}sub __PPIX_TOKENIZER__finish {my ($self)=@_;$self->{cursor_limit}> length$self->{content}and confess "Programming error - ran off string";my@tokens=$self->make_token(length$self->{delimiter_finish},'PPIx::Regexp::Token::Delimiter');if ($self->{cursor_curr}==$self->{cursor_modifiers}){push@tokens,@{delete$self->{trailing_tokens}};$self->_set_mode('kaput')}else {$self->{cookie}={};$self->{cursor_limit}=$self->{cursor_modifiers}- 1;if ($self->close_bracket($self->{delimiter_start})){my$accept;while ($self->find_regexp(qr{ \A ( \s* \n \s* ) ( \# [^\n]* \n ) }smx)){my ($white_space,$comment)=$self->capture();push@tokens,$self->make_token(length$white_space,'PPIx::Regexp::Token::Whitespace',),$self->make_token(length$comment,'PPIx::Regexp::Token::Comment',)}$accept=$self->find_regexp(qr{ \A \s+ }smx)and push@tokens,$self->make_token($accept,'PPIx::Regexp::Token::Whitespace');my$character=$self->peek();$self->{delimiter_start}=$character;push@tokens,$self->make_token(1,'PPIx::Regexp::Token::Delimiter');$self->{delimiter_finish}=substr $self->{content},$self->{cursor_limit}- 1,1}if ($self->modifier('e*')){push@tokens,$self->make_token($self->{cursor_limit}- $self->{cursor_curr},'PPIx::Regexp::Token::Code',{perl_version_introduced=>MINIMUM_PERL },);$self->{cursor_limit}=length$self->{content};push@tokens,$self->make_token(1,'PPIx::Regexp::Token::Delimiter'),@{delete$self->{trailing_tokens}};$self->_set_mode('kaput')}else {$self->_set_mode('repl')}}return@tokens}1;
PPIX_REGEXP_TOKENIZER

$fatpacked{"PPIx/Regexp/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_REGEXP_UTIL';
  package PPIx::Regexp::Util;use 5.006;use strict;use warnings;use Carp;use Scalar::Util qw{blessed};use base qw{Exporter};our@EXPORT_OK=qw{__choose_tokenizer_class __instance __to_ordinal_en};our$VERSION='0.01';{my@ppi_zoo=(['PPI::Token::Regexp::Transliterate' ],['PPI::Token::Regexp','PPIx::Regexp::Tokenizer' ],['PPI::Token::QuoteLike::Regexp','PPIx::Regexp::Tokenizer' ],['PPI::Token::Quote','PPIx::Regexp::StringTokenizer' ],['PPI::Token::QuoteLike::Command','PPIx::Regexp::StringTokenizer' ],['PPI::Token::QuoteLike::BackTick','PPIx::Regexp::StringTokenizer' ],['PPI::Token::HereDoc','PPIx::Regexp::StringTokenizer' ],);my%parse_type=(guess=>sub {my ($content)=@_;if (__instance($content,'PPI::Element')){for (@ppi_zoo){$content->isa($_->[0])and return $_->[1]}return}elsif (ref$content){return}else {return$content =~ m/ \A \s*
  		(?: ["'`] | << | (?: (?: qq | q | qx ) \b ) ) /smx ? 'PPIx::Regexp::StringTokenizer' : 'PPIx::Regexp::Tokenizer'}},regex=>sub {return 'PPIx::Regexp::Tokenizer'},string=>sub {return 'PPIx::Regexp::StringTokenizer'},);sub __choose_tokenizer_class {my ($content,$arg)=@_;my$parse=defined$arg->{parse}? $arg->{parse}: 'regex';my$code=$parse_type{$parse}or return PPIx::Regexp::Tokenizer->__set_errstr("Unknown parse type '$parse'");return$code->($content)}}sub __instance {my ($object,$class)=@_;blessed($object)or return;return$object->isa($class)}sub __to_ordinal_en {my ($num)=@_;$num += 0;1==$num % 10 and return "${num}st";2==$num % 10 and return "${num}nd";3==$num % 10 and return "${num}rd";return "${num}th"}1;
PPIX_REGEXP_UTIL

$fatpacked{"PPIx/Utilities.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_UTILITIES';
  package PPIx::Utilities;use 5.006001;use strict;use warnings;our$VERSION='0.01';1;
PPIX_UTILITIES

$fatpacked{"PPIx/Utilities/Exception/Bug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_UTILITIES_EXCEPTION_BUG';
  package PPIx::Utilities::Exception::Bug;use 5.006001;use strict;use warnings;our$VERSION='0.01';use Exception::Class ('PPIx::Utilities::Exception::Bug'=>{isa=>'Exception::Class::Base',description=>'A bug in either PPIx::Utilities or PPI.',},);1;
PPIX_UTILITIES_EXCEPTION_BUG

$fatpacked{"PPIx/Utilities/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_UTILITIES_NODE';
  package PPIx::Utilities::Node;use 5.006001;use strict;use warnings;our$VERSION='0.01';use Readonly;use PPI::Document::Fragment 1.208 qw<>;use Scalar::Util qw<refaddr>;use PPIx::Utilities::Exception::Bug qw<>;use base 'Exporter';Readonly::Array our@EXPORT_OK=>qw<split_ppi_node_by_namespace>;sub split_ppi_node_by_namespace {my ($node)=@_;$node=$node->clone();eval {$node->location()};if (my$single_namespace=_split_ppi_node_by_namespace_single($node)){return$single_namespace}my%nodes_by_namespace;_split_ppi_node_by_namespace_in_lexical_scope($node,'main',undef,\%nodes_by_namespace,);return \%nodes_by_namespace}sub _split_ppi_node_by_namespace_single {my ($node)=@_;my$package_statements=$node->find('PPI::Statement::Package');if (not $package_statements or not @{$package_statements}){return {main=>[$node]}}if (@{$package_statements}==1){my$package_statement=$package_statements->[0];my$package_address=refaddr$package_statement;my$first_child=$node->child(0);if ($package_address==refaddr$node or $first_child and $package_address==refaddr$first_child){return {$package_statement->namespace()=>[$node]}}}return}sub _split_ppi_node_by_namespace_in_lexical_scope {my ($node,$initial_namespace,$initial_fragment,$nodes_by_namespace)=@_;my%scope_fragments_by_namespace;my$initial_fragment_address=refaddr$initial_fragment || 0;my ($namespace,$fragment)=($initial_namespace,$initial_fragment);if ($initial_fragment){$scope_fragments_by_namespace{$namespace}=$initial_fragment}for my$child ($node->children()){if ($child->isa('PPI::Statement::Package')){if ($fragment){_push_fragment($nodes_by_namespace,$namespace,$fragment);undef$fragment}$namespace=$child->namespace()}elsif ($child->isa('PPI::Statement::Compound')or $child->isa('PPI::Statement::Given')or $child->isa('PPI::Statement::When')){my$block;my@components=$child->children();while (not $block and my$component=shift@components){if ($component->isa('PPI::Structure::Block')){$block=$component}}if ($block){if (not $fragment){$fragment=_get_fragment_for_split_ppi_node($nodes_by_namespace,\%scope_fragments_by_namespace,$namespace,)}_split_ppi_node_by_namespace_in_lexical_scope($block,$namespace,$fragment,$nodes_by_namespace,)}}$fragment=_get_fragment_for_split_ppi_node($nodes_by_namespace,\%scope_fragments_by_namespace,$namespace,);if ($initial_fragment_address!=refaddr$fragment){$child->remove()or PPIx::Utilities::Exception::Bug->throw('Could not remove child from parent.');$fragment->add_element($child)or PPIx::Utilities::Exception::Bug->throw('Could not add child to fragment.')}}return}sub _get_fragment_for_split_ppi_node {my ($nodes_by_namespace,$scope_fragments_by_namespace,$namespace)=@_;my$fragment;if (not $fragment=$scope_fragments_by_namespace->{$namespace}){$fragment=PPI::Document::Fragment->new();$scope_fragments_by_namespace->{$namespace}=$fragment;_push_fragment($nodes_by_namespace,$namespace,$fragment)}return$fragment}sub _push_fragment {my ($nodes_by_namespace,$namespace,$fragment)=@_;my$nodes=$nodes_by_namespace->{$namespace}||= [];if (not @{$nodes}or refaddr$nodes->[-1]!=refaddr$fragment){push @{$nodes},$fragment}return}1;
PPIX_UTILITIES_NODE

$fatpacked{"PPIx/Utilities/Statement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPIX_UTILITIES_STATEMENT';
  package PPIx::Utilities::Statement;use 5.006001;use strict;use warnings;our$VERSION='0.01';use Readonly;use PPI 1.208 qw<>;use base 'Exporter';our@EXPORT_OK=qw(get_constant_name_elements_from_declaring_statement);Readonly::Hash my%IS_COMMA=>(q[,]=>1,q[=>]=>1);sub get_constant_name_elements_from_declaring_statement {my ($element)=@_;return if not $element;return if not $element->isa('PPI::Statement');if ($element->isa('PPI::Statement::Include')){my$pragma;if ($pragma=$element->pragma()and $pragma eq 'constant'){return _get_constant_names_from_constant_pragma($element)}}elsif (not $element->specialized()and $element->schildren()> 2){my$supposed_constant_function=$element->schild(0)->content();my$declaring_scope=$element->schild(1)->content();if (($supposed_constant_function eq 'const' or $supposed_constant_function =~ m< \A Readonly \b >xms)and ($declaring_scope eq 'our' or $declaring_scope eq 'my')){return$element->schild(2)}}return}sub _get_constant_names_from_constant_pragma {my ($include)=@_;my@arguments=$include->arguments()or return;my$follower=$arguments[0];return if not defined$follower;if ($follower->isa('PPI::Structure::Constructor')or $follower->isa('PPI::Structure::Block')){my$statement=$follower->schild(0)or return;$statement->isa('PPI::Statement')or return;my@elements;my$inx=0;for my$child ($statement->schildren()){if (not $inx % 2){push @{$elements[$inx ]||= []},$child}if ($IS_COMMA{$child->content()}){$inx++}}return map {($_ and @{$_}==2 and '=>' eq $_->[1]->content()and $_->[0]->isa('PPI::Token::Word'))? $_->[0]: ()}@elements}else {return$follower}return$follower}1;
PPIX_UTILITIES_STATEMENT

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;BEGIN {$Package::Stash::AUTHORITY='cpan:DOY'}$Package::Stash::VERSION='0.01';use strict;use warnings;use 5.008001;our$IMPLEMENTATION;use Module::Implementation 0.06;BEGIN {local$ENV{PACKAGE_STASH_IMPLEMENTATION}=$IMPLEMENTATION if ($IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION});Module::Implementation::build_loader_sub(implementations=>['XS','PP' ],symbols=>[qw(new name namespace add_symbol remove_glob has_symbol get_symbol get_or_add_symbol remove_symbol list_all_symbols get_all_symbols)],)->();$IMPLEMENTATION=Module::Implementation::implementation_for(__PACKAGE__)}1;
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package Package::Stash::Conflicts;use strict;use warnings;use Dist::CheckConflicts -dist=>'Package::Stash',-conflicts=>{'Class::MOP'=>'1.08','MooseX::Method::Signatures'=>'0.36','MooseX::Role::WithOverloading'=>'0.08','namespace::clean'=>'0.18',},-also=>[qw(B Carp Dist::CheckConflicts Getopt::Long Module::Implementation Scalar::Util Symbol constant strict warnings) ],;1;
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;BEGIN {$Package::Stash::PP::AUTHORITY='cpan:DOY'}$Package::Stash::PP::VERSION='0.01';use strict;use warnings;use B;use Carp qw(confess);use Scalar::Util qw(blessed reftype weaken);use Symbol;use constant BROKEN_ISA_ASSIGNMENT=>($] < 5.012);use constant BROKEN_WEAK_STASH=>($] < 5.010);use constant BROKEN_SCALAR_INITIALIZATION=>($] < 5.010);use constant BROKEN_GLOB_ASSIGNMENT=>($] < 5.013004);use constant HAS_ISA_CACHE=>($] < 5.010);sub new {my$class=shift;my ($package)=@_;if (!defined($package)|| (ref($package)&& reftype($package)ne 'HASH')){confess "Package::Stash->new must be passed the name of the " ."package to access"}elsif (ref($package)&& reftype($package)eq 'HASH'){confess "The PP implementation of Package::Stash does not support " ."anonymous stashes before perl 5.14" if BROKEN_GLOB_ASSIGNMENT;return bless {'namespace'=>$package,},$class}elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/){return bless {'package'=>$package,},$class}else {confess "$package is not a module name"}}sub name {confess "Can't call name as a class method" unless blessed($_[0]);confess "Can't get the name of an anonymous package" unless defined($_[0]->{package});return $_[0]->{package}}sub namespace {confess "Can't call namespace as a class method" unless blessed($_[0]);if (BROKEN_WEAK_STASH){no strict 'refs';return \%{$_[0]->name .'::'}}else {return $_[0]->{namespace}if defined $_[0]->{namespace};{no strict 'refs';$_[0]->{namespace}=\%{$_[0]->name .'::'}}weaken($_[0]->{namespace});return $_[0]->{namespace}}}{my%SIGIL_MAP=('$'=>'SCALAR','@'=>'ARRAY','%'=>'HASH','&'=>'CODE',''=>'IO',);sub _deconstruct_variable_name {my ($variable)=@_;my@ret;if (ref($variable)eq 'HASH'){@ret=@{$variable}{qw[name sigil type]}}else {(defined$variable && length$variable)|| confess "You must pass a variable name";my$sigil=substr($variable,0,1,'');if (exists$SIGIL_MAP{$sigil}){@ret=($variable,$sigil,$SIGIL_MAP{$sigil})}else {@ret=("${sigil}${variable}",'',$SIGIL_MAP{''})}}($ret[0]!~ /::/)|| confess "Variable names may not contain ::";return@ret}}sub _valid_for_type {my ($value,$type)=@_;if ($type eq 'HASH' || $type eq 'ARRAY' || $type eq 'IO' || $type eq 'CODE'){return reftype($value)eq $type}else {my$ref=reftype($value);return!defined($ref)|| $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING'}}sub add_symbol {my ($self,$variable,$initial_value,%opts)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);if (@_ > 2){_valid_for_type($initial_value,$type)|| confess "$initial_value is not of type $type";if ($^P and $^P & 0x10 && $sigil eq '&'){my$filename=$opts{filename};my$first_line_num=$opts{first_line_num};(undef,$filename,$first_line_num)=caller if not defined$filename;my$last_line_num=$opts{last_line_num}|| ($first_line_num ||= 0);$DB::sub{$self->name .'::' .$name}="$filename:$first_line_num-$last_line_num"}}if (BROKEN_GLOB_ASSIGNMENT){if (@_ > 2){no strict 'refs';no warnings 'redefine';*{$self->name .'::' .$name}=ref$initial_value ? $initial_value : \$initial_value}else {no strict 'refs';if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA'){*{$self->name .'::' .$name}}else {my$undef=_undef_ref_for_type($type);*{$self->name .'::' .$name}=$undef}}}else {my$namespace=$self->namespace;{local*__ANON__::=$namespace;no strict 'refs';no warnings 'void';no warnings 'once';*{"__ANON__::$name"}}if (@_ > 2){no warnings 'redefine';*{$namespace->{$name}}=ref$initial_value ? $initial_value : \$initial_value}else {return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';*{$namespace->{$name}}=_undef_ref_for_type($type)}}}sub _undef_ref_for_type {my ($type)=@_;if ($type eq 'ARRAY'){return []}elsif ($type eq 'HASH'){return {}}elsif ($type eq 'SCALAR'){return \undef}elsif ($type eq 'IO'){return Symbol::geniosym}elsif ($type eq 'CODE'){confess "Don't know how to vivify CODE variables"}else {confess "Unknown type $type in vivication"}}sub remove_glob {my ($self,$name)=@_;delete$self->namespace->{$name}}sub has_symbol {my ($self,$variable)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my$namespace=$self->namespace;return unless exists$namespace->{$name};my$entry_ref=\$namespace->{$name};if (reftype($entry_ref)eq 'GLOB'){if ($type eq 'SCALAR'){if (BROKEN_SCALAR_INITIALIZATION){return defined ${*{$entry_ref}{$type}}}else {my$sv=B::svref_2object($entry_ref)->SV;return$sv->isa('B::SV')|| ($sv->isa('B::SPECIAL')&& $B::specialsv_name[$$sv]ne 'Nullsv')}}else {return defined *{$entry_ref}{$type}}}else {return$type eq 'CODE'}}sub get_symbol {my ($self,$variable,%opts)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my$namespace=$self->namespace;if (!exists$namespace->{$name}){if ($opts{vivify}){$self->add_symbol($variable)}else {return undef}}my$entry_ref=\$namespace->{$name};if (ref($entry_ref)eq 'GLOB'){return *{$entry_ref}{$type}}else {if ($type eq 'CODE'){if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})){no strict 'refs';return \&{$self->name .'::' .$name}}if (blessed($namespace)&& $namespace->isa('Package::Anon')){$namespace->bless(\(my$foo))->can($name)}else {confess "Don't know how to inflate a " .ref($entry_ref)." into a full coderef (perhaps you could use" ." Package::Anon instead of a bare stash?)"}return *{$namespace->{$name}}{CODE}}else {return undef}}}sub get_or_add_symbol {my$self=shift;$self->get_symbol(@_,vivify=>1)}sub remove_symbol {my ($self,$variable)=@_;my ($name,$sigil,$type)=_deconstruct_variable_name($variable);my%desc=(SCALAR=>{sigil=>'$',type=>'SCALAR',name=>$name },ARRAY=>{sigil=>'@',type=>'ARRAY',name=>$name },HASH=>{sigil=>'%',type=>'HASH',name=>$name },CODE=>{sigil=>'&',type=>'CODE',name=>$name },IO=>{sigil=>'',type=>'IO',name=>$name },);confess "This should never ever ever happen" if!$desc{$type};my@types_to_store=grep {$type ne $_ && $self->has_symbol($desc{$_})}keys%desc;my%values=map {$_,$self->get_symbol($desc{$_})}@types_to_store;$values{SCALAR}=$self->get_symbol($desc{SCALAR})if!defined$values{SCALAR}&& $type ne 'SCALAR' && BROKEN_SCALAR_INITIALIZATION;$self->remove_glob($name);$self->add_symbol($desc{$_}=>$values{$_})for grep {defined$values{$_}}keys%values}sub list_all_symbols {my ($self,$type_filter)=@_;my$namespace=$self->namespace;if (HAS_ISA_CACHE){return grep {$_ ne '::ISA::CACHE::'}keys %{$namespace}unless defined$type_filter}else {return keys %{$namespace}unless defined$type_filter}if ($type_filter eq 'CODE'){return grep {ref(\$namespace->{$_})ne 'GLOB' || defined(*{$namespace->{$_}}{CODE})}keys %{$namespace}}elsif ($type_filter eq 'SCALAR'){return grep {!(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::')&& (BROKEN_SCALAR_INITIALIZATION ? (ref(\$namespace->{$_})eq 'GLOB' && defined(${*{$namespace->{$_}}{'SCALAR'}})): (do {my$entry=\$namespace->{$_};ref($entry)eq 'GLOB' && B::svref_2object($entry)->SV->isa('B::SV')}))}keys %{$namespace}}else {return grep {ref(\$namespace->{$_})eq 'GLOB' && defined(*{$namespace->{$_}}{$type_filter})}keys %{$namespace}}}sub get_all_symbols {my ($self,$type_filter)=@_;my$namespace=$self->namespace;return {%{$namespace}}unless defined$type_filter;return {map {$_=>$self->get_symbol({name=>$_,type=>$type_filter})}$self->list_all_symbols($type_filter)}}1;
PACKAGE_STASH_PP

$fatpacked{"Package/Stash/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_XS';
  package Package::Stash::XS;BEGIN {$Package::Stash::XS::AUTHORITY='cpan:DOY'}{$Package::Stash::XS::VERSION='0.01'}use strict;use warnings;use 5.008001;use XSLoader;XSLoader::load(__PACKAGE__,exists$Package::Stash::XS::{VERSION}? ${$Package::Stash::XS::{VERSION}}: (),);1;
PACKAGE_STASH_XS

$fatpacked{"Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_UTIL';
  package Params::Util;use 5.00503;use strict;require overload;require Exporter;require Scalar::Util;require DynaLoader;use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};$VERSION='0.01';@ISA=qw{Exporter DynaLoader};@EXPORT_OK=qw{_STRING _IDENTIFIER _CLASS _CLASSISA _SUBCLASS _DRIVER _CLASSDOES _NUMBER _POSINT _NONNEGINT _SCALAR _SCALAR0 _ARRAY _ARRAY0 _ARRAYLIKE _HASH _HASH0 _HASHLIKE _CODE _CODELIKE _INVOCANT _REGEX _INSTANCE _INSTANCEDOES _SET _SET0 _HANDLE};%EXPORT_TAGS=(ALL=>\@EXPORT_OK);eval {local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};bootstrap Params::Util$VERSION;1}unless$ENV{PERL_PARAMS_UTIL_PP};my$SU=eval "$Scalar::Util::VERSION" || 0;if ($SU >= 1.18){Scalar::Util->import('looks_like_number')}else {eval <<'END_PERL'}eval <<'END_PERL' unless defined&_STRING;eval <<'END_PERL' unless defined&_IDENTIFIER;eval <<'END_PERL' unless defined&_CLASS;eval <<'END_PERL' unless defined&_CLASSISA;eval <<'END_PERL' unless defined&_CLASSDOES;eval <<'END_PERL' unless defined&_SUBCLASS;eval <<'END_PERL' unless defined&_NUMBER;eval <<'END_PERL' unless defined&_POSINT;eval <<'END_PERL' unless defined&_NONNEGINT;eval <<'END_PERL' unless defined&_SCALAR;eval <<'END_PERL' unless defined&_SCALAR0;eval <<'END_PERL' unless defined&_ARRAY;eval <<'END_PERL' unless defined&_ARRAY0;eval <<'END_PERL' unless defined&_ARRAYLIKE;eval <<'END_PERL' unless defined&_HASH;eval <<'END_PERL' unless defined&_HASH0;eval <<'END_PERL' unless defined&_HASHLIKE;eval <<'END_PERL' unless defined&_CODE;eval <<'END_PERL' unless defined&_CODELIKE;eval <<'END_PERL' unless defined&_INVOCANT;eval <<'END_PERL' unless defined&_INSTANCE;eval <<'END_PERL' unless defined&_INSTANCEDOES;eval <<'END_PERL' unless defined&_REGEX;eval <<'END_PERL' unless defined&_SET;eval <<'END_PERL' unless defined&_SET0;eval <<'END_PERL' unless defined&_HANDLE;eval <<'END_PERL' unless defined&_DRIVER;1;
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
PARAMS_UTIL

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;use strict;use warnings;package Path::Tiny;our$VERSION='0.01';use Config;use Exporter 5.57 (qw/import/);use File::Spec 0.86 ();use Carp ();our@EXPORT=qw/path/;our@EXPORT_OK=qw/cwd rootdir tempfile tempdir/;use constant {PATH=>0,CANON=>1,VOL=>2,DIR=>3,FILE=>4,TEMP=>5,IS_BSD=>(scalar $^O =~ /bsd$/),IS_WIN32=>($^O eq 'MSWin32'),};use overload (q{""}=>sub {$_[0]->[PATH]},bool=>sub () {1},fallback=>1,);sub FREEZE {return $_[0]->[PATH]}sub THAW {return path($_[2])}{no warnings 'once';*TO_JSON=*FREEZE};my$HAS_UU;sub _check_UU {!!eval {require Unicode::UTF8;Unicode::UTF8->VERSION(0.58);1}}my$HAS_PU;sub _check_PU {!!eval {require PerlIO::utf8_strict;PerlIO::utf8_strict->VERSION(0.003);1}}my$HAS_FLOCK=$Config{d_flock}|| $Config{d_fcntl_can_lock}|| $Config{d_lockf};my$SLASH=qr{[\\/]};my$NOTSLASH=qr{[^\\/]};my$DRV_VOL=qr{[a-z]:}i;my$UNC_VOL=qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;my$WIN32_ROOT=qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;sub _win32_vol {my ($path,$drv)=@_;require Cwd;my$dcwd=eval {Cwd::getdcwd($drv)};$dcwd="$drv" unless defined$dcwd && length$dcwd;$dcwd =~ s{$SLASH?$}{/};$path =~ s{^$DRV_VOL}{$dcwd};return$path}sub _is_root {return IS_WIN32()? ($_[0]=~ /^$WIN32_ROOT$/): ($_[0]eq '/')}BEGIN {*_same=IS_WIN32()? sub {lc($_[0])eq lc($_[1])}: sub {$_[0]eq $_[1]}}my%MODEBITS=(om=>0007,gm=>0070,um=>0700);{my$m=0;$MODEBITS{$_}=(1 << $m++)for qw/ox ow or gx gw gr ux uw ur/};sub _symbolic_chmod {my ($mode,$symbolic)=@_;for my$clause (split /,\s*/,$symbolic){if ($clause =~ m{\A([augo]+)([=+-])([rwx]+)\z}){my ($who,$action,$perms)=($1,$2,$3);$who =~ s/a/ugo/g;for my$w (split //,$who){my$p=0;$p |= $MODEBITS{"$w$_"}for split //,$perms;if ($action eq '='){$mode=($mode & ~$MODEBITS{"${w}m"})| $p}else {$mode=$action eq "+" ? ($mode | $p): ($mode & ~$p)}}}else {Carp::croak("Invalid mode clause '$clause' for chmod()")}}return$mode}{package flock;use if Path::Tiny::IS_BSD(),'warnings::register'}my$WARNED_BSD_NFS=0;sub _throw {my ($self,$function,$file,$msg)=@_;if (IS_BSD()&& $function =~ /^flock/ && $! =~ /operation not supported/i &&!warnings::fatal_enabled('flock')){if (!$WARNED_BSD_NFS){warnings::warn(flock=>"No flock for NFS on BSD: continuing in unsafe mode");$WARNED_BSD_NFS++}}else {$msg=$! unless defined$msg;Path::Tiny::Error->throw($function,(defined$file ? $file : $self->[PATH]),$msg)}return}sub _get_args {my ($raw,@valid)=@_;if (defined($raw)&& ref($raw)ne 'HASH'){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Options for $called_as must be a hash reference")}my$cooked={};for my$k (@valid){$cooked->{$k}=delete$raw->{$k}if exists$raw->{$k}}if (keys %$raw){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Invalid option(s) for $called_as: " .join(", ",keys %$raw))}return$cooked}sub path {my$path=shift;Carp::croak("Path::Tiny paths require defined, positive-length parts")unless 1 + @_==grep {defined && length}$path,@_;if (!@_ && ref($path)eq __PACKAGE__ &&!$path->[TEMP]){return$path}$path="$path";if (IS_WIN32()){$path=_win32_vol($path,$1)if$path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};$path .= "/" if$path =~ m{^$UNC_VOL$}}if (@_){$path .= (_is_root($path)? "" : "/").join("/",@_)}my$cpath=$path=File::Spec->canonpath($path);$path =~ tr[\\][/] if IS_WIN32();$path="/" if$path eq '/..';$path .= "/" if IS_WIN32()&& $path =~ m{^$UNC_VOL$};if (_is_root($path)){$path =~ s{/?$}{/}}else {$path =~ s{/$}{}}if ($path =~ m{^(~[^/]*).*}){require File::Glob;my ($homedir)=File::Glob::bsd_glob($1);$homedir =~ tr[\\][/] if IS_WIN32();$path =~ s{^(~[^/]*)}{$homedir}}bless [$path,$cpath ],__PACKAGE__}sub new {shift;path(@_)}sub cwd {require Cwd;return path(Cwd::getcwd())}sub rootdir {path(File::Spec->rootdir)}sub tempfile {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);$args->{TEMPLATE}=$maybe_template->[0]if @$maybe_template;require File::Temp;my$temp=File::Temp->new(TMPDIR=>1,%$args);close$temp;my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub tempdir {shift if @_ && $_[0]eq 'Path::Tiny';my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my ($maybe_template,$args)=_parse_file_temp_args(@_);require File::Temp;my$temp=File::Temp->newdir(@$maybe_template,TMPDIR=>1,%$args);my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;$temp->{REALNAME}=$self->[CANON]if IS_WIN32;return$self}sub _parse_file_temp_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? delete$args{TEMPLATE}: $leading_template ? $leading_template : ());return (\@template,\%args)}sub _splitpath {my ($self)=@_;@{$self}[VOL,DIR,FILE ]=File::Spec->splitpath($self->[PATH])}sub _resolve_symlinks {my ($self)=@_;my$new=$self;my ($count,%seen)=0;while (-l $new->[PATH]){if ($seen{$new->[PATH]}++){$self->_throw('readlink',$self->[PATH],"symlink loop detected")}if (++$count > 100){$self->_throw('readlink',$self->[PATH],"maximum symlink depth exceeded")}my$resolved=readlink$new->[PATH]or $new->_throw('readlink',$new->[PATH]);$resolved=path($resolved);$new=$resolved->is_absolute ? $resolved : $new->sibling($resolved)}return$new}sub absolute {my ($self,$base)=@_;if (IS_WIN32){return$self if length$self->volume;if ($self->is_absolute){require Cwd;my ($drv)=Win32::GetCwd()=~ /^($DRV_VOL | $UNC_VOL)/x;return path($drv .$self->[PATH])}}else {return$self if$self->is_absolute}require Cwd;return path(Cwd::getcwd(),$_[0]->[PATH])unless defined$base;$base=path($base);return path(($base->is_absolute ? $base : $base->absolute),$_[0]->[PATH])}sub append {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$mode=$args->{truncate}? ">" : ">>";my$fh=$self->filehandle({locked=>1 },$mode,$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close')}sub append_raw {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);$args->{binmode}=':unix';append($self,$args,@data)}sub append_utf8 {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){$args->{binmode}=":unix";append($self,$args,map {Unicode::UTF8::encode_utf8($_)}@data)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";append($self,$args,@data)}else {$args->{binmode}=":unix:encoding(UTF-8)";append($self,$args,@data)}}sub assert {my ($self,$assertion)=@_;return$self unless$assertion;if (ref$assertion eq 'CODE'){local $_=$self;$assertion->()or Path::Tiny::Error->throw("assert",$self->[PATH],"failed assertion")}else {Carp::croak("argument to assert must be a code reference argument")}return$self}sub basename {my ($self,@suffixes)=@_;$self->_splitpath unless defined$self->[FILE];my$file=$self->[FILE];for my$s (@suffixes){my$re=ref($s)eq 'Regexp' ? qr/$s$/ : qr/\Q$s\E$/;last if$file =~ s/$re//}return$file}sub canonpath {$_[0]->[CANON]}sub cached_temp {my$self=shift;$self->_throw("cached_temp",$self,"has no cached File::Temp object")unless defined$self->[TEMP];return$self->[TEMP]}sub child {my ($self,@parts)=@_;return path($self->[PATH],@parts)}sub children {my ($self,$filter)=@_;my$dh;opendir$dh,$self->[PATH]or $self->_throw('opendir');my@children=readdir$dh;closedir$dh or $self->_throw('closedir');if (not defined$filter){@children=grep {$_ ne '.' && $_ ne '..'}@children}elsif ($filter && ref($filter)eq 'Regexp'){@children=grep {$_ ne '.' && $_ ne '..' && $_ =~ $filter}@children}else {Carp::croak("Invalid argument '$filter' for children()")}return map {path($self->[PATH],$_)}@children}sub chmod {my ($self,$new_mode)=@_;my$mode;if ($new_mode =~ /\d/){$mode=($new_mode =~ /^0/ ? oct($new_mode): $new_mode)}elsif ($new_mode =~ /[=+-]/){$mode=_symbolic_chmod($self->stat->mode & 07777,$new_mode)}else {Carp::croak("Invalid mode argument '$new_mode' for chmod()")}CORE::chmod($mode,$self->[PATH])or $self->_throw("chmod");return 1}sub copy {my ($self,$dest)=@_;require File::Copy;File::Copy::copy($self->[PATH],$dest)or Carp::croak("copy failed for $self to $dest: $!");return -d $dest ? path($dest,$self->basename): path($dest)}sub digest {my ($self,@opts)=@_;my$args=(@opts && ref$opts[0]eq 'HASH')? shift@opts : {};$args=_get_args($args,qw/chunk_size/);unshift@opts,'SHA-256' unless@opts;require Digest;my$digest=Digest->new(@opts);if ($args->{chunk_size}){my$fh=$self->filehandle({locked=>1 },"<",":unix");my$buf;$digest->add($buf)while read$fh,$buf,$args->{chunk_size}}else {$digest->add($self->slurp_raw)}return$digest->hexdigest}sub dirname {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return length$self->[DIR]? $self->[DIR]: "."}sub edit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp(exists($args->{binmode})? {binmode=>$args->{binmode}}: ());$cb->();$self->spew($args,$_);return}sub edit_utf8 {my ($self,$cb)=@_;Carp::croak("Callback for edit_utf8() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp_utf8;$cb->();$self->spew_utf8($_);return}sub edit_raw {$_[2]={binmode=>":unix" };goto&edit}sub edit_lines {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit_lines() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$temp_fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);my$in_fh=$self->filehandle({locked=>1 },'<',$binmode);local $_;while (<$in_fh>){$cb->();$temp_fh->print($_)}close$temp_fh or $self->_throw('close',$temp);close$in_fh or $self->_throw('close');return$temp->move($resolved_path)}sub edit_lines_raw {$_[2]={binmode=>":unix" };goto&edit_lines}sub edit_lines_utf8 {$_[2]={binmode=>":raw:encoding(UTF-8)" };goto&edit_lines}sub exists {-e $_[0]->[PATH]}sub is_file {-e $_[0]->[PATH]&&!-d _}sub is_dir {-d $_[0]->[PATH]}sub filehandle {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked exclusive/);$args->{locked}=1 if$args->{exclusive};my ($opentype,$binmode)=@args;$opentype="<" unless defined$opentype;Carp::croak("Invalid file mode '$opentype'")unless grep {$opentype eq $_}qw/< +< > +> >> +>>/;$binmode=((caller(0))[10]|| {})->{'open' .substr($opentype,-1,1)}unless defined$binmode;$binmode="" unless defined$binmode;my ($fh,$lock,$trunc);if ($HAS_FLOCK && $args->{locked}){require Fcntl;if (grep {$opentype eq $_}qw(> +>)){my$flags=$opentype eq ">" ? Fcntl::O_WRONLY(): Fcntl::O_RDWR();$flags |= Fcntl::O_CREAT();$flags |= Fcntl::O_EXCL()if$args->{exclusive};sysopen($fh,$self->[PATH],$flags)or $self->_throw("sysopen");if ($binmode =~ s/^:unix//){binmode($fh,":raw")or $self->_throw("binmode (:raw)");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")or $self->_throw("binmode (:pop)")}}if (length$binmode){binmode($fh,$binmode)or $self->_throw("binmode ($binmode)")}$lock=Fcntl::LOCK_EX();$trunc=1}elsif ($^O eq 'aix' && $opentype eq "<"){if (-w $self->[PATH]){$opentype="+<";$lock=Fcntl::LOCK_EX()}}else {$lock=$opentype eq "<" ? Fcntl::LOCK_SH(): Fcntl::LOCK_EX()}}unless ($fh){my$mode=$opentype .$binmode;open$fh,$mode,$self->[PATH]or $self->_throw("open ($mode)")}do {flock($fh,$lock)or $self->_throw("flock ($lock)")}if$lock;do {truncate($fh,0)or $self->_throw("truncate")}if$trunc;return$fh}sub is_absolute {substr($_[0]->dirname,0,1)eq '/'}sub is_relative {substr($_[0]->dirname,0,1)ne '/'}sub is_rootdir {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return$self->[DIR]eq '/' && $self->[FILE]eq ''}sub iterator {my$self=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);my@dirs=$self;my$current;return sub {my$next;while (@dirs){if (ref$dirs[0]eq 'Path::Tiny'){if (!-r $dirs[0]){shift@dirs and next}$current=$dirs[0];my$dh;opendir($dh,$current->[PATH])or $self->_throw('opendir',$current->[PATH]);$dirs[0]=$dh;if (-l $current->[PATH]&&!$args->{follow_symlinks}){shift@dirs and next}}while (defined($next=readdir$dirs[0])){next if$next eq '.' || $next eq '..';my$path=$current->child($next);push@dirs,$path if$args->{recurse}&& -d $path &&!(!$args->{follow_symlinks}&& -l $path);return$path}shift@dirs}return}}sub lines {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);my$chomp=$args->{chomp};if ($args->{count}){my ($counter,$mod,@result)=(0,abs($args->{count}));while (my$line=<$fh>){$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if$chomp;$result[$counter++ ]=$line;last if$counter==$args->{count};$counter %= $mod}splice(@result,0,0,splice(@result,$counter))if@result==$mod && $counter % $mod;return@result}elsif ($chomp){return map {s/(?:\x{0d}?\x{0a}|\x{0d})$//;$_}<$fh>}else {return wantarray ? <$fh> : (my$count=()=<$fh>)}}sub lines_raw {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ($args->{chomp}&&!$args->{count}){return split /\n/,slurp_raw($self)}else {$args->{binmode}=":raw";return lines($self,$args)}}my$CRLF=qr/(?:\x{0d}?\x{0a}|\x{0d})/;sub lines_utf8 {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ((defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU()))&& $args->{chomp}&&!$args->{count}){my$slurp=slurp_utf8($self);$slurp =~ s/$CRLF$//;return split$CRLF,$slurp,-1}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";return lines($self,$args)}else {$args->{binmode}=":raw:encoding(UTF-8)";return lines($self,$args)}}sub mkpath {my ($self,$args)=@_;$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};require File::Path;my@dirs=File::Path::make_path($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("mkpath failed for $file: $message")}return@dirs}sub move {my ($self,$dst)=@_;return rename($self->[PATH],$dst)|| $self->_throw('rename',$self->[PATH]."' -> '$dst")}my%opens=(opena=>">>",openr=>"<",openw=>">",openrw=>"+<");while (my ($k,$v)=each%opens){no strict 'refs';*{$k}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($binmode)=@args;$binmode=((caller(0))[10]|| {})->{'open' .substr($v,-1,1)}unless defined$binmode;$self->filehandle($args,$v,$binmode)};*{$k ."_raw"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw")};*{$k ."_utf8"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw:encoding(UTF-8)")}}sub parent {my ($self,$level)=@_;$level=1 unless defined$level && $level > 0;$self->_splitpath unless defined$self->[FILE];my$parent;if (length$self->[FILE]){if ($self->[FILE]eq '.' || $self->[FILE]eq ".."){$parent=path($self->[PATH]."/..")}else {$parent=path(_non_empty($self->[VOL].$self->[DIR]))}}elsif (length$self->[DIR]){if ($self->[DIR]=~ m{(?:^\.\./|/\.\./|/\.\.$)}){$parent=path($self->[VOL].$self->[DIR]."/..")}else {(my$dir=$self->[DIR])=~ s{/[^\/]+/$}{/};$parent=path($self->[VOL].$dir)}}else {$parent=path(_non_empty($self->[VOL]))}return$level==1 ? $parent : $parent->parent($level - 1)}sub _non_empty {my ($string)=shift;return ((defined($string)&& length($string))? $string : ".")}sub realpath {my$self=shift;$self=$self->_resolve_symlinks;require Cwd;$self->_splitpath if!defined$self->[FILE];my$check_parent=length$self->[FILE]&& $self->[FILE]ne '.' && $self->[FILE]ne '..';my$realpath=eval {local$SIG{__WARN__}=sub {};Cwd::realpath($check_parent ? $self->parent->[PATH]: $self->[PATH])};$self->_throw("resolving realpath")unless defined$realpath && length$realpath && -e $realpath;return ($check_parent ? path($realpath,$self->[FILE]): path($realpath))}sub relative {my ($self,$base)=@_;$base=path(defined$base && length$base ? $base : '.');$self=$self->absolute if$self->is_relative;$base=$base->absolute if$base->is_relative;$self=$self->absolute if!length$self->volume && length$base->volume;$base=$base->absolute if length$self->volume &&!length$base->volume;if (!_same($self->volume,$base->volume)){Carp::croak("relative() can't cross volumes: '$self' vs '$base'")}return path(".")if _same($self->[PATH],$base->[PATH]);if ($base->subsumes($self)){$base="" if$base->is_rootdir;my$relative="$self";$relative =~ s{\A\Q$base/}{};return path($relative)}my (@common,@self_parts,@base_parts);@base_parts=split /\//,$base->_just_filepath;if ($self->is_rootdir){@common=("");shift@base_parts}else {@self_parts=split /\//,$self->_just_filepath;while (@self_parts && @base_parts && _same($self_parts[0],$base_parts[0])){push@common,shift@base_parts;shift@self_parts}}if (my$new_base=$self->_resolve_between(\@common,\@base_parts)){return$self->relative($new_base)}my@new_path=(("..")x (0+ @base_parts),@self_parts);return path(@new_path)}sub _just_filepath {my$self=shift;my$self_vol=$self->volume;return "$self" if!length$self_vol;(my$self_path="$self")=~ s{\A\Q$self_vol}{};return$self_path}sub _resolve_between {my ($self,$common,$base)=@_;my$path=$self->volume .join("/",@$common);my$changed=0;for my$p (@$base){$path .= "/$p";if ($p eq '..'){$changed=1;if (-e $path){$path=path($path)->realpath->[PATH]}else {$path =~ s{/[^/]+/..$}{/}}}if (-l $path){$changed=1;$path=path($path)->realpath->[PATH]}}return$changed ? path($path): undef}sub remove {my$self=shift;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];return unlink($self->[PATH])|| $self->_throw('unlink')}sub remove_tree {my ($self,$args)=@_;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};$args->{safe}=1 unless defined$args->{safe};require File::Path;my$count=File::Path::remove_tree($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("remove_tree failed for $file: $message")}return$count}sub sibling {my$self=shift;return path($self->parent->[PATH],@_)}sub slurp {my$self=shift;my$args=_get_args(shift,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);if ((defined($binmode)? $binmode : "")eq ":unix" and my$size=-s $fh){my$buf;read$fh,$buf,$size;return$buf}else {local $/;return scalar <$fh>}}sub slurp_raw {$_[1]={binmode=>":unix" };goto&slurp}sub slurp_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){return Unicode::UTF8::decode_utf8(slurp($_[0],{binmode=>":unix" }))}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$_[1]={binmode=>":unix:utf8_strict" };goto&slurp}else {$_[1]={binmode=>":raw:encoding(UTF-8)" };goto&slurp}}sub spew {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close',$temp->[PATH]);return$temp->move($resolved_path)}sub spew_raw {splice @_,1,0,{binmode=>":unix" };goto&spew}sub spew_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){my$self=shift;spew($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}map {ref eq 'ARRAY' ? @$_ : $_}@_)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){splice @_,1,0,{binmode=>":unix:utf8_strict" };goto&spew}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&spew}}sub stat {my$self=shift;require File::stat;return File::stat::stat($self->[PATH])|| $self->_throw('stat')}sub lstat {my$self=shift;require File::stat;return File::stat::lstat($self->[PATH])|| $self->_throw('lstat')}sub stringify {$_[0]->[PATH]}sub subsumes {my$self=shift;Carp::croak("subsumes() requires a defined, positive-length argument")unless defined $_[0];my$other=path(shift);if ($self->is_absolute &&!$other->is_absolute){$other=$other->absolute}elsif ($other->is_absolute &&!$self->is_absolute){$self=$self->absolute}if (length$self->volume &&!length$other->volume){$other=$other->absolute}elsif (length$other->volume &&!length$self->volume){$self=$self->absolute}if ($self->[PATH]eq '.'){return!!1}elsif ($self->is_rootdir){return$other->[PATH]=~ m{^\Q$self->[PATH]\E}}else {return$other->[PATH]=~ m{^\Q$self->[PATH]\E(?:/|$)}}}sub touch {my ($self,$epoch)=@_;if (!-e $self->[PATH]){my$fh=$self->openw;close$fh or $self->_throw('close')}if (defined$epoch){utime$epoch,$epoch,$self->[PATH]or $self->_throw("utime ($epoch)")}else {utime undef,undef,$self->[PATH]or $self->_throw("utime ()")}return$self}sub touchpath {my ($self)=@_;my$parent=$self->parent;$parent->mkpath unless$parent->exists;$self->touch}sub visit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);Carp::croak("Callback for visit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$next=$self->iterator($args);my$state={};while (my$file=$next->()){local $_=$file;my$r=$cb->($file,$state);last if ref($r)eq 'SCALAR' &&!$$r}return$state}sub volume {my ($self)=@_;$self->_splitpath unless defined$self->[VOL];return$self->[VOL]}package Path::Tiny::Error;our@CARP_NOT=qw/Path::Tiny/;use overload (q{""}=>sub {(shift)->{msg}},fallback=>1);sub throw {my ($class,$op,$file,$err)=@_;chomp(my$trace=Carp::shortmess);my$msg="Error $op on '$file': $err$trace\n";die bless {op=>$op,file=>$file,err=>$err,msg=>$msg },$class}1;
PATH_TINY

$fatpacked{"Perl/Critic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC';
  package Perl::Critic;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use Exporter 'import';use File::Spec;use List::MoreUtils qw<firstidx>;use Scalar::Util qw<blessed>;use Perl::Critic::Exception::Configuration::Generic;use Perl::Critic::Config;use Perl::Critic::Violation;use Perl::Critic::Document;use Perl::Critic::Statistics;use Perl::Critic::Utils qw<:characters hashify shebang_line>;our$VERSION='0.01';Readonly::Array our@EXPORT_OK=>qw(critique);sub new {my ($class,%args)=@_;my$self=bless {},$class;$self->{_config}=$args{-config}|| Perl::Critic::Config->new(%args);$self->{_stats}=Perl::Critic::Statistics->new();return$self}sub config {my$self=shift;return$self->{_config}}sub add_policy {my ($self,@args)=@_;return$self->config()->add_policy(@args)}sub policies {my$self=shift;return$self->config()->policies()}sub statistics {my$self=shift;return$self->{_stats}}sub critique {my ($self,$source_code)=@_ >= 2 ? @_ : ({},$_[0]);$self=ref$self eq 'HASH' ? __PACKAGE__->new(%{$self}): $self;return if not defined$source_code;my$config=$self->config();my$doc=blessed($source_code)&& $source_code->isa('Perl::Critic::Document')? $source_code : Perl::Critic::Document->new('-source'=>$source_code,'-program-extensions'=>[$config->program_extensions_as_regexes()],);if (0==$self->policies()){Perl::Critic::Exception::Configuration::Generic->throw(message=>'There are no enabled policies.',)}return$self->_gather_violations($doc)}sub _gather_violations {my ($self,$doc)=@_;if (not $self->config->force()){$doc->process_annotations()}my@policies=$self->config->policies();my@ordered_policies=_futz_with_policy_order(@policies);my@violations=map {_critique($_,$doc)}@ordered_policies;$self->statistics->accumulate($doc,\@violations);if (@violations && (my$top=$self->config->top())){my$limit=@violations < $top ? $#violations : $top-1;@violations=Perl::Critic::Violation::sort_by_severity(@violations);@violations=(reverse@violations)[0 .. $limit ]}return Perl::Critic::Violation->sort_by_location(@violations)}sub _critique {my ($policy,$doc)=@_;return if not $policy->prepare_to_scan_document($doc);my$maximum_violations=$policy->get_maximum_violations_per_document();return if defined$maximum_violations && $maximum_violations==0;my@violations=();TYPE: for my$type ($policy->applies_to()){my@elements;if ($type eq 'PPI::Document'){@elements=($doc)}else {@elements=@{$doc->find($type)|| []}}ELEMENT: for my$element (@elements){VIOLATION: for my$violation ($policy->violates($element,$doc)){my$line=$violation->location()->[0];if ($doc->line_is_disabled_for_policy($line,$policy)){$doc->add_suppressed_violation($violation);next VIOLATION}push@violations,$violation;last TYPE if defined$maximum_violations and @violations >= $maximum_violations}}}return@violations}sub _futz_with_policy_order {my@policy_objects=@_;my$magical_policy_name='Perl::Critic::Policy::Miscellanea::ProhibitUselessNoCritic';my$idx=firstidx {ref $_ eq $magical_policy_name}@policy_objects;push@policy_objects,splice@policy_objects,$idx,1;return@policy_objects}1;
PERL_CRITIC

$fatpacked{"Perl/Critic/Annotation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_ANNOTATION';
  package Perl::Critic::Annotation;use 5.006001;use strict;use warnings;use Carp qw(confess);use English qw(-no_match_vars);use Perl::Critic::PolicyFactory;use Perl::Critic::Utils qw(:characters hashify);use Readonly;our$VERSION='0.01';Readonly::Scalar my$LAST_ELEMENT=>-1;sub create_annotations {my ($class,$doc)=@_;my@annotations=();my$comment_elements_ref=$doc->find('PPI::Token::Comment')|| return;my$annotation_rx=qr{\A (?: [#]! .*? )? \s* [#][#] \s* no  \s+ critic}xms;for my$annotation_element (grep {$_ =~ $annotation_rx}@{$comment_elements_ref}){push@annotations,Perl::Critic::Annotation->new(-element=>$annotation_element)}return@annotations}sub new {my ($class,@args)=@_;my$self=bless {},$class;$self->_init(@args);return$self}sub _init {my ($self,%args)=@_;my$annotation_element=$args{-element}|| confess '-element argument is required';$self->{_element}=$annotation_element;my%disabled_policies=_parse_annotation($annotation_element);$self->{_disables_all_policies}=%disabled_policies ? 0 : 1;$self->{_disabled_policies}=\%disabled_policies;my$annotation_line=$annotation_element->logical_line_number();my$parent=$annotation_element->parent();my$grandparent=$parent ? $parent->parent(): undef;if ($annotation_element =~ m{\A [#]!}xms){$self->{_effective_range}=[$annotation_line,$annotation_line];return$self}if (_is_single_line_annotation_on_simple_statement($annotation_element)){$self->{_effective_range}=[$annotation_line,$annotation_line];return$self}if (ref$parent eq 'PPI::Structure::Block'){if (ref$grandparent eq 'PPI::Statement::Compound' || ref$grandparent eq 'PPI::Statement::Sub'){if ($parent->logical_line_number()==$annotation_line){my$grandparent_line=$grandparent->logical_line_number();$self->{_effective_range}=[$grandparent_line,$grandparent_line];return$self}}}my$end=$annotation_element;my$use_critic=qr{\A \s* [#][#] \s* use \s+ critic}xms;SIB: while (my$esib=$end->next_sibling()){$end=$esib;last SIB if$esib->isa('PPI::Token::Comment')&& $esib =~ $use_critic}if ($end->isa('PPI::Statement::End')and my$kid=$end->child(0)){$end=$kid;SIB: while (my$esib=$end->next_sibling()){$end=$esib;last SIB if$esib->isa('PPI::Token::Comment')&& $esib->content()=~ $use_critic}}my$ending_line=$end->logical_line_number();$self->{_effective_range}=[$annotation_line,$ending_line];return$self}sub element {my ($self)=@_;return$self->{_element}}sub effective_range {my$self=shift;return @{$self->{_effective_range}}}sub disabled_policies {my$self=shift;return keys %{$self->{_disabled_policies}}}sub disables_policy {my ($self,$policy_name)=@_;return 1 if$self->{_disabled_policies}->{$policy_name};return 1 if$self->disables_all_policies();return 0}sub disables_all_policies {my ($self)=@_;return$self->{_disables_all_policies}}sub disables_line {my ($self,$line_number)=@_;my$effective_range=$self->{_effective_range};return 1 if$line_number >= $effective_range->[0]and $line_number <= $effective_range->[$LAST_ELEMENT];return 0}sub _is_single_line_annotation_on_simple_statement {my ($annotation_element)=@_;my$annotation_line=$annotation_element->logical_line_number();my$sib=$annotation_element->sprevious_sibling()or return 0;$sib->logical_line_number()==$annotation_line and return 1;if ($sib->isa('PPI::Node')&& $sib->logical_line_number()< $annotation_line){my$neighbor=$sib;while ($neighbor->isa('PPI::Node')and my$kid=$neighbor->schild($LAST_ELEMENT)){$neighbor=$kid}if ($neighbor && $neighbor->logical_line_number()==$annotation_line){return 1}}return 0}sub _parse_annotation {my ($annotation_element)=@_;my$no_critic=qr{\#\# \s* no \s+ critic \s* (?:qw)? [(["'] ([\s\w:,]+) }xms;my@disabled_policy_names=();if (my ($patterns_string)=$annotation_element =~ $no_critic){my@policy_name_patterns=grep {$_ ne $EMPTY}split m{\s *[,\s] \s*}xms,$patterns_string;my$re=join$PIPE,map {"(?:$_)"}@policy_name_patterns;my@site_policy_names=Perl::Critic::PolicyFactory::site_policy_names();@disabled_policy_names=grep {m/$re/ixms}@site_policy_names;if (not @disabled_policy_names){@disabled_policy_names=@policy_name_patterns}}return hashify(@disabled_policy_names)}1;
PERL_CRITIC_ANNOTATION

$fatpacked{"Perl/Critic/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_COMMAND';
  package Perl::Critic::Command;use 5.006001;use strict;use warnings;use English qw<-no_match_vars>;use Readonly;use Getopt::Long qw<GetOptions>;use List::Util qw<first max>;use Pod::Usage qw<pod2usage>;use Perl::Critic::Exception::Parse ();use Perl::Critic::Utils qw<:characters :severities policy_short_name $DEFAULT_VERBOSITY $DEFAULT_VERBOSITY_WITH_FILE_NAME>;use Perl::Critic::Utils::Constants qw<$_MODULE_VERSION_TERM_ANSICOLOR>;use Perl::Critic::Violation qw<>;our$VERSION='0.01';use Exporter 'import';Readonly::Array our@EXPORT_OK=>qw<run>;Readonly::Hash our%EXPORT_TAGS=>(all=>[@EXPORT_OK ],);Readonly::Scalar my$DEFAULT_VIOLATIONS_FOR_TOP=>20;Readonly::Scalar my$EXIT_SUCCESS=>0;Readonly::Scalar my$EXIT_NO_FILES=>1;Readonly::Scalar my$EXIT_HAD_VIOLATIONS=>2;Readonly::Scalar my$EXIT_HAD_FILE_PROBLEMS=>3;my@files=();my$critic=undef;my$output=\*STDOUT;sub _out {my@lines=@_;return print {$output}@lines}sub run {my%options=_get_options();@files=_get_input(@ARGV);my ($violations,$had_error_in_file)=_critique(\%options,@files);return$EXIT_HAD_FILE_PROBLEMS if$had_error_in_file;return$EXIT_NO_FILES if not defined$violations;return$EXIT_HAD_VIOLATIONS if$violations;return$EXIT_SUCCESS}sub _get_options {my%opts=_parse_command_line();_dispatch_special_requests(%opts);_validate_options(%opts);$opts{-severity}||= first {exists$opts{"-$_"}}@SEVERITY_NAMES;$opts{-severity}||= first {exists$opts{"-$_"}}($SEVERITY_LOWEST .. $SEVERITY_HIGHEST);if (exists$opts{-top}){$opts{-severity}||= 1;$opts{-top}||= $DEFAULT_VIOLATIONS_FOR_TOP}if (exists$opts{-noprofile}){$opts{-profile}=$EMPTY}return%opts}sub _parse_command_line {my%opts;my@opt_specs=_get_option_specification();Getopt::Long::Configure('no_ignore_case');GetOptions(\%opts,@opt_specs)|| pod2usage();my%dashed_opts=map {("-$_"=>$opts{$_})}keys%opts;return%dashed_opts}sub _dispatch_special_requests {my (%opts)=@_;if ($opts{-help}){pod2usage(-verbose=>0)}if ($opts{-options}){pod2usage(-verbose=>1)}if ($opts{-man}){pod2usage(-verbose=>2)}if ($opts{-version}){_display_version()}if ($opts{-list}){_render_all_policy_listing()}if ($opts{'-list-enabled'}){_render_policy_listing(%opts)}if ($opts{'-list-themes'}){_render_theme_listing()}if ($opts{'-profile-proto'}){_render_profile_prototype()}if ($opts{-doc}){_render_policy_docs(%opts)}return 1}sub _validate_options {my (%opts)=@_;my$msg=$EMPTY;if ($opts{-noprofile}&& $opts{-profile}){$msg .= qq{Warning: Cannot use -noprofile with -profile option.\n}}if ($opts{-verbose}&& $opts{-verbose}!~ m{(?: \d+ | %[mfFlcCedrpPs] )}xms){$msg .= qq<Warning: --verbose arg "$opts{-verbose}" looks odd.  >;$msg .= qq<Perhaps you meant to say "--verbose 3 $opts{-verbose}."\n>}if (exists$opts{-top}&& $opts{-top}< 0){$msg .= qq<Warning: --top argument "$opts{-top}" is negative.  >;$msg .= qq<Perhaps you meant to say "$opts{-top} --top".\n>}if (exists$opts{-severity}&& ($opts{-severity}< $SEVERITY_LOWEST || $opts{-severity}> $SEVERITY_HIGHEST)){$msg .= qq<Warning: --severity arg "$opts{-severity}" out of range.  >;$msg .= qq<Severities range from "$SEVERITY_LOWEST" (lowest) to >;$msg .= qq<"$SEVERITY_HIGHEST" (highest).\n>}if ($msg){pod2usage(-exitstatus=>1,-message=>$msg,-verbose=>0)}return 1}sub _get_input {my@args=@_;if (!@args || (@args==1 && $args[0]eq q{-})){my$code_string=do {local$RS=undef;<STDIN>};if (!defined$code_string){$code_string=$EMPTY}$code_string =~ m{ \S+ }xms || die qq{Nothing to critique.\n};return \$code_string}else {if (my$nonexistent=first {!-e}@args){my$msg=qq{No such file or directory: '$nonexistent'};pod2usage(-exitstatus=>1,-message=>$msg,-verbose=>0)}return map {(-d)? Perl::Critic::Utils::all_perl_files($_): $_}@args}}sub _critique {my ($opts_ref,@files_to_critique)=@_;@files_to_critique || die "No perl files were found.\n";require Perl::Critic;$critic=Perl::Critic->new(%{$opts_ref});$critic->policies()|| die "No policies selected.\n";_set_up_pager($critic->config()->pager());my$number_of_violations=undef;my$had_error_in_file=0;for my$file (@files_to_critique){eval {my@violations=$critic->critique($file);$number_of_violations += scalar@violations;if (not $opts_ref->{'-statistics-only'}){_render_report($file,$opts_ref,@violations)}1}or do {if (my$exception=Perl::Critic::Exception::Parse->caught()){$had_error_in_file=1;warn qq<Problem while critiquing "$file": $EVAL_ERROR\n>}elsif ($EVAL_ERROR){die qq<Fatal error while critiquing "$file": $EVAL_ERROR\n>}else {die qq<Fatal error while critiquing "$file". Unfortunately, >,q<$@/$EVAL_ERROR >,qq<is empty, so the reason can't be shown.\n>}}}if ($opts_ref->{-statistics}or $opts_ref->{'-statistics-only'}){my$stats=$critic->statistics();_report_statistics($opts_ref,$stats)}return$number_of_violations,$had_error_in_file}sub _render_report {my ($file,$opts_ref,@violations)=@_;my$number_of_violations=scalar@violations;if ($opts_ref->{'-files-with-violations'}|| $opts_ref->{'-files-without-violations'}){not ref$file and $opts_ref->{$number_of_violations ? '-files-with-violations' : '-files-without-violations'}and _out "$file\n";return$number_of_violations}if($opts_ref->{-count}){ref$file || _out "$file: ";_out "$number_of_violations\n";return$number_of_violations}if(!@violations &&!$opts_ref->{-quiet}){ref$file || _out "$file ";_out "source OK\n";return 0}my$verbosity=$critic->config->verbose();$verbosity=($verbosity eq $DEFAULT_VERBOSITY && @files > 1)? $DEFAULT_VERBOSITY_WITH_FILE_NAME : $verbosity;my$fmt=Perl::Critic::Utils::verbosity_to_format($verbosity);if (not -f $file){$fmt =~ s< \%[fF] ><STDIN>xms}Perl::Critic::Violation::set_format($fmt);my$color=$critic->config->color();_out$color ? _colorize_by_severity(@violations): @violations;return$number_of_violations}sub _set_up_pager {my ($pager_command)=@_;return if not $pager_command;return if not _at_tty();open my$pager,q<|->,$pager_command or die qq<Unable to pipe to pager "$pager_command": $ERRNO\n>;$output=$pager;return}sub _report_statistics {my ($opts_ref,$statistics)=@_;if (not $opts_ref->{'-statistics-only'}and ($statistics->total_violations()or not $opts_ref->{-quiet}and $statistics->modules())){_out "\n"}my$files=_commaify($statistics->modules());my$subroutines=_commaify($statistics->subs());my$statements=_commaify($statistics->statements_other_than_subs());my$lines=_commaify($statistics->lines());my$width=max map {length}$files,$subroutines,$statements;_out sprintf "%*s %s.\n",$width,$files,'files';_out sprintf "%*s %s.\n",$width,$subroutines,'subroutines/methods';_out sprintf "%*s %s.\n",$width,$statements,'statements';my$lines_of_blank=_commaify($statistics->lines_of_blank());my$lines_of_comment=_commaify($statistics->lines_of_comment());my$lines_of_data=_commaify($statistics->lines_of_data());my$lines_of_perl=_commaify($statistics->lines_of_perl());my$lines_of_pod=_commaify($statistics->lines_of_pod());$width=max map {length}$lines_of_blank,$lines_of_comment,$lines_of_data,$lines_of_perl,$lines_of_pod;_out sprintf "\n%s %s:\n",$lines,'lines, consisting of';_out sprintf "    %*s %s.\n",$width,$lines_of_blank,'blank lines';_out sprintf "    %*s %s.\n",$width,$lines_of_comment,'comment lines';_out sprintf "    %*s %s.\n",$width,$lines_of_data,'data lines';_out sprintf "    %*s %s.\n",$width,$lines_of_perl,'lines of Perl code';_out sprintf "    %*s %s.\n",$width,$lines_of_pod,'lines of POD';my$average_sub_mccabe=$statistics->average_sub_mccabe();if (defined$average_sub_mccabe){_out sprintf "\nAverage McCabe score of subroutines was %.2f.\n",$average_sub_mccabe}_out "\n";_out _commaify($statistics->total_violations())," violations.\n";my$violations_per_file=$statistics->violations_per_file();if (defined$violations_per_file){_out sprintf "Violations per file was %.3f.\n",$violations_per_file}my$violations_per_statement=$statistics->violations_per_statement();if (defined$violations_per_statement){_out sprintf "Violations per statement was %.3f.\n",$violations_per_statement}my$violations_per_line=$statistics->violations_per_line_of_code();if (defined$violations_per_line){_out sprintf "Violations per line of code was %.3f.\n",$violations_per_line}if ($statistics->total_violations()){_out "\n";my%severity_violations=%{$statistics->violations_by_severity()};my@severities=reverse sort keys%severity_violations;$width=max map {length _commaify($severity_violations{$_})}@severities;for my$severity (@severities){_out sprintf "%*s severity %d violations.\n",$width,_commaify($severity_violations{$severity}),$severity}_out "\n";my%policy_violations=%{$statistics->violations_by_policy()};my@policies=sort keys%policy_violations;$width=max map {length _commaify($policy_violations{$_})}@policies;for my$policy (@policies){_out sprintf "%*s violations of %s.\n",$width,_commaify($policy_violations{$policy}),policy_short_name($policy)}}return}sub _commaify {my ($number)=@_;while ($number =~ s/ \A ( [-+]? \d+ ) ( \d{3} ) /$1,$2/xms){}return$number}sub _get_option_specification {return qw<5 4 3 2 1 Safari version brutal count|C cruel doc=s exclude=s@ force! gentle harsh help|?|H include=s@ list list-enabled list-themes man color|colour! noprofile only! options pager=s profile|p=s profile-proto quiet severity=i single-policy|s=s stern statistics! statistics-only! profile-strictness=s theme=s top:i allow-unsafe verbose=s color-severity-highest|colour-severity-highest|color-severity-5|colour-severity-5=s color-severity-high|colour-severity-high|color-severity-4|colour-severity-4=s color-severity-medium|colour-severity-medium|color-severity-3|colour-severity-3=s color-severity-low|colour-severity-low|color-severity-2|colour-severity-2=s color-severity-lowest|colour-severity-lowest|color-severity-1|colour-severity-1=s files-with-violations|l files-without-violations|L program-extensions=s@>}sub _colorize_by_severity {my@violations=@_;return@violations if _this_is_windows();return@violations if not eval {require Term::ANSIColor;Term::ANSIColor->VERSION($_MODULE_VERSION_TERM_ANSICOLOR);1};my$config=$critic->config();my%color_of=($SEVERITY_HIGHEST=>$config->color_severity_highest(),$SEVERITY_HIGH=>$config->color_severity_high(),$SEVERITY_MEDIUM=>$config->color_severity_medium(),$SEVERITY_LOW=>$config->color_severity_low(),$SEVERITY_LOWEST=>$config->color_severity_lowest(),);return map {_colorize("$_",$color_of{$_->severity()})}@violations}sub _colorize {my ($string,$color)=@_;return$string if not defined$color;return$string if$color eq $EMPTY;my$terminator=chomp$string ? "\n" : $EMPTY;return Term::ANSIColor::colored($string,$color).$terminator}sub _this_is_windows {return 1 if$OSNAME =~ m/MSWin32/xms;return 0}sub _at_tty {return -t STDOUT}sub _render_all_policy_listing {my%pc_params=(-profile=>$EMPTY,-severity=>$SEVERITY_LOWEST);return _render_policy_listing(%pc_params)}sub _render_policy_listing {my%pc_params=@_;require Perl::Critic::PolicyListing;require Perl::Critic;my@policies=Perl::Critic->new(%pc_params)->policies();my$listing=Perl::Critic::PolicyListing->new(-policies=>\@policies);_out$listing;exit$EXIT_SUCCESS}sub _render_theme_listing {require Perl::Critic::ThemeListing;require Perl::Critic;my%pc_params=(-profile=>$EMPTY,-severity=>$SEVERITY_LOWEST);my@policies=Perl::Critic->new(%pc_params)->policies();my$listing=Perl::Critic::ThemeListing->new(-policies=>\@policies);_out$listing;exit$EXIT_SUCCESS}sub _render_profile_prototype {require Perl::Critic::ProfilePrototype;require Perl::Critic;my%pc_params=(-profile=>$EMPTY,-severity=>$SEVERITY_LOWEST);my@policies=Perl::Critic->new(%pc_params)->policies();my$prototype=Perl::Critic::ProfilePrototype->new(-policies=>\@policies);_out$prototype;exit$EXIT_SUCCESS}sub _render_policy_docs {my (%opts)=@_;my$pattern=delete$opts{-doc};require Perl::Critic;$critic=Perl::Critic->new(%opts);_set_up_pager($critic->config()->pager());require Perl::Critic::PolicyFactory;my@site_policies=Perl::Critic::PolicyFactory->site_policy_names();my@matching_policies=grep {/$pattern/ixms}@site_policies;my@perldoc_output=map {`perldoc -T $_`}@matching_policies;_out@perldoc_output;exit$EXIT_SUCCESS}sub _display_version {_out "$VERSION\n";exit$EXIT_SUCCESS}1;
PERL_CRITIC_COMMAND

$fatpacked{"Perl/Critic/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_CONFIG';
  package Perl::Critic::Config;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use List::MoreUtils qw(any none apply);use Scalar::Util qw(blessed);use Perl::Critic::Exception::AggregateConfiguration;use Perl::Critic::Exception::Configuration;use Perl::Critic::Exception::Configuration::Option::Global::ParameterValue;use Perl::Critic::Exception::Fatal::Internal qw{throw_internal};use Perl::Critic::PolicyFactory;use Perl::Critic::Theme qw($RULE_INVALID_CHARACTER_REGEX cook_rule);use Perl::Critic::UserProfile qw();use Perl::Critic::Utils qw{:booleans :characters :severities :internal_lookup :classification :data_conversion};use Perl::Critic::Utils::Constants qw<:profile_strictness $_MODULE_VERSION_TERM_ANSICOLOR>;use Perl::Critic::Utils::DataConversion qw<boolean_to_number dor>;our$VERSION='0.01';Readonly::Scalar my$SINGLE_POLICY_CONFIG_KEY=>'single-policy';sub new {my ($class,%args)=@_;my$self=bless {},$class;$self->_init(%args);return$self}sub _init {my ($self,%args)=@_;if (defined$args{-top}|| defined$args{-theme}){$args{-severity}||= $SEVERITY_LOWEST}my$errors=Perl::Critic::Exception::AggregateConfiguration->new();my$profile_source=$args{-profile};my$profile=Perl::Critic::UserProfile->new(-profile=>$profile_source);my$options_processor=$profile->options_processor();$self->{_profile}=$profile;$self->_validate_and_save_profile_strictness($args{'-profile-strictness'},$errors,);$self->_validate_and_save_regex('include',$args{-include},$options_processor->include(),$errors);$self->_validate_and_save_regex('exclude',$args{-exclude},$options_processor->exclude(),$errors);$self->_validate_and_save_regex($SINGLE_POLICY_CONFIG_KEY,$args{qq/-$SINGLE_POLICY_CONFIG_KEY/ },$options_processor->single_policy(),$errors,);$self->_validate_and_save_color_severity('color_severity_highest',$args{'-color-severity-highest'},$options_processor->color_severity_highest(),$errors);$self->_validate_and_save_color_severity('color_severity_high',$args{'-color-severity-high'},$options_processor->color_severity_high(),$errors);$self->_validate_and_save_color_severity('color_severity_medium',$args{'-color-severity-medium'},$options_processor->color_severity_medium(),$errors);$self->_validate_and_save_color_severity('color_severity_low',$args{'-color-severity-low'},$options_processor->color_severity_low(),$errors);$self->_validate_and_save_color_severity('color_severity_lowest',$args{'-color-severity-lowest'},$options_processor->color_severity_lowest(),$errors);$self->_validate_and_save_verbosity($args{-verbose},$errors);$self->_validate_and_save_severity($args{-severity},$errors);$self->_validate_and_save_top($args{-top},$errors);$self->_validate_and_save_theme($args{-theme},$errors);$self->_validate_and_save_pager($args{-pager},$errors);$self->_validate_and_save_program_extensions($args{'-program-extensions'},$errors);$self->{_force}=boolean_to_number(dor($args{-force},$options_processor->force()));$self->{_only}=boolean_to_number(dor($args{-only},$options_processor->only()));$self->{_color}=boolean_to_number(dor($args{-color},$options_processor->color()));$self->{_unsafe_allowed}=boolean_to_number(dor($args{'-allow-unsafe'},$options_processor->allow_unsafe()));$self->{_criticism_fatal}=boolean_to_number(dor($args{'-criticism-fatal'},$options_processor->criticism_fatal()));my$factory=Perl::Critic::PolicyFactory->new(-profile=>$profile,-errors=>$errors,'-profile-strictness'=>$self->profile_strictness(),);$self->{_factory}=$factory;$self->{_all_policies_enabled_or_not}=[];$self->{_policies}=[];if (not defined$profile_source or $profile_source ne 'NONE'){$self->_load_policies($errors)}if ($errors->has_exceptions()){$errors->rethrow()}return$self}sub add_policy {my ($self,%args)=@_;if (not $args{-policy}){throw_internal q{The -policy argument is required}}my$policy=$args{-policy};if (blessed$policy){$self->_add_policy_if_enabled($policy);return$self}my$params=$args{-params}|| $args{-config};my$factory=$self->{_factory};my$policy_object=$factory->create_policy(-name=>$policy,-params=>$params);$self->_add_policy_if_enabled($policy_object);return$self}sub _add_policy_if_enabled {my ($self,$policy_object)=@_;my$config=$policy_object->__get_config()or throw_internal q{Policy was not set up properly because it does not have } .q{a value for its config attribute.};push @{$self->{_all_policies_enabled_or_not}},$policy_object;if ($policy_object->initialize_if_enabled($config)){$policy_object->__set_enabled($TRUE);push @{$self->{_policies}},$policy_object}else {$policy_object->__set_enabled($FALSE)}return}sub _load_policies {my ($self,$errors)=@_;my$factory=$self->{_factory};my@policies=$factory->create_all_policies($errors);return if$errors->has_exceptions();for my$policy (@policies){if ($self->single_policy()){if ($self->_policy_is_single_policy($policy)){$self->add_policy(-policy=>$policy)}next}next if not ($policy->is_safe()or $self->unsafe_allowed());my$load_me=$self->only()? $FALSE : $TRUE;$load_me=$FALSE if$self->_policy_is_disabled($policy);$load_me=$TRUE if$self->_policy_is_enabled($policy);$load_me=$FALSE if$self->_policy_is_unimportant($policy);$load_me=$FALSE if not $self->_policy_is_thematic($policy);$load_me=$TRUE if$self->_policy_is_included($policy);$load_me=$FALSE if$self->_policy_is_excluded($policy);next if not $load_me;$self->add_policy(-policy=>$policy)}if ($self->single_policy()&& scalar$self->policies()!=1){$self->_add_single_policy_exception_to($errors)}return}sub _policy_is_disabled {my ($self,$policy)=@_;my$profile=$self->_profile();return$profile->policy_is_disabled($policy)}sub _policy_is_enabled {my ($self,$policy)=@_;my$profile=$self->_profile();return$profile->policy_is_enabled($policy)}sub _policy_is_thematic {my ($self,$policy)=@_;my$theme=$self->theme();return$theme->policy_is_thematic(-policy=>$policy)}sub _policy_is_unimportant {my ($self,$policy)=@_;my$policy_severity=$policy->get_severity();my$min_severity=$self->{_severity};return$policy_severity < $min_severity}sub _policy_is_included {my ($self,$policy)=@_;my$policy_long_name=ref$policy;my@inclusions=$self->include();return any {$policy_long_name =~ m/$_/ixms}@inclusions}sub _policy_is_excluded {my ($self,$policy)=@_;my$policy_long_name=ref$policy;my@exclusions=$self->exclude();return any {$policy_long_name =~ m/$_/ixms}@exclusions}sub _policy_is_single_policy {my ($self,$policy)=@_;my@patterns=$self->single_policy();return if not @patterns;my$policy_long_name=ref$policy;return any {$policy_long_name =~ m/$_/ixms}@patterns}sub _new_global_value_exception {my ($self,@args)=@_;return Perl::Critic::Exception::Configuration::Option::Global::ParameterValue ->new(@args)}sub _add_single_policy_exception_to {my ($self,$errors)=@_;my$message_suffix=$EMPTY;my$patterns=join q{", "},$self->single_policy();if (scalar$self->policies()==0){$message_suffix=q{did not match any policies (in combination with } .q{other policy restrictions).}}else {$message_suffix=qq{matched multiple policies:\n\t};$message_suffix .= join qq{,\n\t},apply {chomp}sort$self->policies()}$errors->add_exception($self->_new_global_value_exception(option_name=>$SINGLE_POLICY_CONFIG_KEY,option_value=>$patterns,message_suffix=>$message_suffix,));return}sub _validate_and_save_regex {my ($self,$option_name,$args_value,$default_value,$errors)=@_;my$full_option_name;my$source;my@regexes;if ($args_value){$full_option_name="-$option_name";if (ref$args_value){@regexes=@{$args_value}}else {@regexes=($args_value)}}if (not @regexes){$full_option_name=$option_name;$source=$self->_profile()->source();if (ref$default_value){@regexes=@{$default_value}}elsif ($default_value){@regexes=($default_value)}}my$found_errors;for my$regex (@regexes){eval {qr/$regex/ixms}or do {my$cleaned_error=$EVAL_ERROR || '<unknown reason>';$cleaned_error =~ s/ [ ] at [ ] .* Config [.] pm [ ] line [ ] \d+ [.] \n? \z/./xms;$errors->add_exception($self->_new_global_value_exception(option_name=>$option_name,option_value=>$regex,source=>$source,message_suffix=>qq{is not valid: $cleaned_error},));$found_errors=1}}if (not $found_errors){my$option_key=$option_name;$option_key =~ s/ - /_/xmsg;$self->{"_$option_key"}=\@regexes}return}sub _validate_and_save_profile_strictness {my ($self,$args_value,$errors)=@_;my$option_name;my$source;my$profile_strictness;if ($args_value){$option_name='-profile-strictness';$profile_strictness=$args_value}else {$option_name='profile-strictness';my$profile=$self->_profile();$source=$profile->source();$profile_strictness=$profile->options_processor()->profile_strictness()}if (not $PROFILE_STRICTNESSES{$profile_strictness}){$errors->add_exception($self->_new_global_value_exception(option_name=>$option_name,option_value=>$profile_strictness,source=>$source,message_suffix=>q{is not one of "} .join (q{", "},(sort keys%PROFILE_STRICTNESSES)).q{".},));$profile_strictness=$PROFILE_STRICTNESS_FATAL}$self->{_profile_strictness}=$profile_strictness;return}sub _validate_and_save_verbosity {my ($self,$args_value,$errors)=@_;my$option_name;my$source;my$verbosity;if ($args_value){$option_name='-verbose';$verbosity=$args_value}else {$option_name='verbose';my$profile=$self->_profile();$source=$profile->source();$verbosity=$profile->options_processor()->verbose()}if (is_integer($verbosity)and not is_valid_numeric_verbosity($verbosity)){$errors->add_exception($self->_new_global_value_exception(option_name=>$option_name,option_value=>$verbosity,source=>$source,message_suffix=>'is not the number of one of the pre-defined verbosity formats.',))}else {$self->{_verbose}=$verbosity}return}sub _validate_and_save_severity {my ($self,$args_value,$errors)=@_;my$option_name;my$source;my$severity;if ($args_value){$option_name='-severity';$severity=$args_value}else {$option_name='severity';my$profile=$self->_profile();$source=$profile->source();$severity=$profile->options_processor()->severity()}if (is_integer($severity)){if ($severity >= $SEVERITY_LOWEST and $severity <= $SEVERITY_HIGHEST){$self->{_severity}=$severity}else {$errors->add_exception($self->_new_global_value_exception(option_name=>$option_name,option_value=>$severity,source=>$source,message_suffix=>"is not between $SEVERITY_LOWEST (low) and $SEVERITY_HIGHEST (high).",))}}elsif (not any {$_ eq lc$severity}@SEVERITY_NAMES){$errors->add_exception($self->_new_global_value_exception(option_name=>$option_name,option_value=>$severity,source=>$source,message_suffix=>q{is not one of the valid severity names: "} .join (q{", "},@SEVERITY_NAMES).q{".},))}else {$self->{_severity}=severity_to_number($severity)}return}sub _validate_and_save_top {my ($self,$args_value,$errors)=@_;my$option_name;my$source;my$top;if (defined$args_value and $args_value ne q{}){$option_name='-top';$top=$args_value}else {$option_name='top';my$profile=$self->_profile();$source=$profile->source();$top=$profile->options_processor()->top()}if (is_integer($top)and $top >= 0){$self->{_top}=$top}else {$errors->add_exception($self->_new_global_value_exception(option_name=>$option_name,option_value=>$top,source=>$source,message_suffix=>q{is not a non-negative integer.},))}return}sub _validate_and_save_theme {my ($self,$args_value,$errors)=@_;my$option_name;my$source;my$theme_rule;if ($args_value){$option_name='-theme';$theme_rule=$args_value}else {$option_name='theme';my$profile=$self->_profile();$source=$profile->source();$theme_rule=$profile->options_processor()->theme()}if ($theme_rule =~ m/$RULE_INVALID_CHARACTER_REGEX/xms){my$bad_character=$1;$errors->add_exception($self->_new_global_value_exception(option_name=>$option_name,option_value=>$theme_rule,source=>$source,message_suffix=>qq{contains an illegal character ("$bad_character").},))}else {my$rule_as_code=cook_rule($theme_rule);$rule_as_code =~ s/ [\w\d]+ / 1 /gxms;local$EVAL_ERROR=$EMPTY;eval$rule_as_code;if ($EVAL_ERROR){$errors->add_exception($self->_new_global_value_exception(option_name=>$option_name,option_value=>$theme_rule,source=>$source,message_suffix=>q{is not syntactically valid.},))}else {eval {$self->{_theme}=Perl::Critic::Theme->new(-rule=>$theme_rule)}or do {$errors->add_exception_or_rethrow($EVAL_ERROR)}}}return}sub _validate_and_save_pager {my ($self,$args_value,$errors)=@_;my$pager;if ($args_value){$pager=defined$args_value ? $args_value : $EMPTY}elsif ($ENV{PERLCRITIC_PAGER}){$pager=$ENV{PERLCRITIC_PAGER}}else {my$profile=$self->_profile();$pager=$profile->options_processor()->pager()}if ($pager eq '$PAGER'){$pager=$ENV{PAGER}}$pager ||= $EMPTY;$self->{_pager}=$pager;return}sub _validate_and_save_color_severity {my ($self,$option_name,$args_value,$default_value,$errors)=@_;my$source;my$color_severity;my$full_option_name;if (defined$args_value){$full_option_name="-$option_name";$color_severity=lc$args_value}else {$full_option_name=$option_name;$source=$self->_profile()->source();$color_severity=lc$default_value}$color_severity =~ s/ \s+ / /xmsg;$color_severity =~ s/ \A\s+ //xms;$color_severity =~ s/ \s+\z //xms;$full_option_name =~ s/ _ /-/xmsg;my$found_errors;if (eval {require Term::ANSIColor;Term::ANSIColor->VERSION($_MODULE_VERSION_TERM_ANSICOLOR);1}){$found_errors=not Term::ANSIColor::colorvalid(words_from_string($color_severity))}if ($found_errors){$errors->add_exception($self->_new_global_value_exception(option_name=>$full_option_name,option_value=>$color_severity,source=>$source,message_suffix=>'is not valid.',))}else {my$option_key=$option_name;$option_key =~ s/ - /_/xmsg;$self->{"_$option_key"}=$color_severity}return}sub _validate_and_save_program_extensions {my ($self,$args_value,$errors)=@_;delete$self->{_program_extensions_as_regexes};my$extension_list=q{ARRAY} eq ref$args_value ? [map {words_from_string($_)}@{$args_value}]: $self->_profile()->options_processor()->program_extensions();my%program_extensions=hashify(@{$extension_list});$self->{_program_extensions}=[keys%program_extensions];return}sub _profile {my ($self)=@_;return$self->{_profile}}sub all_policies_enabled_or_not {my ($self)=@_;return @{$self->{_all_policies_enabled_or_not}}}sub policies {my ($self)=@_;return @{$self->{_policies}}}sub exclude {my ($self)=@_;return @{$self->{_exclude}}}sub force {my ($self)=@_;return$self->{_force}}sub include {my ($self)=@_;return @{$self->{_include}}}sub only {my ($self)=@_;return$self->{_only}}sub profile_strictness {my ($self)=@_;return$self->{_profile_strictness}}sub severity {my ($self)=@_;return$self->{_severity}}sub single_policy {my ($self)=@_;return @{$self->{_single_policy}}}sub theme {my ($self)=@_;return$self->{_theme}}sub top {my ($self)=@_;return$self->{_top}}sub verbose {my ($self)=@_;return$self->{_verbose}}sub color {my ($self)=@_;return$self->{_color}}sub pager {my ($self)=@_;return$self->{_pager}}sub unsafe_allowed {my ($self)=@_;return$self->{_unsafe_allowed}}sub criticism_fatal {my ($self)=@_;return$self->{_criticism_fatal}}sub site_policy_names {return Perl::Critic::PolicyFactory::site_policy_names()}sub color_severity_highest {my ($self)=@_;return$self->{_color_severity_highest}}sub color_severity_high {my ($self)=@_;return$self->{_color_severity_high}}sub color_severity_medium {my ($self)=@_;return$self->{_color_severity_medium}}sub color_severity_low {my ($self)=@_;return$self->{_color_severity_low}}sub color_severity_lowest {my ($self)=@_;return$self->{_color_severity_lowest}}sub program_extensions {my ($self)=@_;return @{$self->{_program_extensions}}}sub program_extensions_as_regexes {my ($self)=@_;return @{$self->{_program_extensions_as_regexes}}if$self->{_program_extensions_as_regexes};my%program_extensions=hashify($self->program_extensions());$program_extensions{'.PL'}=1;return @{$self->{_program_extensions_as_regexes}=[map {qr< @{[quotemeta $_]} \z >smx}sort keys%program_extensions ]}}1;
PERL_CRITIC_CONFIG

$fatpacked{"Perl/Critic/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_DOCUMENT';
  package Perl::Critic::Document;use 5.006001;use strict;use warnings;use Carp qw<confess>;use List::Util qw<reduce>;use Scalar::Util qw<blessed refaddr weaken>;use version;use PPI::Document;use PPI::Document::File;use PPIx::Utilities::Node qw<split_ppi_node_by_namespace>;use Perl::Critic::Annotation;use Perl::Critic::Exception::Parse qw<throw_parse>;use Perl::Critic::Utils qw<:booleans :characters shebang_line>;use PPIx::Regexp 0.010 qw<>;our$VERSION='0.01';our$AUTOLOAD;sub AUTOLOAD {my ($function_name)=$AUTOLOAD =~ m/ ([^:\']+) \z /xms;return if$function_name eq 'DESTROY';my$self=shift;return$self->{_doc}->$function_name(@_)}sub new {my ($class,@args)=@_;my$self=bless {},$class;$self->_init_common();$self->_init_from_external_source(@args);return$self}sub _new_for_parent_document {my ($class,$ppi_document,$parent_document)=@_;my$self=bless {},$class;$self->_init_common();$self->{_doc}=$ppi_document;$self->{_is_module}=$parent_document->is_module();return$self}sub _init_common {my ($self)=@_;$self->{_annotations}=[];$self->{_suppressed_violations}=[];$self->{_disabled_line_map}={};return}sub _init_from_external_source {my$self=shift;my%args;if (@_==1){warnings::warnif('deprecated','Perl::Critic::Document->new($source) deprecated, use Perl::Critic::Document->new(-source => $source) instead.');%args=('-source'=>shift)}else {%args=@_}my$source_code=$args{'-source'};my$ppi_document=_is_ppi_doc($source_code)? $source_code : ref$source_code ? PPI::Document->new($source_code): PPI::Document::File->new($source_code);if (not defined$ppi_document){my$errstr=PPI::Document::errstr();my$file=ref$source_code ? undef : $source_code;throw_parse message=>qq<Can't parse code: $errstr>,file_name=>$file}$self->{_doc}=$ppi_document;$self->index_locations();$self->_disable_shebang_fix();$self->{_filename_override}=$args{'-filename-override'};$self->{_is_module}=$self->_determine_is_module(\%args);return}sub _is_ppi_doc {my ($ref)=@_;return blessed($ref)&& $ref->isa('PPI::Document')}sub ppi_document {my ($self)=@_;return$self->{_doc}}sub isa {my ($self,@args)=@_;return$self->SUPER::isa(@args)|| ((ref$self)&& $self->{_doc}&& $self->{_doc}->isa(@args))}sub find {my ($self,$wanted,@more_args)=@_;if ((ref$wanted)||!$wanted || $wanted !~ m/ \A PPI:: /xms){return$self->{_doc}->find($wanted,@more_args)}if (!$self->{_elements_of}){my%cache=('PPI::Document'=>[$self ]);weaken($cache{'PPI::Document'}->[0]);my$finder_coderef=_caching_finder(\%cache);$self->{_doc}->find($finder_coderef);$self->{_elements_of}=\%cache}return$self->{_elements_of}->{$wanted}|| q{}}sub find_first {my ($self,$wanted,@more_args)=@_;if ((ref$wanted)||!$wanted || $wanted !~ m/ \A PPI:: /xms){return$self->{_doc}->find_first($wanted,@more_args)}my$result=$self->find($wanted);return$result ? $result->[0]: $result}sub find_any {my ($self,$wanted,@more_args)=@_;if ((ref$wanted)||!$wanted || $wanted !~ m/ \A PPI:: /xms){return$self->{_doc}->find_any($wanted,@more_args)}my$result=$self->find($wanted);return$result ? 1 : $result}sub namespaces {my ($self)=@_;return keys %{$self->_nodes_by_namespace()}}sub subdocuments_for_namespace {my ($self,$namespace)=@_;my$subdocuments=$self->_nodes_by_namespace()->{$namespace};return$subdocuments ? @{$subdocuments}: ()}sub ppix_regexp_from_element {my ($self,$element)=@_;if (blessed($element)&& $element->isa('PPI::Element')){my$addr=refaddr($element);return$self->{_ppix_regexp_from_element}{$addr}if exists$self->{_ppix_regexp_from_element}{$addr};return ($self->{_ppix_regexp_from_element}{$addr}=PPIx::Regexp->new($element,default_modifiers=>$self->_find_use_re_modifiers_in_scope_from_element($element),))}else {return PPIx::Regexp->new($element)}}sub _find_use_re_modifiers_in_scope_from_element {my ($self,$elem)=@_;my@found;for my$use_re (@{$self->find('PPI::Statement::Include')|| []}){'re' eq $use_re->module()or next;$self->element_is_in_lexical_scope_after_statement_containing($elem,$use_re)or next;my$prefix='no' eq $use_re->type()? q{-} : $EMPTY;push@found,map {"$prefix$_"}grep {m{ \A / }smx}map {$_->isa('PPI::Token::Quote')? $_->string(): $_->isa('PPI::Token::QuoteLike::Words')? $_->literal(): $_->content()}$use_re->schildren()}return \@found}sub element_is_in_lexical_scope_after_statement_containing {my ($self,$inner_elem,$outer_elem)=@_;$outer_elem->scope()and return$inner_elem->descendant_of($outer_elem);my$stmt=$outer_elem->statement()or return;my$last_elem=$stmt->last_element()or return;my$stmt_loc=$last_elem->location()or return;my$inner_loc=$inner_elem->location()or return;$stmt_loc->[0]> $inner_loc->[0]and return;$stmt_loc->[0]==$inner_loc->[0]and $stmt_loc->[1]> $inner_loc->[1]and return;my$parent=$stmt;while (!$parent->scope()){$parent=$parent->parent()or return}return$inner_elem->descendant_of($parent)}sub filename {my ($self)=@_;if (defined$self->{_filename_override}){return$self->{_filename_override}}else {my$doc=$self->{_doc};return$doc->can('filename')? $doc->filename(): undef}}sub highest_explicit_perl_version {my ($self)=@_;my$highest_explicit_perl_version=$self->{_highest_explicit_perl_version};if (not exists$self->{_highest_explicit_perl_version}){my$includes=$self->find(\&_is_a_version_statement);if ($includes){$highest_explicit_perl_version=reduce {$a >= $b ? $a : $b}map {version->new($_->version())}@{$includes}}else {$highest_explicit_perl_version=undef}$self->{_highest_explicit_perl_version}=$highest_explicit_perl_version}return$highest_explicit_perl_version if$highest_explicit_perl_version;return}sub uses_module {my ($self,$module_name)=@_;return exists$self->_modules_used()->{$module_name}}sub process_annotations {my ($self)=@_;my@annotations=Perl::Critic::Annotation->create_annotations($self);$self->add_annotation(@annotations);return$self}sub line_is_disabled_for_policy {my ($self,$line,$policy)=@_;my$policy_name=ref$policy || $policy;return 0 if$policy_name eq 'Perl::Critic::Policy::Miscellanea::ProhibitUnrestrictedNoCritic';return 1 if$self->{_disabled_line_map}->{$line}->{$policy_name};return 1 if$self->{_disabled_line_map}->{$line}->{ALL};return 0}sub add_annotation {my ($self,@annotations)=@_;for my$annotation (@annotations){my ($start,$end)=$annotation->effective_range();my@affected_policies=$annotation->disables_all_policies ? qw(ALL) : $annotation->disabled_policies();for my$line ($start .. $end){for my$policy (@affected_policies){$self->{_disabled_line_map}->{$line}->{$policy}=1}}}push @{$self->{_annotations}},@annotations;return$self}sub annotations {my ($self)=@_;return @{$self->{_annotations}}}sub add_suppressed_violation {my ($self,$violation)=@_;push @{$self->{_suppressed_violations}},$violation;return$self}sub suppressed_violations {my ($self)=@_;return @{$self->{_suppressed_violations}}}sub is_program {my ($self)=@_;return not $self->is_module()}sub is_module {my ($self)=@_;return$self->{_is_module}}sub _is_a_version_statement {my (undef,$element)=@_;return 0 if not $element->isa('PPI::Statement::Include');return 1 if$element->version();return 0}sub _caching_finder {my$cache_ref=shift;my%isa_cache=();return sub {my (undef,$element)=@_;my$classes=$isa_cache{ref$element};if (!$classes){$classes=[ref$element ];for (my$i=0;$i < @{$classes};$i++ ){no strict 'refs';push @{$classes},@{"$classes->[$i]::ISA"};$cache_ref->{$classes->[$i]}||= []}$isa_cache{$classes->[0]}=$classes}for my$class (@{$classes}){push @{$cache_ref->{$class}},$element}return 0}}sub _disable_shebang_fix {my ($self)=@_;my$first_stmnt=$self->schild(0)|| return;my$fixin_rx=qr<^eval 'exec .* \$0 \$[{]1[+]"\$@"}'\s*[\r\n]\s*if.+;>ms;if ($first_stmnt =~ $fixin_rx){my$line=$first_stmnt->location->[0];$self->{_disabled_line_map}->{$line}->{ALL}=1;$self->{_disabled_line_map}->{$line + 1}->{ALL}=1}return$self}sub _determine_is_module {my ($self,$args)=@_;my$file_name=$self->filename();if (defined$file_name and ref$args->{'-program-extensions'}eq 'ARRAY'){for my$ext (@{$args->{'-program-extensions'}}){my$regex=ref$ext eq 'Regexp' ? $ext : qr< @{ [ quotemeta $ext ] } \z >xms;return$FALSE if$file_name =~ m/$regex/smx}}return$FALSE if shebang_line($self);return$FALSE if defined$file_name && $file_name =~ m/ [.] PL \z /smx;return$TRUE}sub _nodes_by_namespace {my ($self)=@_;my$nodes=$self->{_nodes_by_namespace};return$nodes if$nodes;my$ppi_document=$self->ppi_document();if (not $ppi_document){return$self->{_nodes_by_namespace}={}}my$raw_nodes_map=split_ppi_node_by_namespace($ppi_document);my%wrapped_nodes;while (my ($namespace,$raw_nodes)=each %{$raw_nodes_map}){$wrapped_nodes{$namespace}=[map {__PACKAGE__->_new_for_parent_document($_,$self)}@{$raw_nodes}]}return$self->{_nodes_by_namespace}=\%wrapped_nodes}sub _modules_used {my ($self)=@_;my$mapping=$self->{_modules_used};return$mapping if$mapping;my$includes=$self->find('PPI::Statement::Include');if (not $includes){return$self->{_modules_used}={}}my%mapping;for my$module (grep {$_}map {$_->module()|| $_->pragma()}@{$includes}){$mapping{$module}=()}return$self->{_modules_used}=\%mapping}1;
PERL_CRITIC_DOCUMENT

$fatpacked{"Perl/Critic/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION';
  package Perl::Critic::Exception;use 5.006001;use strict;use warnings;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception'=>{isa=>'Exception::Class::Base',description=>'A problem discovered by Perl::Critic.',},);use Exporter 'import';sub short_class_name {my ($self)=@_;return substr ref$self,(length 'Perl::Critic')+ 2}1;
PERL_CRITIC_EXCEPTION

$fatpacked{"Perl/Critic/Exception/AggregateConfiguration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_AGGREGATECONFIGURATION';
  package Perl::Critic::Exception::AggregateConfiguration;use 5.006001;use strict;use warnings;use Carp qw{confess};use English qw(-no_match_vars);use Readonly;use Perl::Critic::Utils qw{:characters};our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::AggregateConfiguration'=>{isa=>'Perl::Critic::Exception',description=>'A collected set of configuration exceptions.',fields=>[qw{exceptions} ],alias=>'throw_aggregate',},);Readonly::Array our@EXPORT_OK=>qw<throw_aggregate>;sub new {my ($class,%options)=@_;my$exceptions=$options{exceptions};if (not $exceptions){$options{exceptions}=[]}return$class->SUPER::new(%options)}sub add_exception {my ($self,$exception)=@_;push @{$self->exceptions()},$exception;return}sub add_exceptions_from {my ($self,$aggregate)=@_;push @{$self->exceptions()},@{$aggregate->exceptions()};return}sub add_exception_or_rethrow {my ($self,$eval_error)=@_;return if not $eval_error;confess$eval_error if not ref$eval_error;if ($eval_error->isa('Perl::Critic::Exception::Configuration')){$self->add_exception($eval_error)}elsif ($eval_error->isa('Perl::Critic::Exception::AggregateConfiguration')){$self->add_exceptions_from($eval_error)}else {die$eval_error}return}sub has_exceptions {my ($self)=@_;return @{$self->exceptions()}? 1 : 0}Readonly::Scalar my$MESSAGE_PREFIX=>$EMPTY;Readonly::Scalar my$MESSAGE_SUFFIX=>"\n";Readonly::Scalar my$MESSAGE_SEPARATOR=>$MESSAGE_SUFFIX .$MESSAGE_PREFIX;sub full_message {my ($self)=@_;my$message=$MESSAGE_PREFIX;$message .= join$MESSAGE_SEPARATOR,@{$self->exceptions()};$message .= $MESSAGE_SUFFIX;return$message}1;
PERL_CRITIC_EXCEPTION_AGGREGATECONFIGURATION

$fatpacked{"Perl/Critic/Exception/Configuration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION';
  package Perl::Critic::Exception::Configuration;use 5.006001;use strict;use warnings;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration'=>{isa=>'Perl::Critic::Exception',description=>'A problem with Perl::Critic configuration, whether from a file or a command line or some other source.',fields=>[qw{source} ],},);1;
PERL_CRITIC_EXCEPTION_CONFIGURATION

$fatpacked{"Perl/Critic/Exception/Configuration/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_GENERIC';
  package Perl::Critic::Exception::Configuration::Generic;use 5.006001;use strict;use warnings;use Readonly;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration::Generic'=>{isa=>'Perl::Critic::Exception::Configuration',description=>q{A problem with Perl::Critic configuration that isn't related to an option.},alias=>'throw_generic',},);Readonly::Array our@EXPORT_OK=>qw<throw_generic>;1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_GENERIC

$fatpacked{"Perl/Critic/Exception/Configuration/NonExistentPolicy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_NONEXISTENTPOLICY';
  package Perl::Critic::Exception::Configuration::NonExistentPolicy;use 5.006001;use strict;use warnings;use Readonly;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration::NonExistentPolicy'=>{isa=>'Perl::Critic::Exception::Configuration',description=>'The configuration referred to a non-existant policy.',fields=>[qw{policy} ],},);Readonly::Array our@EXPORT_OK=>qw<throw_extra_parameter>;sub full_message {my ($self)=@_;my$policy=$self->policy();return qq<There is no $policy policy installed.>}1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_NONEXISTENTPOLICY

$fatpacked{"Perl/Critic/Exception/Configuration/Option.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION';
  package Perl::Critic::Exception::Configuration::Option;use 5.006001;use strict;use warnings;our$VERSION='0.01';use Perl::Critic::Exception::Fatal::Internal;use Exception::Class ('Perl::Critic::Exception::Configuration::Option'=>{isa=>'Perl::Critic::Exception::Configuration',description=>'A problem with an option in the Perl::Critic configuration, whether from a file or a command line or some other source.',fields=>[qw{option_name option_value message_suffix} ],},);sub message {my$self=shift;return$self->full_message()}sub error {my$self=shift;return$self->full_message()}sub full_message {Perl::Critic::Exception::Fatal::Internal->throw('Subclass failed to override abstract method.')}1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Global.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL';
  package Perl::Critic::Exception::Configuration::Option::Global;use 5.006001;use strict;use warnings;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration::Option::Global'=>{isa=>'Perl::Critic::Exception::Configuration::Option',description=>'A problem with global Perl::Critic configuration.',},);1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Global/ExtraParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL_EXTRAPARAMETER';
  package Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter;use 5.006001;use strict;use warnings;use Readonly;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter'=>{isa=>'Perl::Critic::Exception::Configuration::Option::Global',description=>'The configuration referred to a non-existant global option.',alias=>'throw_extra_global',},);Readonly::Array our@EXPORT_OK=>qw<throw_extra_global>;sub full_message {my ($self)=@_;my$source=$self->source();if ($source){$source=qq{ (found in "$source")}}else {$source=q{}}my$option_name=$self->option_name();return qq{"$option_name" is not a supported option$source.}}1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL_EXTRAPARAMETER

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Global/ParameterValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL_PARAMETERVALUE';
  package Perl::Critic::Exception::Configuration::Option::Global::ParameterValue;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters};our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration::Option::Global::ParameterValue'=>{isa=>'Perl::Critic::Exception::Configuration::Option::Global',description=>'A problem with the value of a global parameter.',alias=>'throw_global_value',},);Readonly::Array our@EXPORT_OK=>qw<throw_global_value>;sub full_message {my ($self)=@_;my$source=$self->source();if ($source){$source=qq{ found in "$source"}}else {$source=$EMPTY}my$option_name=$self->option_name();my$option_value=defined$self->option_value()? $DQUOTE .$self->option_value().$DQUOTE : '<undef>';my$message_suffix=$self->message_suffix()|| $EMPTY;return qq{The value for the global "$option_name" option } .qq{($option_value)$source $message_suffix}}1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL_PARAMETERVALUE

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Policy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY';
  package Perl::Critic::Exception::Configuration::Option::Policy;use 5.006001;use strict;use warnings;use Perl::Critic::Utils qw{&policy_short_name};our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration::Option::Policy'=>{isa=>'Perl::Critic::Exception::Configuration::Option',description=>'A problem with the configuration of a policy.',fields=>[qw{policy} ],},);sub new {my ($class,%options)=@_;my$policy=$options{policy};if ($policy){$options{policy}=policy_short_name($policy)}return$class->SUPER::new(%options)}1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Policy/ExtraParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY_EXTRAPARAMETER';
  package Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter;use 5.006001;use strict;use warnings;use Readonly;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter'=>{isa=>'Perl::Critic::Exception::Configuration::Option::Policy',description=>'The configuration of a policy referred to a non-existant parameter.',alias=>'throw_extra_parameter',},);Readonly::Array our@EXPORT_OK=>qw<throw_extra_parameter>;sub full_message {my ($self)=@_;my$source=$self->source();if ($source){$source=qq{ (found in "$source")}}else {$source=q{}}my$policy=$self->policy();my$option_name=$self->option_name();return qq{The $policy policy doesn't take a "$option_name" option$source.}}1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY_EXTRAPARAMETER

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Policy/ParameterValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY_PARAMETERVALUE';
  package Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters};our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue'=>{isa=>'Perl::Critic::Exception::Configuration::Option::Policy',description=>'A problem with the value of a parameter for a policy.',alias=>'throw_policy_value',},);Readonly::Array our@EXPORT_OK=>qw<throw_policy_value>;sub full_message {my ($self)=@_;my$source=$self->source();if ($source){$source=qq{ found in "$source"}}else {$source=$EMPTY}my$policy=$self->policy();my$option_name=$self->option_name();my$option_value=defined$self->option_value()? $DQUOTE .$self->option_value().$DQUOTE : '<undef>';my$message_suffix=$self->message_suffix()|| $EMPTY;return qq{The value for the $policy "$option_name" option } .qq{($option_value)$source $message_suffix}}1;
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY_PARAMETERVALUE

$fatpacked{"Perl/Critic/Exception/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_FATAL';
  package Perl::Critic::Exception::Fatal;use 5.006001;use strict;use warnings;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Fatal'=>{isa=>'Perl::Critic::Exception',description=>'A problem that should cause Perl::Critic to stop running.',},);sub new {my ($class,@args)=@_;my$self=$class->SUPER::new(@args);$self->show_trace(1);return$self}sub full_message {my ($self)=@_;return $self->short_class_name().q{: } .$self->description()."\n\n" .$self->message()."\n\n" .gmtime$self->time()."\n\n"}1;
PERL_CRITIC_EXCEPTION_FATAL

$fatpacked{"Perl/Critic/Exception/Fatal/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_FATAL_GENERIC';
  package Perl::Critic::Exception::Fatal::Generic;use 5.006001;use strict;use warnings;use Readonly;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Fatal::Generic'=>{isa=>'Perl::Critic::Exception::Fatal',description=>'A general problem was found.',alias=>'throw_generic',},);Readonly::Array our@EXPORT_OK=>qw<throw_generic>;1;
PERL_CRITIC_EXCEPTION_FATAL_GENERIC

$fatpacked{"Perl/Critic/Exception/Fatal/Internal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_FATAL_INTERNAL';
  package Perl::Critic::Exception::Fatal::Internal;use 5.006001;use strict;use warnings;use Readonly;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Fatal::Internal'=>{isa=>'Perl::Critic::Exception::Fatal',description=>'A problem with the Perl::Critic code was found, a.k.a. a bug.',alias=>'throw_internal',},);Readonly::Array our@EXPORT_OK=>qw<throw_internal>;1;
PERL_CRITIC_EXCEPTION_FATAL_INTERNAL

$fatpacked{"Perl/Critic/Exception/Fatal/PolicyDefinition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_FATAL_POLICYDEFINITION';
  package Perl::Critic::Exception::Fatal::PolicyDefinition;use 5.006001;use strict;use warnings;use Readonly;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Fatal::PolicyDefinition'=>{isa=>'Perl::Critic::Exception::Fatal',description=>'A bug in a policy was found.',alias=>'throw_policy_definition',},);Readonly::Array our@EXPORT_OK=>qw<throw_policy_definition>;1;
PERL_CRITIC_EXCEPTION_FATAL_POLICYDEFINITION

$fatpacked{"Perl/Critic/Exception/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_IO';
  package Perl::Critic::Exception::IO;use 5.006001;use strict;use warnings;use Carp qw{confess};use English qw(-no_match_vars);use Readonly;use Perl::Critic::Utils qw{:characters};our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::IO'=>{isa=>'Perl::Critic::Exception',description=>'An input/output problem.',fields=>[qw<file_name errno> ],alias=>'throw_io',},);Readonly::Array our@EXPORT_OK=>qw<throw_io>;1;
PERL_CRITIC_EXCEPTION_IO

$fatpacked{"Perl/Critic/Exception/Parse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_PARSE';
  package Perl::Critic::Exception::Parse;use 5.006001;use strict;use warnings;use English qw<-no_match_vars>;use Carp qw<confess>;use Readonly;use Perl::Critic::Utils qw<:characters>;our$VERSION='0.01';use Exception::Class ('Perl::Critic::Exception::Parse'=>{isa=>'Perl::Critic::Exception',description=>'A problem parsing source code.',fields=>[qw<file_name> ],alias=>'throw_parse',},);Readonly::Array our@EXPORT_OK=>qw<throw_parse>;1;
PERL_CRITIC_EXCEPTION_PARSE

$fatpacked{"Perl/Critic/OptionsProcessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_OPTIONSPROCESSOR';
  package Perl::Critic::OptionsProcessor;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Perl::Critic::Exception::AggregateConfiguration;use Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter;use Perl::Critic::Utils qw<:booleans :characters :severities :data_conversion $DEFAULT_VERBOSITY>;use Perl::Critic::Utils::Constants qw<$PROFILE_STRICTNESS_DEFAULT :color_severity>;use Perl::Critic::Utils::DataConversion qw<dor>;our$VERSION='0.01';sub new {my ($class,%args)=@_;my$self=bless {},$class;$self->_init(%args);return$self}sub _init {my ($self,%args)=@_;my$exclude=dor(delete$args{exclude},$EMPTY);$self->{_exclude}=[words_from_string($exclude)];my$include=dor(delete$args{include},$EMPTY);$self->{_include}=[words_from_string($include)];my$program_extensions=dor(delete$args{'program-extensions'},$EMPTY);$self->{_program_extensions}=[words_from_string($program_extensions)];$self->{_force}=dor(delete$args{force},$FALSE);$self->{_only}=dor(delete$args{only},$FALSE);$self->{_profile_strictness}=dor(delete$args{'profile-strictness'},$PROFILE_STRICTNESS_DEFAULT);$self->{_single_policy}=dor(delete$args{'single-policy'},$EMPTY);$self->{_severity}=dor(delete$args{severity},$SEVERITY_HIGHEST);$self->{_theme}=dor(delete$args{theme},$EMPTY);$self->{_top}=dor(delete$args{top},$FALSE);$self->{_verbose}=dor(delete$args{verbose},$DEFAULT_VERBOSITY);$self->{_criticism_fatal}=dor(delete$args{'criticism-fatal'},$FALSE);$self->{_pager}=dor(delete$args{pager},$EMPTY);$self->{_allow_unsafe}=dor(delete$args{'allow-unsafe'},$FALSE);$self->{_color_severity_highest}=dor(delete$args{'color-severity-highest'},delete$args{'colour-severity-highest'},delete$args{'color-severity-5'},delete$args{'colour-severity-5'},$PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT,);$self->{_color_severity_high}=dor(delete$args{'color-severity-high'},delete$args{'colour-severity-high'},delete$args{'color-severity-4'},delete$args{'colour-severity-4'},$PROFILE_COLOR_SEVERITY_HIGH_DEFAULT,);$self->{_color_severity_medium}=dor(delete$args{'color-severity-medium'},delete$args{'colour-severity-medium'},delete$args{'color-severity-3'},delete$args{'colour-severity-3'},$PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT,);$self->{_color_severity_low}=dor(delete$args{'color-severity-low'},delete$args{'colour-severity-low'},delete$args{'color-severity-2'},delete$args{'colour-severity-2'},$PROFILE_COLOR_SEVERITY_LOW_DEFAULT,);$self->{_color_severity_lowest}=dor(delete$args{'color-severity-lowest'},delete$args{'colour-severity-lowest'},delete$args{'color-severity-1'},delete$args{'colour-severity-1'},$PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT,);my$default_color=($self->pager()or not -t *STDOUT)? $FALSE : $TRUE;$self->{_color}=dor(delete$args{color},delete$args{colour},$default_color);_check_for_extra_options(%args);return$self}sub _check_for_extra_options {my%args=@_;if (my@remaining=sort keys%args){my$errors=Perl::Critic::Exception::AggregateConfiguration->new();for my$option_name (@remaining){$errors->add_exception(Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter->new(option_name=>$option_name,))}$errors->rethrow()}return}sub severity {my ($self)=@_;return$self->{_severity}}sub theme {my ($self)=@_;return$self->{_theme}}sub exclude {my ($self)=@_;return$self->{_exclude}}sub include {my ($self)=@_;return$self->{_include}}sub only {my ($self)=@_;return$self->{_only}}sub profile_strictness {my ($self)=@_;return$self->{_profile_strictness}}sub single_policy {my ($self)=@_;return$self->{_single_policy}}sub verbose {my ($self)=@_;return$self->{_verbose}}sub color {my ($self)=@_;return$self->{_color}}sub pager {my ($self)=@_;return$self->{_pager}}sub allow_unsafe {my ($self)=@_;return$self->{_allow_unsafe}}sub criticism_fatal {my ($self)=@_;return$self->{_criticism_fatal}}sub force {my ($self)=@_;return$self->{_force}}sub top {my ($self)=@_;return$self->{_top}}sub color_severity_highest {my ($self)=@_;return$self->{_color_severity_highest}}sub color_severity_high {my ($self)=@_;return$self->{_color_severity_high}}sub color_severity_medium {my ($self)=@_;return$self->{_color_severity_medium}}sub color_severity_low {my ($self)=@_;return$self->{_color_severity_low}}sub color_severity_lowest {my ($self)=@_;return$self->{_color_severity_lowest}}sub program_extensions {my ($self)=@_;return$self->{_program_extensions}}1;
PERL_CRITIC_OPTIONSPROCESSOR

$fatpacked{"Perl/Critic/Policy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY';
  package Perl::Critic::Policy;use 5.006001;use strict;use warnings;use English qw<-no_match_vars>;use Readonly;use File::Spec ();use String::Format qw<stringf>;use overload (q<"">=>'to_string',cmp=>'_compare');use Perl::Critic::Utils qw<:characters :booleans :severities :data_conversion interpolate is_integer policy_long_name policy_short_name severity_to_number>;use Perl::Critic::Utils::DataConversion qw<dor>;use Perl::Critic::Utils::POD qw<get_module_abstract_for_module get_raw_module_abstract_for_module>;use Perl::Critic::Exception::AggregateConfiguration;use Perl::Critic::Exception::Configuration;use Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter;use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue;use Perl::Critic::Exception::Fatal::PolicyDefinition qw<throw_policy_definition>;use Perl::Critic::PolicyConfig qw<>;use Perl::Critic::PolicyParameter qw<>;use Perl::Critic::Violation qw<>;use Exception::Class;our$VERSION='0.01';Readonly::Scalar my$NO_LIMIT=>'no_limit';my$format='%p';sub new {my ($class,%config)=@_;my$self=bless {},$class;my$config_object;if ($config{_config_object}){$config_object=$config{_config_object}}else {$config_object=Perl::Critic::PolicyConfig->new($self->get_short_name(),\%config,)}$self->__set_config($config_object);my@parameters;my$parameter_metadata_available=0;if ($class->can('supported_parameters')){$parameter_metadata_available=1;@parameters=map {Perl::Critic::PolicyParameter->new($_)}$class->supported_parameters()}$self->{_parameter_metadata_available}=$parameter_metadata_available;$self->{_parameters}=\@parameters;my$errors=Perl::Critic::Exception::AggregateConfiguration->new();for my$parameter (@parameters){eval {$parameter->parse_and_validate_config_value($self,$config_object)}or do {$errors->add_exception_or_rethrow($EVAL_ERROR)};$config_object->remove($parameter->get_name())}if ($parameter_metadata_available){$config_object->handle_extra_parameters($self,$errors)}if ($errors->has_exceptions()){$errors->rethrow()}return$self}sub is_safe {return$TRUE}sub initialize_if_enabled {return$TRUE}sub prepare_to_scan_document {return$TRUE}sub __get_parameter_name {my ($self,$parameter)=@_;return '_' .$parameter->get_name()}sub __set_parameter_value {my ($self,$parameter,$value)=@_;$self->{$self->__get_parameter_name($parameter)}=$value;return}sub __set_base_parameters {my ($self)=@_;my$config=$self->__get_config();my$errors=Perl::Critic::Exception::AggregateConfiguration->new();$self->_set_maximum_violations_per_document($errors);my$user_severity=$config->get_severity();if (defined$user_severity){my$normalized_severity=severity_to_number($user_severity);$self->set_severity($normalized_severity)}my$user_set_themes=$config->get_set_themes();if (defined$user_set_themes){my@set_themes=words_from_string($user_set_themes);$self->set_themes(@set_themes)}my$user_add_themes=$config->get_add_themes();if (defined$user_add_themes){my@add_themes=words_from_string($user_add_themes);$self->add_themes(@add_themes)}if ($errors->has_exceptions()){$errors->rethrow()}return}sub _set_maximum_violations_per_document {my ($self,$errors)=@_;my$config=$self->__get_config();if ($config->is_maximum_violations_per_document_unlimited()){return}my$user_maximum_violations=$config->get_maximum_violations_per_document();if (not is_integer($user_maximum_violations)){$errors->add_exception(new_parameter_value_exception('maximum_violations_per_document',$user_maximum_violations,undef,"does not look like an integer.\n"));return}elsif ($user_maximum_violations < 0){$errors->add_exception(new_parameter_value_exception('maximum_violations_per_document',$user_maximum_violations,undef,"is not greater than or equal to zero.\n"));return}$self->set_maximum_violations_per_document($user_maximum_violations);return}sub __get_config {my ($self)=@_;return$self->{_config}}sub __set_config {my ($self,$config)=@_;$self->{_config}=$config;return}sub get_long_name {my ($self)=@_;return policy_long_name(ref$self)}sub get_short_name {my ($self)=@_;return policy_short_name(ref$self)}sub is_enabled {my ($self)=@_;return$self->{_enabled}}sub __set_enabled {my ($self,$new_value)=@_;$self->{_enabled}=$new_value;return}sub applies_to {return qw(PPI::Element)}sub set_maximum_violations_per_document {my ($self,$maximum_violations_per_document)=@_;$self->{_maximum_violations_per_document}=$maximum_violations_per_document;return$self}sub get_maximum_violations_per_document {my ($self)=@_;return exists$self->{_maximum_violations_per_document}? $self->{_maximum_violations_per_document}: $self->default_maximum_violations_per_document()}sub default_maximum_violations_per_document {return}sub set_severity {my ($self,$severity)=@_;$self->{_severity}=$severity;return$self}sub get_severity {my ($self)=@_;return$self->{_severity}|| $self->default_severity()}sub default_severity {return$SEVERITY_LOWEST}sub set_themes {my ($self,@themes)=@_;$self->{_themes}=[sort@themes ];return$self}sub get_themes {my ($self)=@_;my@themes=defined$self->{_themes}? @{$self->{_themes}}: $self->default_themes();my@sorted_themes=sort@themes;return@sorted_themes}sub add_themes {my ($self,@additional_themes)=@_;my%merged=hashify($self->get_themes(),@additional_themes);$self->{_themes}=[keys%merged];return$self}sub default_themes {return ()}sub get_abstract {my ($self)=@_;return get_module_abstract_for_module(ref$self)}sub get_raw_abstract {my ($self)=@_;return get_raw_module_abstract_for_module(ref$self)}sub parameter_metadata_available {my ($self)=@_;return$self->{_parameter_metadata_available}}sub get_parameters {my ($self)=@_;return$self->{_parameters}}sub violates {my ($self)=@_;return throw_policy_definition $self->get_short_name().q/ does not implement violates()./}sub violation {my ($self,$desc,$expl,$elem)=@_;my$sev=$self->get_severity();@_=('Perl::Critic::Violation',$desc,$expl,$elem,$sev);goto&Perl::Critic::Violation::new}sub new_parameter_value_exception {my ($self,$option_name,$option_value,$source,$message_suffix)=@_;return Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue->new(policy=>$self->get_short_name(),option_name=>$option_name,option_value=>$option_value,source=>$source,message_suffix=>$message_suffix)}sub throw_parameter_value_exception {my ($self,$option_name,$option_value,$source,$message_suffix)=@_;$self->new_parameter_value_exception($option_name,$option_value,$source,$message_suffix)->throw()}sub set_format {return$format=$_[0]}sub get_format {return$format}sub to_string {my ($self,@args)=@_;my%fspec=('P'=>sub {$self->get_long_name()},'p'=>sub {$self->get_short_name()},'a'=>sub {dor($self->get_abstract(),$EMPTY)},'O'=>sub {$self->_format_parameters(@_)},'U'=>sub {$self->_format_lack_of_parameter_metadata(@_)},'S'=>sub {$self->default_severity()},'s'=>sub {$self->get_severity()},'T'=>sub {join$SPACE,$self->default_themes()},'t'=>sub {join$SPACE,$self->get_themes()},'V'=>sub {dor($self->default_maximum_violations_per_document(),$NO_LIMIT)},'v'=>sub {dor($self->get_maximum_violations_per_document(),$NO_LIMIT)},);return stringf(get_format(),%fspec)}sub _format_parameters {my ($self,$parameter_format)=@_;return$EMPTY if not $self->parameter_metadata_available();my$separator;if ($parameter_format){$separator=$EMPTY}else {$separator=$SPACE;$parameter_format='%n'}return join $separator,map {$_->to_formatted_string($parameter_format)}@{$self->get_parameters()}}sub _format_lack_of_parameter_metadata {my ($self,$message)=@_;return$EMPTY if$self->parameter_metadata_available();return interpolate($message)if$message;return 'Cannot programmatically discover what parameters this policy takes.'}sub _compare {return "$_[0]" cmp "$_[1]"}1;
PERL_CRITIC_POLICY

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitBooleanGrep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITBOOLEANGREP';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitBooleanGrep;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification hashify};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"grep" used in boolean context};Readonly::Scalar my$EXPL=>[71,72];Readonly::Hash my%POSTFIX_CONDITIONALS=>hashify(qw(if unless while until));Readonly::Hash my%BOOLEAN_OPERATORS=>hashify(qw(&& || ! not or and));sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp performance certrec)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'grep';return if not is_function_call($elem);return if not _is_in_boolean_context($elem);return$self->violation($DESC,$EXPL,$elem)}sub _is_in_boolean_context {my ($token)=@_;return _does_prev_sibling_cause_boolean($token)|| _does_parent_cause_boolean($token)}sub _does_prev_sibling_cause_boolean {my ($token)=@_;my$prev=$token->sprevious_sibling;return if!$prev;return 1 if$prev->isa('PPI::Token::Word')and $POSTFIX_CONDITIONALS{$prev};return if not ($prev->isa('PPI::Token::Operator')and $BOOLEAN_OPERATORS{$prev});my$next=$token->snext_sibling;return 1 if not $next;return 1 if not $next->isa('PPI::Structure::List');$next=$next->snext_sibling;return 1 if not $next;return 1 if$next->isa('PPI::Token::Operator')and $BOOLEAN_OPERATORS{$next};return}sub _does_parent_cause_boolean {my ($token)=@_;my$prev=$token->sprevious_sibling;return if$prev;my$parent=$token->statement->parent;for (my$node=$parent;$node;$node=$node->parent){next if$node->isa('PPI::Structure::List');return 1 if$node->isa('PPI::Structure::Condition')}return}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITBOOLEANGREP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitComplexMappings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITCOMPLEXMAPPINGS';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitComplexMappings;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Map blocks should have a single statement};Readonly::Scalar my$EXPL=>[113 ];sub supported_parameters {return ({name=>'max_statements',description=>'The maximum number of statements to allow within a map block.',default_string=>'1',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance complexity)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'map';return if!is_function_call($elem);my$sib=$elem->snext_sibling();return if!$sib;my$arg=$sib;if ($arg->isa('PPI::Structure::List')){$arg=$arg->schild(0);if ($arg && $arg->isa('PPI::Statement::Expression')){$arg=$arg->schild(0)}}return if!$arg;return if!$arg->isa('PPI::Structure::Block');return if$self->{_max_statements}>= $arg->schildren()&& 0==grep {$_->isa('PPI::Statement::Compound')}$arg->schildren();return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITCOMPLEXMAPPINGS

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitLvalueSubstr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITLVALUESUBSTR';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitLvalueSubstr;use 5.006001;use strict;use warnings;use Readonly;use version 0.77 ();use Perl::Critic::Utils qw{:severities :classification :language};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Lvalue form of "substr" used};Readonly::Scalar my$EXPL=>[165 ];Readonly::Scalar my$ASSIGNMENT_PRECEDENCE=>precedence_of(q{=});Readonly::Scalar my$MINIMUM_PERL_VERSION=>version->new(5.005);sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance pbp)}sub applies_to {return 'PPI::Token::Word'}sub prepare_to_scan_document {my ($self,$document)=@_;my$version=$document->highest_explicit_perl_version();return!$version || $version >= $MINIMUM_PERL_VERSION}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'substr';return if!is_function_call($elem);my$sib=$elem;while ($sib=$sib->snext_sibling()){if ($sib->isa('PPI::Token::Operator')){my$rslt=$ASSIGNMENT_PRECEDENCE <=> precedence_of($sib->content());return if$rslt < 0;return$self->violation($DESC,$EXPL,$sib)if$rslt==0}}return}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITLVALUESUBSTR

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitReverseSortBlock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITREVERSESORTBLOCK';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitReverseSortBlock;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Forbid $b before $a in sort blocks};Readonly::Scalar my$EXPL=>[152 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,$doc)=@_;return if$elem->content()ne 'sort';return if!is_function_call($elem);my$sib=$elem->snext_sibling();return if!$sib;my$arg=$sib;if ($arg->isa('PPI::Structure::List')){$arg=$arg->schild(0);if ($arg && $arg->isa('PPI::Statement::Expression')){$arg=$arg->schild(0)}}return if!$arg ||!$arg->isa('PPI::Structure::Block');for my$statement ($arg->children){my@sort_vars=$statement =~ m/\$([ab])\b/gxms;my$count=0;for my$sort_var (@sort_vars){if ($sort_var eq 'a'){$count++}else {$count--;if ($count < 0){return$self->violation($DESC,$EXPL,$elem)}}}}return}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITREVERSESORTBLOCK

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitSleepViaSelect.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSLEEPVIASELECT';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitSleepViaSelect;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"select" used to emulate "sleep"};Readonly::Scalar my$EXPL=>[168];Readonly::Scalar my$SELECT_ARGUMENT_COUNT=>4;sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'select';return if!is_function_call($elem);my@arguments=parse_arg_list($elem);return if$SELECT_ARGUMENT_COUNT!=@arguments;for my$argument (@arguments[0..2]){return if$argument->[0]ne 'undef'}if ($arguments[-1]->[0]ne 'undef'){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSLEEPVIASELECT

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitStringyEval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSTRINGYEVAL';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitStringyEval;use 5.006001;use strict;use warnings;use Readonly;use PPI::Document;use Perl::Critic::Utils qw{:booleans :severities :classification :ppi $SCOLON};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Expression form of "eval"};Readonly::Scalar my$EXPL=>[161 ];sub supported_parameters {return ({name=>'allow_includes',description=>q<Allow eval of "use" and "require" strings.>,default_string=>'0',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'eval';return if not is_function_call($elem);my$argument=first_arg($elem);return if not $argument;return if$argument->isa('PPI::Structure::Block');return if $self->{_allow_includes}and _string_eval_is_an_include($argument);return$self->violation($DESC,$EXPL,$elem)}sub _string_eval_is_an_include {my ($eval_argument)=@_;return if not $eval_argument->isa('PPI::Token::Quote');my$string=$eval_argument->string();my$document;eval {$document=PPI::Document->new(\$string);1}or return;my@statements=$document->schildren;return if@statements > 2;my$include=$statements[0];return if not defined$include;return if not $include->isa('PPI::Statement::Include');return if$include->type()eq 'no';if ($eval_argument->isa('PPI::Token::Quote::Single')or $eval_argument->isa('PPI::Token::Quote::Literal')){return if$include->find('PPI::Token::Symbol')}return$TRUE if@statements==1;my$follow_on=$statements[1];return if not $follow_on->isa('PPI::Statement');my@follow_on_components=$follow_on->schildren();return if@follow_on_components > 2;return if not $follow_on_components[0]->isa('PPI::Token::Number');return$TRUE if@follow_on_components==1;return$follow_on_components[1]->content()eq $SCOLON}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSTRINGYEVAL

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitStringySplit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSTRINGYSPLIT';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitStringySplit;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{String delimiter used with "split"};Readonly::Scalar my$EXPL=>q{Express it as a regex instead};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'split';return if!is_function_call($elem);my@args=parse_arg_list($elem);my$pattern=@args ? $args[0]->[0]: return;if ($pattern->isa('PPI::Token::Quote')&& $pattern->string()ne $SPACE){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSTRINGYSPLIT

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitUniversalCan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUNIVERSALCAN';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalCan;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{UNIVERSAL::can should not be used as a function};Readonly::Scalar my$EXPL=>q{Use eval{$obj->can($pkg)} instead};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if!($elem eq 'can' || $elem eq 'UNIVERSAL::can');return if!is_function_call($elem);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUNIVERSALCAN

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitUniversalIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUNIVERSALISA';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalIsa;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{UNIVERSAL::isa should not be used as a function};Readonly::Scalar my$EXPL=>q{Use eval{$obj->isa($pkg)} instead};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if!($elem eq 'isa' || $elem eq 'UNIVERSAL::isa');return if!is_function_call($elem);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUNIVERSALISA

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitUselessTopic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUSELESSTOPIC';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitUselessTopic;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Useless use of $_};Readonly::Scalar my$EXPL_FILETEST=>q{$_ should be omitted when using a filetest operator};Readonly::Scalar my$EXPL_FUNCTION=>q{$_ should be omitted when calling "%s"};Readonly::Scalar my$EXPL_FUNCTION_SPLIT=>q{$_ should be omitted when calling "split" with two arguments};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core)}sub applies_to {return 'PPI::Token::Operator','PPI::Token::Word'}my@filetest_operators=qw(-r -w -x -o -R -W -X -O -e -z -s -f -d -l -p -S -b -c -u -g -k -T -B -M -A -C);my%filetest_operators=map {($_=>1)}@filetest_operators;my@topical_funcs=qw(abs alarm chomp chop chr chroot cos defined eval exp fc glob hex int lc lcfirst length log lstat mkdir oct ord pos print quotemeta readlink readpipe ref require reverse rmdir say sin split sqrt stat study uc ucfirst unlink unpack);my%topical_funcs=map {($_=>1)}@topical_funcs;sub violates {my ($self,$elem,undef)=@_;my$content=$elem->content;if ($filetest_operators{$content }){my$op_node=$elem->snext_sibling;if ($op_node && $op_node->isa('PPI::Token::Magic')){my$op=$op_node->content;if ($op eq '$_'){return$self->violation($DESC,$EXPL_FILETEST,$elem)}}return}if ($topical_funcs{$content }&& is_perl_builtin($elem)){my$is_split=$content eq 'split';my@args=parse_arg_list($elem);my$nth_arg_for_topic;if ($is_split){return if@args!=2;$nth_arg_for_topic=2}else {$nth_arg_for_topic=1}if (@args==$nth_arg_for_topic){my$topic_arg=$args[$nth_arg_for_topic - 1 ];my@tokens=@{$topic_arg};if ((@tokens==1)&& ($tokens[0]->content eq '$_')){my$msg=$is_split ? $EXPL_FUNCTION_SPLIT : (sprintf$EXPL_FUNCTION,$content);return$self->violation($DESC,$msg,$elem)}}return}return}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUSELESSTOPIC

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitVoidGrep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITVOIDGREP';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitVoidGrep;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification is_in_void_context};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"grep" used in void context};Readonly::Scalar my$EXPL=>q{Use a "for" loop instead};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'grep';return if not is_function_call($elem);return if not is_in_void_context($elem);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITVOIDGREP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitVoidMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITVOIDMAP';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitVoidMap;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification is_in_void_context};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"map" used in void context};Readonly::Scalar my$EXPL=>q{Use a "for" loop instead};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'map';return if not is_function_call($elem);return if not is_in_void_context($elem);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITVOIDMAP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/RequireBlockGrep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREBLOCKGREP';
  package Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Expression form of "grep"};Readonly::Scalar my$EXPL=>[169 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'grep';return if!is_function_call($elem);my$arg=first_arg($elem);return if!$arg;return if$arg->isa('PPI::Structure::Block');return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREBLOCKGREP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/RequireBlockMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREBLOCKMAP';
  package Perl::Critic::Policy::BuiltinFunctions::RequireBlockMap;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Expression form of "map"};Readonly::Scalar my$EXPL=>[169 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem ne 'map';return if!is_function_call($elem);my$arg=first_arg($elem);return if!$arg;return if$arg->isa('PPI::Structure::Block');return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREBLOCKMAP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/RequireGlobFunction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREGLOBFUNCTION';
  package Perl::Critic::Policy::BuiltinFunctions::RequireGlobFunction;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$GLOB_RX=>qr< [*?] >xms;Readonly::Scalar my$DESC=>q{Glob written as <...>};Readonly::Scalar my$EXPL=>[167 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs)}sub applies_to {return 'PPI::Token::QuoteLike::Readline'}sub violates {my ($self,$elem,undef)=@_;if ($elem =~ $GLOB_RX){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREGLOBFUNCTION

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/RequireSimpleSortBlock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIRESIMPLESORTBLOCK';
  package Perl::Critic::Policy::BuiltinFunctions::RequireSimpleSortBlock;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Sort blocks should have a single statement};Readonly::Scalar my$EXPL=>[149 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance complexity)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'sort';return if!is_function_call($elem);my$sib=$elem->snext_sibling();return if!$sib;my$arg=$sib;if ($arg->isa('PPI::Structure::List')){$arg=$arg->schild(0);if ($arg && $arg->isa('PPI::Statement::Expression')){$arg=$arg->schild(0)}}return if!$arg ||!$arg->isa('PPI::Structure::Block');return if (1 >= $arg->schildren());return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIRESIMPLESORTBLOCK

$fatpacked{"Perl/Critic/Policy/ClassHierarchies/ProhibitAutoloading.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITAUTOLOADING';
  package Perl::Critic::Policy::ClassHierarchies::ProhibitAutoloading;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{AUTOLOAD method declared};Readonly::Scalar my$EXPL=>[393 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance pbp)}sub applies_to {return 'PPI::Statement::Sub'}sub violates {my ($self,$elem,undef)=@_;if($elem->name eq 'AUTOLOAD'){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITAUTOLOADING

$fatpacked{"Perl/Critic/Policy/ClassHierarchies/ProhibitExplicitISA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITEXPLICITISA';
  package Perl::Critic::Policy::ClassHierarchies::ProhibitExplicitISA;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{@ISA used instead of "use base"};Readonly::Scalar my$EXPL=>[360 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance pbp certrec)}sub applies_to {return 'PPI::Token::Symbol'}sub violates {my ($self,$elem,undef)=@_;if($elem eq q{@ISA}){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITEXPLICITISA

$fatpacked{"Perl/Critic/Policy/ClassHierarchies/ProhibitOneArgBless.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITONEARGBLESS';
  package Perl::Critic::Policy::ClassHierarchies::ProhibitOneArgBless;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{One-argument "bless" used};Readonly::Scalar my$EXPL=>[365 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'bless';return if!is_function_call($elem);if(scalar parse_arg_list($elem)==1){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITONEARGBLESS

$fatpacked{"Perl/Critic/Policy/CodeLayout/ProhibitHardTabs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITHARDTABS';
  package Perl::Critic::Policy::CodeLayout::ProhibitHardTabs;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Hard tabs used};Readonly::Scalar my$EXPL=>[20 ];Readonly::Scalar my$NON_LEADING_TAB_REGEX=>qr{^ .* \S+ \t }xms;sub supported_parameters {return ({name=>'allow_leading_tabs',description=>'Allow hard tabs before first non-whitespace character.',default_string=>'1',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core cosmetic pbp)}sub applies_to {return 'PPI::Token'}sub violates {my ($self,$elem,undef)=@_;$elem =~ m{ \t }xms || return;return if$elem->parent->isa('PPI::Statement::Data');if ($self->_allow_leading_tabs()){return if$elem->location->[1]==1;return if _is_extended_regex($elem)&& $elem !~ $NON_LEADING_TAB_REGEX;return if$elem->isa('PPI::Token::QuoteLike::Words')&& $elem !~ $NON_LEADING_TAB_REGEX}return$self->violation($DESC,$EXPL,$elem)}sub _allow_leading_tabs {my ($self)=@_;return$self->{_allow_leading_tabs}}sub _is_extended_regex {my ($elem)=@_;$elem->isa('PPI::Token::Regexp')|| $elem->isa('PPI::Token::QuoteLike::Regexp')|| return;return$elem =~ m{\b [gimso]* x [gimso]* $}xms}1;
PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITHARDTABS

$fatpacked{"Perl/Critic/Policy/CodeLayout/ProhibitParensWithBuiltins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITPARENSWITHBUILTINS';
  package Perl::Critic::Policy::CodeLayout::ProhibitParensWithBuiltins;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw{any};use Perl::Critic::Utils qw{:booleans :severities :data_conversion :classification :language};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Array my@ALLOW=>qw(my our local return state);Readonly::Hash my%ALLOW=>hashify(@ALLOW);Readonly::Scalar my$DESC=>q{Builtin function called with parentheses};Readonly::Scalar my$EXPL=>[13 ];Readonly::Scalar my$PRECENDENCE_OF_LIST=>precedence_of(q{>>})+ 1;Readonly::Scalar my$PRECEDENCE_OF_COMMA=>precedence_of(q{,});Readonly::Array my@NAMED_UNARY_OPS=>qw(alarm glob rand caller gmtime readlink chdir hex ref chroot int require cos lc return defined lcfirst rmdir delete length scalar do localtime sin eval lock sleep exists log sqrt exit lstat srand getgrp my stat gethostbyname oct uc getnetbyname ord ucfirst getprotobyname quotemeta umask undef);Readonly::Hash my%NAMED_UNARY_OPS=>hashify(@NAMED_UNARY_OPS);sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if exists$ALLOW{$elem};return if not is_perl_builtin($elem);return if not is_function_call($elem);my$sibling=$elem->snext_sibling();return if not $sibling;if ($sibling->isa('PPI::Structure::List')){my$elem_after_parens=$sibling->snext_sibling();return if _is_named_unary_with_operator_inside_parens_exemption($elem,$sibling);return if _is_named_unary_with_operator_following_parens_exemption($elem,$elem_after_parens);return if _is_precedence_exemption($elem_after_parens);return if _is_equals_exemption($sibling);return if _is_sort_exemption($elem,$sibling);return$self->violation($DESC,$EXPL,$elem)}return}sub _is_named_unary_with_operator_following_parens_exemption {my ($elem,$elem_after_parens)=@_;if (_is_named_unary($elem)&& $elem_after_parens){my$precedence=precedence_of($elem_after_parens);return$TRUE if defined$precedence && $precedence < $PRECENDENCE_OF_LIST}return$FALSE}sub _is_named_unary {my ($elem)=@_;return exists$NAMED_UNARY_OPS{$elem->content}}sub _is_precedence_exemption {my ($elem_after_parens)=@_;if ($elem_after_parens){my$precedence=precedence_of($elem_after_parens);return$TRUE if defined$precedence && $precedence <= $PRECEDENCE_OF_COMMA}return$FALSE}sub _is_equals_exemption {my ($sibling)=@_;if (my$first_op=$sibling->find_first('PPI::Token::Operator')){return$TRUE if$first_op eq q{=}}return$FALSE}sub _is_sort_exemption {my ($elem,$sibling)=@_;if ($elem eq 'sort'){my$first_arg=$sibling->schild(0);if ($first_arg && $first_arg->isa('PPI::Statement::Expression')){$first_arg=$first_arg->schild(0)}if ($first_arg && $first_arg->isa('PPI::Token::Word')){my$next_arg=$first_arg->snext_sibling;return$TRUE if$next_arg && $next_arg->isa('PPI::Structure::List')}}return$FALSE}sub _is_named_unary_with_operator_inside_parens_exemption {my ($elem,$parens)=@_;return _is_named_unary($elem)&& _contains_operators($parens)}sub _contains_operators {my ($parens)=@_;return$TRUE if$parens->find_first('PPI::Token::Operator');return$FALSE}1;
PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITPARENSWITHBUILTINS

$fatpacked{"Perl/Critic/Policy/CodeLayout/ProhibitQuotedWordLists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITQUOTEDWORDLISTS';
  package Perl::Critic::Policy::CodeLayout::ProhibitQuotedWordLists;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{List of quoted literal words};Readonly::Scalar my$EXPL=>q{Use 'qw()' instead};sub supported_parameters {return ({name=>'min_elements',description=>'The minimum number of words in a list that will be complained about.',default_string=>'2',behavior=>'integer',integer_minimum=>1,},{name=>'strict',description=>'Complain even if there are non-word characters in the values.',default_string=>'0',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core cosmetic)}sub applies_to {return 'PPI::Structure::List'}sub violates {my ($self,$elem,undef)=@_;my$sibling=$elem->sprevious_sibling();return if not $sibling;return if$sibling->isa('PPI::Token::Symbol');return if$sibling->isa('PPI::Token::Operator')and $sibling eq '->';return if$sibling->isa('PPI::Token::Word')and not is_included_module_name($sibling);my$expr=$elem->schild(0);return if not $expr;my@children=$expr->schildren();return if not @children;my$count=0;for my$child (@children){next if$child->isa('PPI::Token::Operator')&& $child eq $COMMA;return if not _is_literal($child);my$string=$child->string();return if$string =~ m{ \s }xms;return if$string eq $EMPTY;return if not $self->{_strict}and $string !~ m{\A [\w-]+ \z}xms;$count++}return if$count < $self->{_min_elements};return$self->violation($DESC,$EXPL,$elem)}sub _is_literal {my$elem=shift;return$elem->isa('PPI::Token::Quote::Single')|| $elem->isa('PPI::Token::Quote::Literal')}1;
PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITQUOTEDWORDLISTS

$fatpacked{"Perl/Critic/Policy/CodeLayout/ProhibitTrailingWhitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITTRAILINGWHITESPACE';
  package Perl::Critic::Policy::CodeLayout::ProhibitTrailingWhitespace;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use charnames qw{};use PPI::Token::Whitespace;use Perl::Critic::Utils qw{:characters :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Don't use whitespace at the end of lines};Readonly::Hash my%C_STYLE_ESCAPES=>(ord "\t"=>q{\t},ord "\n"=>q{\n},ord "\r"=>q{\r},ord "\f"=>q{\f},ord "\b"=>q{\b},ord "\a"=>q{\a},ord "\e"=>q{\e},);sub supported_parameters {return qw{}}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Token::Whitespace'}sub violates {my ($self,$token,undef)=@_;if ($token->content()=~ m< ( (?! \n) \s )+ \n >xms){my$extra_whitespace=$1;my$description=q{Found "};$description .= join $EMPTY,map {_escape($_)}split$EMPTY,$extra_whitespace;$description .= q{" at the end of the line};return$self->violation($description,$EXPL,$token)}return}sub _escape {my$character=shift;my$ordinal=ord$character;if (my$c_escape=$C_STYLE_ESCAPES{$ordinal}){return$c_escape}if (charnames->can('viacode')){return q/\N{/ .charnames::viacode($ordinal).q/}/}else {return '\N{WHITESPACE CHAR}'}}1;
PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITTRAILINGWHITESPACE

$fatpacked{"Perl/Critic/Policy/CodeLayout/RequireConsistentNewlines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_REQUIRECONSISTENTNEWLINES';
  package Perl::Critic::Policy::CodeLayout::RequireConsistentNewlines;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use PPI::Token::Whitespace;use English qw(-no_match_vars);use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$LINE_END=>qr/\015{1,2}\012|[\012\015]/mxs;Readonly::Scalar my$DESC=>q{Use the same newline through the source};Readonly::Scalar my$EXPL=>q{Change your newlines to be the same throughout};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Document'}sub violates {my ($self,undef,$doc)=@_;my$filename=$doc->filename();return if!$filename;my$fh;return if!open$fh,'<',$filename;local$RS=undef;my$source=<$fh>;close$fh or return;my$newline;my$line=1;my@v;while ($source =~ m/\G([^\012\015]*)($LINE_END)/cgmxs){my$code=$1;my$nl=$2;my$col=length$code;$newline ||= $nl;if ($nl ne $newline){my$token=PPI::Token::Whitespace->new($nl);$token->{_location}=[$line,$col,$col,$line,$filename];push@v,$self->violation($DESC,$EXPL,$token)}$line++}return@v}1;
PERL_CRITIC_POLICY_CODELAYOUT_REQUIRECONSISTENTNEWLINES

$fatpacked{"Perl/Critic/Policy/CodeLayout/RequireTidyCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_REQUIRETIDYCODE';
  package Perl::Critic::Policy::CodeLayout::RequireTidyCode;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use IO::String qw<>;use Readonly;use Perl::Tidy qw<>;use Perl::Critic::Utils qw{:booleans :characters :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Code is not tidy};Readonly::Scalar my$EXPL=>[33 ];sub supported_parameters {return ({name=>'perltidyrc',description=>'The Perl::Tidy configuration file to use, if any.',default_string=>undef,},)}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Document'}sub initialize_if_enabled {my ($self,$config)=@_;if (defined$self->{_perltidyrc}&& $self->{_perltidyrc}eq $EMPTY){my$rc=$EMPTY;$self->{_perltidyrc}=\$rc}return$TRUE}sub violates {my ($self,$elem,$doc)=@_;my$source=$doc->serialize();$source =~ s{ \s+ \Z}{\n}xms;my$shebang_re=qr< [#]! [^\015\012]+ [\015\012]+ >xms;my$shell_re=qr<eval [ ] 'exec [ ] [^\015\012]* [ ] \$0 [ ] \$[{]1[+]"\$@"}'
                          [ \t]*[\012\015]+ [ \t]* if [^\015\012]+ [\015\012]+ >xms;$source =~ s/\A ($shebang_re) $shell_re /$1/xms;my$dest=$EMPTY;my$stderr=$EMPTY;local@ARGV=qw(-nst -nse -nb);my$eval_worked=eval {my$handle=IO::String->new($stderr);my$source_copy=$source;local*STDERR=\*STDERR;Perl::Tidy::perltidy(source=>\$source_copy,destination=>\$dest,stderr=>$handle,defined$self->{_perltidyrc}? (perltidyrc=>$self->{_perltidyrc}): (),);1};if ($stderr or not $eval_worked){return$self->violation('perltidy had errors!!',$EXPL,$elem)}if ($source ne $dest){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_CODELAYOUT_REQUIRETIDYCODE

$fatpacked{"Perl/Critic/Policy/CodeLayout/RequireTrailingCommas.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_REQUIRETRAILINGCOMMAS';
  package Perl::Critic::Policy::CodeLayout::RequireTrailingCommas;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{List declaration without trailing comma};Readonly::Scalar my$EXPL=>[17 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Structure::List'}sub violates {my ($self,$elem,undef)=@_;$elem =~ m{ \n }xms || return;my$sib=$elem->sprevious_sibling();return if!$sib;$sib->isa('PPI::Token::Operator')&& $sib =~ m{ = }xms || return;my$expr=$elem->schild(0);return if!$expr;my@children=$expr->schildren();return if 1 >= grep {$_->isa('PPI::Token::Operator')&& $_ eq $COMMA}@children;my$final=$children[-1];if (!($final->isa('PPI::Token::Operator')&& $final eq $COMMA)){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_CODELAYOUT_REQUIRETRAILINGCOMMAS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitCStyleForLoops.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITCSTYLEFORLOOPS';
  package Perl::Critic::Policy::ControlStructures::ProhibitCStyleForLoops;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{C-style "for" loop used};Readonly::Scalar my$EXPL=>[100 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Structure::For'}sub violates {my ($self,$elem,undef)=@_;if (_is_cstyle($elem)){return$self->violation($DESC,$EXPL,$elem)}return}sub _is_cstyle {my$elem=shift;my$nodes_ref=$elem->find('PPI::Token::Structure');return if!$nodes_ref;my@semis=grep {$_ eq $SCOLON}@{$nodes_ref};return scalar@semis==2}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITCSTYLEFORLOOPS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitCascadingIfElse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITCASCADINGIFELSE';
  package Perl::Critic::Policy::ControlStructures::ProhibitCascadingIfElse;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Cascading if-elsif chain};Readonly::Scalar my$EXPL=>[117,118 ];sub supported_parameters {return ({name=>'max_elsif',description=>'The maximum number of alternatives that will be allowed.',default_string=>'2',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance complexity)}sub applies_to {return 'PPI::Statement::Compound'}sub violates {my ($self,$elem,undef)=@_;return if ($elem->type()ne 'if');if (_count_elsifs($elem)> $self->{_max_elsif}){return$self->violation($DESC,$EXPL,$elem)}return}sub _count_elsifs {my$elem=shift;return grep {$_->isa('PPI::Token::Word')&& $_->content()eq 'elsif'}$elem->schildren()}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITCASCADINGIFELSE

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitDeepNests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITDEEPNESTS';
  package Perl::Critic::Policy::ControlStructures::ProhibitDeepNests;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Code structure is deeply nested};Readonly::Scalar my$EXPL=>q{Consider refactoring};sub supported_parameters {return ({name=>'max_nests',description=>'The maximum number of nested constructs to allow.',default_string=>'5',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance complexity)}sub applies_to {return 'PPI::Statement::Compound'}sub violates {my ($self,$elem,undef)=@_;my$nest_count=1;my$parent=$elem;while ($parent=$parent->parent()){if($parent->isa('PPI::Statement::Compound')){$nest_count++}}if ($nest_count > $self->{_max_nests}){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITDEEPNESTS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitLabelsWithSpecialBlockNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITLABELSWITHSPECIALBLOCKNAMES';
  package Perl::Critic::Policy::ControlStructures::ProhibitLabelsWithSpecialBlockNames;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities hashify};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Hash my%SPECIAL_BLOCK_NAMES=>hashify(qw<BEGIN END INIT CHECK UNITCHECK>);Readonly::Scalar my$DESC=>q<Special block name used as label.>;Readonly::Scalar my$EXPL=>q<Use a label that cannot be confused with BEGIN, END, CHECK, INIT, or UNITCHECK blocks.>;sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw<core bugs>}sub applies_to {return qw<PPI::Token::Label>}sub violates {my ($self,$elem,undef)=@_;my$label=$elem->content();$label =~ s/ \s* : \z //xms;return if not $SPECIAL_BLOCK_NAMES{$label };return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITLABELSWITHSPECIALBLOCKNAMES

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitMutatingListFunctions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITMUTATINGLISTFUNCTIONS';
  package Perl::Critic::Policy::ControlStructures::ProhibitMutatingListFunctions;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(none any);use Perl::Critic::Utils qw{:booleans :characters :severities :data_conversion :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Array my@BUILTIN_LIST_FUNCS=>qw(map grep);Readonly::Array my@CPAN_LIST_FUNCS=>_get_cpan_list_funcs();sub _get_cpan_list_funcs {return qw(List::Util::first),map {'List::MoreUtils::'.$_}_get_list_moreutils_funcs()}sub _get_list_moreutils_funcs {return qw(any all none notall true false firstidx first_index lastidx last_index insert_after insert_after_string)}sub _is_topic {my$elem=shift;return defined$elem && $elem->isa('PPI::Token::Magic')&& $elem->content()eq q{$_}}Readonly::Scalar my$DESC=>q{Don't modify $_ in list functions};Readonly::Scalar my$EXPL=>[114 ];sub supported_parameters {return ({name=>'list_funcs',description=>'The base set of functions to check.',default_string=>join ($SPACE,@BUILTIN_LIST_FUNCS,@CPAN_LIST_FUNCS),behavior=>'string list',},{name=>'add_list_funcs',description=>'The set of functions to check, in addition to those given in list_funcs.',default_string=>$EMPTY,behavior=>'string list',},)}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core bugs pbp certrule)}sub applies_to {return 'PPI::Token::Word'}sub initialize_if_enabled {my ($self,$config)=@_;$self->{_all_list_funcs}={hashify keys %{$self->{_list_funcs}},keys %{$self->{_add_list_funcs}}};return$TRUE}sub violates {my ($self,$elem,$doc)=@_;return if not $self->{_all_list_funcs}->{$elem};return if not is_function_call($elem);return if not my$first_arg=first_arg($elem);return if not $first_arg->isa('PPI::Structure::Block');return if not $self->_has_topic_side_effect($first_arg,$doc);return$self->violation($DESC,$EXPL,$elem)}sub _has_topic_side_effect {my ($self,$node,$doc)=@_;my$tokens=$node->find('PPI::Token')|| [];for my$elem (@{$tokens}){next if not $elem->significant();return 1 if _is_assignment_to_topic($elem);return 1 if$self->_is_topic_mutating_regex($elem,$doc);return 1 if _is_topic_mutating_func($elem);return 1 if _is_topic_mutating_substr($elem)}return}sub _is_assignment_to_topic {my$elem=shift;return if not _is_topic($elem);my$sib=$elem->snext_sibling();if ($sib && $sib->isa('PPI::Token::Operator')){return 1 if _is_assignment_operator($sib)}my$psib=$elem->sprevious_sibling();if ($psib && $psib->isa('PPI::Token::Operator')){return 1 if _is_increment_operator($psib)}return}sub _is_topic_mutating_regex {my ($self,$elem,$doc)=@_;return if!($elem->isa('PPI::Token::Regexp::Substitute')|| $elem->isa('PPI::Token::Regexp::Transliterate'));if ($elem->isa('PPI::Token::Regexp::Transliterate')){my$subs=$elem->get_substitute_string();my%mods=$elem->get_modifiers();$mods{r}and return;if ($EMPTY eq $subs){$mods{d}or $mods{s}or return}elsif ($elem->get_match_string()eq $subs){$mods{c}or $mods{s}or return}}if ($elem->isa('PPI::Token::Regexp::Substitute')){my$re=$doc->ppix_regexp_from_element($elem)or return;$re->modifier_asserted('r')and return}my$prevsib=$elem->sprevious_sibling;return 1 if not $prevsib;return 1 if not _is_binding_operator($prevsib);my$bound_to=$prevsib->sprevious_sibling;return _is_topic($bound_to)}sub _is_topic_mutating_func {my$elem=shift;return if not $elem->isa('PPI::Token::Word');my@mutator_funcs=qw(chop chomp undef);return if not any {$elem->content()eq $_}@mutator_funcs;return if not is_function_call($elem);my$first_arg=first_arg($elem);if (not defined$first_arg){return if$elem->content()eq 'undef';return 1}return _is_topic($first_arg)}Readonly::Scalar my$MUTATING_SUBSTR_ARG_COUNT=>4;sub _is_topic_mutating_substr {my$elem=shift;return if$elem->content()ne 'substr';return if not is_function_call($elem);my@args=parse_arg_list($elem);return@args >= $MUTATING_SUBSTR_ARG_COUNT && _is_topic($args[0]->[0])}{my%assignment_ops=hashify qw(= *= /= += -= %= **= x= .= &= |= ^= &&= ||= <<= >>= //= ++ --);sub _is_assignment_operator {return exists$assignment_ops{$_[0]}}my%increment_ops=hashify qw(++ --);sub _is_increment_operator {return exists$increment_ops{$_[0]}}my%binding_ops=hashify qw(=~ !~);sub _is_binding_operator {return exists$binding_ops{$_[0]}}}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITMUTATINGLISTFUNCTIONS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitNegativeExpressionsInUnlessAndUntilConditions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITNEGATIVEEXPRESSIONSINUNLESSANDUNTILCONDITIONS';
  package Perl::Critic::Policy::ControlStructures::ProhibitNegativeExpressionsInUnlessAndUntilConditions;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use Perl::Critic::Utils qw<:characters :severities :classification hashify>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>[99];sub supported_parameters {return qw<>}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance pbp)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$token,undef)=@_;return if$token->content()ne 'until' && $token->content()ne 'unless';return if is_hash_key($token);return if is_subroutine_name($token);return if is_method_call($token);return if is_included_module_name($token);return map {$self->_violation_for_operator($_,$token)}_get_negative_operators($token)}sub _get_negative_operators {my ($token)=@_;my@operators;for my$element (_get_condition_elements($token)){if ($element->isa('PPI::Node')){my$operators=$element->find(\&_is_negative_operator);if ($operators){push@operators,@{$operators}}}else {if (_is_negative_operator(undef,$element)){push@operators,$element}}}return@operators}sub _get_condition_elements {my ($token)=@_;my$statement=$token->statement();return if not $statement;if ($statement->isa('PPI::Statement::Compound')){my$condition=$token->snext_sibling();return if not $condition;return if not $condition->isa('PPI::Structure::Condition');return ($condition)}my@condition_elements;my$element=$token;while ($element=$element->snext_sibling()and $element->content()ne $SCOLON){push@condition_elements,$element}return@condition_elements}Readonly::Hash my%NEGATIVE_OPERATORS=>hashify(qw/! not !~ ne != < > <= >= <=> lt gt le ge cmp/);sub _is_negative_operator {my (undef,$element)=@_;return $element->isa('PPI::Token::Operator')&& $NEGATIVE_OPERATORS{$element}}sub _violation_for_operator {my ($self,$operator,$control_structure)=@_;return $self->violation(qq<Found "$operator" in condition for an "$control_structure">,$EXPL,$control_structure,)}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITNEGATIVEEXPRESSIONSINUNLESSANDUNTILCONDITIONS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitPostfixControls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITPOSTFIXCONTROLS';
  package Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities :data_conversion :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Hash my%PAGES_OF=>(if=>[93,94 ],unless=>[96,97 ],until=>[96,97 ],for=>[96 ],foreach=>[96 ],while=>[96 ],when=>q<Similar to "if", postfix "when" should only be used with flow-control>,);sub supported_parameters {return ({name=>'allow',description=>'The permitted postfix controls.',default_string=>$EMPTY,behavior=>'enumeration',enumeration_values=>[sort keys%PAGES_OF ],enumeration_allow_multiple_values=>1,},{name=>'flowcontrol',description=>'The exempt flow control functions.',default_string=>'carp cluck confess croak die exit goto warn',behavior=>'string list',},)}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;my$expl=$PAGES_OF{$elem};return if not $expl;return if is_hash_key($elem);return if is_method_call($elem);return if is_subroutine_name($elem);return if is_included_module_name($elem);return if is_package_declaration($elem);return if exists$self->{_allow}->{$elem->content()};my$stmnt=$elem->statement();return if not $stmnt;return if$stmnt->isa('PPI::Statement::Compound');return if$stmnt->isa('PPI::Statement::When');my$content=$elem->content();if ($content eq 'if' or $content eq 'when'){return if$stmnt->isa('PPI::Statement::Break');return if defined$self->{_flowcontrol}{$stmnt->schild(0)->content()}}my$desc=qq{Postfix control "$content" used};return$self->violation($desc,$expl,$elem)}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITPOSTFIXCONTROLS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitUnlessBlocks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNLESSBLOCKS';
  package Perl::Critic::Policy::ControlStructures::ProhibitUnlessBlocks;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"unless" block used};Readonly::Scalar my$EXPL=>[97 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Statement::Compound'}sub violates {my ($self,$elem,undef)=@_;if ($elem->first_element()eq 'unless'){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNLESSBLOCKS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitUnreachableCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNREACHABLECODE';
  package Perl::Critic::Policy::ControlStructures::ProhibitUnreachableCode;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :data_conversion :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Array my@TERMINALS=>qw(die exit croak confess);Readonly::Hash my%TERMINALS=>hashify(@TERMINALS);Readonly::Array my@CONDITIONALS=>qw(if unless foreach while until for);Readonly::Hash my%CONDITIONALS=>hashify(@CONDITIONALS);Readonly::Array my@OPERATORS=>qw(&& || // and or err ?);Readonly::Hash my%OPERATORS=>hashify(@OPERATORS);Readonly::Scalar my$DESC=>q{Unreachable code};Readonly::Scalar my$EXPL=>q{Consider removing it};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs certrec)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;my$statement=$elem->statement();return if not $statement;return if (!exists$TERMINALS{$elem})&& (!$statement->isa('PPI::Statement::Break'));return if not is_function_call($elem);for my$child ($statement->schildren()){return if$child->isa('PPI::Token::Operator')&& exists$OPERATORS{$child};return if$child->isa('PPI::Token::Word')&& exists$CONDITIONALS{$child}}return$self->_gather_violations($statement)}sub _gather_violations {my ($self,$statement)=@_;my@violations=();while ($statement=$statement->snext_sibling()){my@children=$statement->schildren();last if@children && $children[0]->isa('PPI::Token::Label');next if$statement->isa('PPI::Statement::Sub');next if$statement->isa('PPI::Statement::End');next if$statement->isa('PPI::Statement::Data');next if$statement->isa('PPI::Statement::Package');next if$statement->isa('PPI::Statement::Include')&& $statement->type()ne 'require';next if$statement->isa('PPI::Statement::Variable')&& $statement->type()eq 'our';push@violations,$self->violation($DESC,$EXPL,$statement)}return@violations}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNREACHABLECODE

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitUntilBlocks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNTILBLOCKS';
  package Perl::Critic::Policy::ControlStructures::ProhibitUntilBlocks;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"until" block used};Readonly::Scalar my$EXPL=>[97 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Statement'}sub violates {my ($self,$elem,undef)=@_;if ($elem->first_element()eq 'until'){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNTILBLOCKS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitYadaOperator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITYADAOPERATOR';
  package Perl::Critic::Policy::ControlStructures::ProhibitYadaOperator;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{yada operator (...) used};Readonly::Scalar my$EXPL=>q{The yada operator is a placeholder for code you have not yet written.};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Token::Operator'}sub violates {my ($self,$elem,undef)=@_;if (_is_yada($elem)){return$self->violation($DESC,$EXPL,$elem)}return}sub _is_yada {my ($elem)=@_;return if$elem ne '...';return if ($elem->snext_sibling and $elem->sprevious_sibling);return 1}1;
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITYADAOPERATOR

$fatpacked{"Perl/Critic/Policy/Documentation/PodSpelling.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_PODSPELLING';
  package Perl::Critic::Policy::Documentation::PodSpelling;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use File::Spec;use File::Temp;use IO::String qw<>;use List::MoreUtils qw(uniq);use Pod::Spell qw<>;use Text::ParseWords qw<>;use Perl::Critic::Utils qw{:characters :booleans :severities words_from_string};use Perl::Critic::Exception::Fatal::Generic qw{throw_generic};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$POD_RX=>qr{\A = (?: for|begin|end ) }xms;Readonly::Scalar my$DESC=>q{Check the spelling in your POD};Readonly::Scalar my$EXPL=>[148];sub supported_parameters {return ({name=>'spell_command',description=>'The command to invoke to check spelling.',default_string=>'aspell list',behavior=>'string',},{name=>'stop_words',description=>'The words to not consider as misspelled.',default_string=>$EMPTY,behavior=>'string list',},{name=>'stop_words_file',description=>'A file containing words to not consider as misspelled.',default_string=>$EMPTY,behavior=>'string',},)}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core cosmetic pbp)}sub applies_to {return 'PPI::Document'}my$got_sigpipe=0;sub got_sigpipe {return$got_sigpipe}sub initialize_if_enabled {my ($self,$config)=@_;eval {require File::Which;1}or return$FALSE;return$FALSE if not $self->_derive_spell_command_line();return$FALSE if not $self->_run_spell_command(<<'END_TEST_CODE');$self->_load_stop_words_file();return$TRUE}sub violates {my ($self,$elem,$doc)=@_;my$code=$doc->serialize();my$words=$self->_run_spell_command($code);return if not $words;return if not @{$words};return$self->violation("$DESC: @{$words}",$EXPL,$doc)}sub _derive_spell_command_line {my ($self)=@_;my@words=Text::ParseWords::shellwords($self->_get_spell_command());if (!@words){return}if (!File::Spec->file_name_is_absolute($words[0])){$words[0]=File::Which::which($words[0])}if (!$words[0]||!-x $words[0]){return}$self->_set_spell_command_line(\@words);return$self->_get_spell_command_line()}sub _get_spell_command {my ($self)=@_;return$self->{_spell_command}}sub _get_spell_command_line {my ($self)=@_;return$self->{_spell_command_line}}sub _set_spell_command_line {my ($self,$spell_command_line)=@_;$self->{_spell_command_line}=$spell_command_line;return}sub _get_stop_words {my ($self)=@_;return$self->{_stop_words}}sub _set_stop_words {my ($self,$stop_words)=@_;$self->{_stop_words}=$stop_words;return}sub _get_stop_words_file {my ($self)=@_;return$self->{_stop_words_file}}sub _run_spell_command {my ($self,$code)=@_;my$infh=IO::String->new($code);my$outfh=File::Temp->new();my$outfile=$outfh->filename();my@words;local$EVAL_ERROR=undef;eval {local%Pod::Wordlist::Wordlist=%{$self->_get_stop_words()};Pod::Spell->new()->parse_from_filehandle($infh,$outfh);close$outfh or throw_generic "Failed to close pod temp file: $OS_ERROR";return if not -s $outfile;local$SIG{PIPE}=sub {$got_sigpipe=1};my$command_line=join$SPACE,@{$self->_get_spell_command_line()};open my$aspell_out_fh,q{-|},"$command_line < $outfile" or throw_generic "Failed to open handle to spelling program: $OS_ERROR";@words=uniq(<$aspell_out_fh>);close$aspell_out_fh or throw_generic "Failed to close handle to spelling program: $OS_ERROR";for (@words){chomp}@words=grep {not exists$Pod::Wordlist::Wordlist{$_}}@words;1}or do {if ($EVAL_ERROR and not ref Perl::Critic::Exception::Fatal::Generic->caught()){ref$EVAL_ERROR ? $EVAL_ERROR->rethrow(): die$EVAL_ERROR}return};return [@words ]}sub _load_stop_words_file {my ($self)=@_;my%stop_words=%{$self->_get_stop_words()};my$file_name=$self->_get_stop_words_file()or return;open my$handle,'<',$file_name or do {warn qq<Could not open "$file_name": $OS_ERROR\n>;return};while (my$line=<$handle>){if (my$word=_word_from_line($line)){$stop_words{$word}=1}}close$handle or warn qq<Could not close "$file_name": $OS_ERROR\n>;$self->_set_stop_words(\%stop_words);return}sub _word_from_line {my ($line)=@_;$line =~ s< [#] .* \z ><>xms;$line =~ s< \s+ \z ><>xms;$line =~ s< \A \s+ ><>xms;return$line}1;
  =pod
  
  =head1 Test The Spell Command
  
  =cut
  END_TEST_CODE
PERL_CRITIC_POLICY_DOCUMENTATION_PODSPELLING

$fatpacked{"Perl/Critic/Policy/Documentation/RequirePackageMatchesPodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPACKAGEMATCHESPODNAME';
  package Perl::Critic::Policy::Documentation::RequirePackageMatchesPodName;use 5.006001;use strict;use warnings;use Readonly;use English qw{-no_match_vars};use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$PKG_RX=>qr{ [[:alpha:]](?:[\w:\']*\w)? }xms;Readonly::Scalar my$DESC=>q{Pod NAME on line %d does not match the package declaration};Readonly::Scalar my$EXPL=>q{};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core cosmetic)}sub applies_to {return 'PPI::Document'}sub prepare_to_scan_document {my ($self,$document)=@_;return$document->is_module()}sub violates {my ($self,$elem,$doc)=@_;my$pods_ref=$doc->find('PPI::Token::Pod');return if!$pods_ref;for my$pod (@{$pods_ref}){my$content=$pod->content;next if$content !~ m{^=head1 [ \t]+ NAME [ \t]*$ \s*}cgxms;my$line_number=$pod->line_number()+ (substr($content,0,$LAST_MATCH_START[0]+ 1)=~ tr/\n/\n/);my ($pod_pkg)=$content =~ m{\G (\S+) }cgxms;if (!$pod_pkg){return$self->violation(sprintf($DESC,$line_number),q{Empty name declaration},$pod)}$pod_pkg =~ s{\A [CL]<(.*)>\z}{$1}gxms;$pod_pkg =~ s{\'}{::}gxms;for my$stmt (@{$doc->find('PPI::Statement::Package')|| []}){my$pkg=$stmt->namespace();$pkg =~ s{\'}{::}gxms;return if$pkg eq $pod_pkg}return$self->violation(sprintf($DESC,$line_number),$EXPL,$pod)}return}1;
PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPACKAGEMATCHESPODNAME

$fatpacked{"Perl/Critic/Policy/Documentation/RequirePodAtEnd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODATEND';
  package Perl::Critic::Policy::Documentation::RequirePodAtEnd;use 5.006001;use strict;use warnings;use Readonly;use List::Util qw(first);use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$POD_RX=>qr{\A = (?: for|begin|end ) }xms;Readonly::Scalar my$DESC=>q{POD before __END__};Readonly::Scalar my$EXPL=>[139,140];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core cosmetic pbp)}sub applies_to {return 'PPI::Document'}sub violates {my ($self,$elem,$doc)=@_;my$pods_ref=$doc->find('PPI::Token::Pod');return if!$pods_ref;my$pod=first {$_ !~ $POD_RX}@{$pods_ref};return if!$pod;my$end=$doc->find_first('PPI::Statement::End');if ($end){my$pod_loc=$pod->location();my$end_loc=$end->location();if ($pod_loc->[0]> $end_loc->[0]){return}}return$self->violation($DESC,$EXPL,$pod)}1;
PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODATEND

$fatpacked{"Perl/Critic/Policy/Documentation/RequirePodLinksIncludeText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODLINKSINCLUDETEXT';
  package Perl::Critic::Policy::Documentation::RequirePodLinksIncludeText;use 5.006001;use strict;use warnings;use Readonly;use English qw{-no_match_vars};use Perl::Critic::Utils qw{:booleans :characters :severities};use base 'Perl::Critic::Policy';use Perl::Critic::Utils::POD::ParseInteriorSequence;our$VERSION='0.01';Readonly::Scalar my$EXPL=>'Without text, you are at the mercy of the POD translator';sub supported_parameters {return ({name=>'allow_external_sections',description=>'Allow external sections without text',default_string=>'1',behavior=>'boolean',},{name=>'allow_internal_sections',description=>'Allow internal sections without text',default_string=>'1',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Token::Pod'}Readonly::Scalar my$INCREMENT_NESTING=>1;Readonly::Scalar my$DECREMENT_NESTING=>-1;Readonly::Hash my%ESCAPE_NESTING=>('<'=>$INCREMENT_NESTING,'>'=>$DECREMENT_NESTING,);sub violates {my ($self,$elem,$doc)=@_;my@violations;my$parser=Perl::Critic::Utils::POD::ParseInteriorSequence->new();$parser->errorsub(sub {return 1});for my$seq ($parser->get_interior_sequences($elem->content())){$seq->nested()and next;'L' eq $seq->cmd_name()or next;$self->_allowed_link($seq)and next;my$line_number=$elem->line_number()+ ($seq->file_line())[1]- 1;push@violations,$self->violation(join($SPACE,'Link',$seq->raw_text(),"on line $line_number does not specify text"),$EXPL,$elem)}return@violations}sub _allowed_link {my ($self,$pod_seq)=@_;my$content=$pod_seq->raw_text();$content=substr$content,0,- length$pod_seq->right_delimiter();$content=substr$content,length($pod_seq->cmd_name())+ length($pod_seq->left_delimiter());$content =~ m{ \A \w+ : (?! : ) }smx and return$TRUE;$content =~ m/ [|] /smx and return$TRUE;$content =~ m{ \A [/"] }smx and return$self->{_allow_internal_sections};$content =~ m{ / }smx and return$self->{_allow_external_sections};return$FALSE}1;
PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODLINKSINCLUDETEXT

$fatpacked{"Perl/Critic/Policy/Documentation/RequirePodSections.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODSECTIONS';
  package Perl::Critic::Policy::Documentation::RequirePodSections;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :characters :severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>[133,138];Readonly::Scalar my$BOOK=>'book';Readonly::Scalar my$BOOK_FIRST_EDITION=>'book_first_edition';Readonly::Scalar my$MODULE_STARTER_PBP=>'module_starter_pbp';Readonly::Scalar my$M_S_PBP_0_0_3=>'module_starter_pbp_0_0_3';Readonly::Scalar my$DEFAULT_SOURCE=>$BOOK_FIRST_EDITION;Readonly::Hash my%SOURCE_TRANSLATION=>($BOOK=>$BOOK_FIRST_EDITION,$BOOK_FIRST_EDITION=>$BOOK_FIRST_EDITION,$MODULE_STARTER_PBP=>$M_S_PBP_0_0_3,$M_S_PBP_0_0_3=>$M_S_PBP_0_0_3,);Readonly::Scalar my$EN_AU=>'en_AU';Readonly::Scalar my$EN_US=>'en_US';Readonly::Scalar my$ORIGINAL_MODULE_VERSION=>'original';Readonly::Hash my%SOURCE_DEFAULT_LANGUAGE=>($BOOK_FIRST_EDITION=>$ORIGINAL_MODULE_VERSION,$M_S_PBP_0_0_3=>$EN_AU,);Readonly::Scalar my$BOOK_FIRST_EDITION_US_LIB_SECTIONS=>['NAME','VERSION','SYNOPSIS','DESCRIPTION','SUBROUTINES/METHODS','DIAGNOSTICS','CONFIGURATION AND ENVIRONMENT','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENSE AND COPYRIGHT',];Readonly::Hash my%DEFAULT_LIB_SECTIONS=>($BOOK_FIRST_EDITION=>{$ORIGINAL_MODULE_VERSION=>$BOOK_FIRST_EDITION_US_LIB_SECTIONS,$EN_AU=>['NAME','VERSION','SYNOPSIS','DESCRIPTION','SUBROUTINES/METHODS','DIAGNOSTICS','CONFIGURATION AND ENVIRONMENT','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENCE AND COPYRIGHT',],$EN_US=>$BOOK_FIRST_EDITION_US_LIB_SECTIONS,},$M_S_PBP_0_0_3=>{$EN_AU=>['NAME','VERSION','SYNOPSIS','DESCRIPTION','INTERFACE','DIAGNOSTICS','CONFIGURATION AND ENVIRONMENT','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENCE AND COPYRIGHT','DISCLAIMER OF WARRANTY',],$EN_US=>['NAME','VERSION','SYNOPSIS','DESCRIPTION','INTERFACE','DIAGNOSTICS','CONFIGURATION AND ENVIRONMENT','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENSE AND COPYRIGHT','DISCLAIMER OF WARRANTY' ],},);Readonly::Hash my%DEFAULT_SCRIPT_SECTIONS=>($BOOK_FIRST_EDITION=>{$ORIGINAL_MODULE_VERSION=>['NAME','USAGE','DESCRIPTION','REQUIRED ARGUMENTS','OPTIONS','DIAGNOSTICS','EXIT STATUS','CONFIGURATION','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENSE AND COPYRIGHT',],$EN_AU=>['NAME','VERSION','USAGE','REQUIRED ARGUMENTS','OPTIONS','DESCRIPTION','DIAGNOSTICS','CONFIGURATION AND ENVIRONMENT','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENCE AND COPYRIGHT',],$EN_US=>['NAME','VERSION','USAGE','REQUIRED ARGUMENTS','OPTIONS','DESCRIPTION','DIAGNOSTICS','CONFIGURATION AND ENVIRONMENT','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENSE AND COPYRIGHT',],},$M_S_PBP_0_0_3=>{$EN_AU=>['NAME','VERSION','USAGE','REQUIRED ARGUMENTS','OPTIONS','DESCRIPTION','DIAGNOSTICS','CONFIGURATION AND ENVIRONMENT','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENCE AND COPYRIGHT','DISCLAIMER OF WARRANTY',],$EN_US=>['NAME','VERSION','USAGE','REQUIRED ARGUMENTS','OPTIONS','DESCRIPTION','DIAGNOSTICS','CONFIGURATION AND ENVIRONMENT','DEPENDENCIES','INCOMPATIBILITIES','BUGS AND LIMITATIONS','AUTHOR','LICENSE AND COPYRIGHT','DISCLAIMER OF WARRANTY',],},);sub supported_parameters {return ({name=>'lib_sections',description=>'The sections to require for modules (separated by qr/\s* [|] \s*/xms).',default_string=>$EMPTY,parser=>\&_parse_lib_sections,},{name=>'script_sections',description=>'The sections to require for programs (separated by qr/\s* [|] \s*/xms).',default_string=>$EMPTY,parser=>\&_parse_script_sections,},{name=>'source',description=>'The origin of sections to use.',default_string=>$DEFAULT_SOURCE,behavior=>'enumeration',enumeration_values=>[keys%SOURCE_TRANSLATION ],},{name=>'language',description=>'The spelling of sections to use.',default_string=>$EMPTY,behavior=>'enumeration',enumeration_values=>[$EN_AU,$EN_US ],},)}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Document'}sub _parse_sections {my$config_string=shift;my@sections=split m{ \s* [|] \s* }xms,$config_string;return map {uc}@sections}sub _parse_lib_sections {my ($self,$parameter,$config_string)=@_;if (defined$config_string){$self->{_lib_sections}=[_parse_sections($config_string)]}return}sub _parse_script_sections {my ($self,$parameter,$config_string)=@_;if (defined$config_string){$self->{_script_sections}=[_parse_sections($config_string)]}return}sub initialize_if_enabled {my ($self,$config)=@_;my$source=$self->{_source};if (not defined$source or not defined$DEFAULT_LIB_SECTIONS{$source}){$source=$DEFAULT_SOURCE}my$language=$self->{_language};if (not defined$language or not defined$DEFAULT_LIB_SECTIONS{$source}{$language}){$language=$SOURCE_DEFAULT_LANGUAGE{$source}}if (not $self->_sections_specified('_lib_sections')){$self->{_lib_sections}=$DEFAULT_LIB_SECTIONS{$source}{$language}}if (not $self->_sections_specified('_script_sections')){$self->{_script_sections}=$DEFAULT_SCRIPT_SECTIONS{$source}{$language}}return$TRUE}sub _sections_specified {my ($self,$sections_key)=@_;my$sections=$self->{$sections_key};return 0 if not defined$sections;return scalar @{$sections}}sub violates {my ($self,$elem,$doc)=@_;return if!$doc->schild(0);my%found_sections=();my@violations=();my@required_sections=$doc->is_program()? @{$self->{_script_sections}}: @{$self->{_lib_sections}};my$pods_ref=$doc->find('PPI::Token::Pod');return if not $pods_ref;my$pod_of_record;for my$pod (@{$pods_ref}){for my$found ($pod =~ m{ ^ =head1 \s+ ( .+? ) \s* $ }gxms){$pod_of_record ||= $pod;$found_sections{uc$found }=1}}for my$required (@required_sections){if (not exists$found_sections{$required}){my$desc=qq{Missing "$required" section in POD};push@violations,$self->violation($desc,$EXPL,$pod_of_record || $pods_ref->[0])}}return@violations}1;
PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODSECTIONS

$fatpacked{"Perl/Critic/Policy/ErrorHandling/RequireCarping.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_ERRORHANDLING_REQUIRECARPING';
  package Perl::Critic::Policy::ErrorHandling::RequireCarping;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :characters :severities :classification :data_conversion};use Perl::Critic::Utils::PPI qw{is_ppi_expression_or_generic_statement};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>[283 ];sub supported_parameters {return ({name=>'allow_messages_ending_with_newlines',description=>q{Don't complain about die or warn if the message ends in a newline.},default_string=>'1',behavior=>'boolean',},{name=>'allow_in_main_unless_in_subroutine',description=>q{Don't complain about die or warn in main::, unless in a subroutine.},default_string=>'0',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;my$alternative;if ($elem eq 'warn'){$alternative='carp'}elsif ($elem eq 'die'){$alternative='croak'}else {return}return if!is_function_call($elem);if ($self->{_allow_messages_ending_with_newlines}){return if _last_flattened_argument_list_element_ends_in_newline($elem)}return if$self->{_allow_in_main_unless_in_subroutine}&&!$self->_is_element_contained_in_subroutine($elem)&& $self->_is_element_in_namespace_main($elem);my$desc=qq{"$elem" used instead of "$alternative"};return$self->violation($desc,$EXPL,$elem)}sub _last_flattened_argument_list_element_ends_in_newline {my$die_or_warn=shift;my$last_flattened_argument=_find_last_flattened_argument_list_element($die_or_warn)or return$FALSE;if ($last_flattened_argument->isa('PPI::Token::Quote')){my$last_flattened_argument_string=$last_flattened_argument->string();if ($last_flattened_argument_string =~ m{ \n \z }xms or (($last_flattened_argument->isa('PPI::Token::Quote::Double')or $last_flattened_argument->isa('PPI::Token::Quote::Interpolate'))and $last_flattened_argument_string =~ m{ [\\] n \z }xms)){return$TRUE}}elsif ($last_flattened_argument->isa('PPI::Token::HereDoc')){return$TRUE}return$FALSE}sub _find_last_flattened_argument_list_element {my$die_or_warn=shift;my$current_candidate=_find_last_element_in_subexpression($die_or_warn);while ($current_candidate and not _is_simple_list_element_token($current_candidate)and not _is_complex_expression_token($current_candidate)){if ($current_candidate->isa('PPI::Structure::List')){$current_candidate=_determine_if_list_is_a_plain_list_and_get_last_child($current_candidate,$die_or_warn)}elsif (not $current_candidate->isa('PPI::Token')){return}else {$current_candidate=$current_candidate->sprevious_sibling()}}return if not $current_candidate;return if _is_complex_expression_token($current_candidate);my$penultimate_element=$current_candidate->sprevious_sibling();if ($penultimate_element){if ($penultimate_element->isa('PPI::Token::Operator')){if ($penultimate_element ne $COMMA and $penultimate_element ne $PERIOD){return}}elsif ($penultimate_element!=$die_or_warn){return}}return$current_candidate}sub _find_last_element_in_subexpression {my$die_or_warn=shift;my$last_following_sibling;my$next_sibling=$die_or_warn;while ($next_sibling=$next_sibling->snext_sibling()and not _is_postfix_operator($next_sibling)){$last_following_sibling=$next_sibling}return$last_following_sibling}sub _determine_if_list_is_a_plain_list_and_get_last_child {my ($list,$die_or_warn)=@_;my$prior_sibling=$list->sprevious_sibling();if ($prior_sibling){if ($prior_sibling->isa('PPI::Token::Operator')){if ($prior_sibling ne $COMMA){return}}elsif ($prior_sibling!=$die_or_warn){return}}my@list_children=$list->schildren();return if scalar (@list_children)!=1;my$list_child=$list_children[0];return if not is_ppi_expression_or_generic_statement($list_child);my@statement_children=$list_child->schildren();return if scalar (@statement_children)< 1;return$statement_children[-1]}Readonly::Hash my%POSTFIX_OPERATORS=>hashify qw{if unless while until for foreach};sub _is_postfix_operator {my$element=shift;if ($element->isa('PPI::Token::Word')and $POSTFIX_OPERATORS{$element}){return$TRUE}return$FALSE}Readonly::Array my@SIMPLE_LIST_ELEMENT_TOKEN_CLASSES=>qw{PPI::Token::Number PPI::Token::Word PPI::Token::DashedWord PPI::Token::Symbol PPI::Token::Quote PPI::Token::HereDoc};sub _is_simple_list_element_token {my$element=shift;return$FALSE if not $element->isa('PPI::Token');for my$class (@SIMPLE_LIST_ELEMENT_TOKEN_CLASSES){return$TRUE if$element->isa($class)}return$FALSE}Readonly::Array my@COMPLEX_EXPRESSION_TOKEN_CLASSES=>qw{PPI::Token::ArrayIndex PPI::Token::QuoteLike PPI::Token::Regexp PPI::Token::Cast PPI::Token::Label PPI::Token::Separator PPI::Token::Data PPI::Token::End PPI::Token::Prototype PPI::Token::Attribute PPI::Token::Unknown};sub _is_complex_expression_token {my$element=shift;return$FALSE if not $element->isa('PPI::Token');for my$class (@COMPLEX_EXPRESSION_TOKEN_CLASSES){return$TRUE if$element->isa($class)}return$FALSE}sub _is_element_contained_in_subroutine {my ($self,$elem)=@_;my$parent=$elem;while ($parent=$parent->parent()){$parent->isa('PPI::Statement::Sub')and return$TRUE;$parent->isa('PPI::Structure::Block')or next;my$prior_elem=$parent->sprevious_sibling()or next;$prior_elem->isa('PPI::Token::Word')and 'sub' eq $prior_elem->content()and return$TRUE}return$FALSE}sub _is_element_in_namespace_main {my ($self,$elem)=@_;my$current_elem=$elem;my$prior_elem;while ($current_elem){while ($prior_elem=$current_elem->sprevious_sibling()){if ($prior_elem->isa('PPI::Statement::Package')){return 'main' eq $prior_elem->namespace()}}continue {$current_elem=$prior_elem}$current_elem=$current_elem->parent()}return$TRUE}1;
PERL_CRITIC_POLICY_ERRORHANDLING_REQUIRECARPING

$fatpacked{"Perl/Critic/Policy/ErrorHandling/RequireCheckingReturnValueOfEval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_ERRORHANDLING_REQUIRECHECKINGRETURNVALUEOFEVAL';
  package Perl::Critic::Policy::ErrorHandling::RequireCheckingReturnValueOfEval;use 5.006001;use strict;use warnings;use Readonly;use Scalar::Util qw<refaddr>;use Perl::Critic::Utils qw<:booleans :characters :severities hashify precedence_of>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>'Return value of eval not tested.';Readonly::Scalar my$EXPL=>q<You can't depend upon the value of $@/$EVAL_ERROR to tell whether an eval failed.>;Readonly::Hash my%BOOLEAN_OPERATORS=>hashify qw<|| && // or and>;Readonly::Hash my%POSTFIX_OPERATORS=>hashify qw<for foreach if unless while until>;Readonly::Scalar my$PRECEDENCE_OF_EQUALS=>precedence_of(q{=});sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'eval';my$evaluated=$elem->snext_sibling()or return;my$following=$evaluated->snext_sibling();return if _is_in_right_hand_side_of_assignment($elem);return if _is_in_postfix_expression($elem);return if _is_in_correct_position_in_a_condition_or_foreach_loop_collection($elem,$following,);return if _scan_backwards_for_grep($elem);if ($following and $following->isa('PPI::Token::Operator')){return if$BOOLEAN_OPERATORS{$following->content()};return if q{?} eq $following->content}return$self->violation($DESC,$EXPL,$elem)}sub _is_in_right_hand_side_of_assignment {my ($elem)=@_;my$previous=$elem->sprevious_sibling();if (not $previous){$previous=_grandparent_for_is_in_right_hand_side_of_assignment($elem)}while ($previous){my$base_previous=$previous;EQUALS_SCAN: while ($previous){if ($previous->isa('PPI::Token::Operator')){return$TRUE if$previous->content()=~ m/= \Z/xms;last EQUALS_SCAN if _is_effectively_a_comma($previous)}$previous=$previous->sprevious_sibling()}$previous=_grandparent_for_is_in_right_hand_side_of_assignment($base_previous)}return}sub _grandparent_for_is_in_right_hand_side_of_assignment {my ($elem)=@_;my$parent=$elem->parent()or return;$parent->isa('PPI::Statement')or return;my$grandparent=$parent->parent()or return;if ($grandparent->isa('PPI::Structure::Constructor')or $grandparent->isa('PPI::Structure::List')){return$grandparent}return}Readonly::Scalar my$CONDITION_POSITION_IN_C_STYLE_FOR_LOOP=>1;sub _is_in_correct_position_in_a_condition_or_foreach_loop_collection {my ($elem,$following)=@_;my$parent=$elem->parent();while ($parent){if ($parent->isa('PPI::Structure::Condition')){return _is_in_correct_position_in_a_structure_condition($elem,$parent,$following,)}if ($parent->isa('PPI::Structure::List')and my$parent_statement=$parent->statement()){return$TRUE if $parent_statement->isa('PPI::Statement::Compound')and $parent_statement->type()eq 'foreach'}if ($parent->isa('PPI::Structure::For')){my@for_loop_components=$parent->schildren();my$condition=$for_loop_components[$CONDITION_POSITION_IN_C_STYLE_FOR_LOOP]or return;return _descendant_of($elem,$condition)}$parent=$parent->parent()}return}sub _is_in_correct_position_in_a_structure_condition {my ($elem,$parent,$following)=@_;my$level=$elem;while ($level and refaddr$level!=$parent){my$cursor=refaddr$elem==refaddr$level ? $following : $level;IS_FINAL_EXPRESSION_AT_DEPTH: while ($cursor){if (_is_effectively_a_comma($cursor)){$cursor=$cursor->snext_sibling();while (_is_effectively_a_comma($cursor)){$cursor=$cursor->snext_sibling()}return if$cursor;last IS_FINAL_EXPRESSION_AT_DEPTH}$cursor=$cursor->snext_sibling()}my$statement=$level->parent();return$TRUE if not $statement;return$TRUE if not $statement->isa('PPI::Statement');$level=$statement->parent();if (not $level or (not $level->isa('PPI::Structure::List')and not $level->isa('PPI::Structure::Condition'))){return$TRUE}}return$TRUE}sub _descendant_of {my ($cursor,$potential_ancestor)=@_;return$EMPTY if not $potential_ancestor;while (refaddr$cursor!=refaddr$potential_ancestor){$cursor=$cursor->parent()or return$EMPTY}return 1}sub _is_in_postfix_expression {my ($elem)=@_;my$current_base=$elem;while ($TRUE){my$previous=$current_base->sprevious_sibling();while ($previous){if ($previous->isa('PPI::Token::Word')and $POSTFIX_OPERATORS{$previous->content()}){return$TRUE}$previous=$previous->sprevious_sibling()}my$parent=$current_base->parent()or return;if ($parent->isa('PPI::Statement')){return if$parent->specialized();my$grandparent=$parent->parent()or return;return if not $grandparent->isa('PPI::Structure::List');$current_base=$grandparent}else {$current_base=$parent}return if not $current_base->isa('PPI::Structure::List')}return}sub _scan_backwards_for_grep {my ($elem)=@_;while ($elem){my$parent=$elem->parent();while ($elem=$elem->sprevious_sibling()){$elem->isa('PPI::Token::Word')and 'grep' eq $elem->content()and return$TRUE;$elem->isa('PPI::Token::Operator')and precedence_of($elem)>= $PRECEDENCE_OF_EQUALS and return$FALSE}$elem=$parent}return$FALSE}sub _is_effectively_a_comma {my ($elem)=@_;return if not $elem;return $elem->isa('PPI::Token::Operator')&& ($elem->content()eq $COMMA || $elem->content()eq $FATCOMMA)}1;
PERL_CRITIC_POLICY_ERRORHANDLING_REQUIRECHECKINGRETURNVALUEOFEVAL

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitBacktickOperators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITBACKTICKOPERATORS';
  package Perl::Critic::Policy::InputOutput::ProhibitBacktickOperators;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities is_in_void_context};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Use IPC::Open3 instead};Readonly::Scalar my$DESC=>q{Backtick operator used};Readonly::Scalar my$VOID_EXPL=>q{Assign result to a variable or use system() instead};Readonly::Scalar my$VOID_DESC=>q{Backtick operator used in void context};sub supported_parameters {return ({name=>'only_in_void_context',description=>'Allow backticks everywhere except in void contexts.',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance)}sub applies_to {return qw(PPI::Token::QuoteLike::Backtick PPI::Token::QuoteLike::Command)}sub violates {my ($self,$elem,undef)=@_;if ($self->{_only_in_void_context}){return if not is_in_void_context($elem);return$self->violation($VOID_DESC,$VOID_EXPL,$elem)}return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITBACKTICKOPERATORS

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitBarewordFileHandles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITBAREWORDFILEHANDLES';
  package Perl::Critic::Policy::InputOutput::ProhibitBarewordFileHandles;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Bareword file handle opened};Readonly::Scalar my$EXPL=>[202,204 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs certrec)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'open';return if!is_function_call($elem);my$first_arg=(parse_arg_list($elem))[0];return if!$first_arg;my$first_token=$first_arg->[0];return if!$first_token;if ($first_token->isa('PPI::Token::Word')){if (($first_token ne 'my')&& ($first_token !~ m/^STD(?:IN|OUT|ERR)$/xms)){return$self->violation($DESC,$EXPL,$elem)}}return}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITBAREWORDFILEHANDLES

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitExplicitStdin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITEXPLICITSTDIN';
  package Perl::Critic::Policy::InputOutput::ProhibitExplicitStdin;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(any);use Perl::Critic::Utils qw{:severities :classification &parse_arg_list};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Use "<>" or "<ARGV>" or a prompting module instead of "<STDIN>"};Readonly::Scalar my$EXPL=>[216,220,221];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Token::QuoteLike::Readline'}sub violates {my ($self,$elem,undef)=@_;return if$elem ne '<STDIN>';return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITEXPLICITSTDIN

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitInteractiveTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITINTERACTIVETEST';
  package Perl::Critic::Policy::InputOutput::ProhibitInteractiveTest;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Use IO::Interactive::is_interactive() instead of -t};Readonly::Scalar my$EXPL=>[218 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs certrule)}sub applies_to {return 'PPI::Token::Operator'}sub violates {my ($self,$elem,$doc)=@_;return if$elem->content()ne '-t';return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITINTERACTIVETEST

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitJoinedReadline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITJOINEDREADLINE';
  package Perl::Critic::Policy::InputOutput::ProhibitJoinedReadline;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(any);use Perl::Critic::Utils qw{:severities :classification parse_arg_list};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Use "local $/ = undef" or Path::Tiny instead of joined readline};Readonly::Scalar my$EXPL=>[213];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp performance)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'join';return if!is_function_call($elem);my@args=parse_arg_list($elem);shift@args;if (any {any {$_->isa('PPI::Token::QuoteLike::Readline')}@{$_}}@args){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITJOINEDREADLINE

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitOneArgSelect.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITONEARGSELECT';
  package Perl::Critic::Policy::InputOutput::ProhibitOneArgSelect;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{One-argument "select" used};Readonly::Scalar my$EXPL=>[224 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'select';return if!is_function_call($elem);my@arguments=parse_arg_list($elem);if(1==@arguments){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITONEARGSELECT

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitReadlineInForLoop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITREADLINEINFORLOOP';
  package Perl::Critic::Policy::InputOutput::ProhibitReadlineInForLoop;use 5.006001;use strict;use warnings;use Readonly;use List::Util qw<first>;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Readline inside "for" loop};Readonly::Scalar my$EXPL=>[211 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw<core bugs pbp>}sub applies_to {return qw<PPI::Statement::Compound>}sub violates {my ($self,$elem,undef)=@_;return if$elem->type()ne 'foreach';my$list=first {$_->isa('PPI::Structure::List')}$elem->schildren()or return;if (my$readline=$list->find_first('PPI::Token::QuoteLike::Readline')){return$self->violation($DESC,$EXPL,$readline)}return}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITREADLINEINFORLOOP

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitTwoArgOpen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITTWOARGOPEN';
  package Perl::Critic::Policy::InputOutput::ProhibitTwoArgOpen;use 5.006001;use strict;use warnings;use Readonly;use version;use Perl::Critic::Utils qw{:severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$STDIO_HANDLES_RX=>qr/\b STD (?: IN | OUT | ERR \b)/xms;Readonly::Scalar my$FORK_HANDLES_RX=>qr/\A (?: -[|] | [|]- ) \z/xms;Readonly::Scalar my$DESC=>q{Two-argument "open" used};Readonly::Scalar my$EXPL=>[207 ];Readonly::Scalar my$MINIMUM_VERSION=>version->new(5.006);sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs security certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,$document)=@_;return if$elem->content()ne 'open';return if!is_function_call($elem);my$version=$document->highest_explicit_perl_version();return if$version and $version < $MINIMUM_VERSION;my@args=parse_arg_list($elem);if (scalar@args==2){return if$args[1]->[0]=~ $STDIO_HANDLES_RX;return if$args[1]->[0]->isa('PPI::Token::Quote')&& $args[1]->[0]->string()=~ $FORK_HANDLES_RX;return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITTWOARGOPEN

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireBracedFileHandleWithPrint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREBRACEDFILEHANDLEWITHPRINT';
  package Perl::Critic::Policy::InputOutput::RequireBracedFileHandleWithPrint;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Array my@POSTFIX_WORDS=>qw(if unless for);Readonly::Hash my%POSTFIX_WORDS=>hashify(@POSTFIX_WORDS);Readonly::Scalar my$PRINT_RX=>qr/ \A (?: print f? | say ) \z /xms;Readonly::Scalar my$DESC=>q{File handle for "print" or "printf" is not braced};Readonly::Scalar my$EXPL=>[217 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem !~ $PRINT_RX;return if!is_function_call($elem);my@sib;$sib[0]=$elem->snext_sibling();return if!$sib[0];if ($sib[0]->isa('PPI::Structure::List')){my$expr=$sib[0]->schild(0);return if!$expr;$sib[0]=$expr->schild(0);return if!$sib[0]}$sib[1]=$sib[0]->next_sibling();return if!$sib[1];$sib[2]=$sib[1]->next_sibling();return if!$sib[2];return if!(($sib[0]->isa('PPI::Token::Symbol')&& $sib[0]=~ m/\A \$/xms)|| $sib[0]->isa('PPI::Token::Word'));return if is_perl_builtin($sib[0]);return if exists$POSTFIX_WORDS{$sib[0]};return if!$sib[1]->isa('PPI::Token::Whitespace');return if$sib[2]->isa('PPI::Token::Operator');return if exists$POSTFIX_WORDS{$sib[2]};return if$sib[0]->isa('PPI::Structure::Block');return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREBRACEDFILEHANDLEWITHPRINT

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireBriefOpen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREBRIEFOPEN';
  package Perl::Critic::Policy::InputOutput::RequireBriefOpen;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(any);use Perl::Critic::Utils qw{:severities :classification :booleans hashify parse_arg_list};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q<Close filehandles as soon as possible after opening them..>;Readonly::Scalar my$EXPL=>[209];Readonly::Scalar my$SCALAR_SIGIL=>q<$>;Readonly::Scalar my$GLOB_SIGIL=>q<*>;Readonly::Hash my%CLOSE_BUILTIN=>hashify(qw{close CORE::close CORE::GLOBAL::close return});Readonly::Hash my%OPEN_BUILTIN=>hashify(qw{open CORE::open CORE::GLOBAL::open});Readonly::Scalar my$NOT_LEXICAL=>0;Readonly::Scalar my$LOCAL_LEXICAL=>1;Readonly::Scalar my$NON_LOCAL_LEXICAL=>2;Readonly::Scalar my$LAST_ELEMENT=>-1;sub supported_parameters {return ({name=>'lines',description=>'The maximum number of lines between an open() and a close().',default_string=>'9',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw<core pbp maintenance>}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;$OPEN_BUILTIN{$elem->content()}or return;return if!is_function_call($elem);my@open_args=parse_arg_list($elem);return if 2 > @open_args;my ($is_lexical,$fh)=_get_opened_fh($open_args[0]);return if not $fh;return if$fh =~ m< \A [*]? STD (?: IN|OUT|ERR ) \z >xms;for my$close_token ($self->_find_close_invocations_or_return($elem,$is_lexical)){if (is_function_call($close_token)){my@close_args=parse_arg_list($close_token);my$close_parameter=$close_args[0];if ('ARRAY' eq ref$close_parameter){$close_parameter=${$close_parameter}[0]}if ($close_parameter){$close_parameter="$close_parameter";return if$fh eq $close_parameter;if (any {m< \A [*] >xms}($fh,$close_parameter)){(my$stripped_fh=$fh)=~ s< \A [*] ><>xms;(my$stripped_parameter=$close_parameter)=~ s< \A [*] ><>xms;return if$stripped_fh eq $stripped_parameter}}}elsif ($is_lexical && is_method_call($close_token)){my$tok=$close_token->sprevious_sibling->sprevious_sibling;return if$fh eq $tok}}return$self->violation($DESC,$EXPL,$elem)}sub _find_close_invocations_or_return {my ($self,$elem,$is_lexical)=@_;my$parent=$self->_get_scope($elem,$is_lexical);return if!$parent;my$open_loc=$elem->location;my$end_line=$self->{_lines}? $open_loc->[0]+ $self->{_lines}: undef;my$closes=$parent->find(sub {my ($parent,$candidate)=@_;return undef if$candidate->isa('PPI::Statement::Sub');my$candidate_loc=$candidate->location;return undef if!defined$candidate_loc->[0];return 0 if$candidate_loc->[0]< $open_loc->[0];return 0 if$candidate_loc->[0]==$open_loc->[0]&& $candidate_loc->[1]<= $open_loc->[1];return undef if defined$end_line && $candidate_loc->[0]> $end_line;return 0 if!$candidate->isa('PPI::Token::Word');return$CLOSE_BUILTIN{$candidate->content()}|| 0});return @{$closes || []}}sub _get_scope {my ($self,$elem,$is_lexical)=@_;my$open_loc=$elem->location;my$end_line=($self->{_lines}&& defined$open_loc->[0])? $open_loc->[0]+ $self->{_lines}: undef;while (my$dad=$elem->parent){$elem=$dad;next if not $elem->scope;return$elem if$LOCAL_LEXICAL==$is_lexical;next if not defined$end_line;return$elem if not $open_loc;my$elem_loc=$elem->location or return$elem;my$last_kid=$elem->child($LAST_ELEMENT)or return$elem;my$last_kid_loc=$last_kid->location or return$elem;return$elem if$last_kid_loc->[0]> $end_line}return$elem}sub _get_opened_fh {my ($tokens)=shift;my$is_lexical;my$fh;if (2==@{$tokens}){if ('my' eq $tokens->[0]&& $tokens->[1]->isa('PPI::Token::Symbol')&& $SCALAR_SIGIL eq $tokens->[1]->raw_type){$is_lexical=$LOCAL_LEXICAL;$fh=$tokens->[1]}}elsif (1==@{$tokens}){my$argument=_unwrap_block($tokens->[0]);if ($argument->isa('PPI::Token::Symbol')){my$sigil=$argument->raw_type();if ($SCALAR_SIGIL eq $sigil){$is_lexical=$NON_LOCAL_LEXICAL;$fh=$argument}elsif ($GLOB_SIGIL eq $sigil){$is_lexical=$NOT_LEXICAL;$fh=$argument}}elsif ($argument->isa('PPI::Token::Word')&& $argument eq uc$argument){$is_lexical=$NOT_LEXICAL;$fh=$argument}}return ($is_lexical,$fh)}sub _unwrap_block {my ($element)=@_;return$element if not $element->isa('PPI::Structure::Block');my@children=$element->schildren();return$element if 1!=@children;my$child=$children[0];return$child if not $child->isa('PPI::Statement');my@grandchildren=$child->schildren();return$element if 1!=@grandchildren;return$grandchildren[0]}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREBRIEFOPEN

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireCheckedClose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDCLOSE';
  package Perl::Critic::Policy::InputOutput::RequireCheckedClose;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Return value of "close" ignored};Readonly::Scalar my$EXPL=>q{Check the return value of "close" for success};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core maintenance certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'close';return if!is_unchecked_call($elem);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDCLOSE

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireCheckedOpen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDOPEN';
  package Perl::Critic::Policy::InputOutput::RequireCheckedOpen;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Return value of "open" ignored};Readonly::Scalar my$EXPL=>q{Check the return value of "open" for success};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'open';return if!is_unchecked_call($elem);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDOPEN

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireCheckedSyscalls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDSYSCALLS';
  package Perl::Critic::Policy::InputOutput::RequireCheckedSyscalls;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :characters :severities :classification hashify is_perl_bareword};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Return value of flagged function ignored};Readonly::Scalar my$EXPL=>[208,278];Readonly::Array my@DEFAULT_FUNCTIONS=>qw(open close print say);Readonly::Array my@BUILTIN_FUNCTIONS=>qw(accept bind binmode chdir chmod chown close closedir connect dbmclose dbmopen exec fcntl flock fork ioctl kill link listen mkdir msgctl msgget msgrcv msgsnd open opendir pipe print read readdir readline readlink readpipe recv rename rmdir say seek seekdir semctl semget semop send setpgrp setpriority setsockopt shmctl shmget shmread shutdown sleep socket socketpair symlink syscall sysopen sysread sysseek system syswrite tell telldir truncate umask unlink utime wait waitpid);sub supported_parameters {return ({name=>'functions',description=>'The set of functions to require checking the return value of.',default_string=>join($SPACE,@DEFAULT_FUNCTIONS),behavior=>'string list',},{name=>'exclude_functions',description=>'The set of functions to not require checking the return value of.',default_string=>$EMPTY,behavior=>'string list',},)}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core maintenance certrule)}sub applies_to {return 'PPI::Token::Word'}sub initialize_if_enabled {my ($self,$config)=@_;my@specified_functions=keys %{$self->{_functions}};my@resulting_functions;for my$function (@specified_functions){if ($function eq ':defaults'){push@resulting_functions,@DEFAULT_FUNCTIONS}elsif ($function eq ':builtins'){push@resulting_functions,@BUILTIN_FUNCTIONS}else {push@resulting_functions,$function}}my%functions=hashify(@resulting_functions);for my$function (keys %{$self->{_exclude_functions}}){delete$functions{$function}}$self->{_functions}=\%functions;return$TRUE}sub violates {my ($self,$elem,undef)=@_;if ($self->{_functions}->{':all'}){return if is_perl_bareword($elem);return if$self->{_exclude_functions}->{$elem->content()}}elsif (not $self->{_functions}->{$elem->content()}){return}return if not is_unchecked_call($elem);return$self->violation("$DESC - " .$elem->content(),$EXPL,$elem)}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDSYSCALLS

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireEncodingWithUTF8Layer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREENCODINGWITHUTF8LAYER';
  package Perl::Critic::Policy::InputOutput::RequireEncodingWithUTF8Layer;use 5.006001;use strict;use warnings;use Readonly;use version;use Perl::Critic::Utils qw{:severities :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{I/O layer ":utf8" used};Readonly::Scalar my$EXPL=>q{Use ":encoding(UTF-8)" to get strict validation};Readonly::Scalar my$THREE_ARGUMENT_OPEN=>3;Readonly::Hash my%RECOVER_ENCODING=>(binmode=>\&_recover_binmode_encoding,open=>\&_recover_open_encoding,);sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core bugs security)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,$document)=@_;my$handler=$RECOVER_ENCODING{$elem->content()}or return;my$encoding=$handler->(parse_arg_list($elem))or return;return if$encoding !~ m/ (?: \A | : ) utf8 \b /smxi;return$self->violation($DESC,$EXPL,$elem)}sub _get_argument_string {my ($arg)=@_;ref$arg eq 'ARRAY' or return;return if @{$arg}==0 || @{$arg}> 1;return$arg->[0]->string()if$arg->[0]->isa('PPI::Token::Quote');return}sub _recover_binmode_encoding {my (@args)=@_;return _get_argument_string($args[1])}sub _recover_open_encoding {my (@args)=@_;@args < $THREE_ARGUMENT_OPEN and return;defined(my$string=_get_argument_string($args[1]))or return;$string =~ s/ [+]? (?: < | >{1,2} ) //smx;return$string}1;
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREENCODINGWITHUTF8LAYER

$fatpacked{"Perl/Critic/Policy/Miscellanea/ProhibitFormats.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITFORMATS';
  package Perl::Critic::Policy::Miscellanea::ProhibitFormats;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Format used};Readonly::Scalar my$EXPL=>[449 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance pbp certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'format';return if!is_function_call($elem);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITFORMATS

$fatpacked{"Perl/Critic/Policy/Miscellanea/ProhibitTies.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITTIES';
  package Perl::Critic::Policy::Miscellanea::ProhibitTies;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Tied variable used};Readonly::Scalar my$EXPL=>[451 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'tie';return if!is_function_call($elem);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITTIES

$fatpacked{"Perl/Critic/Policy/Miscellanea/ProhibitUnrestrictedNoCritic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITUNRESTRICTEDNOCRITIC';
  package Perl::Critic::Policy::Miscellanea::ProhibitUnrestrictedNoCritic;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw<:severities :booleans>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Unrestricted '## no critic' annotation};Readonly::Scalar my$EXPL=>q{Only disable the Policies you really need to disable};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Document'}sub violates {my ($self,$doc,undef)=@_;return if not $doc->isa('Perl::Critic::Document');my@violations=();for my$annotation ($doc->annotations()){if ($annotation->disables_all_policies()){my$elem=$annotation->element();push@violations,$self->violation($DESC,$EXPL,$elem)}}return@violations}1;
PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITUNRESTRICTEDNOCRITIC

$fatpacked{"Perl/Critic/Policy/Miscellanea/ProhibitUselessNoCritic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITUSELESSNOCRITIC';
  package Perl::Critic::Policy::Miscellanea::ProhibitUselessNoCritic;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw<none>;use Perl::Critic::Utils qw{:severities :classification hashify};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Useless '## no critic' annotation};Readonly::Scalar my$EXPL=>q{This annotation can be removed};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Document'}sub violates {my ($self,undef,$doc)=@_;return if not $doc->isa('Perl::Critic::Document');my@violations=();my@suppressed_viols=$doc->suppressed_violations();for my$ann ($doc->annotations()){if (none {_annotation_suppresses_violation($ann,$_)}@suppressed_viols){push@violations,$self->violation($DESC,$EXPL,$ann->element())}}return@violations}sub _annotation_suppresses_violation {my ($annotation,$violation)=@_;my$policy_name=$violation->policy();my$line=$violation->location()->[0];return$annotation->disables_line($line)&& $annotation->disables_policy($policy_name)}1;
PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITUSELESSNOCRITIC

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitAutomaticExportation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITAUTOMATICEXPORTATION';
  package Perl::Critic::Policy::Modules::ProhibitAutomaticExportation;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use List::MoreUtils qw(any);use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Symbols are exported by default};Readonly::Scalar my$EXPL=>q{Use '@EXPORT_OK' or '%EXPORT_TAGS' instead};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Document'}sub violates {my ($self,$elem,$doc)=@_;if (_uses_exporter($doc)){if (my$exp=_has_exports($doc)){return$self->violation($DESC,$EXPL,$exp)}}return}sub _uses_exporter {my ($doc)=@_;my$includes_ref=$doc->find('PPI::Statement::Include');return if not $includes_ref;return scalar grep {m/ \b Exporter \b/xms}@{$includes_ref}}sub _has_exports {my ($doc)=@_;my$wanted=sub {_our_export(@_)or _vars_export(@_)or _package_export(@_)};return$doc->find_first($wanted)}sub _our_export {my (undef,$elem)=@_;$elem->isa('PPI::Statement::Variable')or return 0;$elem->type()eq 'our' or return 0;return any {$_ eq '@EXPORT'}$elem->variables()}sub _vars_export {my (undef,$elem)=@_;$elem->isa('PPI::Statement::Include')or return 0;$elem->pragma()eq 'vars' or return 0;return$elem =~ m{ \@EXPORT \b }xms}sub _package_export {my (undef,$elem)=@_;$elem->isa('PPI::Token::Symbol')or return 0;return$elem =~ m{ \A \@ \S+ ::EXPORT \z }xms}1;
PERL_CRITIC_POLICY_MODULES_PROHIBITAUTOMATICEXPORTATION

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitConditionalUseStatements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITCONDITIONALUSESTATEMENTS';
  package Perl::Critic::Policy::Modules::ProhibitConditionalUseStatements;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Conditional "use" statement};Readonly::Scalar my$EXPL=>q{Use "require" to conditionally include a module.};Readonly::Hash my%OPS=>map {$_=>1}qw(|| && or and);sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Statement::Include'}sub violates {my ($self,$elem,$doc)=@_;return$self->violation($DESC,$EXPL,$elem)if$elem->type()eq 'use' &&!$elem->pragma()&& $elem->module()&& $self->_is_in_conditional_logic($elem);return}sub _is_eval {my ($self,$elem)=@_;$elem->isa('PPI::Statement')or return;my$first_elem=$elem->first_element();return$TRUE if$first_elem->isa('PPI::Token::Word')&& $first_elem eq 'eval';return}sub _is_in_do_conditional_block {my ($self,$elem)=@_;return if!$elem->isa('PPI::Structure::Block');my$prev_sibling=$elem->sprevious_sibling()or return;if ($prev_sibling->isa('PPI::Token::Word')&& $prev_sibling eq 'do'){my$next_sibling=$elem->snext_sibling();return$TRUE if$next_sibling && $next_sibling->isa('PPI::Token::Word');$prev_sibling=$prev_sibling->sprevious_sibling()or return;return$TRUE if$prev_sibling->isa('PPI::Token::Operator')&& $OPS{$prev_sibling->content()}}return}sub _is_compound_statement {my ($self,$elem)=@_;return if!$elem->isa('PPI::Statement::Compound');return$TRUE if$elem->type()ne 'continue';return}sub _is_in_conditional_logic {my ($self,$elem)=@_;while ($elem=$elem->parent()){last if$elem->isa('PPI::Document');return$TRUE if$self->_is_compound_statement($elem)|| $self->_is_eval($elem)|| $self->_is_in_do_conditional_block($elem)}return}1;
PERL_CRITIC_POLICY_MODULES_PROHIBITCONDITIONALUSESTATEMENTS

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitEvilModules.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITEVILMODULES';
  package Perl::Critic::Policy::Modules::ProhibitEvilModules;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue qw{throw_policy_value};use Perl::Critic::Utils qw{:booleans :characters :severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Find an alternative module};Readonly::Scalar my$MODULE_NAME_REGEX=>qr<
          \b
          [[:alpha:]_]
          (?:
              (?: \w | :: )*
              \w
          )?
          \b
      >xms;Readonly::Scalar my$REGULAR_EXPRESSION_REGEX=>qr< [/] ( [^/]+ ) [/] >xms;Readonly::Scalar my$DESCRIPTION_REGEX=>qr< [{] ( [^}]+ ) [}] >xms;Readonly::Scalar my$MODULES_REGEX=>qr<
          \A
          \s*
          (?:
                  ( $MODULE_NAME_REGEX )
              |   $REGULAR_EXPRESSION_REGEX
          )
          (?: \s* $DESCRIPTION_REGEX )?
          \s*
      >xms;Readonly::Scalar my$MODULES_FILE_LINE_REGEX=>qr<
          \A
          \s*
          (?:
                  ( $MODULE_NAME_REGEX )
              |   $REGULAR_EXPRESSION_REGEX
          )
          \s*
          ( \S (?: .* \S )? )?
          \s*
          \z
      >xms;Readonly::Scalar my$DEFAULT_MODULES=>join $SPACE,map {"$_ {Found use of $_. This module is deprecated by the Perl 5 Porters.}"}qw<Class::ISA Pod::Plainer Shell Switch>;Readonly::Scalar my$INDEX_REGEX=>0;Readonly::Scalar my$INDEX_DESCRIPTION=>1;sub supported_parameters {return ({name=>'modules',description=>'The names of or patterns for modules to forbid.',default_string=>$DEFAULT_MODULES,parser=>\&_parse_modules,},{name=>'modules_file',description=>'A file containing names of or patterns for modules to forbid.',default_string=>$EMPTY,parser=>\&_parse_modules_file,},)}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core bugs certrule)}sub applies_to {return 'PPI::Statement::Include'}sub _parse_modules {my ($self,$parameter,$config_string)=@_;my$module_specifications=defined$config_string ? $config_string : $parameter->get_default_string();return if not $module_specifications;return if$module_specifications =~ m< \A \s* \z >xms;while ($module_specifications =~ s< $MODULES_REGEX ><>xms){my ($module,$regex_string,$description)=($1,$2,$3);$self->_handle_module_specification(module=>$module,regex_string=>$regex_string,description=>$description,option_name=>'modules',option_value=>$config_string,)}if ($module_specifications){throw_policy_value policy=>$self->get_short_name(),option_name=>'modules',option_value=>$config_string,message_suffix=>qq{contains unparseable data: "$module_specifications"}}return}sub _parse_modules_file {my ($self,$parameter,$config_string)=@_;return if not $config_string;return if$config_string =~ m< \A \s* \z >xms;open my$handle,'<',$config_string or throw_policy_value policy=>$self->get_short_name(),option_name=>'modules_file',option_value=>$config_string,message_suffix=>qq<refers to a file that could not be opened: $OS_ERROR>;while (my$line=<$handle>){$self->_handle_module_specification_on_line($line,$config_string)}close$handle or warn qq<Could not close "$config_string": $OS_ERROR\n>;return}sub _handle_module_specification_on_line {my ($self,$line,$config_string)=@_;$line =~ s< [#] .* \z ><>xms;$line =~ s< \s+ \z ><>xms;$line =~ s< \A \s+ ><>xms;return if not $line;if ($line =~ s< $MODULES_FILE_LINE_REGEX ><>xms){my ($module,$regex_string,$description)=($1,$2,$3);$self->_handle_module_specification(module=>$module,regex_string=>$regex_string,description=>$description,option_name=>'modules_file',option_value=>$config_string,)}else {throw_policy_value policy=>$self->get_short_name(),option_name=>'modules_file',option_value=>$config_string,message_suffix=>qq{contains unparseable data: "$line"}}return}sub _handle_module_specification {my ($self,%arguments)=@_;my$description=$arguments{description}|| $EMPTY;if (my$regex_string=$arguments{regex_string}){my$actual_regex;eval {$actual_regex=qr/$regex_string/;1}or throw_policy_value policy=>$self->get_short_name(),option_name=>$arguments{option_name},option_value=>$arguments{option_value},message_suffix=>qq{contains an invalid regular expression: "$regex_string"};$self->{_evil_modules_regexes}||= [];push @{$self->{_evil_modules_regexes}},[$actual_regex,$description ]}else {$self->{_evil_modules}||= {};$self->{_evil_modules}{$arguments{module}}=$description}return}sub initialize_if_enabled {my ($self,$config)=@_;return exists$self->{_evil_modules}|| exists$self->{_evil_modules_regexes}}sub violates {my ($self,$elem,undef)=@_;my$module=$elem->module();return if not $module;my$evil_modules=$self->{_evil_modules};my$evil_modules_regexes=$self->{_evil_modules_regexes};my$description;if (exists$evil_modules->{$module}){$description=$evil_modules->{$module }}else {REGEX: foreach my$regex (@{$evil_modules_regexes}){if ($module =~ $regex->[$INDEX_REGEX]){$description=$regex->[$INDEX_DESCRIPTION];last REGEX}}}if (defined$description){$description ||= qq<Prohibited module "$module" used>;return$self->violation($description,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_MODULES_PROHIBITEVILMODULES

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitExcessMainComplexity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITEXCESSMAINCOMPLEXITY';
  package Perl::Critic::Policy::Modules::ProhibitExcessMainComplexity;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use Perl::Critic::Utils::McCabe qw{calculate_mccabe_of_main};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Consider refactoring};sub supported_parameters {return ({name=>'max_mccabe',description=>'The maximum complexity score allowed.',default_string=>'20',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core complexity maintenance)}sub applies_to {return 'PPI::Document'}sub violates {my ($self,$doc,undef)=@_;my$score=calculate_mccabe_of_main($doc);return if$score <= $self->{_max_mccabe};my$desc=qq{Main code has high complexity score ($score)};return$self->violation($desc,$EXPL,$doc)}1;
PERL_CRITIC_POLICY_MODULES_PROHIBITEXCESSMAINCOMPLEXITY

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitMultiplePackages.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITMULTIPLEPACKAGES';
  package Perl::Critic::Policy::Modules::ProhibitMultiplePackages;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Multiple "package" declarations};Readonly::Scalar my$EXPL=>q{Limit to one per file};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Document'}sub violates {my ($self,$elem,$doc)=@_;my$nodes_ref=$doc->find('PPI::Statement::Package');return if!$nodes_ref;my@matches=@{$nodes_ref}> 1 ? @{$nodes_ref}[1 .. $#{$nodes_ref}]:();return map {$self->violation($DESC,$EXPL,$_)}@matches}1;
PERL_CRITIC_POLICY_MODULES_PROHIBITMULTIPLEPACKAGES

$fatpacked{"Perl/Critic/Policy/Modules/RequireBarewordIncludes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREBAREWORDINCLUDES';
  package Perl::Critic::Policy::Modules::RequireBarewordIncludes;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Use a bareword instead};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core portability)}sub applies_to {return 'PPI::Statement::Include'}sub violates {my ($self,$elem,undef)=@_;my$child=$elem->schild(1);return if!$child;if ($child->isa('PPI::Token::Quote')){my$type=$elem->type;my$desc=qq{"$type" statement with library name as string};return$self->violation($desc,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_MODULES_REQUIREBAREWORDINCLUDES

$fatpacked{"Perl/Critic/Policy/Modules/RequireEndWithOne.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREENDWITHONE';
  package Perl::Critic::Policy::Modules::RequireEndWithOne;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Must end with a recognizable true value};Readonly::Scalar my$DESC=>q{Module does not end with "1;"};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp certrule)}sub applies_to {return 'PPI::Document'}sub prepare_to_scan_document {my ($self,$document)=@_;return$document->is_module()}sub violates {my ($self,$elem,$doc)=@_;my@significant=grep {_is_code($_)}$doc->schildren();my$match=$significant[-1];return if!$match;return if ((ref$match)eq 'PPI::Statement' && $match =~ m{\A 1 \s* ; \z}xms);return$self->violation($DESC,$EXPL,$match)}sub _is_code {my$elem=shift;return!($elem->isa('PPI::Statement::End')|| $elem->isa('PPI::Statement::Data'))}1;
PERL_CRITIC_POLICY_MODULES_REQUIREENDWITHONE

$fatpacked{"Perl/Critic/Policy/Modules/RequireExplicitPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREEXPLICITPACKAGE';
  package Perl::Critic::Policy::Modules::RequireExplicitPackage;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Violates encapsulation};Readonly::Scalar my$DESC=>q{Code not contained in explicit package};sub supported_parameters {return ({name=>'exempt_scripts',description=>q{Don't require programs to contain a package statement.},default_string=>'1',behavior=>'boolean',},{name=>'allow_import_of',description=>q{Allow the specified modules to be imported outside a package},behavior=>'string list',},)}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Document'}sub default_maximum_violations_per_document {return 1}sub prepare_to_scan_document {my ($self,$document)=@_;return!$self->{_exempt_scripts}|| $document->is_module()}sub violates {my ($self,$elem,$doc)=@_;my$package_stmnt=$doc->find_first('PPI::Statement::Package');my$package_line=$package_stmnt ? $package_stmnt->location()->[0]: undef;my$stmnts_ref=$doc->find('PPI::Statement');return if!$stmnts_ref;my@non_packages=grep {$self->_is_statement_of_interest($_)}@{$stmnts_ref};return if!@non_packages;my@viols=();for my$stmnt (@non_packages){my$stmnt_line=$stmnt->location()->[0];if ((!defined$package_line)|| ($stmnt_line < $package_line)){push@viols,$self->violation($DESC,$EXPL,$stmnt)}}return@viols}sub _is_statement_of_interest {my ($self,$elem)=@_;$elem or return$FALSE;$elem->isa('PPI::Statement::Package')and return$FALSE;if ($elem->isa('PPI::Statement::Include')){if (my$module=$elem->module()){$self->{_allow_import_of}{$module}and return$FALSE}}return$TRUE}1;
PERL_CRITIC_POLICY_MODULES_REQUIREEXPLICITPACKAGE

$fatpacked{"Perl/Critic/Policy/Modules/RequireFilenameMatchesPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREFILENAMEMATCHESPACKAGE';
  package Perl::Critic::Policy::Modules::RequireFilenameMatchesPackage;use 5.006001;use strict;use warnings;use Readonly;use File::Spec;use Perl::Critic::Utils qw{:characters :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Package declaration must match filename};Readonly::Scalar my$EXPL=>q{Correct the filename or package statement};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Document'}sub prepare_to_scan_document {my ($self,$document)=@_;return$document->is_module()}sub violates {my ($self,$elem,$doc)=@_;my$pkg_node=$doc->find_first('PPI::Statement::Package');return if not $pkg_node;my$pkg=$pkg_node->namespace();return if$pkg eq 'main';my@pkg_parts=split m/(?:\'|::)/xms,$pkg;my$filename=$pkg_node->logical_filename()|| $doc->filename();return if not $filename;my@path=File::Spec->splitpath($filename);$filename=$path[2];$filename =~ s/ [.] \w+ \z //xms;my@path_parts=grep {$_ ne $EMPTY}File::Spec->splitdir($path[1]),$filename;my$matched_any;while (@pkg_parts && @path_parts){my$pkg_part=pop@pkg_parts;my$path_part=pop@path_parts;if ($pkg_part eq $path_part){$matched_any=1;next}last if ($path_part =~ m/\W/xms);return$self->violation($DESC,$EXPL,$pkg_node)}return if$matched_any;return$self->violation($DESC,$EXPL,$pkg_node)}1;
PERL_CRITIC_POLICY_MODULES_REQUIREFILENAMEMATCHESPACKAGE

$fatpacked{"Perl/Critic/Policy/Modules/RequireNoMatchVarsWithUseEnglish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIRENOMATCHVARSWITHUSEENGLISH';
  package Perl::Critic::Policy::Modules::RequireNoMatchVarsWithUseEnglish;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw<:characters :severities>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{"use English" without the '-no_match_vars' argument degrades performance.'};Readonly::Scalar my$DESC=>q{"use English" without '-no_match_vars' argument};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core performance)}sub applies_to {return 'PPI::Statement::Include'}sub violates {my ($self,$elem,$doc)=@_;return if$elem->type()ne 'use';return if$elem->module()ne 'English';my@elements=$elem->schildren();shift@elements;shift@elements;if (not @elements){return$self->violation($DESC,$EXPL,$elem)}_skip_version_number(\@elements);@elements=_descend_into_parenthesized_list_if_present(@elements);if (not @elements){return$self->violation($DESC,$EXPL,$elem)}my$current_element=$elements[0];while ($current_element){if ($current_element->isa('PPI::Token::Quote')){return if$current_element->string()eq '-no_match_vars'}elsif ($current_element->isa('PPI::Token::QuoteLike::Words')){return if$current_element->content()=~ m/-no_match_vars \b/xms}elsif (not $current_element->isa('PPI::Token::Operator')or $current_element->content()ne $COMMA and $current_element->content()ne $FATCOMMA){return$self->violation($DESC,$EXPL,$elem)}shift@elements;$current_element=$elements[0]}return$self->violation($DESC,$EXPL,$elem)}sub _skip_version_number {my ($elements_ref)=@_;my$current_element=$elements_ref->[0];if ($current_element->isa('PPI::Token::Number')){shift @{$elements_ref}}elsif (@{$elements_ref}>= 2 and $current_element->isa('PPI::Token::Word')and $current_element->content()=~ m/\A v \d+ \z/xms and $elements_ref->[1]->isa('PPI::Token::Number')){shift @{$elements_ref};shift @{$elements_ref}}return}sub _descend_into_parenthesized_list_if_present {my@elements=@_;return if not @elements;my$current_element=$elements[0];if ($current_element->isa('PPI::Structure::List')){my@grand_children=$current_element->schildren();if (not @grand_children){return}my$grand_child=$grand_children[0];if ($grand_child->isa('PPI::Statement::Expression')){my@great_grand_children=$grand_child->schildren();if (not @great_grand_children){return}return@great_grand_children}else {return@grand_children}}return@elements}1;
PERL_CRITIC_POLICY_MODULES_REQUIRENOMATCHVARSWITHUSEENGLISH

$fatpacked{"Perl/Critic/Policy/Modules/RequireVersionVar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREVERSIONVAR';
  package Perl::Critic::Policy::Modules::RequireVersionVar;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(any);use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{No package-scoped "$VERSION" variable found};Readonly::Scalar my$EXPL=>[404 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp readability)}sub applies_to {return 'PPI::Document'}sub violates {my ($self,$elem,$doc)=@_;return if$doc->find_first(\&_is_version_declaration);return$self->violation($DESC,$EXPL,$doc)}sub _is_version_declaration {return 1 if _is_our_version(@_);return 1 if _is_vars_version(@_);return 1 if _is_package_version(@_);return 1 if _is_readonly_version(@_);return 1 if _is_package_argument_version(@_);return 0}sub _is_our_version {my (undef,$elem)=@_;$elem->isa('PPI::Statement::Variable')|| return 0;$elem->type()eq 'our' || return 0;return any {$_ eq '$VERSION'}$elem->variables()}sub _is_vars_version {my (undef,$elem)=@_;$elem->isa('PPI::Statement::Include')|| return 0;$elem->pragma()eq 'vars' || return 0;return$elem =~ m{ \$VERSION }xms}sub _is_package_version {my (undef,$elem)=@_;$elem->isa('PPI::Token::Symbol')|| return 0;return$elem =~ m{ \A \$ \S+ ::VERSION \z }xms}sub _is_readonly_version {my (undef,$elem)=@_;$elem->isa('PPI::Token::Symbol')|| return 0;return 0 if$elem !~ m{ \A \$VERSION \z }xms;my$psib=$elem->sprevious_sibling()|| return 0;return 0 if$psib ne 'our';my$ppsib=$psib->sprevious_sibling()|| return 0;return$ppsib eq 'Readonly' || $ppsib eq 'Readonly::Scalar'}sub _is_package_argument_version {my (undef,$elem)=@_;$elem->isa('PPI::Statement::Package')or return 0;my$ver=$elem->schild(2)or return 0;return$ver->isa('PPI::Token::Number')}1;
PERL_CRITIC_POLICY_MODULES_REQUIREVERSIONVAR

$fatpacked{"Perl/Critic/Policy/NamingConventions/Capitalization.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_NAMINGCONVENTIONS_CAPITALIZATION';
  package Perl::Critic::Policy::NamingConventions::Capitalization;use 5.006001;use strict;use warnings;use English qw<-no_match_vars>;use Readonly;use List::MoreUtils qw<any>;use Perl::Critic::Exception::AggregateConfiguration;use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue;use Perl::Critic::Utils qw<:booleans :characters :severities hashify is_perl_global>;use Perl::Critic::Utils::Perl qw<symbol_without_sigil>;use Perl::Critic::Utils::PPI qw<is_in_subroutine>;use PPIx::Utilities::Statement qw<get_constant_name_elements_from_declaring_statement>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$ALL_ONE_CASE_REGEX=>qr< \A [@%\$]? (?: [[:lower:]_\d]+ | [[:upper:]_\d]+ ) \z >xms;Readonly::Scalar my$ALL_LOWER_REGEX=>qr< \A [[:lower:]_\d]+ \z >xms;Readonly::Scalar my$ALL_UPPER_REGEX=>qr< \A [[:upper:]_\d]+ \z >xms;Readonly::Scalar my$STARTS_WITH_LOWER_REGEX=>qr< \A _* [[:lower:]\d]   >xms;Readonly::Scalar my$STARTS_WITH_UPPER_REGEX=>qr< \A _* [[:upper:]\d]   >xms;Readonly::Scalar my$NO_RESTRICTION_REGEX=>qr< .                     >xms;Readonly::Hash my%CAPITALIZATION_SCHEME_TAGS=>(':single_case'=>{regex=>$ALL_ONE_CASE_REGEX,regex_violation=>'is not all lower case or all upper case',},':all_lower'=>{regex=>$ALL_LOWER_REGEX,regex_violation=>'is not all lower case',},':all_upper'=>{regex=>$ALL_UPPER_REGEX,regex_violation=>'is not all upper case',},':starts_with_lower'=>{regex=>$STARTS_WITH_LOWER_REGEX,regex_violation=>'does not start with a lower case letter',},':starts_with_upper'=>{regex=>$STARTS_WITH_UPPER_REGEX,regex_violation=>'does not start with a upper case letter',},':no_restriction'=>{regex=>$NO_RESTRICTION_REGEX,regex_violation=>'there is a bug in Perl::Critic if you are reading this',},);Readonly::Scalar my$PACKAGE_REGEX=>qr/ :: | ' /xms;Readonly::Hash my%NAME_FOR_TYPE=>(package=>'Package',subroutine=>'Subroutine',local_lexical_variable=>'Local lexical variable',scoped_lexical_variable=>'Scoped lexical variable',file_lexical_variable=>'File lexical variable',global_variable=>'Global variable',constant=>'Constant',label=>'Label',);Readonly::Hash my%IS_COMMA=>hashify($COMMA,$FATCOMMA);Readonly::Scalar my$EXPL=>[45,46 ];sub supported_parameters {return ({name=>'packages',description=>'How package name components should be capitalized.  Valid values are :single_case, :all_lower, :all_upper:, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',default_string=>':starts_with_upper',behavior=>'string',},{name=>'package_exemptions',description=>'Package names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',default_string=>'main',behavior=>'string list',},{name=>'subroutines',description=>'How subroutine names should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',default_string=>':single_case',behavior=>'string',},{name=>'subroutine_exemptions',description=>'Subroutine names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',default_string=>join ($SPACE,qw<AUTOLOAD BUILD BUILDARGS CLEAR CLOSE DELETE DEMOLISH DESTROY EXISTS EXTEND FETCH FETCHSIZE FIRSTKEY GETC NEXTKEY POP PRINT PRINTF PUSH READ READLINE SCALAR SHIFT SPLICE STORE STORESIZE TIEARRAY TIEHANDLE TIEHASH TIESCALAR UNSHIFT UNTIE WRITE>,),behavior=>'string list',},{name=>'local_lexical_variables',description=>'How local lexical variables names should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',default_string=>':single_case',behavior=>'string',},{name=>'local_lexical_variable_exemptions',description=>'Local lexical variable names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',default_string=>$EMPTY,behavior=>'string list',},{name=>'scoped_lexical_variables',description=>'How lexical variables that are scoped to a subset of subroutines, should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',default_string=>':single_case',behavior=>'string',},{name=>'scoped_lexical_variable_exemptions',description=>'Names for variables in anonymous blocks that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',default_string=>$EMPTY,behavior=>'string list',},{name=>'file_lexical_variables',description=>'How lexical variables at the file level should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',default_string=>':single_case',behavior=>'string',},{name=>'file_lexical_variable_exemptions',description=>'File-scope lexical variable names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',default_string=>$EMPTY,behavior=>'string list',},{name=>'global_variables',description=>'How global (package) variables should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',default_string=>':single_case',behavior=>'string',},{name=>'global_variable_exemptions',description=>'Global variable names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',default_string=>'\$VERSION @ISA @EXPORT(?:_OK)? %EXPORT_TAGS \$AUTOLOAD %ENV %SIG \$TODO',behavior=>'string list',},{name=>'constants',description=>'How constant names should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',default_string=>':all_upper',behavior=>'string',},{name=>'constant_exemptions',description=>'Constant names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',default_string=>$EMPTY,behavior=>'string list',},{name=>'labels',description=>'How labels should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',default_string=>':all_upper',behavior=>'string',},{name=>'label_exemptions',description=>'Labels that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',default_string=>$EMPTY,behavior=>'string list',},)}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw<core pbp cosmetic>}sub applies_to {return qw<PPI::Statement PPI::Token::Label>}sub initialize_if_enabled {my ($self,$config)=@_;my$configuration_exceptions=Perl::Critic::Exception::AggregateConfiguration->new();KIND: foreach my$kind_of_name (qw<package subroutine local_lexical_variable scoped_lexical_variable file_lexical_variable global_variable constant label>){my ($capitalization_regex,$message)=$self->_derive_capitalization_test_regex_and_message($kind_of_name,$configuration_exceptions,);my$exemption_regexes=$self->_derive_capitalization_exemption_test_regexes($kind_of_name,$configuration_exceptions,);next KIND if$configuration_exceptions->has_exceptions();$self->{"_${kind_of_name}_test"}=sub {my ($name)=@_;return if _name_is_exempt($name,$exemption_regexes);return$message if$name !~ m/$capitalization_regex/xms;return}}if ($configuration_exceptions->has_exceptions()){$configuration_exceptions->throw()}return$TRUE}sub _derive_capitalization_test_regex_and_message {my ($self,$kind_of_name,$configuration_exceptions)=@_;my$capitalization_option="${kind_of_name}s";my$capitalization=$self->{"_$capitalization_option"};if (my$tag_properties=$CAPITALIZATION_SCHEME_TAGS{$capitalization}){return @{$tag_properties}{qw<regex regex_violation> }}elsif ($capitalization =~ m< \A : >xms){$configuration_exceptions->add_exception(Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue->new(policy=>$self,option_name=>$capitalization_option,option_value=>$capitalization,message_suffix=>'is not a known capitalization scheme tag. Valid tags are: ' .(join q<, >,sort keys%CAPITALIZATION_SCHEME_TAGS).$PERIOD,));return}my$regex;eval {$regex=qr< \A $capitalization \z >xms}or do {$configuration_exceptions->add_exception(Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue->new(policy=>$self,option_name=>$capitalization_option,option_value=>$capitalization,message_suffix=>"is not a valid regular expression: $EVAL_ERROR",));return};return$regex,qq<does not match "\\A$capitalization\\z".>}sub _derive_capitalization_exemption_test_regexes {my ($self,$kind_of_name,$configuration_exceptions)=@_;my$exemptions_option="${kind_of_name}_exemptions";my$exemptions=$self->{"_$exemptions_option"};my@regexes;PATTERN: foreach my$pattern (keys %{$exemptions}){my$regex;eval {$regex=qr< \A $pattern \z >xms}or do {$configuration_exceptions->add_exception(Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue->new(policy=>$self,option_name=>$exemptions_option,option_value=>$pattern,message_suffix=>"is not a valid regular expression: $EVAL_ERROR",));next PATTERN};push@regexes,$regex}return \@regexes}sub _name_is_exempt {my ($name,$exemption_regexes)=@_;for my$regex (@{$exemption_regexes}){return$TRUE if$name =~ m/$regex/xms}return$FALSE}sub violates {my ($self,$elem,undef)=@_;if ($elem->isa('PPI::Statement::Variable')){return$self->_variable_capitalization($elem)}if ($elem->isa('PPI::Statement::Sub')){return$self->_subroutine_capitalization($elem)}if (my@names=get_constant_name_elements_from_declaring_statement($elem)){return (grep {$_}map {$self->_constant_capitalization($elem,$_)}@names)}if ($elem->isa('PPI::Statement::Package')){return$self->_package_capitalization($elem)}if ($elem->isa('PPI::Statement::Compound')and $elem->type()eq 'foreach'){return$self->_foreach_variable_capitalization($elem)}if ($elem->isa('PPI::Token::Label')){return$self->_label_capitalization($elem)}return}sub _variable_capitalization {my ($self,$elem)=@_;my@violations;NAME: for my$name (map {$_->symbol()}$elem->symbols()){if ($elem->type()eq 'local'){next NAME if$name =~ m/$PACKAGE_REGEX/xms;next NAME if is_perl_global($name);push @violations,$self->_check_capitalization(symbol_without_sigil($name),$name,'global_variable',$elem,)}elsif ($elem->type()eq 'our'){push @violations,$self->_check_capitalization(symbol_without_sigil($name),$name,'global_variable',$elem,)}else {my$parent=$elem->parent();if (not $parent or $parent->isa('PPI::Document')){push @violations,$self->_check_capitalization(symbol_without_sigil($name),$name,'file_lexical_variable',$elem,)}else {if (_is_directly_in_scope_block($elem)){push @violations,$self->_check_capitalization(symbol_without_sigil($name),$name,'scoped_lexical_variable',$elem,)}else {push @violations,$self->_check_capitalization(symbol_without_sigil($name),$name,'local_lexical_variable',$elem,)}}}}return@violations}sub _subroutine_capitalization {my ($self,$elem)=@_;return if$elem->isa('PPI::Statement::Scheduled');my$name=$elem->name();$name =~ s{ .* :: }{}smx;return$self->_check_capitalization($name,$name,'subroutine',$elem)}sub _constant_capitalization {my ($self,$elem,$name)=@_;return$self->_check_capitalization(symbol_without_sigil($name),$name,'constant',$elem,)}sub _package_capitalization {my ($self,$elem)=@_;my$namespace=$elem->namespace();my@components=split m/::/xms,$namespace;for my$component (@components){my$violation=$self->_check_capitalization($component,$namespace,'package',$elem,);return$violation if$violation}return}sub _foreach_variable_capitalization {my ($self,$elem)=@_;my$type;my$symbol;my$second_element=$elem->schild(1);return if not $second_element;if ($second_element->isa('PPI::Token::Word')){$type=$second_element->content();$symbol=$second_element->snext_sibling()}else {$type='my';$symbol=$second_element}return if not $symbol;return if not $symbol->isa('PPI::Token::Symbol');my$name=$symbol->symbol();if ($type eq 'local'){return if$name =~ m/$PACKAGE_REGEX/xms;return if is_perl_global($name);return$self->_check_capitalization(symbol_without_sigil($name),$name,'global_variable',$elem,)}elsif ($type eq 'our'){return$self->_check_capitalization(symbol_without_sigil($name),$name,'global_variable',$elem,)}return$self->_check_capitalization(symbol_without_sigil($name),$name,'local_lexical_variable',$elem,)}sub _label_capitalization {my ($self,$elem,$name)=@_;return if _is_not_real_label($elem);(my$label=$elem->content())=~ s< \s* : \z ><>xms;return$self->_check_capitalization($label,$label,'label',$elem)}sub _check_capitalization {my ($self,$to_match,$full_name,$name_type,$elem)=@_;my$test=$self->{"_${name_type}_test"};if (my$message=$test->($to_match)){return$self->violation(qq<$NAME_FOR_TYPE{$name_type} "$full_name" $message>,$EXPL,$elem,)}return}sub _is_directly_in_scope_block {my ($elem)=@_;return if is_in_subroutine($elem);my$parent=$elem->parent();return if not $parent->isa('PPI::Structure::Block');my$grand_parent=$parent->parent();return$TRUE if not $grand_parent;return$TRUE if$grand_parent->isa('PPI::Document');return if not $grand_parent->isa('PPI::Statement::Compound');my$type=$grand_parent->type();return if not $type;return if$type ne 'continue';my$great_grand_parent=$grand_parent->parent();return if $great_grand_parent and not $great_grand_parent->isa('PPI::Document');my$prior_to_grand_parent=$grand_parent->sprevious_sibling();return$TRUE if not $prior_to_grand_parent;return$TRUE if not $prior_to_grand_parent->isa('PPI::Token::Word');return$prior_to_grand_parent->content()ne 'continue'}sub _is_not_real_label {my$elem=shift;my$stmnt=$elem->statement()|| return;my$first_child=$stmnt->schild(0)|| return;return$first_child ne $elem}1;
PERL_CRITIC_POLICY_NAMINGCONVENTIONS_CAPITALIZATION

$fatpacked{"Perl/Critic/Policy/NamingConventions/ProhibitAmbiguousNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_NAMINGCONVENTIONS_PROHIBITAMBIGUOUSNAMES';
  package Perl::Critic::Policy::NamingConventions::ProhibitAmbiguousNames;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>[48 ];Readonly::Scalar my$DEFAULT_FORBID=>'abstract bases close contract last left no record right second set';sub supported_parameters {return ({name=>'forbid',description=>'The variable names that are not to be allowed.',default_string=>$DEFAULT_FORBID,behavior=>'string list',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return qw(PPI::Statement::Sub PPI::Statement::Variable)}sub violates {my ($self,$elem,undef)=@_;if ($elem->isa('PPI::Statement::Sub')){my@words=grep {$_->isa('PPI::Token::Word')}$elem->schildren();for my$word (@words){my ($name)=$word =~ m/ (\w+) \z /xms;next if not defined$name;if (exists$self->{_forbid}->{$name}){return$self->violation(qq<Ambiguously named subroutine "$name">,$EXPL,$elem,)}}return}my@violations;my$symbols=$elem->find('PPI::Token::Symbol');if ($symbols){for my$symbol (@{$symbols}){my ($name)=$symbol =~ m/ (\w+) \z /xms;next if!defined$name;if (exists$self->{_forbid}->{$name}){push @violations,$self->violation(qq<Ambiguously named variable "$name">,$EXPL,$elem,)}}}return@violations}1;
PERL_CRITIC_POLICY_NAMINGCONVENTIONS_PROHIBITAMBIGUOUSNAMES

$fatpacked{"Perl/Critic/Policy/Objects/ProhibitIndirectSyntax.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_OBJECTS_PROHIBITINDIRECTSYNTAX';
  package Perl::Critic::Policy::Objects::ProhibitIndirectSyntax;use 5.006001;use strict;use warnings;use Carp;use English qw(-no_match_vars);use Perl::Critic::Utils qw{:severities :classification};use Readonly;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Hash my%COMMA=>{q<,>=>1,q{=>}=>1,};Readonly::Scalar my$DOLLAR=>q<$>;Readonly::Scalar my$DESC=>'Subroutine "%s" called using indirect syntax';Readonly::Scalar my$EXPL=>[349 ];sub supported_parameters {return ({name=>'forbid',description=>'Indirect method syntax is forbidden for these methods.',behavior=>'string list',list_always_present_values=>[qw{new} ],})}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core pbp maintenance certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,$doc)=@_;return if not $self->{_forbid}->{$elem->content()};return if not is_function_call($elem);my$object=$elem->snext_sibling()or return;return if not ($object->isa('PPI::Token::Word')or $object->isa('PPI::Token::Symbol')and $DOLLAR eq $object->raw_type()or $object->isa('PPI::Structure::Block'));if (my$operator=$object->snext_sibling()){return if $operator->isa('PPI::Token::Operator')and $COMMA{$operator->content()}}my$message=sprintf$DESC,$elem->content();return$self->violation($message,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_OBJECTS_PROHIBITINDIRECTSYNTAX

$fatpacked{"Perl/Critic/Policy/References/ProhibitDoubleSigils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REFERENCES_PROHIBITDOUBLESIGILS';
  package Perl::Critic::Policy::References::ProhibitDoubleSigils;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Double-sigil dereference};Readonly::Scalar my$EXPL=>[228 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::Cast'}sub violates {my ($self,$elem,undef)=@_;return if$elem eq q{\\};my$sib=$elem->snext_sibling;return if!$sib;if (!$sib->isa('PPI::Structure::Block')){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_REFERENCES_PROHIBITDOUBLESIGILS

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitCaptureWithoutTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITCAPTUREWITHOUTTEST';
  package Perl::Critic::Policy::RegularExpressions::ProhibitCaptureWithoutTest;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :data_conversion :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Hash my%CONDITIONAL_OPERATOR=>hashify(qw{&& || ? and or xor});Readonly::Hash my%UNAMBIGUOUS_CONTROL_TRANSFER=>hashify(qw<next last redo return>);Readonly::Scalar my$DESC=>q{Capture variable used outside conditional};Readonly::Scalar my$EXPL=>[253 ];sub supported_parameters {return ({name=>'exception_source',description=>'Names of ways to generate exceptions',behavior=>'string list',list_always_present_values=>[qw{die croak confess} ],})}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance certrule)}sub applies_to {return 'PPI::Token::Magic'}sub violates {my ($self,$elem,$doc)=@_;return if$elem !~ m/\A \$[1-9] \z/xms;return if _is_in_conditional_expression($elem);return if$self->_is_in_conditional_structure($elem);return$self->violation($DESC,$EXPL,$elem)}sub _is_in_conditional_expression {my$elem=shift;my$psib=$elem->sprevious_sibling;while ($psib){if ($psib->isa('PPI::Token::Operator')){my$op=$psib->content;if ($CONDITIONAL_OPERATOR{$op }){$psib=$psib->sprevious_sibling;while ($psib){return 1 if ($psib->isa('PPI::Token::Regexp::Match'));return 1 if ($psib->isa('PPI::Token::Regexp::Substitute'));$psib=$psib->sprevious_sibling}return}}$psib=$psib->sprevious_sibling}return}sub _is_in_conditional_structure {my ($self,$elem)=@_;my$stmt=$elem->statement();while ($stmt && $elem->isa('PPI::Statement::Expression')){$stmt=$stmt->statement()}return if!$stmt;my$psib=$stmt->sprevious_sibling;while ($psib){if ($psib->isa('PPI::Node')and my$match=_find_exposed_match_or_substitute($psib)){return _is_control_transfer_to_left($self,$match,$elem)|| _is_control_transfer_to_right($self,$match,$elem)}$psib=$psib->sprevious_sibling}my$parent=$stmt->parent;while ($parent){if ($parent->isa('PPI::Statement::Compound')|| $parent->isa('PPI::Statement::When')){return 1}elsif ($parent->isa('PPI::Structure')){return 1 if _is_in_conditional_expression($parent);return 1 if$self->_is_in_conditional_structure($parent);$parent=$parent->parent}else {last}}return}sub _is_control_transfer_to_left {my ($self,$match,$elem)=@_;my$prev=$match->sprevious_sibling()or return;while (not ($prev->isa('PPI::Token::Word')&& q<unless> eq $prev->content())){$prev=$prev->sprevious_sibling()or return}my$parent=$prev->parent()or return;my$first=$parent->schild(0)or return;if (my$method=_get_method_name($first)){return$self->{_exception_source}{$method->content()}}return$self->{_exception_source}{$first->content()}|| _unambiguous_control_transfer($first,$elem)}sub _is_control_transfer_to_right {my ($self,$match,$elem)=@_;my$oper=$match->snext_sibling()or return;my$oper_content=$oper->content();q{or} eq $oper_content or q{||} eq $oper_content or return;my$next=$oper->snext_sibling()or return;if (my$method=_get_method_name($next)){return$self->{_exception_source}{$method->content()}}return$self->{_exception_source}{$next->content()}|| _unambiguous_control_transfer($next,$elem)}sub _find_exposed_match_or_substitute {my$elem=shift;FIND_REGEXP_NOT_IN_BLOCK: foreach my$regexp (reverse @{$elem->find(sub {return $_[1]->isa('PPI::Token::Regexp::Substitute')|| $_[1]->isa('PPI::Token::Regexp::Match')})|| []}){my$parent=$regexp->parent();while ($parent!=$elem){$parent->isa('PPI::Structure::Block')and next FIND_REGEXP_NOT_IN_BLOCK;$parent=$parent->parent()or next FIND_REGEXP_NOT_IN_BLOCK}return$regexp}return}sub _get_method_name {my ($elem)=@_;$elem or return;($elem->isa('PPI::Token::Symbol')&& q<$> eq $elem->raw_type()|| $elem->isa('PPI::Token::Word')&& $elem->content()=~ m/ \A [\w:]+ \z /smx)or return;my$prior;my$next=$elem->snext_sibling()or return;while ($next->isa('PPI::Token::Subscript')|| $next->isa('PPI::Token::Operator')&& q{->} eq $next->content()){$prior=$next;$next=$next->snext_sibling or return}($prior && $prior->isa('PPI::Token::Operator')&& q{->} eq $prior->content())or return;$next->isa('PPI::Token::Word')or return;return$next}sub _unambiguous_control_transfer {my ($xfer,$elem)=@_;my$content=$xfer->content();return$TRUE if$UNAMBIGUOUS_CONTROL_TRANSFER{$content };q<goto> eq $content and return _unambiguous_goto($xfer,$elem);return}sub _unambiguous_goto {my ($xfer,$elem)=@_;my$target=$xfer->snext_sibling()or return;$target->isa('PPI::Token::Symbol')and q<&> eq $target->raw_type()and return$TRUE;if ($target->isa('PPI::Token::Word')){my$container=$target;while (my$parent=$container->parent()){$container=$parent;$container->isa('PPI::Structure::Block')and last}my$looking_for=qr/ \A @{[ $target->content() ]} \s* : \z /smx;my ($start_line,$start_char)=@{$xfer->location()|| []};defined$start_line or return;my ($end_line,$end_char)=@{$elem->location()|| []};for my$label (@{$container->find('PPI::Token::Label')|| []}){$label->content()=~ m/$looking_for/smx or next;my ($line,$char)=@{$label->location()|| []};return$TRUE if$line < $start_line || $line==$start_line && $char < $start_char;return$TRUE if$line > $end_line || $line==$end_line && $char > $end_char;return}return$TRUE}return}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITCAPTUREWITHOUTTEST

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitComplexRegexes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITCOMPLEXREGEXES';
  package Perl::Critic::Policy::RegularExpressions::ProhibitComplexRegexes;use 5.006001;use strict;use warnings;use Carp;use English qw(-no_match_vars);use List::Util qw{min};use Readonly;use Perl::Critic::Utils qw{:booleans :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Split long regexps into smaller qr// chunks};Readonly::Scalar my$EXPL=>[261];Readonly::Scalar my$MAX_LITERAL_LENGTH=>7;Readonly::Scalar my$MAX_VARIABLE_LENGTH=>4;sub supported_parameters {return ({name=>'max_characters',description=>'The maximum number of characters to allow in a regular expression.',default_string=>'60',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return qw(PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp)}sub violates {my ($self,$elem,$document)=@_;return if$self->{_max_characters}>= length$elem->get_match_string();my$re=$document->ppix_regexp_from_element($elem)or return;$re->failures()and return;my$qr=$re->regular_expression()or return;my$length=0;for my$token (map {$_->tokens()}$qr->children()){$token->significant()or next;if ($token->isa('PPIx::Regexp::Token::Interpolation')){$length += min($MAX_VARIABLE_LENGTH,length$token->content())}elsif ($token->isa('PPIx::Regexp::Token::Literal')){$length += min($MAX_LITERAL_LENGTH,length$token->content())}else {$length += length$token->content()}}return if$self->{_max_characters}>= $length;return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITCOMPLEXREGEXES

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitEnumeratedClasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITENUMERATEDCLASSES';
  package Perl::Critic::Policy::RegularExpressions::ProhibitEnumeratedClasses;use 5.006001;use strict;use warnings;use Carp qw(carp);use English qw(-no_match_vars);use List::MoreUtils qw(all);use Readonly;use Perl::Critic::Utils qw{:booleans :severities hashify};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Use named character classes};Readonly::Scalar my$EXPL=>[248];Readonly::Array my@PATTERNS=>([q{ },'\\t','\\r','\\n']=>['\\s','\\S'],['A-Z','a-z','0-9','_']=>['\\w','\\W'],['A-Z','a-z']=>['[[:alpha:]]','[[:^alpha:]]'],['A-Z']=>['[[:upper:]]','[[:^upper:]]'],['a-z']=>['[[:lower:]]','[[:^lower:]]'],['0-9']=>['\\d','\\D'],['\w']=>[undef,'\\W'],['\s']=>[undef,'\\S'],);sub supported_parameters {return qw()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic unicode)}sub applies_to {return qw(PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp)}sub violates {my ($self,$elem,$document)=@_;return if$elem !~ m/\[/xms;my$re=$document->ppix_regexp_from_element($elem)or return;$re->failures()and return;my$anyofs=$re->find('PPIx::Regexp::Structure::CharClass')or return;for my$anyof (@{$anyofs}){my$violation;$violation=$self->_get_character_class_violations($elem,$anyof)and return$violation}return}sub _get_character_class_violations {my ($self,$elem,$anyof)=@_;my%elements;for my$element ($anyof->children()){$elements{_fixup($element)}=1}for (my$i=0;$i < @PATTERNS;$i += 2){if (all {exists$elements{$_}}@{$PATTERNS[$i]}){my$neg=$anyof->negated();my$improvement=$PATTERNS[$i + 1]->[$neg ? 1 : 0];next if!defined$improvement;if ($neg &&!defined$PATTERNS[$i + 1]->[0]){next if 1!=scalar keys%elements}my$orig=join q{},'[',($neg ? q{^} : ()),@{$PATTERNS[$i]},']';return$self->violation($DESC ." ($orig vs. $improvement)",$EXPL,$elem)}}return}Readonly::Hash my%ORDINALS=>(ord "\n"=>'\\n',ord "\f"=>'\\f',ord "\r"=>'\\r',ord q< >=>q< >,);sub _fixup {my ($element)=@_;if ($element->isa('PPIx::Regexp::Token::Literal')){my$ord=$element->ordinal();exists$ORDINALS{$ord}and return$ORDINALS{$ord};return$element->content()}elsif ($element->isa('PPIx::Regexp::Node')){return join q{},map{_fixup($_)}$element->elements()}else {return$element->content()}}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITENUMERATEDCLASSES

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitEscapedMetacharacters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITESCAPEDMETACHARACTERS';
  package Perl::Critic::Policy::RegularExpressions::ProhibitEscapedMetacharacters;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use List::MoreUtils qw(any);use Readonly;use Perl::Critic::Utils qw{:booleans :severities hashify};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Use character classes for literal metachars instead of escapes};Readonly::Scalar my$EXPL=>[247];Readonly::Hash my%REGEXP_METACHARS=>hashify(split / /xms,'{ } ( ) . * + ? |');sub supported_parameters {return qw()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return qw(PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp)}sub violates {my ($self,$elem,$document)=@_;return if$elem !~ m/\\/xms;my$re=$document->ppix_regexp_from_element($elem)or return;$re->failures()and return;my$qr=$re->regular_expression()or return;my$exacts=$qr->find('PPIx::Regexp::Token::Literal')or return;for my$exact(@{$exacts}){$exact->content()=~ m/ \\ ( . ) /xms or next;return$self->violation($DESC,$EXPL,$elem)if$REGEXP_METACHARS{$1}}return}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITESCAPEDMETACHARACTERS

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitFixedStringMatches.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITFIXEDSTRINGMATCHES';
  package Perl::Critic::Policy::RegularExpressions::ProhibitFixedStringMatches;use 5.006001;use strict;use warnings;use Readonly;use English qw(-no_match_vars);use Carp;use Perl::Critic::Utils qw{:booleans :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Use 'eq' or hash instead of fixed-pattern regexps};Readonly::Scalar my$EXPL=>[271,272];Readonly::Scalar my$RE_METACHAR=>qr/[\\#\$()*+.?\@\[\]^{|}]/xms;sub supported_parameters {return qw()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp performance)}sub applies_to {return qw(PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp)}sub violates {my ($self,$elem,$doc)=@_;my$re=$elem->get_match_string();if ($re =~ m{\A \s*
                   (\\A|\^)  # front anchor == $1
                   (.*?)
                   (\\z|\$)  # end anchor == $2
                   \s* \z}xms){my ($front_anchor,$words,$end_anchor)=($1,$2,$3);if ($front_anchor eq q{^} || $end_anchor eq q{$}){my$regexp=$doc->ppix_regexp_from_element($elem)or return;return if$regexp->modifier_asserted('m')}if ($words =~ m{\A \s*
                          [(]              # start group
                            (?:[?]:)?      # optional non-capturing indicator
                            \s* (.*?) \s*  # interior of group
                          [)]              # end of group
                          \s* \z}xms){$words=$1;$words =~ s/[|]//gxms}return if$words =~ m/$RE_METACHAR/oxms;return$self->violation($DESC,$EXPL,$elem)}else {return}}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITFIXEDSTRINGMATCHES

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitSingleCharAlternation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITSINGLECHARALTERNATION';
  package Perl::Critic::Policy::RegularExpressions::ProhibitSingleCharAlternation;use 5.006001;use strict;use warnings;use Carp;use English qw(-no_match_vars);use List::MoreUtils qw(all);use Readonly;use Perl::Critic::Utils qw{:booleans :characters :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>[265];sub supported_parameters {return qw()}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp performance)}sub applies_to {return qw(PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp)}sub violates {my ($self,$elem,$document)=@_;return if$elem !~ m/[|]/xms;my$re=$document->ppix_regexp_from_element($elem)or return;$re->failures()and return;my@violations;for my$node (@{$re->find_parents(sub {return $_[1]->isa('PPIx::Regexp::Token::Operator')&& $_[1]->content()eq q<|>})|| []}){my@singles;my@alternative;for my$kid ($node->children()){if ($kid->isa('PPIx::Regexp::Token::Operator')&& $kid->content()eq q<|>){@alternative==1 and $alternative[0]->isa('PPIx::Regexp::Token::Literal')and push@singles,map {$_->content()}@alternative;@alternative=()}elsif ($kid->significant()){push@alternative,$kid}}@alternative==1 and $alternative[0]->isa('PPIx::Regexp::Token::Literal')and push@singles,map {$_->content()}@alternative;if (1 < @singles){my$description='Use [' .join($EMPTY,@singles).'] instead of ' .join q<|>,@singles;push@violations,$self->violation($description,$EXPL,$elem)}}return@violations}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITSINGLECHARALTERNATION

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitUnusedCapture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUNUSEDCAPTURE';
  package Perl::Critic::Policy::RegularExpressions::ProhibitUnusedCapture;use 5.006001;use strict;use warnings;use Carp;use English qw(-no_match_vars);use List::MoreUtils qw(none);use Readonly;use Scalar::Util qw(refaddr);use Perl::Critic::Exception::Fatal::Internal qw{throw_internal};use Perl::Critic::Utils qw{:booleans :characters :severities hashify precedence_of split_nodes_on_comma};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$WHILE=>q{while};Readonly::Hash my%CAPTURE_REFERENCE=>hashify(qw{$+ $-});Readonly::Hash my%CAPTURE_REFERENCE_ENGLISH=>(hashify(qw{$LAST_PAREN_MATCH $LAST_MATCH_START $LAST_MATCH_END}),%CAPTURE_REFERENCE);Readonly::Scalar my$DESC=>q{Only use a capturing group if you plan to use the captured value};Readonly::Scalar my$EXPL=>[252];sub supported_parameters {return qw()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return qw<PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute>}Readonly::Scalar my$NUM_CAPTURES_FOR_GLOBAL=>100;sub violates {my ($self,$elem,$doc)=@_;return if 0 > index$elem->content(),'(';my$re=$doc->ppix_regexp_from_element($elem)or return;$re->failures()and return;my$ncaptures=$re->max_capture_number()or return;my@captures;$#captures=$ncaptures - 1;my%named_captures;for my$struct (@{$re->find('PPIx::Regexp::Structure::NamedCapture')|| []}){push @{$named_captures{$struct->name()}||= []},$struct->number()}return if _enough_uses_in_regexp($re,\@captures,\%named_captures,$doc);if ($re->modifier_asserted('g')and not _check_if_in_while_condition_or_block($elem)){$ncaptures=$NUM_CAPTURES_FOR_GLOBAL;$#captures=$ncaptures - 1}return if _enough_assignments($elem,\@captures)&&!%named_captures;return if _is_in_slurpy_array_context($elem)&&!%named_captures;return if _enough_magic($elem,$re,\@captures,\%named_captures,$doc);return$self->violation($DESC,$EXPL,$elem)}sub _enough_uses_in_regexp {my ($re,$captures,$named_captures,$doc)=@_;for my$token (@{$re->find('PPIx::Regexp::Token::Reference')|| []}){if ($token->is_named()){_record_named_capture($token->name(),$captures,$named_captures)}else {_record_numbered_capture($token->absolute(),$captures)}}for my$token (@{$re->find('PPIx::Regexp::Token::Code')|| []}){my$ppi=$token->ppi()or next;_check_node_children($ppi,{regexp=>$re,numbered_captures=>$captures,named_captures=>$named_captures,document=>$doc,},_make_regexp_checker())}return (none {not defined}@{$captures})&& (!%{$named_captures}|| none {defined}values %{$named_captures})}sub _enough_assignments {my ($elem,$captures)=@_;my$psib=$elem->sprevious_sibling;SIBLING: while (1){return if!$psib;if ($psib->isa('PPI::Token::Operator')){last SIBLING if q{=} eq $psib->content;return if q{!~} eq $psib->content}$psib=$psib->sprevious_sibling}$psib=$psib->sprevious_sibling;return if!$psib;if ($psib->isa('PPI::Token::Symbol')){return$TRUE if _symbol_is_slurpy($psib)}elsif ($psib->isa('PPI::Structure::Block')){return$TRUE if _block_is_slurpy($psib)}elsif ($psib->isa('PPI::Structure::List')){my@args=$psib->schildren;return$TRUE if not @args;if (1==@args && $args[0]->isa('PPI::Statement::Expression')){@args=$args[0]->schildren}my@parts=split_nodes_on_comma(@args);PART: for my$i (0 .. $#parts){if (1==@{$parts[$i]}){my$var=$parts[$i]->[0];if ($var->isa('PPI::Token::Symbol')|| $var->isa('PPI::Token::Cast')){return$TRUE if _has_array_sigil($var)}}_record_numbered_capture($i + 1,$captures)}}return none {not defined}@{$captures}}sub _symbol_is_slurpy {my ($symbol)=@_;return$TRUE if _has_array_sigil($symbol);return$TRUE if _has_hash_sigil($symbol);return$TRUE if _is_preceded_by_array_or_hash_cast($symbol);return}sub _has_array_sigil {my ($elem)=@_;return q{@} eq substr$elem->content,0,1}sub _has_hash_sigil {my ($elem)=@_;return q{%} eq substr$elem->content,0,1}sub _block_is_slurpy {my ($block)=@_;return$TRUE if _is_preceded_by_array_or_hash_cast($block);return}sub _is_preceded_by_array_or_hash_cast {my ($elem)=@_;my$psib=$elem->sprevious_sibling;my$cast;while ($psib && $psib->isa('PPI::Token::Cast')){$cast=$psib;$psib=$psib->sprevious_sibling}return if!$cast;my$sigil=substr$cast->content,0,1;return q{@} eq $sigil || q{%} eq $sigil}sub _is_in_slurpy_array_context {my ($elem)=@_;my$psib=$elem->sprevious_sibling;if ($psib && $psib->content eq q{=~}){$psib=_skip_lhs($psib)}if (!$psib){my$parent=$elem->parent;return if!$parent;if ($parent->isa('PPI::Statement')){$parent=$parent->parent;return if!$parent}if ($parent->isa('PPI::Structure::List')){my$parent_statement=$parent->statement()or return$TRUE;return$TRUE if not $parent_statement->isa('PPI::Statement::Compound');return$TRUE if$parent_statement->type()ne 'foreach'}return$TRUE if$parent->isa('PPI::Structure::Constructor');if ($parent->isa('PPI::Structure::Block')){return$TRUE if refaddr($elem->statement)eq refaddr([$parent->schildren]->[-1])}return}if ($psib->isa('PPI::Token::Operator')){return$TRUE if q{,} eq $psib->content;return}return$TRUE}sub _skip_lhs {my ($elem)=@_;$elem=$elem->sprevious_sibling();return$elem}sub _enough_magic {my ($elem,$re,$captures,$named_captures,$doc)=@_;_check_for_magic($elem,$re,$captures,$named_captures,$doc);return (none {not defined}@{$captures})&& (!%{$named_captures}|| none {defined}values %{$named_captures})}sub _check_for_magic {my ($elem,$re,$captures,$named_captures,$doc)=@_;my$arg={regexp=>$re,numbered_captures=>$captures,named_captures=>$named_captures,document=>$doc,};if (my$prior_token=$elem->sprevious_sibling()){$arg->{negated}=$prior_token->isa('PPI::Token::Operator')&& q<!~> eq $prior_token->content()}return if!_check_rest_of_statement($elem,$arg);my$parent=$elem->parent();while ($parent &&!$parent->isa('PPI::Statement::Sub')){return if!_check_rest_of_statement($parent,$arg);$parent=$parent->parent()}return}sub _check_if_in_while_condition_or_block {my ($elem)=@_;$elem or return;my$parent=$elem->parent()or return;$parent->isa('PPI::Statement')or return;my$item=$parent=$parent->parent()or return;if ($item->isa('PPI::Structure::Block')){$item=$item->sprevious_sibling()or return}$item->isa('PPI::Structure::Condition')or return;$item=$item->sprevious_sibling()or return;$item->isa('PPI::Token::Word')or return;return$WHILE eq $item->content()}{Readonly::Hash my%SHORTCUT_OPERATOR=>(q<||>=>$FALSE,q<//>=>$FALSE,and=>$TRUE,or=>$FALSE,);sub _make_regexp_checker {my ($parent)=@_;$parent and not $parent->()and return sub {return$FALSE};my$check=$TRUE;my$precedence=0;return sub {my ($elem)=@_;$elem or return$check;$elem->isa('PPI::Token::Regexp')and return$check;if ($elem->isa('PPI::Token::Structure')&& q<;> eq $elem->content()){$check=$TRUE;$precedence=0;return$FALSE}$elem->isa('PPI::Token::Operator')or return$FALSE;my$content=$elem->content();defined(my$oper_check=$SHORTCUT_OPERATOR{$content})or return$FALSE;my$oper_precedence=precedence_of($content);$oper_precedence >= $precedence or return$FALSE;$precedence=$oper_precedence;$check=$oper_check;return$FALSE}}}sub _check_rest_of_statement {my ($elem,$arg)=@_;my$checker=_make_regexp_checker();my$nsib=$elem->snext_sibling;if ($arg->{negated}&& _is_condition_of_if_statement($elem)){while ($nsib &&!$nsib->isa('PPI::Structure::Block')){$nsib=$nsib->snext_sibling()}$nsib and $nsib=$nsib->snext_sibling()}while ($nsib){return if$checker->($nsib);if ($nsib->isa('PPI::Node')){return if!_check_node_children($nsib,$arg,$checker)}else {_mark_magic($nsib,$arg->{regexp},$arg->{numbered_captures},$arg->{named_captures},$arg->{document})}$nsib=$nsib->snext_sibling}return$TRUE}{Readonly::Hash my%IS_IF_STATEMENT=>hashify(qw{if elsif});sub _is_condition_of_if_statement {my ($elem)=@_;$elem and $elem->isa('PPI::Structure::Condition')or return$FALSE;my$psib=$elem->sprevious_sibling()or return$FALSE;$psib->isa('PPI::Token::Word')or return$FALSE;return$IS_IF_STATEMENT{$psib->content()}}}sub _check_node_children {my ($elem,$arg,$parent_checker)=@_;my$checker=_make_regexp_checker($parent_checker);for my$child ($elem->schildren){return if$checker->($child);if ($child->isa('PPI::Node')){return if!_check_node_children($child,$arg,$checker)}else {_mark_magic($child,$arg->{regexp},$arg->{numbered_captures},$arg->{named_captures},$arg->{document})}}return$TRUE}sub _mark_magic {my ($elem,$re,$captures,$named_captures,$doc)=@_;if (_is_double_quotish_element($elem)){_mark_magic_in_content($elem->content(),$re,$captures,$named_captures,$doc);return}if ($elem->isa('PPI::Token::HereDoc')){$elem->content()=~ m/ \A << \s* ' /sxm or _mark_magic_in_content(join($EMPTY,$elem->heredoc()),$re,$captures,$named_captures,$doc);return}my$content=$elem->content();my$capture_ref=$doc->uses_module('English')? \%CAPTURE_REFERENCE_ENGLISH : \%CAPTURE_REFERENCE;$elem->isa('PPI::Token::Magic')or $capture_ref->{$content}or return;if ($content =~ m/ \A \$ ( \d+ ) /xms){my$num=$1;if (0 < $num){if ($num <= @{$captures}){_record_numbered_capture($num,$captures)}}}elsif ($capture_ref->{$content}){_mark_magic_subscripted_code($elem,$re,$captures,$named_captures)}return}sub _mark_magic_subscripted_code {my ($elem,$re,$captures,$named_captures)=@_;my$subscr=$elem->snext_sibling()or return;$subscr->isa('PPI::Structure::Subscript')or return;my$subval=$subscr->content();_record_subscripted_capture($elem->content(),$subval,$re,$captures,$named_captures);return}sub _mark_magic_in_content {my ($content,$re,$captures,$named_captures,$doc)=@_;my$capture_ref=$doc->uses_module('English')? \%CAPTURE_REFERENCE_ENGLISH : \%CAPTURE_REFERENCE;while ($content =~ m< ( \$ (?:
          [{] (?: \w+ | . ) [}] | \w+ | . ) ) >sxmg){my$name=$1;$name =~ s/ \A \$ [{] /\$/sxm;$name =~ s/ [}] \z //sxm;if ($name =~ m/ \A \$ ( \d+ ) \z /sxm){my$num=$1;0 < $num and $num <= @{$captures}and _record_numbered_capture($num,$captures)}elsif ($capture_ref->{$name}&& $content =~ m/ \G ( [{] [^}]+ [}] | [[] [^]] []] ) /smxgc){_record_subscripted_capture($name,$1,$re,$captures,$named_captures)}}return}sub _is_double_quotish_element {my ($elem)=@_;$elem or return;my$content=$elem->content();if ($elem->isa('PPI::Token::QuoteLike::Command')){return$content !~ m/ \A qx \s* ' /sxm}for my$class (qw{PPI::Token::Quote::Double PPI::Token::Quote::Interpolate PPI::Token::QuoteLike::Backtick PPI::Token::QuoteLike::Readline}){$elem->isa($class)and return$TRUE}return$FALSE}sub _record_subscripted_capture {my ($variable_name,$suffix,$re,$captures,$named_captures)=@_;if ($suffix =~ m/ \A [{] ( .*? ) [}] /smx){(my$name=$1)=~ s/ \A ( ["'] ) ( .*? ) \1 \z /$2/smx;_record_named_capture($name,$captures,$named_captures)}elsif ($suffix =~ m/ \A [[] \s* ( [-+]? \d+ ) \s* []] /smx){_record_numbered_capture($1 .q{},$captures,$re)}return}sub _record_named_capture {my ($name,$captures,$named_captures)=@_;defined (my$numbers=$named_captures->{$name})or return;for my$capnum (@{$numbers}){_record_numbered_capture($capnum,$captures)}$named_captures->{$name}=undef;return}sub _record_numbered_capture {my ($number,$captures,$re)=@_;$re and $number < 0 and $number=$re->max_capture_number()+ $number + 1;return if$number <= 0;$captures->[$number - 1 ]=1;return}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUNUSEDCAPTURE

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitUnusualDelimiters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUNUSUALDELIMITERS';
  package Perl::Critic::Policy::RegularExpressions::ProhibitUnusualDelimiters;use 5.006001;use strict;use warnings;use Readonly;use English qw(-no_match_vars);use Carp;use Perl::Critic::Utils qw{:booleans :severities hashify};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q<Use only '//' or '{}' to delimit regexps>;Readonly::Scalar my$EXPL=>[246];Readonly::Array my@EXTRA_BRACKETS=>qw{() [] <>};sub supported_parameters {return ({name=>'allow_all_brackets',description=>q[In addition to allowing '{}', allow '()', '[]', and '{}'.],behavior=>'boolean',},)}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return qw(PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp)}sub initialize_if_enabled {my ($self,$config)=@_;my%delimiters=hashify(qw<// {}>);if ($self->{_allow_all_brackets}){@delimiters{@EXTRA_BRACKETS }=(1)x @EXTRA_BRACKETS}$self->{_allowed_delimiters}=\%delimiters;return$TRUE}sub violates {my ($self,$elem,undef)=@_;my$allowed_delimiters=$self->{_allowed_delimiters};for my$delimiter ($elem->get_delimiters()){next if$allowed_delimiters->{$delimiter};return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUNUSUALDELIMITERS

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitUselessTopic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUSELESSTOPIC';
  package Perl::Critic::Policy::RegularExpressions::ProhibitUselessTopic;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Useless use of $_};Readonly::Scalar my$EXPL=>q{$_ should be omitted when matching a regular expression};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core)}sub applies_to {return 'PPI::Token::Magic'}sub violates {my ($self,$elem,undef)=@_;my$content=$elem->content;if ($content eq q{$_}){my$op_node=$elem->snext_sibling;if ($op_node && $op_node->isa('PPI::Token::Operator')){my$op=$op_node->content;if ($op eq q{=~} || $op eq q{!~}){my$target_node=$op_node->snext_sibling;if ($target_node && ($target_node->isa('PPI::Token::Regexp')|| $target_node->isa('PPI::Token::QuoteLike::Regexp'))){return$self->violation($DESC,$EXPL,$elem)}}}}return}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUSELESSTOPIC

$fatpacked{"Perl/Critic/Policy/RegularExpressions/RequireBracesForMultiline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREBRACESFORMULTILINE';
  package Perl::Critic::Policy::RegularExpressions::RequireBracesForMultiline;use 5.006001;use strict;use warnings;use Readonly;use English qw(-no_match_vars);use Carp;use Perl::Critic::Utils qw{:booleans :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q<Use '{' and '}' to delimit multi-line regexps>;Readonly::Scalar my$EXPL=>[242];Readonly::Array my@EXTRA_BRACKETS=>qw{() [] <>};sub supported_parameters {return ({name=>'allow_all_brackets',description=>q[In addition to allowing '{}', allow '()', '[]', and '{}'.],behavior=>'boolean',},)}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return qw(PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp)}sub initialize_if_enabled {my ($self,$config)=@_;my%delimiters=(q<{}>=>1);if ($self->{_allow_all_brackets}){@delimiters{@EXTRA_BRACKETS }=(1)x @EXTRA_BRACKETS}$self->{_allowed_delimiters}=\%delimiters;return$TRUE}sub violates {my ($self,$elem,undef)=@_;my$re=$elem->get_match_string();return if$re !~ m/\n/xms;my ($match_delim)=$elem->get_delimiters();return if$self->{_allowed_delimiters}{$match_delim};return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREBRACESFORMULTILINE

$fatpacked{"Perl/Critic/Policy/RegularExpressions/RequireDotMatchAnything.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREDOTMATCHANYTHING';
  package Perl::Critic::Policy::RegularExpressions::RequireDotMatchAnything;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Regular expression without "/s" flag};Readonly::Scalar my$EXPL=>[240,241 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw<core pbp cosmetic>}sub applies_to {return qw<PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp>}sub violates {my ($self,$elem,$doc)=@_;my$re=$doc->ppix_regexp_from_element($elem)or return;$re->modifier_asserted('s')or return$self->violation($DESC,$EXPL,$elem);return}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREDOTMATCHANYTHING

$fatpacked{"Perl/Critic/Policy/RegularExpressions/RequireExtendedFormatting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREEXTENDEDFORMATTING';
  package Perl::Critic::Policy::RegularExpressions::RequireExtendedFormatting;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Regular expression without "/x" flag};Readonly::Scalar my$EXPL=>[236 ];sub supported_parameters {return ({name=>'minimum_regex_length_to_complain_about',description=>q<The number of characters that a regular expression must contain before this policy will complain.>,behavior=>'integer',default_string=>'0',integer_minimum=>0,},{name=>'strict',description=>q<Should regexes that only contain whitespace and word characters be complained about?>,behavior=>'boolean',default_string=>'0',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw<core pbp maintenance>}sub applies_to {return qw<PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp>}sub violates {my ($self,$elem,$doc)=@_;my$match=$elem->get_match_string();return if length$match <= $self->{_minimum_regex_length_to_complain_about};return if not $self->{_strict}and $match =~ m< \A [\s\w]* \z >xms;my$re=$doc->ppix_regexp_from_element($elem)or return;$re->modifier_asserted('x')or return$self->violation($DESC,$EXPL,$elem);return}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREEXTENDEDFORMATTING

$fatpacked{"Perl/Critic/Policy/RegularExpressions/RequireLineBoundaryMatching.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIRELINEBOUNDARYMATCHING';
  package Perl::Critic::Policy::RegularExpressions::RequireLineBoundaryMatching;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Regular expression without "/m" flag};Readonly::Scalar my$EXPL=>[237 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return qw(PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp)}sub violates {my ($self,$elem,$doc)=@_;my$re=$doc->ppix_regexp_from_element($elem)or return;$re->modifier_asserted('m')or return$self->violation($DESC,$EXPL,$elem);return}1;
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIRELINEBOUNDARYMATCHING

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitAmpersandSigils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITAMPERSANDSIGILS';
  package Perl::Critic::Policy::Subroutines::ProhibitAmpersandSigils;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities hashify};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Subroutine called with "&" sigil};Readonly::Scalar my$EXPL=>[175 ];Readonly::Hash my%EXEMPTIONS=>hashify(qw<defined exists goto sort>);Readonly::Hash my%IS_COMMA=>hashify(q{,},q{=>});sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Token::Symbol'}sub violates {my ($self,$elem,undef)=@_;my$previous=$elem->sprevious_sibling();if ($previous){return if$previous->isa('PPI::Token::Cast')&& $previous eq q{\\}}return if ($elem !~ m{\A [&] }xms);if (not $previous or $previous->isa('PPI::Token::Operator')and $IS_COMMA{$previous->content()}){my$up=$elem;PARENT: while (($up=$up->parent)and ($up->isa('PPI::Statement::Expression')or $up->isa('PPI::Structure::List')or $up->isa('PPI::Statement'))){if (my$word=$up->sprevious_sibling){return if $up->isa('PPI::Structure::List')&& $word->isa('PPI::Token::Cast')&& $word->content()eq q{\\};if ($word->isa('PPI::Token::Word')){$previous=$word}last PARENT}}}return if$previous and $EXEMPTIONS{$previous};return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITAMPERSANDSIGILS

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitBuiltinHomonyms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITBUILTINHOMONYMS';
  package Perl::Critic::Policy::Subroutines::ProhibitBuiltinHomonyms;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :data_conversion :classification :characters};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Array my@ALLOW=>qw(import AUTOLOAD DESTROY);Readonly::Hash my%ALLOW=>hashify(@ALLOW);Readonly::Scalar my$DESC=>q{Subroutine name is a homonym for builtin %s %s};Readonly::Scalar my$EXPL=>[177];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp certrule)}sub applies_to {return 'PPI::Statement::Sub'}sub violates {my ($self,$elem,undef)=@_;return if$elem->isa('PPI::Statement::Scheduled');return if exists$ALLOW{$elem->name()};my$homonym_type=$EMPTY;if (is_perl_builtin($elem)){$homonym_type='function'}elsif (is_perl_bareword($elem)){$homonym_type='keyword'}else {return}my$desc=sprintf$DESC,$homonym_type,$elem->name();return$self->violation($desc,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITBUILTINHOMONYMS

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitExcessComplexity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITEXCESSCOMPLEXITY';
  package Perl::Critic::Policy::Subroutines::ProhibitExcessComplexity;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :data_conversion :classification};use Perl::Critic::Utils::McCabe qw{calculate_mccabe_of_sub};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Consider refactoring};sub supported_parameters {return ({name=>'max_mccabe',description=>'The maximum complexity score allowed.',default_string=>'20',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core complexity maintenance)}sub applies_to {return 'PPI::Statement::Sub'}sub violates {my ($self,$elem,undef)=@_;my$score=calculate_mccabe_of_sub($elem);return if$score <= $self->{_max_mccabe};my$desc;if (my$name=$elem->name()){$desc=qq<Subroutine "$name" with high complexity score ($score)>}else {$desc=qq<Anonymous subroutine with high complexity score ($score)>}return$self->violation($desc,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITEXCESSCOMPLEXITY

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitExplicitReturnUndef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITEXPLICITRETURNUNDEF';
  package Perl::Critic::Policy::Subroutines::ProhibitExplicitReturnUndef;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"return" statement with explicit "undef"};Readonly::Scalar my$EXPL=>[199 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs certrec)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'return';return if is_hash_key($elem);my$sib=$elem->snext_sibling();return if!$sib;return if!$sib->isa('PPI::Token::Word');return if$sib->content()ne 'undef';return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITEXPLICITRETURNUNDEF

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitManyArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITMANYARGS';
  package Perl::Critic::Policy::Subroutines::ProhibitManyArgs;use 5.006001;use strict;use warnings;use Readonly;use File::Spec;use List::Util qw(first);use List::MoreUtils qw(uniq any);use English qw(-no_match_vars);use Carp;use Perl::Critic::Utils qw{:booleans :severities split_nodes_on_comma};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$AT=>q{@};Readonly::Scalar my$AT_ARG=>q{@_};Readonly::Scalar my$DESC=>q{Too many arguments};Readonly::Scalar my$EXPL=>[182];sub supported_parameters {return ({name=>'max_arguments',description=>'The maximum number of arguments to allow a subroutine to have.',default_string=>'5',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Statement::Sub'}sub violates {my ($self,$elem,undef)=@_;return if!$elem->block;my$num_args;if ($elem->prototype){my$prototype=$elem->prototype();$prototype =~ s/ \\ [[] .*? []] /*/smxg;$num_args=$prototype =~ tr/$@%&*_+/$@%&*_+/}else {$num_args=_count_args($elem->block->schildren)}if ($self->{_max_arguments}< $num_args){return$self->violation($DESC,$EXPL,$elem)}return}sub _count_args {my@statements=@_;return 0 if!@statements;my$statement=shift@statements;my@elements=$statement->schildren();my$operand=pop@elements;while ($operand && $operand->isa('PPI::Token::Structure')&& q{;} eq $operand->content()){$operand=pop@elements}return 0 if!$operand;my$operator=pop@elements;return 0 if!$operator;return 0 if!$operator->isa('PPI::Token::Operator');return 0 if q{=} ne $operator->content();if ($operand->isa('PPI::Token::Magic')&& $AT_ARG eq $operand->content()){return _count_list_elements(@elements)}elsif ($operand->isa('PPI::Token::Word')&& 'shift' eq $operand->content()){return 1 + _count_args(@statements)}return 0}sub _count_list_elements {my@elements=@_;my$list=pop@elements;return 0 if!$list;return 0 if!$list->isa('PPI::Structure::List');my@inner=$list->schildren;if (1==@inner && $inner[0]->isa('PPI::Statement::Expression')){@inner=$inner[0]->schildren}return scalar split_nodes_on_comma(@inner)}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITMANYARGS

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitNestedSubs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITNESTEDSUBS';
  package Perl::Critic::Policy::Subroutines::ProhibitNestedSubs;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Nested named subroutine};Readonly::Scalar my$EXPL=>q{Declaring a named sub inside another named sub does not prevent the } .q{inner sub from being global};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Statement::Sub'}sub violates {my ($self,$elem,$doc)=@_;return if$elem->isa('PPI::Statement::Scheduled');my$inner=$elem->find_first(sub {return $_[1]->isa('PPI::Statement::Sub')&&!$_[1]->isa('PPI::Statement::Scheduled')});return if not $inner;return$self->violation($DESC,$EXPL,$inner)}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITNESTEDSUBS

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitReturnSort.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITRETURNSORT';
  package Perl::Critic::Policy::Subroutines::ProhibitReturnSort;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"return" statement followed by "sort"};Readonly::Scalar my$EXPL=>q{Behavior is undefined if called in scalar context};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core bugs certrule)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne 'return';return if is_hash_key($elem);my$sib=$elem->snext_sibling();return if!$sib;return if!$sib->isa('PPI::Token::Word');return if$sib->content()ne 'sort';return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITRETURNSORT

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitSubroutinePrototypes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITSUBROUTINEPROTOTYPES';
  package Perl::Critic::Policy::Subroutines::ProhibitSubroutinePrototypes;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Subroutine prototypes used};Readonly::Scalar my$EXPL=>[194 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs certrec)}sub applies_to {return 'PPI::Statement::Sub'}sub violates {my ($self,$elem,undef)=@_;if ($elem->prototype()){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITSUBROUTINEPROTOTYPES

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitUnusedPrivateSubroutines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITUNUSEDPRIVATESUBROUTINES';
  package Perl::Critic::Policy::Subroutines::ProhibitUnusedPrivateSubroutines;use 5.006001;use strict;use warnings;use English qw<$EVAL_ERROR -no_match_vars>;use List::MoreUtils qw(any);use Readonly;use Perl::Critic::Utils qw{:characters hashify is_function_call is_method_call :severities $EMPTY $TRUE};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Private subroutine/method '%s' declared but not used};Readonly::Scalar my$EXPL=>q{Eliminate dead code};Readonly::Hash my%IS_COMMA=>hashify($COMMA,$FATCOMMA);sub supported_parameters {return ({name=>'private_name_regex',description=>'Pattern that determines what a private subroutine is.',default_string=>'\b_\w+\b',behavior=>'string',parser=>\&_parse_private_name_regex,},{name=>'allow',description=>q<Subroutines matching the private name regex to allow under this policy.>,default_string=>$EMPTY,behavior=>'string list',},{name=>'skip_when_using',description=>q<Modules that, if used within a file, will cause the policy to be disabled for this file>,default_string=>$EMPTY,behavior=>'string list',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance certrec)}sub applies_to {return 'PPI::Statement::Sub'}sub _parse_private_name_regex {my ($self,$parameter,$config_string)=@_;defined$config_string or $config_string=$parameter->get_default_string();my$regex;eval {$regex=qr/$config_string/;1}or $self->throw_parameter_value_exception('private_name_regex',$config_string,undef,"is not a valid regular expression: $EVAL_ERROR",);$self->__set_parameter_value($parameter,$regex);return}sub violates {my ($self,$elem,$document)=@_;my@skip_modules=keys %{$self->{_skip_when_using}};return if any {$document->uses_module($_)}@skip_modules;$elem->forward()and return;my$name=$elem->name()or return;$name =~ m/ :: /smx and return;$self->{_allow}{$name}and return;$name =~ m/ \A $self->{_private_name_regex} \z /smx or return;$self->_find_sub_call_in_document($elem,$document)and return;$self->_find_sub_reference_in_document($elem,$document)and return;$self->_find_sub_overload_in_document($elem,$document)and return;return$self->violation(sprintf($DESC,$name),$EXPL,$elem)}sub _compare_token_locations {my ($left_token,$right_token)=@_;my$left_loc=$left_token->location()or return;my$right_loc=$right_token->location()or return;return$left_loc->[0]<=> $right_loc->[0]|| $left_loc->[1]<=> $right_loc->[1]}sub _find_sub_call_in_document {my ($self,$elem,$document)=@_;my$start_token=$elem->first_token();my$finish_token=$elem->last_token();my$name=$elem->name();if (my$found=$document->find('PPI::Token::Word')){for my$usage (@{$found}){$name eq $usage->content()or next;is_function_call($usage)or is_method_call($usage)or next;_compare_token_locations($usage,$start_token)< 0 and return$TRUE;_compare_token_locations($finish_token,$usage)< 0 and return$TRUE}}for my$regexp (_find_regular_expressions($document)){_compare_token_locations($regexp,$start_token)>= 0 and _compare_token_locations($finish_token,$regexp)>= 0 and next;_find_sub_usage_in_regexp($name,$regexp,$document)and return$TRUE}return}sub _find_regular_expressions {my ($document)=@_;return (map {@{$document->find($_)|| []}}qw{PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp})}sub _find_sub_usage_in_regexp {my ($name,$regexp,$document)=@_;my$ppix=$document->ppix_regexp_from_element($regexp)or return;$ppix->failures()and return;for my$code (@{$ppix->find('PPIx::Regexp::Token::Code')|| []}){my$doc=$code->ppi()or next;for my$word (@{$doc->find('PPI::Token::Word')|| []}){$name eq $word->content()or next;is_function_call($word)or is_method_call($word)or next;return$TRUE}}return}sub _find_sub_overload_in_document {my ($self,$elem,$document)=@_;my$name=$elem->name();if (my$found=$document->find('PPI::Statement::Include')){for my$usage (@{$found}){'overload' eq $usage->module()or next;my$inx;for my$arg (_get_include_arguments($usage)){$inx++ % 2 or next;@{$arg}==1 or next;my$element=$arg->[0];if ($element->isa('PPI::Token::Quote')){$element->string()eq $name and return$TRUE}elsif ($element->isa('PPI::Token::Word')){$element->content()eq $name and return$TRUE}}}}return}sub _find_sub_reference_in_document {my ($self,$elem,$document)=@_;my$start_token=$elem->first_token();my$finish_token=$elem->last_token();my$symbol=q<&> .$elem->name();if (my$found=$document->find('PPI::Token::Symbol')){for my$usage (@{$found}){$symbol eq $usage->content()or next;my$prior=$usage->sprevious_sibling();$prior and $prior->isa('PPI::Token::Cast')and q<\\> eq $prior->content()and return$TRUE;is_function_call($usage)or $prior and $prior->isa('PPI::Token::Word')and 'goto' eq $prior->content()or next;_compare_token_locations($usage,$start_token)< 0 and return$TRUE;_compare_token_locations($finish_token,$usage)< 0 and return$TRUE}}return}sub _expand_element {my ($element)=@_;$element->isa('PPI::Node')and return (map {_expand_element($_)}$_->children());$element->significant()and return$element;return}sub _get_include_arguments {my ($include)=@_;my@arguments=map {_expand_element($_)}$include->arguments()or return;my@elements;my$inx=0;for my$element (@arguments){if ($element->isa('PPI::Token::Operator')&& $IS_COMMA{$element->content()}){$inx++}else {push @{$elements[$inx]||= []},$element}}return@elements}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITUNUSEDPRIVATESUBROUTINES

$fatpacked{"Perl/Critic/Policy/Subroutines/ProtectPrivateSubs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROTECTPRIVATESUBS';
  package Perl::Critic::Policy::Subroutines::ProtectPrivateSubs;use 5.006001;use strict;use warnings;use English qw<$EVAL_ERROR -no_match_vars>;use Readonly;use Perl::Critic::Utils qw<:severities $EMPTY is_function_call is_method_call>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q<Private subroutine/method used>;Readonly::Scalar my$EXPL=>q<Use published APIs>;sub supported_parameters {return ({name=>'private_name_regex',description=>'Pattern that determines what a private subroutine is.',default_string=>'\b_\w+\b',behavior=>'string',parser=>\&_parse_private_name_regex,},{name=>'allow',description=>q<Subroutines matching the private name regex to allow under this policy.>,default_string=>$EMPTY,behavior=>'string list',list_always_present_values=>[qw<POSIX::_PC_CHOWN_RESTRICTED POSIX::_PC_LINK_MAX POSIX::_PC_MAX_CANON POSIX::_PC_MAX_INPUT POSIX::_PC_NAME_MAX POSIX::_PC_NO_TRUNC POSIX::_PC_PATH_MAX POSIX::_PC_PIPE_BUF POSIX::_PC_VDISABLE POSIX::_POSIX_ARG_MAX POSIX::_POSIX_CHILD_MAX POSIX::_POSIX_CHOWN_RESTRICTED POSIX::_POSIX_JOB_CONTROL POSIX::_POSIX_LINK_MAX POSIX::_POSIX_MAX_CANON POSIX::_POSIX_MAX_INPUT POSIX::_POSIX_NAME_MAX POSIX::_POSIX_NGROUPS_MAX POSIX::_POSIX_NO_TRUNC POSIX::_POSIX_OPEN_MAX POSIX::_POSIX_PATH_MAX POSIX::_POSIX_PIPE_BUF POSIX::_POSIX_SAVED_IDS POSIX::_POSIX_SSIZE_MAX POSIX::_POSIX_STREAM_MAX POSIX::_POSIX_TZNAME_MAX POSIX::_POSIX_VDISABLE POSIX::_POSIX_VERSION POSIX::_SC_ARG_MAX POSIX::_SC_CHILD_MAX POSIX::_SC_CLK_TCK POSIX::_SC_JOB_CONTROL POSIX::_SC_NGROUPS_MAX POSIX::_SC_OPEN_MAX POSIX::_SC_PAGESIZE POSIX::_SC_SAVED_IDS POSIX::_SC_STREAM_MAX POSIX::_SC_TZNAME_MAX POSIX::_SC_VERSION POSIX::_exit> ],},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance certrule)}sub applies_to {return 'PPI::Token::Word'}sub _parse_private_name_regex {my ($self,$parameter,$config_string)=@_;defined$config_string or $config_string=$parameter->get_default_string();my$regex;eval {$regex=qr/$config_string/;1}or $self->throw_parameter_value_exception('private_name_regex',$config_string,undef,"is not a valid regular expression: $EVAL_ERROR",);$self->__set_parameter_value($parameter,$regex);return}sub violates {my ($self,$elem,undef)=@_;if (my$prior=$elem->sprevious_sibling()){my$prior_name=$prior->content();return if$prior_name eq 'package';return if$prior_name eq 'require';return if$prior_name eq 'use'}if ($self->_is_other_pkg_private_function($elem)or $self->_is_other_pkg_private_method($elem)){return$self->violation($DESC,$EXPL,$elem)}return}sub _is_other_pkg_private_function {my ($self,$elem)=@_;return if!is_method_call($elem)&&!is_function_call($elem);my$private_name_regex=$self->{_private_name_regex};my$content=$elem->content();return $content =~ m< \w+::$private_name_regex \z >xms && $content !~ m< \A SUPER::$private_name_regex \z >xms &&!$self->{_allow}{$content}}sub _is_other_pkg_private_method {my ($self,$elem)=@_;my$private_name_regex=$self->{_private_name_regex};my$content=$elem->content();return if$content !~ m< \A $private_name_regex \z >xms;my$operator=$elem->sprevious_sibling()or return;return if$operator->content()ne q[->];my$package=$operator->sprevious_sibling()or return;return if not $package->isa('PPI::Token::Word');return if$package->content()eq 'shift' or $package->content()eq '__PACKAGE__';return if$self->{_allow}{"${package}::$content"};return 1}1;
PERL_CRITIC_POLICY_SUBROUTINES_PROTECTPRIVATESUBS

$fatpacked{"Perl/Critic/Policy/Subroutines/RequireArgUnpacking.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_REQUIREARGUNPACKING';
  package Perl::Critic::Policy::Subroutines::RequireArgUnpacking;use 5.006001;use strict;use warnings;use Carp;use English qw(-no_match_vars);use Readonly;use File::Spec;use List::Util qw(first);use List::MoreUtils qw(uniq any);use Perl::Critic::Utils qw<:booleans :characters :classification hashify :severities words_from_string>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$AT=>q{@};Readonly::Scalar my$AT_ARG=>q{@_};Readonly::Scalar my$DOLLAR=>q{$};Readonly::Scalar my$DOLLAR_ARG=>q{$_};Readonly::Scalar my$DESC=>qq{Always unpack $AT_ARG first};Readonly::Scalar my$EXPL=>[178];sub supported_parameters {return ({name=>'short_subroutine_statements',description=>'The number of statements to allow without unpacking.',default_string=>'0',behavior=>'integer',integer_minimum=>0,},{name=>'allow_subscripts',description=>'Should unpacking from array slices and elements be allowed?',default_string=>$FALSE,behavior=>'boolean',},{name=>'allow_delegation_to',description=>'Allow the usual delegation idiom to these namespaces/subroutines',behavior=>'string list',list_always_present_values=>[qw<SUPER:: NEXT::> ],})}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Statement::Sub'}sub violates {my ($self,$elem,undef)=@_;return if not $elem->block;my@statements=$elem->block->schildren;return if not @statements;return if$self->{_short_subroutine_statements}>= @statements;my$state='unpacking';for my$statement (@statements){my@magic=_get_arg_symbols($statement);my$saw_unpack=$FALSE;MAGIC: for my$magic (@magic){next MAGIC if _is_size_check($magic);if ('unpacking' eq $state){if ($self->_is_unpack($magic)){$saw_unpack=$TRUE;next MAGIC}}next MAGIC if _is_cast_of_array($magic)and _is_postfix_foreach($magic);next MAGIC if _is_cast_of_scalar($magic);next MAGIC if$self->_is_delegation($magic);return$self->violation($DESC,$EXPL,$elem)}if (not $saw_unpack){$state='post_unpacking'}}return}sub _is_unpack {my ($self,$magic)=@_;my$prev=$magic->sprevious_sibling();my$next=$magic->snext_sibling();if ($next and $next->isa('PPI::Structure::Subscript')){$self->{_allow_subscripts}or return;$next=$next->snext_sibling}return$TRUE if $prev and $prev->isa('PPI::Token::Operator')and is_assignment_operator($prev->content())and (not $next or $next->isa('PPI::Token::Structure')and $SCOLON eq $next->content());return}sub _is_size_check {my ($magic)=@_;$AT eq $magic->raw_type or return;my$prev=$magic->sprevious_sibling;my$next=$magic->snext_sibling;if ($prev || $next){return$TRUE if _legal_before_size_check($prev)and _legal_after_size_check($next)}my$parent=$magic;{$parent=$parent->parent()or return;$prev=$parent->sprevious_sibling();$next=$parent->snext_sibling();$prev or $next or redo}return$TRUE if$parent->isa('PPI::Structure::Condition');return}{Readonly::Hash my%LEGAL_NEXT_OPER=>hashify(qw{&& || == != > >= < <= and or});Readonly::Hash my%LEGAL_NEXT_STRUCT=>hashify(qw{;});sub _legal_after_size_check {my ($next)=@_;$next or return$TRUE;$next->isa('PPI::Token::Operator')and return$LEGAL_NEXT_OPER{$next->content()};$next->isa('PPI::Token::Structure')and return$LEGAL_NEXT_STRUCT{$next->content()};return}}{Readonly::Hash my%LEGAL_PREV_OPER=>hashify(qw{&& || ! == != > >= < <= and or not});Readonly::Hash my%LEGAL_PREV_WORD=>hashify(qw{if unless});sub _legal_before_size_check {my ($prev)=@_;$prev or return$TRUE;$prev->isa('PPI::Token::Operator')and return$LEGAL_PREV_OPER{$prev->content()};$prev->isa('PPI::Token::Word')and return$LEGAL_PREV_WORD{$prev->content()};return}}sub _is_postfix_foreach {my ($magic)=@_;my$sibling=$magic;while ($sibling=$sibling->snext_sibling){return$TRUE if $sibling->isa('PPI::Token::Word')and $sibling =~ m< \A for (?:each)? \z >xms}return}sub _is_cast_of_array {my ($magic)=@_;my$prev=$magic->sprevious_sibling;return$TRUE if ($prev && $prev->content()eq $AT)and $prev->isa('PPI::Token::Cast');return}sub _is_cast_of_scalar {my ($magic)=@_;my$prev=$magic->sprevious_sibling;my$next=$magic->snext_sibling;return$DOLLAR_ARG eq $magic->content()&& $prev && $prev->isa('PPI::Token::Cast')&& $DOLLAR eq $prev->content()&& $next && $next->isa('PPI::Structure::Subscript')}sub _is_delegation {my ($self,$magic)=@_;$AT_ARG eq $magic->content()or return;my$parent=$magic->parent()or return;$parent->isa('PPI::Statement::Expression')or return;1==$parent->schildren()or return;$parent=$parent->parent()or return;$parent->isa ('PPI::Structure::List')or return;1==$parent->schildren()or return;my$subroutine_name=$parent->sprevious_sibling()or return;$subroutine_name->isa('PPI::Token::Word')or return;$self->{_allow_delegation_to}{$subroutine_name}and return 1;my ($subroutine_namespace)=$subroutine_name =~ m/ \A ( .* ::) \w+ \z /smx or return;return$self->{_allow_delegation_to}{$subroutine_namespace}}sub _get_arg_symbols {my ($statement)=@_;return grep {$AT_ARG eq $_->symbol}@{$statement->find(\&_magic_finder)|| []}}sub _magic_finder {my (undef,$elem)=@_;return$TRUE if$elem->isa('PPI::Token::Magic');if ($elem->isa('PPI::Structure::Block')){return if$elem->statement->isa('PPI::Statement::Sub');my$prev=$elem->sprevious_sibling;return if$prev and $prev->isa('PPI::Token::Word')and 'sub' eq $prev->content()}return$FALSE}1;
PERL_CRITIC_POLICY_SUBROUTINES_REQUIREARGUNPACKING

$fatpacked{"Perl/Critic/Policy/Subroutines/RequireFinalReturn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_REQUIREFINALRETURN';
  package Perl::Critic::Policy::Subroutines::RequireFinalReturn;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Exception::Fatal::Internal qw{throw_internal};use Perl::Critic::Utils qw{:characters :severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>[197 ];Readonly::Hash my%CONDITIONALS=>hashify(qw(if unless for foreach));sub supported_parameters {return ({name=>'terminal_funcs',description=>'The additional subroutines to treat as terminal.',default_string=>$EMPTY,behavior=>'string list',list_always_present_values=>[qw<croak confess die exec exit throw Carp::confess Carp::croak ...> ],},)}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp certrec)}sub applies_to {return 'PPI::Statement::Sub'}sub violates {my ($self,$elem,undef)=@_;return if$elem->isa('PPI::Statement::Scheduled');my@blocks=grep {$_->isa('PPI::Structure::Block')}$elem->schildren();if (@blocks > 1){throw_internal 'Subroutine should have no more than one block'}elsif (@blocks==0){return}my ($block)=@blocks;if ($self->_block_is_empty($block)|| $self->_block_has_return($block)){return}my$desc;if (my$name=$elem->name()){$desc=qq<Subroutine "$name" does not end with "return">}else {$desc=q<Subroutine does not end with "return">}return$self->violation($desc,$EXPL,$elem)}sub _block_is_empty {my ($self,$block)=@_;return$block->schildren()==0}sub _block_has_return {my ($self,$block)=@_;my@blockparts=$block->schildren();my$final=$blockparts[-1];return if!$final;return$self->_is_explicit_return($final)|| $self->_is_given_when_return($final)|| $self->_is_compound_return($final)}sub _is_explicit_return {my ($self,$final)=@_;return if$self->_is_conditional_stmnt($final);return$self->_is_return_or_goto_stmnt($final)|| $self->_is_terminal_stmnt($final)}sub _is_compound_return {my ($self,$final)=@_;if (!$final->isa('PPI::Statement::Compound')){return}my$begin=$final->schild(0);return if!$begin;if (!($begin->isa('PPI::Token::Word')&& ($begin->content()eq 'if' || $begin->content()eq 'unless'))){return}my@blocks=grep {!$_->isa('PPI::Structure::Condition')&& !$_->isa('PPI::Token')}$final->schildren();if (scalar grep {!$_->isa('PPI::Structure::Block')}@blocks){throw_internal 'Expected only conditions, blocks and tokens in the if statement'}for my$block (@blocks){if (!$self->_block_has_return($block)){return}}return 1}sub _is_given_when_return {my ($self,$final)=@_;if (!$final->isa('PPI::Statement::Given')){return}my$begin=$final->schild(0);return if!$begin;if (!($begin->isa('PPI::Token::Word')&& $begin->content()eq 'given')){return}my@blocks=grep {!$_->isa('PPI::Structure::Given')&& !$_->isa('PPI::Token')}$final->schildren();if (scalar grep {!$_->isa('PPI::Structure::Block')}@blocks){throw_internal 'Expected only givens, blocks and tokens in the given statement'}if (@blocks > 1){throw_internal 'Given statement should have no more than one block'}@blocks or return;my$have_default;for my$stmnt ($blocks[0]->schildren()){if ($stmnt->isa('PPI::Statement::When')){my$first_token;$first_token=$stmnt->schild(0)and 'default' eq $first_token->content()and $have_default=1;$self->_is_when_stmnt_with_return($stmnt)or return}else {$self->_is_suffix_when_with_return($stmnt)or return}}return$have_default}sub _is_return_or_goto_stmnt {my ($self,$stmnt)=@_;return if not $stmnt->isa('PPI::Statement::Break');my$first_token=$stmnt->schild(0)|| return;return$first_token->content()eq 'return' || $first_token->content()eq 'goto'}sub _is_terminal_stmnt {my ($self,$stmnt)=@_;return if not $stmnt->isa('PPI::Statement');my$first_token=$stmnt->schild(0)|| return;return exists$self->{_terminal_funcs}->{$first_token}}sub _is_conditional_stmnt {my ($self,$stmnt)=@_;return if not $stmnt->isa('PPI::Statement');for my$elem ($stmnt->schildren()){return 1 if$elem->isa('PPI::Token::Word')&& exists$CONDITIONALS{$elem}}return}sub _is_when_stmnt_with_return {my ($self,$stmnt)=@_;my@inner=grep {!$_->isa('PPI::Token')&& !$_->isa('PPI::Structure::When')}$stmnt->schildren();if (scalar grep {!$_->isa('PPI::Structure::Block')}@inner){throw_internal 'When statement should contain only tokens, conditions, and blocks'}@inner > 1 and throw_internal 'When statement should have no more than one block';@inner or return;for my$block (@inner){if (!$self->_block_has_return($block)){return}}return 1}sub _is_suffix_when_with_return {my ($self,$stmnt)=@_;return if not $stmnt->isa('PPI::Statement');for my$elem ($stmnt->schildren()){return ($self->_is_return_or_goto_stmnt($stmnt)|| $self->_is_terminal_stmnt($stmnt))if$elem->isa('PPI::Token::Word')&& 'when' eq $elem->content()}return}1;
PERL_CRITIC_POLICY_SUBROUTINES_REQUIREFINALRETURN

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/ProhibitNoStrict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITNOSTRICT';
  package Perl::Critic::Policy::TestingAndDebugging::ProhibitNoStrict;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(all);use Perl::Critic::Utils qw{:characters :severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Stricture disabled};Readonly::Scalar my$EXPL=>[429 ];sub supported_parameters {return ({name=>'allow',description=>'Allow vars, subs, and/or refs.',default_string=>$EMPTY,parser=>\&_parse_allow,},)}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs certrec)}sub applies_to {return 'PPI::Statement::Include'}sub _parse_allow {my ($self,$parameter,$config_string)=@_;$self->{_allow}={};if(defined$config_string){my$allowed=lc$config_string;my%allowed=hashify($allowed =~ m/ (\w+) /gxms);$self->{_allow}=\%allowed}return}sub violates {my ($self,$elem,undef)=@_;return if$elem->type()ne 'no';return if$elem->pragma()ne 'strict';my$stmnt=$elem->statement();return if!$stmnt;my@words=$stmnt =~ m/ ([[:lower:]]+) /gxms;@words=grep {$_ ne 'qw' && $_ ne 'no' && $_ ne 'strict'}@words;return if@words && all {exists$self->{_allow}->{$_}}@words;return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITNOSTRICT

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/ProhibitNoWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITNOWARNINGS';
  package Perl::Critic::Policy::TestingAndDebugging::ProhibitNoWarnings;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(all);use Perl::Critic::Exception::Fatal::Internal qw{throw_internal};use Perl::Critic::Utils qw{:characters :severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Warnings disabled};Readonly::Scalar my$EXPL=>[431 ];sub supported_parameters {return ({name=>'allow',description=>'Permitted warning categories.',default_string=>$EMPTY,parser=>\&_parse_allow,},{name=>'allow_with_category_restriction',description=>'Allow "no warnings" if it restricts the kinds of warnings that are turned off.',default_string=>'0',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp certrec)}sub applies_to {return 'PPI::Statement::Include'}sub _parse_allow {my ($self,$parameter,$config_string)=@_;$self->{_allow}={};if(defined$config_string){my$allowed=lc$config_string;my%allowed=hashify($allowed =~ m/ (\w+) /gxms);$self->{_allow}=\%allowed}return}sub violates {my ($self,$elem,undef)=@_;return if$elem->type()ne 'no';return if$elem->pragma()ne 'warnings';my@words=_extract_potential_categories($elem);@words >= 2 and 'no' eq $words[0]and 'warnings' eq $words[1]or throw_internal q<'no warnings' word list did not begin with qw{ no warnings }>;splice@words,0,2;return if$self->{_allow_with_category_restriction}and @words;return if@words && all {exists$self->{_allow}->{$_}}@words;return$self->violation($DESC,$EXPL,$elem)}{Readonly::Array my@HANDLER=>(['PPI::Token::Word'=>sub {return $_[0]->content()}],['PPI::Token::QuoteLike::Words'=>sub {return $_[0]->literal()},],['PPI::Token::Quote'=>sub {return $_[0]->string()}],['PPI::Node'=>sub {_extract_potential_categories($_[0])}],);sub _extract_potential_categories {my ($elem)=@_;my@words;for my$child ($elem->schildren()){for my$hdlr (@HANDLER){$child->isa($hdlr->[0])or next;push@words,$hdlr->[1]->($child);last}}return@words}}1;
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITNOWARNINGS

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/ProhibitProlongedStrictureOverride.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITPROLONGEDSTRICTUREOVERRIDE';
  package Perl::Critic::Policy::TestingAndDebugging::ProhibitProlongedStrictureOverride;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Don't turn off strict for large blocks of code};Readonly::Scalar my$EXPL=>[433 ];sub supported_parameters {return ({name=>'statements',description=>'The maximum number of statements in a no strict block.',default_string=>'3',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core pbp bugs certrec)}sub applies_to {return 'PPI::Statement::Include'}sub violates {my ($self,$elem,$doc)=@_;return if$elem->type ne 'no';return if$elem->module ne 'strict';my$sib=$elem->snext_sibling;my$nstatements=0;while ($nstatements++ <= $self->{_statements}){return if!$sib;return if$sib->isa('PPI::Statement::Include')&& $sib->type eq 'use' && $sib->module eq 'strict';$sib=$sib->snext_sibling}return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITPROLONGEDSTRICTUREOVERRIDE

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/RequireTestLabels.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIRETESTLABELS';
  package Perl::Critic::Policy::TestingAndDebugging::RequireTestLabels;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(any);use Perl::Critic::Utils qw{:characters :severities :data_conversion :classification :ppi};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Hash my%LABEL_ARG_POS=>(ok=>1,is=>2,isnt=>2,like=>2,unlike=>2,cmp_ok=>3,is_deeply=>2,pass=>0,fail=>0,);Readonly::Scalar my$DESC=>q{Test without a label};Readonly::Scalar my$EXPL=>q{Add a label argument to all Test::More functions};sub supported_parameters {return ({name=>'modules',description=>'The additional modules to require labels for.',default_string=>$EMPTY,behavior=>'string list',list_always_present_values=>[qw(Test::More) ],},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance tests)}sub applies_to {return 'PPI::Token::Word'}sub violates {my ($self,$elem,$doc)=@_;my$arg_index=$LABEL_ARG_POS{$elem};return if not defined$arg_index;return if not is_function_call($elem);return if not $self->_has_test_more($doc);my@args=parse_arg_list($elem);return if (@args > $arg_index);return$self->violation($DESC,$EXPL,$elem)}sub _has_test_more {my ($self,$doc)=@_;my$includes=$doc->find('PPI::Statement::Include');return if not $includes;return any {exists$self->{_modules}->{$_->module()}}@{$includes}}1;
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIRETESTLABELS

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/RequireUseStrict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIREUSESTRICT';
  package Perl::Critic::Policy::TestingAndDebugging::RequireUseStrict;use 5.006001;use strict;use warnings;use version 0.77;use Readonly;use Scalar::Util qw{blessed};use Perl::Critic::Utils qw{:severities $EMPTY};use Perl::Critic::Utils::Constants qw{:equivalent_modules};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Code before strictures are enabled};Readonly::Scalar my$EXPL=>[429 ];Readonly::Scalar my$PERL_VERSION_WHICH_IMPLIES_STRICTURE=>qv('v5.11.0');sub supported_parameters {return ({name=>'equivalent_modules',description=>q<The additional modules to treat as equivalent to "strict".>,default_string=>$EMPTY,behavior=>'string list',list_always_present_values=>['strict',@STRICT_EQUIVALENT_MODULES],},)}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs certrule certrec)}sub applies_to {return 'PPI::Document'}sub default_maximum_violations_per_document {return 1}sub violates {my ($self,undef,$doc)=@_;my$strict_stmnt=$doc->find_first($self->_generate_is_use_strict());my$strict_line=$strict_stmnt ? $strict_stmnt->location()->[0]: undef;my$stmnts_ref=$self->_find_isnt_include_or_package($doc);return if not $stmnts_ref;my@viols=();for my$stmnt (@{$stmnts_ref}){last if$stmnt->isa('PPI::Statement::End');last if$stmnt->isa('PPI::Statement::Data');my$stmnt_line=$stmnt->location()->[0];if ((!defined$strict_line)|| ($stmnt_line < $strict_line)){push@viols,$self->violation($DESC,$EXPL,$stmnt)}}return@viols}sub _generate_is_use_strict {my ($self)=@_;return sub {my (undef,$elem)=@_;return 0 if!$elem->isa('PPI::Statement::Include');return 0 if$elem->type()ne 'use';my$parent=$elem->parent();return 0 if!$parent->isa('PPI::Document');if (my$pragma=$elem->pragma()){return 1 if$self->{_equivalent_modules}{$pragma}}elsif (my$module=$elem->module()){return 1 if$self->{_equivalent_modules}{$module}}elsif (my$version=$elem->version()){if (not blessed($version)or not $version->isa('version')){if ('v' ne substr$version,0,1 and ($version =~ tr/././)> 1){$version='v' .$version}$version=version->parse($version)}return 1 if$PERL_VERSION_WHICH_IMPLIES_STRICTURE <= $version}return 0}}sub _find_isnt_include_or_package {my ($self,$doc)=@_;my$all_statements=$doc->find('PPI::Statement')or return;my@wanted_statements=grep {_statement_isnt_include_or_package($_)}@{$all_statements};return@wanted_statements ? \@wanted_statements : ()}sub _statement_isnt_include_or_package {my ($elem)=@_;return 0 if$elem->isa('PPI::Statement::Package');return 0 if$elem->isa('PPI::Statement::Include');return 1}1;
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIREUSESTRICT

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/RequireUseWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIREUSEWARNINGS';
  package Perl::Critic::Policy::TestingAndDebugging::RequireUseWarnings;use 5.006001;use strict;use warnings;use Readonly;use List::Util qw(first);use version ();use Perl::Critic::Utils qw{:severities $EMPTY};use Perl::Critic::Utils::Constants qw{:equivalent_modules};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Code before warnings are enabled};Readonly::Scalar my$EXPL=>[431];Readonly::Scalar my$MINIMUM_VERSION=>version->new(5.006);sub supported_parameters {return ({name=>'equivalent_modules',description=>q<The additional modules to treat as equivalent to "warnings".>,default_string=>$EMPTY,behavior=>'string list',list_always_present_values=>['warnings',@WARNINGS_EQUIVALENT_MODULES],},)}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core pbp bugs certrule)}sub applies_to {return 'PPI::Document'}sub default_maximum_violations_per_document {return 1}sub violates {my ($self,undef,$document)=@_;my$version=$document->highest_explicit_perl_version();return if$version and $version < $MINIMUM_VERSION;my$warn_stmnt=$document->find_first($self->_generate_is_use_warnings());my$warn_line=$warn_stmnt ? $warn_stmnt->location()->[0]: undef;my$stmnts_ref=$self->_find_isnt_include_or_package($document);return if!$stmnts_ref;my@viols=();for my$stmnt (@{$stmnts_ref}){last if$stmnt->isa('PPI::Statement::End');last if$stmnt->isa('PPI::Statement::Data');my$stmnt_line=$stmnt->location()->[0];if ((!defined$warn_line)|| ($stmnt_line < $warn_line)){push@viols,$self->violation($DESC,$EXPL,$stmnt)}}return@viols}sub _generate_is_use_warnings {my ($self)=@_;return sub {my (undef,$elem)=@_;return 0 if!$elem->isa('PPI::Statement::Include');return 0 if$elem->type()ne 'use';my$parent=$elem->parent();return 0 if!$parent->isa('PPI::Document');if (my$pragma=$elem->pragma()){return 1 if$self->{_equivalent_modules}{$pragma}}elsif (my$module=$elem->module()){return 1 if$self->{_equivalent_modules}{$module}}return 0}}sub _find_isnt_include_or_package {my ($self,$doc)=@_;my$all_statements=$doc->find('PPI::Statement')or return;my@wanted_statements=grep {_statement_isnt_include_or_package($_)}@{$all_statements};return@wanted_statements ? \@wanted_statements : ()}sub _statement_isnt_include_or_package {my ($elem)=@_;return 0 if$elem->isa('PPI::Statement::Package');return 0 if$elem->isa('PPI::Statement::Include');return 1}1;
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIREUSEWARNINGS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitCommaSeparatedStatements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCOMMASEPARATEDSTATEMENTS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitCommaSeparatedStatements;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :characters :severities :classification};use Perl::Critic::Utils::PPI qw{is_ppi_statement_subclass};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Comma used to separate statements};Readonly::Scalar my$EXPL=>[68,71 ];sub supported_parameters {return ({name=>'allow_last_statement_to_be_comma_separated_in_map_and_grep',description=>'Allow map and grep blocks to return lists.',default_string=>$FALSE,behavior=>'boolean',},)}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp certrule)}sub applies_to {return 'PPI::Statement'}sub violates {my ($self,$elem,undef)=@_;return if is_ppi_statement_subclass($elem);return if _is_parent_a_constructor_or_list($elem);return if _is_parent_a_for_loop($elem);if ($self->{_allow_last_statement_to_be_comma_separated_in_map_and_grep}){return if not _is_direct_part_of_map_or_grep_block($elem)}for my$child ($elem->schildren()){if (not $self->{_allow_last_statement_to_be_comma_separated_in_map_and_grep}and not _is_last_statement_in_a_block($child)){if ($child->isa('PPI::Token::Word')){return if _succeeding_commas_are_list_element_separators($child)}elsif ($child->isa('PPI::Token::Operator')){if ($child->content()eq $COMMA){return$self->violation($DESC,$EXPL,$elem)}}}}return}sub _is_parent_a_constructor_or_list {my ($elem)=@_;my$parent=$elem->parent();return if not $parent;return ($parent->isa('PPI::Structure::Constructor')or $parent->isa('PPI::Structure::List'))}sub _is_parent_a_for_loop {my ($elem)=@_;my$parent=$elem->parent();return if not $parent;return if not $parent->isa('PPI::Structure::For');return 1==scalar$parent->schildren()}sub _is_direct_part_of_map_or_grep_block {my ($elem)=@_;my$parent=$elem->parent();return if not $parent;return if not $parent->isa('PPI::Structure::Block');my$block_prior_sibling=$parent->sprevious_sibling();return if not $block_prior_sibling;return if not $block_prior_sibling->isa('PPI::Token::Word');return$block_prior_sibling eq 'map' || $block_prior_sibling eq 'grep'}sub _is_last_statement_in_a_block {my ($elem)=@_;my$parent=$elem->parent();return if not $parent;return if not $parent->isa('PPI::Structure::Block');my$next_sibling=$elem->snext_sibling();return if not $next_sibling;return 1}sub _succeeding_commas_are_list_element_separators {my ($elem)=@_;if (is_perl_builtin_with_zero_and_or_one_arguments($elem)and not is_perl_builtin_with_multiple_arguments($elem)){return}my$sibling=$elem->snext_sibling();return 1 if not $sibling;return not $sibling->isa('PPI::Structure::List')}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCOMMASEPARATEDSTATEMENTS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitComplexVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCOMPLEXVERSION';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitComplexVersion;use 5.006001;use strict;use warnings;use Carp;use English qw(-no_match_vars);use Perl::Critic::Utils qw{:booleans :characters :severities};use Perl::Critic::Utils::PPI qw{get_next_element_in_same_simple_statement get_previous_module_used_on_same_line is_ppi_simple_statement};use Readonly;use Scalar::Util qw{blessed};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DOLLAR=>q<$>;Readonly::Scalar my$VERSION_MODULE=>q<version>;Readonly::Scalar my$VERSION_VARIABLE=>$DOLLAR .q<VERSION>;Readonly::Scalar my$DESC=>$DOLLAR .q<VERSION value should not come from outside module>;Readonly::Scalar my$EXPL=>q<If the version comes from outside the module, you can get everything from unexpected version changes to denial-of-service attacks.>;sub supported_parameters {return ({name=>'forbid_use_version',description=>qq<Make "use version; our ${DOLLAR}VERSION = qv('1.2.3');" a violation of this policy.>,default_string=>$FALSE,behavior=>'boolean',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Token::Symbol'}sub violates {my ($self,$elem,$doc)=@_;return if$VERSION_VARIABLE ne $elem->content();my$operator;return if not $operator=get_next_element_in_same_simple_statement($elem)or $EQUAL ne $operator;my$statement=$self->_get_simple_statement($elem)or return;my$exception;return$exception if $exception=$self->_validate_fully_qualified_symbols($elem,$statement,$doc);my$module=get_previous_module_used_on_same_line($elem)or return;return if$module eq $VERSION_MODULE and not $self->{_forbid_use_version};return$self->violation($DESC,$EXPL,$elem)}sub _get_simple_statement {my ($self,$elem)=@_;my$statement=$elem;while ($statement){my$parent;if (is_ppi_simple_statement($statement)){return$statement if not $parent=$statement->parent()or not $parent->isa('PPI::Structure::List');$statement=$parent}else {$statement=$statement->parent()}}return}sub _validate_fully_qualified_symbols {my ($self,$elem,$statement,$doc)=@_;my%local_package=map {$_->schild(1)=>1}@{$doc->find('PPI::Statement::Package')|| []};$local_package{main}=1;for my$symbol (@{$statement->find('PPI::Token::Symbol')|| []}){if ($symbol->canonical()=~ m< \A [@\$%&] ([\w:]*) :: >smx){$local_package{$1 }or return$self->violation($DESC,$EXPL,$elem)}}for my$string (@{$statement->find(sub {return $_[1]->isa('PPI::Token::Quote::Double')|| $_[1]->isa('PPI::Token::Quote::Interpolate')})or []}){my$unquoted=$string->string();while ($unquoted =~ m<
                      (?: \A | [^\\] )
                      (?: \\{2} )*
                      [@\$]
                      [{]?
                      ([\w:]*)
                      ::
                  >gsmx){next if$local_package{$1 };return$self->violation($DESC,$EXPL,$elem)}}for my$symbol (@{$statement->find('PPI::Token::Word')|| []}){if ($symbol->content()=~ m/ \A ([\w:]*) :: /smx){return$self->violation($DESC,$EXPL,$elem)if not $local_package{$1 }}}return}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCOMPLEXVERSION

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitConstantPragma.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCONSTANTPRAGMA';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitConstantPragma;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Pragma "constant" used};Readonly::Scalar my$EXPL=>[55 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp)}sub applies_to {return 'PPI::Statement::Include'}sub violates {my ($self,$elem,undef)=@_;if ($elem->type()eq 'use' && $elem->pragma()eq 'constant'){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCONSTANTPRAGMA

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitEmptyQuotes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITEMPTYQUOTES';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitEmptyQuotes;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EMPTY_RX=>qr{\A ["'] \s* ['"] \z}xms;Readonly::Scalar my$DESC=>q<Quotes used with a string containing no non-whitespace characters>;Readonly::Scalar my$EXPL=>[53 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::Quote'}sub violates {my ($self,$elem,undef)=@_;if ($elem =~ $EMPTY_RX){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITEMPTYQUOTES

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitEscapedCharacters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITESCAPEDCHARACTERS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitEscapedCharacters;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Numeric escapes in interpolated string};Readonly::Scalar my$EXPL=>[54..55 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return qw(PPI::Token::Quote::Double PPI::Token::Quote::Interpolate)}sub violates {my ($self,$elem,undef)=@_;my$not_escaped=qr/(?<!\\)(?:\\\\)*/xms;my$hex=qr/\\x[\dA-Fa-f]{2}/xms;my$widehex=qr/\\x[{][\dA-Fa-f]+[}]/xms;my$oct=qr/\\[01][0-7]/xms;if ($elem->content =~ m/$not_escaped (?:$hex|$widehex|$oct)/xmso){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITESCAPEDCHARACTERS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitImplicitNewlines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITIMPLICITNEWLINES';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitImplicitNewlines;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Literal line breaks in a string};Readonly::Scalar my$EXPL=>[60,61];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::Quote'}sub violates {my ($self,$elem,undef)=@_;return if$elem->string !~ m/\n/xms;return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITIMPLICITNEWLINES

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitInterpolationOfLiterals.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITINTERPOLATIONOFLITERALS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitInterpolationOfLiterals;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw(any);use Perl::Critic::Utils qw{:characters :severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Useless interpolation of literal string};Readonly::Scalar my$EXPL=>[51];sub supported_parameters {return ({name=>'allow',description=>'Kinds of delimiters to permit, e.g. "qq{", "qq(", "qq[", "qq/".',default_string=>$EMPTY,parser=>\&_parse_allow,},{name=>'allow_if_string_contains_single_quote',description=>q<If the string contains ' characters, allow "" to quote it.>,default_string=>'0',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return qw(PPI::Token::Quote::Double PPI::Token::Quote::Interpolate)}Readonly::Scalar my$MAX_SPECIFICATION_LENGTH=>3;sub _parse_allow {my ($self,$parameter,$config_string)=@_;my@allow;if (defined$config_string){@allow=words_from_string($config_string);for (@allow){m{ \A qq }xms || ($_='qq' .$_)}for (@allow){(length $_ <= $MAX_SPECIFICATION_LENGTH)|| chop}}$self->{_allow}=\@allow;return}sub violates {my ($self,$elem,undef)=@_;return if _has_interpolation($elem);return if any {$elem =~ m{ \A \Q$_\E }xms}@{$self->{_allow}};if ($self->{_allow_if_string_contains_single_quote}){return if index ($elem,$QUOTE)>= 0}return$self->violation($DESC,$EXPL,$elem)}sub _has_interpolation {my$elem=shift;return$elem =~ m<
          (?: \A | [^\\] )
          (?: \\{2} )*
          (?: [\$\@] \S+ | \\[tnrfbae0xcNLuLUEQ] )
      >xmso}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITINTERPOLATIONOFLITERALS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitLeadingZeros.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITLEADINGZEROS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitLeadingZeros;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$LEADING_RX=>qr<\A [+-]? (?: 0+ _* )+ [1-9]>xms;Readonly::Scalar my$EXPL=>[58 ];sub supported_parameters {return ({name=>'strict',description=>q<Don't allow any leading zeros at all.  Otherwise builtins that deal with Unix permissions, e.g. chmod, don't get flagged.>,default_string=>'0',behavior=>'boolean',},)}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw<core pbp bugs certrec>}sub applies_to {return 'PPI::Token::Number::Octal'}sub violates {my ($self,$elem,undef)=@_;return if$elem !~ $LEADING_RX;return$self->_create_violation($elem)if$self->{_strict};return if$self->_is_first_argument_of_chmod_or_umask($elem);return if$self->_is_second_argument_of_mkdir($elem);return if$self->_is_third_argument_of_dbmopen($elem);return if$self->_is_fourth_argument_of_sysopen($elem);return$self->_create_violation($elem)}sub _create_violation {my ($self,$elem)=@_;return$self->violation(qq<Integer with leading zeros: "$elem">,$EXPL,$elem)}sub _is_first_argument_of_chmod_or_umask {my ($self,$elem)=@_;my$previous_token=_previous_token_that_isnt_a_parenthesis($elem);return if not $previous_token;my$content=$previous_token->content();return$content eq 'chmod' || $content eq 'umask'}sub _is_second_argument_of_mkdir {my ($self,$elem)=@_;my$previous_token=_previous_token_that_isnt_a_parenthesis($elem);return if not $previous_token;return if$previous_token->content()ne $COMMA;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;return$previous_token->content()eq 'mkdir'}sub _is_third_argument_of_dbmopen {my ($self,$elem)=@_;my$previous_token=_previous_token_that_isnt_a_parenthesis($elem);return if not $previous_token;return if$previous_token->content()ne $COMMA;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;return if$previous_token->content()ne $COMMA;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;return$previous_token->content()eq 'dbmopen'}sub _is_fourth_argument_of_sysopen {my ($self,$elem)=@_;my$previous_token=_previous_token_that_isnt_a_parenthesis($elem);return if not $previous_token;return if$previous_token->content()ne $COMMA;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);while ($previous_token and $previous_token->content()ne $COMMA){$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token)}return if not $previous_token;return if$previous_token->content()ne $COMMA;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;return if$previous_token->content()ne $COMMA;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;$previous_token=_previous_token_that_isnt_a_parenthesis($previous_token);return if not $previous_token;return$previous_token->content()eq 'sysopen'}sub _previous_token_that_isnt_a_parenthesis {my ($elem)=@_;my$previous_token=$elem->previous_token();while ($previous_token and (not $previous_token->significant()or $previous_token->content()eq $LEFT_PAREN or $previous_token->content()eq $RIGHT_PAREN)){$previous_token=$previous_token->previous_token()}return$previous_token}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITLEADINGZEROS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitLongChainsOfMethodCalls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITLONGCHAINSOFMETHODCALLS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitLongChainsOfMethodCalls;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities};use Perl::Critic::Utils::PPI qw{is_ppi_expression_or_generic_statement};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Long chains of method calls indicate code that is too tightly coupled};sub supported_parameters {return ({name=>'max_chain_length',description=>'The number of chained calls to allow.',default_string=>'3',behavior=>'integer',integer_minimum=>1,},)}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core maintenance)}sub applies_to {return qw{PPI::Statement}}sub _max_chain_length {my ($self)=@_;return$self->{_max_chain_length}}sub violates {my ($self,$elem,undef)=@_;return if not is_ppi_expression_or_generic_statement($elem);my$chain_length=0;my$max_chain_length=$self->_max_chain_length();my@children=$elem->schildren();my$child=shift@children;while ($child){if ($child->isa('PPI::Token::Word')and @children and $children[0]->isa('PPI::Structure::List')){shift@children}if ($child->isa('PPI::Token::Word')or $child->isa('PPI::Token::Symbol')){if (@children){if ($children[0]->isa('PPI::Token::Operator')){if (q{->} eq $children[0]->content()){$chain_length++;shift@children}}elsif (not $children[0]->isa('PPI::Token::Structure')){$chain_length=0}}}else {if ($chain_length > $max_chain_length){return $self->violation("Found method-call chain of length $chain_length.",$EXPL,$elem,)}$chain_length=0}$child=shift@children}if ($chain_length > $max_chain_length){return $self->violation("Found method-call chain of length $chain_length.",$EXPL,$elem,)}return}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITLONGCHAINSOFMETHODCALLS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitMagicNumbers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMAGICNUMBERS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitMagicNumbers;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :characters :severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Unnamed numeric literals make code less maintainable};Readonly::Scalar my$USE_READONLY_OR_CONSTANT=>' Use the Readonly or Const::Fast module or the "constant" pragma instead';Readonly::Scalar my$TYPE_NOT_ALLOWED_SUFFIX=>") are not allowed.$USE_READONLY_OR_CONSTANT";Readonly::Scalar my$UNSIGNED_NUMBER=>qr{
              \d+ (?: [$PERIOD] \d+ )?  # 1, 1.5, etc.
          |   [$PERIOD] \d+             # .3, .7, etc.
      }xms;Readonly::Scalar my$SIGNED_NUMBER=>qr/ [-+]? $UNSIGNED_NUMBER /xms;Readonly::Scalar my$RANGE=>qr{
          \A
          ($SIGNED_NUMBER)
          [$PERIOD] [$PERIOD]
          ($SIGNED_NUMBER)
          (?:
              [$COLON] by [$LEFT_PAREN]
              ($UNSIGNED_NUMBER)
              [$RIGHT_PAREN]
          )?
          \z
      }xms;Readonly::Scalar my$SPECIAL_ARRAY_SUBSCRIPT_EXEMPTION=>-1;sub supported_parameters {return ({name=>'allowed_values',description=>'Individual and ranges of values to allow, and/or "all_integers".',default_string=>'0 1 2',parser=>\&_parse_allowed_values,},{name=>'allowed_types',description=>'Kind of literals to allow.',default_string=>'Float',behavior=>'enumeration',enumeration_values=>[qw{Binary Exp Float Hex Octal} ],enumeration_allow_multiple_values=>1,},{name=>'allow_to_the_right_of_a_fat_comma',description=>q[Should anything to the right of a "=>" be allowed?],default_string=>'1',behavior=>'boolean',},{name=>'constant_creator_subroutines',description=>q{Names of subroutines that create constants},behavior=>'string list',list_always_present_values=>[qw<Readonly Readonly::Scalar Readonly::Array Readonly::Hash const>,],},)}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core maintenance certrec)}sub applies_to {return 'PPI::Token::Number'}sub default_maximum_violations_per_document {return 10}sub initialize_if_enabled {my ($self,$config)=@_;$self->_determine_checked_types();return$TRUE}sub _parse_allowed_values {my ($self,$parameter,$config_string)=@_;my ($all_integers_allowed,$allowed_values)=_determine_allowed_values($config_string);my$allowed_string=' is not one of the allowed literal values (';if ($all_integers_allowed){$allowed_string .= 'all integers';if (%{$allowed_values}){$allowed_string .= ', '}}$allowed_string .= (join ', ',sort {$a <=> $b}keys %{$allowed_values}).').' .$USE_READONLY_OR_CONSTANT;$self->{_allowed_values}=$allowed_values;$self->{_all_integers_allowed}=$all_integers_allowed;$self->{_allowed_string}=$allowed_string;return}sub _determine_allowed_values {my ($config_string)=@_;my@allowed_values;my@potential_allowed_values;my$all_integers_allowed=0;if (defined$config_string){my@allowed_values_strings=grep {$_}split m/\s+/xms,$config_string;for my$value_string (@allowed_values_strings){if ($value_string eq 'all_integers'){$all_integers_allowed=1}elsif ($value_string =~ m/ \A $SIGNED_NUMBER \z /xms){push@potential_allowed_values,$value_string + 0}elsif ($value_string =~ m/$RANGE/xms){my ($minimum,$maximum,$increment)=($1,$2,$3);$increment ||= 1;$minimum += 0;$maximum += 0;$increment += 0;for (my$value=$minimum;$value <= $maximum;$value += $increment ){push@potential_allowed_values,$value}}else {die q{Invalid value for allowed_values: },$value_string,q{. Must be a number, a number range, or},qq{ "all_integers".\n}}}if ($all_integers_allowed){@allowed_values=grep {$_!=int $_}@potential_allowed_values}else {@allowed_values=@potential_allowed_values}}else {@allowed_values=(2)}if (not $all_integers_allowed){push@allowed_values,0,1}my%allowed_values=hashify(@allowed_values);return ($all_integers_allowed,\%allowed_values)}sub _determine_checked_types {my ($self)=@_;my%checked_types=('PPI::Token::Number::Binary'=>'Binary literals (','PPI::Token::Number::Float'=>'Floating-point literals (','PPI::Token::Number::Exp'=>'Exponential literals (','PPI::Token::Number::Hex'=>'Hexadecimal literals (','PPI::Token::Number::Octal'=>'Octal literals (','PPI::Token::Number::Version'=>'Version literals (',);my$allowed_types=$self->{_allowed_types};for my$allowed_type (keys %{$allowed_types}){delete$checked_types{"PPI::Token::Number::$allowed_type"};if ($allowed_type eq 'Exp'){delete$checked_types{'PPI::Token::Number::Float'}}}$self->{_checked_types}=\%checked_types;return}sub violates {my ($self,$elem,undef)=@_;if ($self->{_allow_to_the_right_of_a_fat_comma}){return if _element_is_to_the_right_of_a_fat_comma($elem)}return if _element_is_in_an_include_readonly_or_version_statement($self,$elem,);return if _element_is_in_a_plan_statement($elem);return if _element_is_in_a_constant_subroutine($elem);return if _element_is_a_package_statement_version_number($elem);my$literal=$elem->literal();if (defined$literal and not ($self->{_all_integers_allowed}and int$literal==$literal)and not defined$self->{_allowed_values}{$literal}and not (_element_is_sole_component_of_a_subscript($elem)and $literal==$SPECIAL_ARRAY_SUBSCRIPT_EXEMPTION)){return $self->violation($elem->content().$self->{_allowed_string},$EXPL,$elem,)}my ($number_type,$type_string);while (($number_type,$type_string)=(each %{$self->{_checked_types}})){if ($elem->isa($number_type)){return $self->violation($type_string .$elem->content().$TYPE_NOT_ALLOWED_SUFFIX,$EXPL,$elem,)}}return}sub _element_is_to_the_right_of_a_fat_comma {my ($elem)=@_;my$previous=$elem->sprevious_sibling()or return;$previous->isa('PPI::Token::Operator')or return;return$previous->content()eq q[=>]}sub _element_is_sole_component_of_a_subscript {my ($elem)=@_;my$parent=$elem->parent();if ($parent and $parent->isa('PPI::Statement::Expression')){if ($parent->schildren()> 1){return 0}my$grandparent=$parent->parent();if ($grandparent and $grandparent->isa('PPI::Structure::Subscript')){return 1}}return 0}sub _element_is_in_an_include_readonly_or_version_statement {my ($self,$elem)=@_;my$parent=$elem->parent();while ($parent){if ($parent->isa('PPI::Statement')){return 1 if$parent->isa('PPI::Statement::Include');if ($parent->isa('PPI::Statement::Variable')){if ($parent->type()eq 'our'){my@variables=$parent->variables();if (scalar@variables==1 and $variables[0]eq '$VERSION'){return 1}}return 0}my$first_token=$parent->first_token();if ($first_token->isa('PPI::Token::Word')){if ($self->{_constant_creator_subroutines}{$first_token->content()}){return 1}}elsif ($parent->isa('PPI::Structure::Block')){return 0}}$parent=$parent->parent()}return 0}Readonly::Scalar my$PLAN_STATEMENT_MINIMUM_TOKENS=>4;sub _element_is_in_a_plan_statement {my ($elem)=@_;my$parent=$elem->parent();return 0 if not $parent;return 0 if not $parent->isa('PPI::Statement');my@children=$parent->schildren();return 0 if@children < $PLAN_STATEMENT_MINIMUM_TOKENS;return 0 if not $children[0]->isa('PPI::Token::Word');return 0 if$children[0]->content()ne 'plan';return 0 if not $children[1]->isa('PPI::Token::Word');return 0 if$children[1]->content()ne 'tests';return 0 if not $children[2]->isa('PPI::Token::Operator');return 0 if$children[2]->content()ne '=>';return 1}sub _element_is_in_a_constant_subroutine {my ($elem)=@_;my$parent=$elem->parent();return 0 if not $parent;return 0 if not $parent->isa('PPI::Statement');my$following=$elem->snext_sibling();if ($following){return 0 if not $following->isa('PPI::Token::Structure');return 0 if$following->content()ne $SCOLON;return 0 if$following->snext_sibling()}my$preceding=$elem->sprevious_sibling();if ($preceding){return 0 if not $preceding->isa('PPI::Token::Word');return 0 if$preceding->content()ne 'return';return 0 if$preceding->sprevious_sibling()}return 0 if$parent->snext_sibling();return 0 if$parent->sprevious_sibling();my$grandparent=$parent->parent();return 0 if not $grandparent;return 0 if not $grandparent->isa('PPI::Structure::Block');my$greatgrandparent=$grandparent->parent();return 0 if not $greatgrandparent;return 0 if not $greatgrandparent->isa('PPI::Statement::Sub');return 1}sub _element_is_a_package_statement_version_number {my ($elem)=@_;my$parent=$elem->statement()or return 0;$parent->isa('PPI::Statement::Package')or return 0;my$version=$parent->schild(2)or return 0;return$version==$elem}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMAGICNUMBERS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitMismatchedOperators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMISMATCHEDOPERATORS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitMismatchedOperators;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q<Mismatched operator>;Readonly::Scalar my$EXPL=>q<Numeric/string operators and operands should match>;Readonly::Hash my%TOKEN_COMPATIBILITY=>('PPI::Token::Number'=>[$TRUE,$FALSE],'PPI::Token::Symbol'=>[$TRUE,$TRUE ],'PPI::Token::Quote'=>[$FALSE,$TRUE ],);Readonly::Hash my%FILE_OPERATOR_COMPATIBILITY=>map {;"-$_"=>[$TRUE,$FALSE]}qw<r w x o R W X O e z s f d l p S b c t u g k T B M A>;Readonly::Scalar my$TOKEN_COMPATIBILITY_INDEX_NUMERIC=>0;Readonly::Scalar my$TOKEN_COMPATIBILITY_INDEX_STRING=>1;Readonly::Hash my%OPERATOR_TYPES=>((map {$_=>$TOKEN_COMPATIBILITY_INDEX_NUMERIC}qw[== != > >= < <= + - * / += -= *= /=]),map {$_=>$TOKEN_COMPATIBILITY_INDEX_STRING}qw<eq ne lt gt le ge . .=>,);sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw<core bugs certrule>}sub applies_to {return 'PPI::Token::Operator'}sub violates {my ($self,$elem)=@_;my$elem_text=$elem->content();return if not exists$OPERATOR_TYPES{$elem_text};my$leading_operator=$self->_get_potential_leading_operator($elem)or return;my$next_elem=$elem->snext_sibling()or return;if ($next_elem->isa('PPI::Token::Operator')){$elem_text .= $next_elem->content();$next_elem=$next_elem->snext_sibling()}return if not exists$OPERATOR_TYPES{$elem_text};my$operator_type=$OPERATOR_TYPES{$elem_text};my$leading_operator_compatibility=$self->_get_token_compatibility($leading_operator);my$next_compatibility=$self->_get_token_compatibility($next_elem);return if (!defined$leading_operator_compatibility || $leading_operator_compatibility->[$operator_type])&& (!defined$next_compatibility || $next_compatibility->[$operator_type]);return if $operator_type && defined$leading_operator_compatibility &&!$leading_operator_compatibility->[$operator_type]&& $self->_have_stringy_x($leading_operator);return$self->violation($DESC,$EXPL,$elem)}sub _get_token_compatibility {my ($self,$elem)=@_;return$FILE_OPERATOR_COMPATIBILITY{$elem->content()}if$self->_is_file_operator($elem);for my$class (keys%TOKEN_COMPATIBILITY){return$TOKEN_COMPATIBILITY{$class}if$elem->isa($class)}return}sub _have_stringy_x {my ($self,$elem)=@_;return if not $elem;my$prev_oper=$elem->sprevious_sibling()or return;return if not $prev_oper->isa('PPI::Token::Operator');return if 'x' ne $prev_oper->content();return!!$prev_oper->sprevious_sibling()}sub _get_potential_leading_operator {my ($self,$elem)=@_;my$previous_element=$elem->sprevious_sibling()or return;if ($self->_get_token_compatibility($previous_element)){my$previous_sibling=$previous_element->sprevious_sibling();if ($previous_sibling and $self->_is_file_operator($previous_sibling)){$previous_element=$previous_sibling}}return$previous_element}sub _is_file_operator {my ($self,$elem)=@_;return if not $elem;return if not $elem->isa('PPI::Token::Operator');return!!$FILE_OPERATOR_COMPATIBILITY{$elem->content()}}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMISMATCHEDOPERATORS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitMixedBooleanOperators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMIXEDBOOLEANOPERATORS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitMixedBooleanOperators;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Hash my%LOW_BOOLEANS=>hashify(qw(not or and));Readonly::Hash my%HIGH_BOOLEANS=>hashify(qw(! || && ||= &&= //=));Readonly::Hash my%EXEMPT_TYPES=>hashify(qw(PPI::Statement::Block PPI::Statement::Scheduled PPI::Statement::Package PPI::Statement::Include PPI::Statement::Sub PPI::Statement::Variable PPI::Statement::Compound PPI::Statement::Data PPI::Statement::End));Readonly::Scalar my$DESC=>q{Mixed high and low-precedence booleans};Readonly::Scalar my$EXPL=>[70 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs pbp certrec)}sub applies_to {return 'PPI::Statement'}sub violates {my ($self,$elem,undef)=@_;return if exists$EXEMPT_TYPES{ref$elem };if ($elem->find_first(\&_low_boolean)&& $elem->find_first(\&_high_boolean)){return$self->violation($DESC,$EXPL,$elem)}return}sub _low_boolean {my (undef,$elem)=@_;return if$elem->isa('PPI::Statement');$elem->isa('PPI::Token::Operator')|| return 0;return exists$LOW_BOOLEANS{$elem}}sub _high_boolean {my (undef,$elem)=@_;return if$elem->isa('PPI::Statement');$elem->isa('PPI::Token::Operator')|| return 0;return exists$HIGH_BOOLEANS{$elem}}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMIXEDBOOLEANOPERATORS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitNoisyQuotes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITNOISYQUOTES';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitNoisyQuotes;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$NOISE_RX=>qr{\A ["']  [^ \w () {} [\] <> ]{1,2}  ['"] \z}xms;Readonly::Scalar my$DESC=>q{Quotes used with a noisy string};Readonly::Scalar my$EXPL=>[53 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return qw(PPI::Token::Quote::Double PPI::Token::Quote::Single)}sub violates {my ($self,$elem,undef)=@_;return if$elem !~ $NOISE_RX;my$statement=$elem->statement;return if$statement && $statement->isa('PPI::Statement::Include')&& $statement->type eq 'use' && $statement->module eq 'overload';return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITNOISYQUOTES

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitQuotesAsQuotelikeOperatorDelimiters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITQUOTESASQUOTELIKEOPERATORDELIMITERS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitQuotesAsQuotelikeOperatorDelimiters;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:booleans :characters :severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Hash my%DESCRIPTIONS=>($QUOTE=>q{Single-quote used as quote-like operator delimiter},$DQUOTE=>q{Double-quote used as quote-like operator delimiter},$BACKTICK=>q{Back-quote (back-tick) used as quote-like operator delimiter},);Readonly::Scalar my$EXPL=>q{Using quotes as delimiters for quote-like operators obfuscates code};Readonly::Array my@OPERATORS=>qw{m q qq qr qw qx s tr y};Readonly::Hash my%INFO_RETRIEVERS_BY_PPI_CLASS=>('PPI::Token::Quote::Literal'=>\&_info_for_single_character_operator,'PPI::Token::Quote::Interpolate'=>\&_info_for_two_character_operator,'PPI::Token::QuoteLike::Command'=>\&_info_for_two_character_operator,'PPI::Token::QuoteLike::Regexp'=>\&_info_for_two_character_operator,'PPI::Token::QuoteLike::Words'=>\&_info_for_two_character_operator,'PPI::Token::Regexp::Match'=>\&_info_for_match,'PPI::Token::Regexp::Substitute'=>\&_info_for_single_character_operator,'PPI::Token::Regexp::Transliterate'=>\&_info_for_transliterate,);sub supported_parameters {return ({name=>'single_quote_allowed_operators',description=>'The operators to allow single-quotes as delimiters for.',default_string=>'m s qr qx',behavior=>'enumeration',enumeration_values=>[@OPERATORS ],enumeration_allow_multiple_values=>1,},{name=>'double_quote_allowed_operators',description=>'The operators to allow double-quotes as delimiters for.',default_string=>$EMPTY,behavior=>'enumeration',enumeration_values=>[@OPERATORS ],enumeration_allow_multiple_values=>1,},{name=>'back_quote_allowed_operators',description=>'The operators to allow back-quotes (back-ticks) as delimiters for.',default_string=>$EMPTY,behavior=>'enumeration',enumeration_values=>[@OPERATORS ],enumeration_allow_multiple_values=>1,},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance)}sub applies_to {return qw{PPI::Token::Quote::Interpolate PPI::Token::Quote::Literal PPI::Token::QuoteLike::Command PPI::Token::QuoteLike::Regexp PPI::Token::QuoteLike::Words PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::Regexp::Transliterate}}sub initialize_if_enabled {my ($self,$config)=@_;$self->{_allowed_operators_by_delimiter}={$QUOTE=>$self->_single_quote_allowed_operators(),$DQUOTE=>$self->_double_quote_allowed_operators(),$BACKTICK=>$self->_back_quote_allowed_operators(),};return$TRUE}sub _single_quote_allowed_operators {my ($self)=@_;return$self->{_single_quote_allowed_operators}}sub _double_quote_allowed_operators {my ($self)=@_;return$self->{_double_quote_allowed_operators}}sub _back_quote_allowed_operators {my ($self)=@_;return$self->{_back_quote_allowed_operators}}sub _allowed_operators_by_delimiter {my ($self)=@_;return$self->{_allowed_operators_by_delimiter}}sub violates {my ($self,$elem,undef)=@_;my$info_retriever=$INFO_RETRIEVERS_BY_PPI_CLASS{ref$elem };return if not $info_retriever;my ($operator,$delimiter)=$info_retriever->($elem);my$allowed_operators=$self->_allowed_operators_by_delimiter()->{$delimiter};return if not $allowed_operators;if (not $allowed_operators->{$operator}){return$self->violation($DESCRIPTIONS{$delimiter},$EXPL,$elem)}return}sub _info_for_single_character_operator {my ($elem)=@_;return (substr ($elem,0,1),substr ($elem,1,1))}sub _info_for_two_character_operator {my ($elem)=@_;return (substr ($elem,0,2),substr ($elem,2,1))}sub _info_for_match {my ($elem)=@_;if ($elem =~ m/ ^ m /xms){return ('m',substr$elem,1,1)}return ('m',q{/})}sub _info_for_transliterate {my ($elem)=@_;if ($elem =~ m/ ^ tr /xms){return ('tr',substr$elem,2,1)}return ('y',substr$elem,1,1)}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITQUOTESASQUOTELIKEOPERATORDELIMITERS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitSpecialLiteralHeredocTerminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITSPECIALLITERALHEREDOCTERMINATOR';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitSpecialLiteralHeredocTerminator;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Hash my%SPECIAL_LITERAL=>map {'__' .$_ .'__'=>1}qw(FILE LINE PACKAGE END DATA);Readonly::Scalar my$DESC=>q{Heredoc terminator must not be a special literal};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Token::HereDoc'}sub violates {my ($self,$elem,undef)=@_;(my$heredoc_terminator=$elem)=~ s{ \A << \s* (["']?) (.*) \1 \z }{$2}xms;if ($SPECIAL_LITERAL{$heredoc_terminator }){my$expl=qq{Used "$heredoc_terminator" as heredoc terminator};return$self->violation($DESC,$expl,$elem)}return}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITSPECIALLITERALHEREDOCTERMINATOR

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitVersionStrings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITVERSIONSTRINGS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitVersionStrings;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Version string used};Readonly::Scalar my$EXPL=>q{Use a real number instead};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Statement::Include'}sub violates {my ($self,$elem,undef)=@_;my$version;if (my$module=$elem->module()){return if$module eq 'lib';$version=$elem->module_version()}else {$version=$elem->schild(1)}return if not defined$version;return if not $version->isa('PPI::Token::Number::Version');return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITVERSIONSTRINGS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireConstantVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIRECONSTANTVERSION';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireConstantVersion;use 5.006001;use strict;use warnings;use Carp;use English qw(-no_match_vars);use Perl::Critic::Utils qw<:booleans :characters :classification :data_conversion :language :severities>;use Perl::Critic::Utils::PPI qw{is_ppi_constant_element get_next_element_in_same_simple_statement get_previous_module_used_on_same_line};use Readonly;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$BIND_REGEX=>q<=~>;Readonly::Scalar my$DOLLAR=>q<$>;Readonly::Scalar my$QV=>q<qv>;Readonly::Scalar my$VERSION_MODULE=>q<version>;Readonly::Scalar my$VERSION_VARIABLE=>$DOLLAR .q<VERSION>;Readonly::Hash my%OPERATOR_WHICH_MAKES_NEW_VALUE=>hashify(qw{= . + - * ** / % ^ ~ & | > < == != >= <= eq ne gt lt ge le});Readonly::Scalar my$DESC=>$DOLLAR .q<VERSION value must be a constant>;Readonly::Scalar my$EXPL=>qq<Computed ${DOLLAR}VERSION may tie the code to a single repository, or cause spooky action from a distance>;sub supported_parameters {return ({name=>'allow_version_without_use_on_same_line',description=>q{Allow qv() and version->new() without a 'use version' on the same line.},default_string=>$FALSE,behavior=>'boolean',})}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core maintenance)}sub applies_to {return 'PPI::Token::Symbol'}sub violates {my ($self,$elem,$doc)=@_;return if$VERSION_VARIABLE ne $elem->content();my$operator;return if not $operator=get_next_element_in_same_simple_statement($elem);return$self->violation($DESC,$EXPL,$elem)if$self->_validate_operator_bind_regex($operator,$elem);return if not $operator=_check_for_assignment_operator($operator);my$value;return if not $value=$operator->snext_sibling();return if $value->isa('PPI::Token::Symbol')and $value->content()eq $VERSION_VARIABLE;$value=$self->_validate_word_token($elem,$value);return$value if$value->isa('Perl::Critic::Exception');return$self->violation($DESC,$EXPL,$elem)if not is_ppi_constant_element($value);my$structure;return if not $structure=get_next_element_in_same_simple_statement($value);return if$SCOLON eq $structure->content();return$self->violation($DESC,$EXPL,$elem)}sub _check_for_assignment_operator {my ($operator)=@_;return if not $operator->isa('PPI::Token::Operator');return$operator if is_assignment_operator($operator->content());return}sub _validate_operator_bind_regex {my ($self,$operator,$elem)=@_;return if$BIND_REGEX ne $operator->content();my$operand;return if not $operand=$operator->snext_sibling();return if not $operand->isa('PPI::Token::Regexp::Substitute');return$TRUE if$elem->snext_sibling();my$containing_list;$containing_list=$elem->parent()and $containing_list->isa('PPI::Statement')and $containing_list=$containing_list->parent()and $containing_list->isa('PPI::Structure::List')or return$TRUE;my$prior=$elem->sprevious_sibling()or return$TRUE;return if$prior->isa('PPI::Token::Operator')&& $OPERATOR_WHICH_MAKES_NEW_VALUE{$prior->content()};my$current=$prior;while($prior=$current->sprevious_sibling()){$prior->isa('PPI::Token::Word')or next;is_function_call($prior)or next;$current->isa('PPI::Structure::List')or return}continue {$current=$prior}$prior=$containing_list->sprevious_sibling()or return$TRUE;if ($prior->isa('PPI::Token::Word')){return if is_method_call($prior);return if is_function_call($prior)}return$TRUE}sub _validate_word_token {my ($self,$elem,$value)=@_;if ($value->isa('PPI::Token::Word')){my$content=$value->content();if ($content =~ m/ \A v \d+ \z /smx){$value=$self->_validate_word_vstring($elem,$value)}elsif ($QV eq $content){$value=$self->_validate_word_qv($elem,$value)}elsif ($VERSION_MODULE eq $content){$value=$self->_validate_word_version($elem,$value)}}return$value}sub _validate_word_vstring {my ($self,$elem,$value)=@_;my$next;return$self->violation($DESC,$EXPL,$elem)if not $next=$value->snext_sibling()or not $next->isa('PPI::Token::Number');return$next}sub _validate_word_qv {my ($self,$elem,$value)=@_;$self->{_allow_version_without_use_on_same_line}or do {my$module;return$self->violation($DESC,$EXPL,$elem)if not $module=get_previous_module_used_on_same_line($value);return$self->violation($DESC,$EXPL,$elem)if$VERSION_MODULE ne $module->content()};my$next;return$self->violation($DESC,$EXPL,$elem)if not ($next=$value->snext_sibling()and $next->isa('PPI::Structure::List')and $next=$next->schild(0)and $next->isa('PPI::Statement::Expression')and $next=$next->schild(0));return$next}sub _validate_word_version {my ($self,$elem,$value)=@_;$self->{_allow_version_without_use_on_same_line}or do {my$module;return$self->violation($DESC,$EXPL,$elem)if not $module=get_previous_module_used_on_same_line($value);return$self->violation($DESC,$EXPL,$elem)if$VERSION_MODULE ne $module->content()};my$next;return$next if $next=$value->snext_sibling()and $next->isa('PPI::Token::Operator')and q{->} eq $next->content()and $next=$next->snext_sibling()and $next->isa('PPI::Token::Word')and q{new} eq $next->content()and $next=$next->snext_sibling()and $next->isa('PPI::Structure::List')and $next=$next->schild(0)and $next->isa('PPI::Statement::Expression')and $next=$next->schild(0);return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIRECONSTANTVERSION

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireInterpolationOfMetachars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREINTERPOLATIONOFMETACHARS';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireInterpolationOfMetachars;use 5.006001;use strict;use warnings;use Readonly;use Email::Address;use Perl::Critic::Utils qw<:booleans :characters :severities>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q<String *may* require interpolation>;Readonly::Scalar my$EXPL=>[51 ];sub supported_parameters {return ({name=>'rcs_keywords',description=>'RCS keywords to ignore in potential interpolation.',default_string=>$EMPTY,behavior=>'string list',},)}sub default_severity {return$SEVERITY_LOWEST}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return qw<PPI::Token::Quote::Single PPI::Token::Quote::Literal>}sub initialize_if_enabled {my ($self,$config)=@_;my$rcs_keywords=$self->{_rcs_keywords};my@rcs_keywords=keys %{$rcs_keywords};if (@rcs_keywords){my$rcs_regexes=[map {qr/ \$ $_ [^\n\$]* \$ /xms}@rcs_keywords ];$self->{_rcs_regexes}=$rcs_regexes}return$TRUE}sub violates {my ($self,$elem,undef)=@_;my$string=$elem->string();return if not _needs_interpolation($string);return if _looks_like_email_address($string);return if _looks_like_use_vars($elem);my$rcs_regexes=$self->{_rcs_regexes};return if$rcs_regexes and _contains_rcs_variable($string,$rcs_regexes);return$self->violation($DESC,$EXPL,$elem)}sub _needs_interpolation {my ($string)=@_;return $string =~ m< [\$\@] (?! [{] [}] ) \S+ >xms || $string =~ m<
                  (?: \A | [^\\] )
                  (?: \\{2} )*
                  \\ [tnrfbae01234567xcNluLUEQ]
              >xms}sub _looks_like_email_address {my ($string)=@_;return if index ($string,q<@>)< 0;return if$string =~ m< \W \@ >xms;return if$string =~ m< \A \@ \w+ \b >xms;return$string =~ $Email::Address::addr_spec}sub _contains_rcs_variable {my ($string,$rcs_regexes)=@_;for my$regex (@{$rcs_regexes}){return$TRUE if$string =~ m/$regex/xms}return}sub _looks_like_use_vars {my ($elem)=@_;my$statement=$elem;while (not $statement->isa('PPI::Statement::Include')){$statement=$statement->parent()or return}return if$statement->type()ne q<use>;return$statement->module()eq q<vars>}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREINTERPOLATIONOFMETACHARS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireNumberSeparators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIRENUMBERSEPARATORS';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireNumberSeparators;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Long number not separated with underscores};Readonly::Scalar my$EXPL=>[59 ];Readonly::Scalar my$MINIMUM_INTEGER_WITH_MULTIPLE_DIGITS=>10;sub supported_parameters {return ({name=>'min_value',description=>'The minimum absolute value to require separators in.',default_string=>'10_000',behavior=>'integer',integer_minimum=>$MINIMUM_INTEGER_WITH_MULTIPLE_DIGITS,},)}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::Number'}sub violates {my ($self,$elem,undef)=@_;my$min=$self->{_min_value};return if$elem !~ m{ \d{4} }xms;return if abs$elem->literal()< $min;return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIRENUMBERSEPARATORS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireQuotedHeredocTerminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREQUOTEDHEREDOCTERMINATOR';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireQuotedHeredocTerminator;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$HEREDOC_RX=>qr/ \A << \s* ["'] .* ['"] \z /xms;Readonly::Scalar my$DESC=>q{Heredoc terminator must be quoted};Readonly::Scalar my$EXPL=>[64 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Token::HereDoc'}sub violates {my ($self,$elem,undef)=@_;if ($elem !~ $HEREDOC_RX){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREQUOTEDHEREDOCTERMINATOR

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireUpperCaseHeredocTerminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREUPPERCASEHEREDOCTERMINATOR';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$HEREDOC_RX=>qr{ \A << \s* (["']?) [[:upper:]_] [[:upper:]\d_]* \1 \z }xms;Readonly::Scalar my$DESC=>q{Heredoc terminator not alphanumeric and upper-case};Readonly::Scalar my$EXPL=>[64 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp cosmetic)}sub applies_to {return 'PPI::Token::HereDoc'}sub violates {my ($self,$elem,undef)=@_;if ($elem !~ $HEREDOC_RX){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREUPPERCASEHEREDOCTERMINATOR

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitAugmentedAssignmentInDeclaration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITAUGMENTEDASSIGNMENTINDECLARATION';
  package Perl::Critic::Policy::Variables::ProhibitAugmentedAssignmentInDeclaration;use 5.006001;use strict;use warnings;use List::MoreUtils qw{firstval};use Readonly;use Perl::Critic::Utils qw{:severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Augmented assignment operator '%s' used in declaration};Readonly::Scalar my$EXPL=>q{Use simple assignment when initializing variables};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Statement::Variable'}my%augmented_assignments=hashify(qw(**= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //=));sub violates {my ($self,$elem,undef)=@_;my$found=firstval {$_->isa('PPI::Token::Operator')}$elem->children();if ($found){my$op=$found->content();if (exists$augmented_assignments{$op }){return$self->violation(sprintf($DESC,$op),$EXPL,$found)}}return}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITAUGMENTEDASSIGNMENTINDECLARATION

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitConditionalDeclarations.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITCONDITIONALDECLARATIONS';
  package Perl::Critic::Policy::Variables::ProhibitConditionalDeclarations;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Variable declared in conditional statement};Readonly::Scalar my$EXPL=>q{Declare variables outside of the condition};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Statement::Variable'}sub violates {my ($self,$elem,undef)=@_;return if$elem->type()eq 'local';if ($elem->find(\&_is_conditional)){return$self->violation($DESC,$EXPL,$elem)}return}my@conditionals=qw(if while foreach for until unless);my%conditionals=hashify(@conditionals);sub _is_conditional {my (undef,$elem)=@_;return if!$conditionals{$elem};return if!$elem->isa('PPI::Token::Word');return if is_hash_key($elem);return if is_method_call($elem);return 1}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITCONDITIONALDECLARATIONS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitEvilVariables.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITEVILVARIABLES';
  package Perl::Critic::Policy::Variables::ProhibitEvilVariables;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue qw{throw_policy_value};use Perl::Critic::Utils qw{:characters :severities :data_conversion};use Perl::Critic::Utils::DataConversion qw{dor};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Find an alternative variable};Readonly::Hash my%SUBSCRIPTED_TYPE=>hashify(qw{@ %});Readonly::Scalar my$VARIABLE_NAME_REGEX=>qr< [\$\@%] \S+ >xms;Readonly::Scalar my$REGULAR_EXPRESSION_REGEX=>qr< [/] ( [^/]+ ) [/] >xms;Readonly::Array my@DESCRIPTION_REGEXES=>qr< [{] ( [^}]+ ) [}] >xms,qr{  <  ( [^>]+ )  >  }xms,qr{ [[] ( [^]]+ ) []] }xms,qr{ [(] ( [^)]+ ) [)] }xms,;Readonly::Scalar my$DESCRIPTION_REGEX=>qr< @{[join '|', @DESCRIPTION_REGEXES]} >xms;Readonly::Scalar my$VARIABLES_REGEX=>qr<
          \A
          \s*
          (?:
                  ( $VARIABLE_NAME_REGEX )
              |   $REGULAR_EXPRESSION_REGEX
          )
          (?: \s* $DESCRIPTION_REGEX )?
          \s*
      >xms;Readonly::Scalar my$VARIABLES_FILE_LINE_REGEX=>qr<
          \A
          \s*
          (?:
                  ( $VARIABLE_NAME_REGEX )
              |   $REGULAR_EXPRESSION_REGEX
          )
          \s*
          ( \S (?: .* \S )? )?
          \s*
          \z
      >xms;Readonly::Scalar my$INDEX_REGEX=>0;Readonly::Scalar my$INDEX_DESCRIPTION=>1;sub supported_parameters {return ({name=>'variables',description=>'The names of or patterns for variables to forbid.',default_string=>$EMPTY,parser=>\&_parse_variables,},{name=>'variables_file',description=>'A file containing names of or patterns for variables to forbid.',default_string=>$EMPTY,parser=>\&_parse_variables_file,},)}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core bugs)}sub applies_to {return qw{PPI::Token::Symbol}}sub _parse_variables {my ($self,$parameter,$config_string)=@_;return if not $config_string;return if$config_string =~ m< \A \s* \z >xms;my$variable_specifications=$config_string;while (my ($variable,$regex_string,@descrs)=$variable_specifications =~ m< $VARIABLES_REGEX >xms){substr$variable_specifications,0,$LAST_MATCH_END[0],$EMPTY;my$description=dor(@descrs);$self->_handle_variable_specification(variable=>$variable,regex_string=>$regex_string,description=>$description,option_name=>'variables',option_value=>$config_string,)}if ($variable_specifications){throw_policy_value policy=>$self->get_short_name(),option_name=>'variables',option_value=>$config_string,message_suffix=>qq{contains unparseable data: "$variable_specifications"}}return}sub _parse_variables_file {my ($self,$parameter,$config_string)=@_;return if not $config_string;return if$config_string =~ m< \A \s* \z >xms;open my$handle,'<',$config_string or throw_policy_value policy=>$self->get_short_name(),option_name=>'variables_file',option_value=>$config_string,message_suffix=>qq<refers to a file that could not be opened: $OS_ERROR>;while (my$line=<$handle>){$self->_handle_variable_specification_on_line($line,$config_string)}close$handle or warn qq<Could not close "$config_string": $OS_ERROR\n>;return}sub _handle_variable_specification_on_line {my ($self,$line,$config_string)=@_;$line =~ s< [#] .* \z ><>xms;$line =~ s< \s+ \z ><>xms;$line =~ s< \A \s+ ><>xms;return if not $line;if (my ($variable,$regex_string,$description)=$line =~ m< $VARIABLES_FILE_LINE_REGEX >xms){$self->_handle_variable_specification(variable=>$variable,regex_string=>$regex_string,description=>$description,option_name=>'variables_file',option_value=>$config_string,)}else {throw_policy_value policy=>$self->get_short_name(),option_name=>'variables_file',option_value=>$config_string,message_suffix=>qq{contains unparseable data: "$line"}}return}sub _handle_variable_specification {my ($self,%arguments)=@_;my$description=$arguments{description}|| $EMPTY;if (my$regex_string=$arguments{regex_string}){my$actual_regex;eval {$actual_regex=qr/$regex_string/sm;1}or throw_policy_value policy=>$self->get_short_name(),option_name=>$arguments{option_name},option_value=>$arguments{option_value},message_suffix=>qq{contains an invalid regular expression: "$regex_string"};push @{$self->{_evil_variables_regexes}||= []},[$actual_regex,$description ]}else {$self->{_evil_variables}||= {};my$name=$arguments{variable};$self->{_evil_variables}{$name}=$description}return}sub initialize_if_enabled {my ($self,$config)=@_;return exists$self->{_evil_variables}|| exists$self->{_evil_variables_regexes}}sub violates {my ($self,$elem,undef)=@_;return if not $elem;my@names=$self->_compute_symbol_names($elem)or return;my$evil_variables=$self->{_evil_variables};my$evil_variables_regexes=$self->{_evil_variables_regexes};for my$variable (@names){exists$evil_variables->{$variable}and return$self->_make_violation($variable,$evil_variables->{$variable},$elem,)}for my$variable (@names){for my$regex (@{$evil_variables_regexes}){$variable =~ $regex->[$INDEX_REGEX]and return$self->_make_violation($variable,$regex->[$INDEX_DESCRIPTION],$elem,)}}return}sub _compute_symbol_names {my ($self,$elem)=@_;my@names;my$name=$elem->symbol();push@names,$name;if ($SUBSCRIPTED_TYPE{$elem->symbol_type()}){$name=$elem->content();my$next=$elem->snext_sibling();my@subscr;while ($next and $next->isa('PPI::Structure::Subscript')){push@subscr,$next->content();$next=$next->snext_sibling()}if (@subscr){push@names,join$EMPTY,$name,@subscr}}return@names}sub _make_violation {my ($self,$variable,$description,$elem)=@_;return$self->violation($description || qq<Prohibited variable "$variable" used>,$EXPL,$elem,)}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITEVILVARIABLES

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitLocalVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITLOCALVARS';
  package Perl::Critic::Policy::Variables::ProhibitLocalVars;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$PACKAGE_RX=>qr/::/xms;Readonly::Scalar my$DESC=>q{Variable declared as "local"};Readonly::Scalar my$EXPL=>[77,78,79 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return 'PPI::Statement::Variable'}sub violates {my ($self,$elem,undef)=@_;if ($elem->type()eq 'local' &&!_all_global_vars($elem)){return$self->violation($DESC,$EXPL,$elem)}return}sub _all_global_vars {my$elem=shift;for my$variable_name ($elem->variables()){next if$variable_name =~ $PACKAGE_RX;next if$variable_name eq '$TODO';return if!is_perl_global($variable_name)}return 1}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITLOCALVARS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitMatchVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITMATCHVARS';
  package Perl::Critic::Policy::Variables::ProhibitMatchVars;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Match variable used};Readonly::Scalar my$EXPL=>[82 ];Readonly::Array my@FORBIDDEN=>qw($` $& $' $MATCH $PREMATCH $POSTMATCH);Readonly::Hash my%FORBIDDEN=>hashify(@FORBIDDEN);sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core performance pbp)}sub applies_to {return qw(PPI::Token::Symbol PPI::Statement::Include)}sub violates {my ($self,$elem,undef)=@_;if (_is_use_english($elem)|| _is_forbidden_var($elem)){return$self->violation($DESC,$EXPL,$elem)}return}sub _is_use_english {my$elem=shift;$elem->isa('PPI::Statement::Include')|| return;$elem->type()eq 'use' || return;$elem->module()eq 'English' || return;return 0 if ($elem =~ m/\A use \s+ English \s* ;\z/xms);return 1 if ($elem =~ m/\$(?:PRE|POST|)MATCH/xms);return}sub _is_forbidden_var {my$elem=shift;$elem->isa('PPI::Token::Symbol')|| return;return exists$FORBIDDEN{$elem}}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITMATCHVARS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitPackageVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITPACKAGEVARS';
  package Perl::Critic::Policy::Variables::ProhibitPackageVars;use 5.006001;use strict;use warnings;use Readonly;use Carp qw(carp);use List::MoreUtils qw(all);use Perl::Critic::Utils qw{:booleans :characters :severities :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Package variable declared or used};Readonly::Scalar my$EXPL=>[73,75 ];sub supported_parameters {return ({name=>'packages',description=>'The base set of packages to allow variables for.',default_string=>'Data::Dumper File::Find FindBin Log::Log4perl',behavior=>'string list',},{name=>'add_packages',description=>'The set of packages to allow variables for, in addition to those given in "packages".',default_string=>$EMPTY,behavior=>'string list',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp maintenance)}sub applies_to {return qw(PPI::Token::Symbol PPI::Statement::Variable PPI::Statement::Include)}sub initialize_if_enabled {my ($self,$config)=@_;$self->{_all_packages}={hashify keys %{$self->{_packages}},keys %{$self->{_add_packages}}};return$TRUE}sub violates {my ($self,$elem,undef)=@_;if ($self->_is_package_var($elem)|| _is_our_var($elem)|| _is_vars_pragma($elem)){return$self->violation($DESC,$EXPL,$elem)}return}sub _is_package_var {my$self=shift;my$elem=shift;return if!$elem->isa('PPI::Token::Symbol');my ($package,$name)=$elem =~ m{ \A [@\$%] (.*) :: (\w+) \z }xms;return if not defined$package;return if _all_upcase($name);return if$self->{_all_packages}->{$package};return 1}sub _is_our_var {my$elem=shift;return if not $elem->isa('PPI::Statement::Variable');return if$elem->type()ne 'our';return if _all_upcase($elem->variables());return 1}sub _is_vars_pragma {my$elem=shift;return if!$elem->isa('PPI::Statement::Include');return if$elem->pragma()ne 'vars';my@varnames=$elem =~ m{ [@\$%&] (\w+) }gxms;return if!@varnames;return if _all_upcase(@varnames);return 1}sub _all_upcase {return all {$_ eq uc $_}@_}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITPACKAGEVARS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitPerl4PackageNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITPERL4PACKAGENAMES';
  package Perl::Critic::Policy::Variables::ProhibitPerl4PackageNames;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :severities :classification};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q{Use double colon (::) to separate package name components instead of single quotes (')};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw(core maintenance certrec)}sub applies_to {return qw(PPI::Token::Word PPI::Token::Symbol)}sub violates {my ($self,$elem,undef)=@_;my$content=$elem->content();if ((index$content,$QUOTE)< 0){return}if ($content =~ m< \A [\$@%&*] ' \z >xms){return}if ($elem->isa('PPI::Token::Word')&& is_hash_key($elem)){return}return $self->violation(qq{"$content" uses the obsolete single quote package separator.},$EXPL,$elem)}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITPERL4PACKAGENAMES

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitPunctuationVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITPUNCTUATIONVARS';
  package Perl::Critic::Policy::Variables::ProhibitPunctuationVars;use 5.006001;use strict;use warnings;use Readonly;use English qw<-no_match_vars>;use PPI::Token::Magic;use Perl::Critic::Utils qw<:characters :severities :data_conversion :booleans>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q<Magic punctuation variable %s used>;Readonly::Scalar my$EXPL=>[79];sub supported_parameters {return ({name=>'allow',description=>'The additional variables to allow.',default_string=>$EMPTY,behavior=>'string list',list_always_present_values=>[qw<$_ @_ $1 $2 $3 $4 $5 $6 $7 $8 $9 _ $]> ],},{name=>'string_mode',description=>'Controls checking interpolated strings for punctuation variables.',default_string=>'thorough',behavior=>'enumeration',enumeration_values=>[qw<simple disable thorough> ],enumeration_allow_multiple_values=>0,},)}sub default_severity {return$SEVERITY_LOW}sub default_themes {return qw<core pbp cosmetic>}sub applies_to {return qw<PPI::Token::Magic PPI::Token::Quote::Double PPI::Token::Quote::Interpolate PPI::Token::QuoteLike::Command PPI::Token::QuoteLike::Backtick PPI::Token::QuoteLike::Regexp PPI::Token::QuoteLike::Readline PPI::Token::HereDoc>}Readonly::Array my@MAGIC_VARIABLES=>qw{$1 $2 $3 $4 $5 $6 $7 $8 $9 $_ $& $` $' $+ @+ %+ $* $. $/ $| $\\ $" $; $% $= $- @- %- $) $~ $^ $: $? $! %! $@ $$ $< $> $( $0 $[ $] @_ @* $^L $^A $^E $^C $^D $^F $^H $^I $^M $^N $^O $^P $^R $^S $^T $^V $^W $^X %^H $::|},q<$}>,q<$,>,q<$#>,q<$#+>,q<$#->;Readonly::Scalar my$MAGIC_REGEX=>_create_magic_detector();Readonly::Array my@IGNORE_FOR_INTERPOLATION=>(q{$'},q{$$},q{$#},q{$:},);sub violates {my ($self,$elem,undef)=@_;if ($elem->isa('PPI::Token::Magic')){return _violates_magic($self,$elem)}elsif ($elem->isa('PPI::Token::HereDoc')){return _violates_heredoc($self,$elem)}return _violates_string($self,$elem)}sub _violates_magic {my ($self,$elem,undef)=@_;if (!exists$self->{_allow}->{$elem}){return$self->_make_violation($DESC,$EXPL,$elem)}return}sub _violates_string {my ($self,$elem,undef)=@_;my$string;if ($elem->can('string')){$string=$elem->string()}else {$string=$elem->content();$string =~ s/ \A \w* \s* . //smx;chop$string}my%matches=_strings_helper($self,$string);if (%matches){my$DESC=qq<$DESC in interpolated string>;return$self->_make_violation($DESC,$EXPL,$elem,\%matches)}return}sub _violates_heredoc {my ($self,$elem,undef)=@_;if ($elem->{_mode}eq 'interpolate' or $elem->{_mode}eq 'command'){my$heredoc_string=join "\n",$elem->heredoc();my%matches=_strings_helper($self,$heredoc_string);if (%matches){my$DESC=qq<$DESC in interpolated here-document>;return$self->_make_violation($DESC,$EXPL,$elem,\%matches)}}return}sub _strings_helper {my ($self,$target_string,undef)=@_;return if ($self->{_string_mode}eq 'disable');return _strings_thorough($self,$target_string)if$self->{_string_mode}eq 'thorough';my@raw_matches=map {_unbracket_variable_name($_)}$target_string =~ m/$MAGIC_REGEX/goxms;return if not @raw_matches;my%matches=hashify(@raw_matches);delete@matches{keys %{$self->{_allow}}};delete@matches{@IGNORE_FOR_INTERPOLATION};return%matches}sub _strings_thorough {my ($self,$target_string,undef)=@_;my%matches;MATCH: while (my ($match)=$target_string =~ m/$MAGIC_REGEX/gcxms){my$nextchar=substr$target_string,$LAST_MATCH_END[0],1;my$vname=_unbracket_variable_name($match);my$c=$vname .$nextchar;if ($c =~ m/ ^  \$  .*  [  \w  :  \$  {  ]  $ /xms){if ($c =~ m/ ^(\$(?:\_[\w:]|::)) /xms or $c =~ m/ ^\$\'[\w] /xms){next MATCH if$c !~ m/ ^\$\'\d$ /xms}next MATCH if$c =~ m/ ^\$\$\w /xms;next MATCH if$c eq '$#$' or $c eq '$#{';next MATCH if$c =~ m/ ^(\$\#)\w /xms ;next MATCH if$c =~ m/ ^ \$ \# [{] /xms}$matches{$vname}=1}delete@matches{keys %{$self->{_allow}}};return%matches}sub _bracketed_form_of_variable_name {my ($name)=@_;length$name > 1 or return ($name);my$brktd=$name;substr$brktd,1,0,'{';$brktd .= '}';return($name,$brktd)}sub _unbracket_variable_name {my ($name)=@_;$name =~ m/ \A ( . ) [{] ( .+ ) [}] \z /smx and return "$1$2";return$name}sub _create_magic_detector {my ($config)=@_;my$magic_alternation='(?:' .(join q<|>,map {quotemeta}reverse sort {length$a <=> length$b}map {_bracketed_form_of_variable_name($_)}grep {q<%> ne substr $_,0,1}@MAGIC_VARIABLES).')';return qr<
          (?: \A | [^\\] )       # beginning-of-string or any non-backslash
          (?: \\{2} )*           # zero or more double-backslashes
          ( $magic_alternation ) # any magic punctuation variable
      >xsm}sub _make_violation {my ($self,$desc,$expl,$elem,$vars)=@_;my$vname='HASH' eq ref$vars ? join ', ',sort keys %{$vars}: $elem->content();return$self->violation(sprintf($desc,$vname),$expl,$elem)}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITPUNCTUATIONVARS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitReusedNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITREUSEDNAMES';
  package Perl::Critic::Policy::Variables::ProhibitReusedNames;use 5.006001;use strict;use warnings;use List::MoreUtils qw(part);use Readonly;use Perl::Critic::Utils qw{:severities :classification :data_conversion};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Reused variable name in lexical scope: };Readonly::Scalar my$EXPL=>q{Invent unique variable names};sub supported_parameters {return ({name=>'allow',description=>'The variables to not consider as duplicates.',default_string=>'$self $class',behavior=>'string list',},)}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core bugs)}sub applies_to {return 'PPI::Statement::Variable'}sub violates {my ($self,$elem,undef)=@_;return if 'local' eq $elem->type;my$allow=$self->{_allow};my$names=[grep {not $allow->{$_}}$elem->variables()];my$outer=$elem;my@violations;while (1){my$up=$outer->sprevious_sibling;if (not $up){$up=$outer->parent;last if!$up}$outer=$up;if ($outer->isa('PPI::Statement::Variable')&& 'local' ne $outer->type){my%vars=map {$_=>undef}$outer->variables;my$hits;($hits,$names)=part {exists$vars{$_}? 0 : 1}@{$names};if ($hits){push@violations,map {$self->violation($DESC .$_,$EXPL,$elem)}@{$hits};last if not $names}}}return@violations}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITREUSEDNAMES

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitUnusedVariables.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITUNUSEDVARIABLES';
  package Perl::Critic::Policy::Variables::ProhibitUnusedVariables;use 5.006001;use strict;use warnings;use Readonly;use List::MoreUtils qw<any>;use PPI::Token::Symbol;use Perl::Critic::Utils qw<:characters :severities>;use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$EXPL=>q<Unused variables clutter code and make it harder to read>;sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw<core maintenance certrec>}sub applies_to {return qw<PPI::Document>}sub violates {my ($self,$elem,$document)=@_;my%symbol_usage;_get_symbol_usage(\%symbol_usage,$document);_get_regexp_symbol_usage(\%symbol_usage,$document);return if not %symbol_usage;my$declarations=$document->find('PPI::Statement::Variable');return if not $declarations;my@violations;DECLARATION: foreach my$declaration (@{$declarations}){next DECLARATION if 'my' ne $declaration->type();my@children=$declaration->schildren();next DECLARATION if any {$_->content()eq q<=>}@children;VARIABLE: foreach my$variable ($declaration->variables()){my$count=$symbol_usage{$variable };next VARIABLE if not $count;next VARIABLE if$count > 1;push @violations,$self->violation(qq<"$variable" is declared but not used.>,$EXPL,$declaration,)}}return@violations}sub _get_symbol_usage {my ($symbol_usage,$document)=@_;my$symbols=$document->find('PPI::Token::Symbol');return if not $symbols;for my$symbol (@{$symbols}){$symbol_usage->{$symbol->symbol()}++}return}sub _get_regexp_symbol_usage {my ($symbol_usage,$document)=@_;for my$class (qw{PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute PPI::Token::QuoteLike::Regexp}){for my$regex (@{$document->find($class)|| []}){my$ppix=$document->ppix_regexp_from_element($regex)or next;$ppix->failures()and next;for my$code (@{$ppix->find('PPIx::Regexp::Token::Code')|| []}){my$subdoc=$code->ppi()or next;_get_symbol_usage($symbol_usage,$subdoc)}}}return}1;
PERL_CRITIC_POLICY_VARIABLES_PROHIBITUNUSEDVARIABLES

$fatpacked{"Perl/Critic/Policy/Variables/ProtectPrivateVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROTECTPRIVATEVARS';
  package Perl::Critic::Policy::Variables::ProtectPrivateVars;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Private variable used};Readonly::Scalar my$EXPL=>q{Use published APIs};sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core maintenance certrule)}sub applies_to {return 'PPI::Token::Symbol'}sub violates {my ($self,$elem,undef)=@_;if ($elem =~ m{ \w::_\w+ \z }xms){return$self->violation($DESC,$EXPL,$elem)}return}1;
PERL_CRITIC_POLICY_VARIABLES_PROTECTPRIVATEVARS

$fatpacked{"Perl/Critic/Policy/Variables/RequireInitializationForLocalVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_REQUIREINITIALIZATIONFORLOCALVARS';
  package Perl::Critic::Policy::Variables::RequireInitializationForLocalVars;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{"local" variable not initialized};Readonly::Scalar my$EXPL=>[78 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_MEDIUM}sub default_themes {return qw(core pbp bugs certrec)}sub applies_to {return 'PPI::Statement::Variable'}sub violates {my ($self,$elem,undef)=@_;if ($elem->type()eq 'local' &&!_is_initialized($elem)){return$self->violation($DESC,$EXPL,$elem)}return}sub _is_initialized {my$elem=shift;my$wanted=sub {$_[1]->isa('PPI::Token::Operator')&& $_[1]eq q{=}};return$elem->find($wanted)? 1 : 0}1;
PERL_CRITIC_POLICY_VARIABLES_REQUIREINITIALIZATIONFORLOCALVARS

$fatpacked{"Perl/Critic/Policy/Variables/RequireLexicalLoopIterators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_REQUIRELEXICALLOOPITERATORS';
  package Perl::Critic::Policy::Variables::RequireLexicalLoopIterators;use 5.006001;use strict;use warnings;use Readonly;use version ();use Perl::Critic::Utils qw{:booleans :severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Loop iterator is not lexical};Readonly::Scalar my$EXPL=>[108 ];Readonly::Scalar my$MINIMUM_PERL_VERSION=>version->new(5.004);sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGHEST}sub default_themes {return qw(core pbp bugs certrec)}sub applies_to {return 'PPI::Statement::Compound'}sub prepare_to_scan_document {my ($self,$document)=@_;my$version=$document->highest_explicit_perl_version();return!$version || $version >= $MINIMUM_PERL_VERSION}sub violates {my ($self,$elem,undef)=@_;return if$elem->type()ne 'foreach';my$first_child=$elem->schild(0);return if not $first_child;my$start=$first_child->isa('PPI::Token::Label')? 1 : 0;my$potential_scope=$elem->schild($start + 1);return if not $potential_scope;return if$potential_scope->isa('PPI::Structure::List');return if$potential_scope eq 'my';return$self->violation($DESC,$EXPL,$elem)}1;
PERL_CRITIC_POLICY_VARIABLES_REQUIRELEXICALLOOPITERATORS

$fatpacked{"Perl/Critic/Policy/Variables/RequireLocalizedPunctuationVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_REQUIRELOCALIZEDPUNCTUATIONVARS';
  package Perl::Critic::Policy::Variables::RequireLocalizedPunctuationVars;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities :classification $EMPTY hashify};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$PACKAGE_RX=>qr/::/xms;Readonly::Hash my%EXCEPTIONS=>hashify(qw($_ $ARG @_));Readonly::Scalar my$DESC=>q{Magic variable "%s" should be assigned as "local"};Readonly::Scalar my$EXPL=>[81,82 ];sub supported_parameters {return ({name=>'allow',description=>q<Global variables to exclude from this policy.>,default_string=>$EMPTY,behavior=>'string list',list_always_present_values=>[qw<$_ $ARG @_> ],},)}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core pbp bugs certrec)}sub applies_to {return 'PPI::Token::Operator'}sub violates {my ($self,$elem,undef)=@_;return if$elem->content()ne q{=};my$destination=$elem->sprevious_sibling;return if!$destination;while ($destination->isa('PPI::Structure::Subscript')){$destination=$destination->sprevious_sibling()or return}if (my$var=$self->_is_non_local_magic_dest($destination)){return$self->violation(sprintf($DESC,$var),$EXPL,$elem)}return}sub _is_non_local_magic_dest {my ($self,$elem)=@_;my$modifier=$elem->sprevious_sibling;return if $modifier && $modifier->isa('PPI::Token::Word')&& ($modifier->content()eq 'local' || $modifier->content()eq 'my');if ($elem->isa('PPI::Token::Symbol')){return$self->_is_magic_var($elem)? $elem : undef}elsif ($elem->isa('PPI::Structure::List')or $elem->isa('PPI::Statement::Expression')){for my$child ($elem->schildren){my$var=$self->_is_non_local_magic_dest($child);return$var if$var}}return}sub _is_magic_var {my ($self,$elem)=@_;my$variable_name=$elem->symbol();return if$self->{_allow}{$variable_name};return 1 if$elem->isa('PPI::Token::Magic');return if not is_perl_global($elem);return 1}1;
PERL_CRITIC_POLICY_VARIABLES_REQUIRELOCALIZEDPUNCTUATIONVARS

$fatpacked{"Perl/Critic/Policy/Variables/RequireNegativeIndices.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_REQUIRENEGATIVEINDICES';
  package Perl::Critic::Policy::Variables::RequireNegativeIndices;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:severities};use base 'Perl::Critic::Policy';our$VERSION='0.01';Readonly::Scalar my$DESC=>q{Negative array index should be used};Readonly::Scalar my$EXPL=>[88 ];sub supported_parameters {return ()}sub default_severity {return$SEVERITY_HIGH}sub default_themes {return qw(core maintenance pbp)}sub applies_to {return 'PPI::Structure::Subscript'}sub violates {my ($self,$elem,$doc)=@_;return if$elem->braces ne '[]';my ($name,$isref)=_is_bad_index($elem);return if (!$name);return if!_is_array_name($elem,$name,$isref);return$self->violation($DESC,$EXPL,$elem)}Readonly::Scalar my$MAX_EXPRESSION_COMPLEXETY=>4;sub _is_bad_index {my ($elem)=@_;my@children=$elem->schildren();return if@children!=1;return if!$children[0]->isa('PPI::Statement::Expression');my@expr=$children[0]->schildren();return if!@expr || @expr > $MAX_EXPRESSION_COMPLEXETY;my ($name,$isref,$isindex)=_is_bad_var_in_index(\@expr);return if!$name;return$name,$isref if!@expr && $isindex;return if!_is_minus_number(@expr);return$name,$isref}sub _is_bad_var_in_index {my ($expr)=@_;if ($expr->[0]->isa('PPI::Token::ArrayIndex')){return _arrayindex($expr)}elsif ($expr->[0]->isa('PPI::Token::Cast')){return _cast($expr)}elsif ($expr->[0]->isa('PPI::Token::Symbol')){return _symbol($expr)}return}sub _arrayindex {my ($expr)=@_;my$arrindex=shift @{$expr};if ($arrindex->content =~ m/\A \$[#] (.*) \z /xms){return $1,0,1}return}sub _cast {my ($expr)=@_;my$cast=shift @{$expr};if ($cast eq q{$#} || $cast eq q{@}){my$isindex=$cast eq q{$#} ? 1 : 0;my$arrvar=shift @{$expr};if ($arrvar->isa('PPI::Structure::Block')){my@blockchildren=$arrvar->schildren();return if@blockchildren!=1;return if!$blockchildren[0]->isa('PPI::Statement');my@ggg=$blockchildren[0]->schildren;return if@ggg!=1;return if!$ggg[0]->isa('PPI::Token::Symbol');if ($ggg[0]=~ m/\A \$ (.*) \z/xms){return $1,1,$isindex}}elsif ($arrvar->isa('PPI::Token::Symbol')){if ($arrvar =~ m/\A \$ (.*) \z/xms){return $1,1,$isindex}}}return}sub _symbol {my ($expr)=@_;my$arrvar=shift @{$expr};if ($arrvar =~ m/\A \@ (.*) \z/xms){return $1,0,0}return}sub _is_minus_number {my@expr=@_;return if!@expr;return if@expr!=2;my$op=shift@expr;return if!$op->isa('PPI::Token::Operator');return if$op ne q{-};my$number=shift@expr;return if!$number->isa('PPI::Token::Number');return 1}sub _is_array_name {my ($elem,$name,$isref)=@_;my$sib=$elem->sprevious_sibling;return if!$sib;if ($sib->isa('PPI::Token::Operator')&& $sib eq '->'){return if (!$isref);$isref=0;$sib=$sib->sprevious_sibling;return if!$sib}return if!$sib->isa('PPI::Token::Symbol');return if$sib !~ m/\A \$ \Q$name\E \z/xms;my$cousin=$sib->sprevious_sibling;return if$isref ^ _is_dereferencer($cousin);return if$isref && _is_dereferencer($cousin->sprevious_sibling);return$elem}sub _is_dereferencer {my$elem=shift;return 0 if!$elem;return 1 if$elem->isa('PPI::Token::Operator')&& $elem eq '->';return 1 if$elem->isa('PPI::Token::Cast');return 0}1;
PERL_CRITIC_POLICY_VARIABLES_REQUIRENEGATIVEINDICES

$fatpacked{"Perl/Critic/PolicyConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYCONFIG';
  package Perl::Critic::PolicyConfig;use 5.006001;use strict;use warnings;use Readonly;our$VERSION='0.01';use Perl::Critic::Exception::AggregateConfiguration;use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue;use Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter;use Perl::Critic::Utils qw<:booleans :characters severity_to_number>;use Perl::Critic::Utils::Constants qw<:profile_strictness>;Readonly::Scalar my$NON_PUBLIC_DATA=>'_non_public_data';Readonly::Scalar my$NO_LIMIT=>'no_limit';sub new {my ($class,$policy_short_name,$specification)=@_;my%self=$specification ? %{$specification}: ();my%non_public_data;$non_public_data{_policy_short_name}=$policy_short_name;$non_public_data{_profile_strictness}=$self{$NON_PUBLIC_DATA}{_profile_strictness};for my$standard_parameter (qw<maximum_violations_per_document severity set_themes add_themes>){if (exists$self{$standard_parameter}){$non_public_data{"_$standard_parameter"}=delete$self{$standard_parameter}}}$self{$NON_PUBLIC_DATA}=\%non_public_data;return bless \%self,$class}sub _get_non_public_data {my$self=shift;return$self->{$NON_PUBLIC_DATA}}sub get_policy_short_name {my$self=shift;return$self->_get_non_public_data()->{_policy_short_name}}sub get_set_themes {my ($self)=@_;return$self->_get_non_public_data()->{_set_themes}}sub get_add_themes {my ($self)=@_;return$self->_get_non_public_data()->{_add_themes}}sub get_severity {my ($self)=@_;return$self->_get_non_public_data()->{_severity}}sub is_maximum_violations_per_document_unlimited {my ($self)=@_;my$maximum_violations=$self->get_maximum_violations_per_document();if (not defined$maximum_violations or $maximum_violations eq $EMPTY or $maximum_violations =~ m<\A $NO_LIMIT \z>xmsio){return$TRUE}return$FALSE}sub get_maximum_violations_per_document {my ($self)=@_;return$self->_get_non_public_data()->{_maximum_violations_per_document}}sub get {my ($self,$parameter)=@_;return if$parameter eq $NON_PUBLIC_DATA;return$self->{$parameter}}sub remove {my ($self,$parameter)=@_;return if$parameter eq $NON_PUBLIC_DATA;delete$self->{$parameter};return}sub is_empty {my ($self)=@_;return 1 >= keys %{$self}}sub get_parameter_names {my ($self)=@_;return grep {$_ ne $NON_PUBLIC_DATA}keys %{$self}}sub handle_extra_parameters {my ($self,$policy,$errors)=@_;my$profile_strictness=$self->{$NON_PUBLIC_DATA}{_profile_strictness};defined$profile_strictness or $profile_strictness=$PROFILE_STRICTNESS_DEFAULT;return if$profile_strictness eq $PROFILE_STRICTNESS_QUIET;my$parameter_errors=$profile_strictness eq $PROFILE_STRICTNESS_WARN ? Perl::Critic::Exception::AggregateConfiguration->new(): $errors;for my$offered_param ($self->get_parameter_names()){$parameter_errors->add_exception(Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter->new(policy=>$policy->get_short_name(),option_name=>$offered_param,source=>undef,))}warn qq<$parameter_errors\n> if ($profile_strictness eq $PROFILE_STRICTNESS_WARN && $parameter_errors->has_exceptions());return}sub set_profile_strictness {my ($self,$profile_strictness)=@_;$self->{$NON_PUBLIC_DATA}{_profile_strictness}=$profile_strictness;return}1;
PERL_CRITIC_POLICYCONFIG

$fatpacked{"Perl/Critic/PolicyFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYFACTORY';
  package Perl::Critic::PolicyFactory;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use File::Spec::Unix qw();use List::MoreUtils qw(any);use Perl::Critic::Utils qw{:characters $POLICY_NAMESPACE :data_conversion policy_long_name policy_short_name :internal_lookup};use Perl::Critic::PolicyConfig;use Perl::Critic::Exception::AggregateConfiguration;use Perl::Critic::Exception::Configuration;use Perl::Critic::Exception::Fatal::Generic qw{throw_generic};use Perl::Critic::Exception::Fatal::Internal qw{throw_internal};use Perl::Critic::Exception::Fatal::PolicyDefinition qw{throw_policy_definition};use Perl::Critic::Exception::Configuration::NonExistentPolicy qw<>;use Perl::Critic::Utils::Constants qw{:profile_strictness};use Exception::Class;our$VERSION='0.01';my@site_policy_names=();sub import {my ($class,%args)=@_;my$test_mode=$args{-test};my$extra_test_policies=$args{'-extra-test-policies'};if (not @site_policy_names){my$eval_worked=eval {require Module::Pluggable;Module::Pluggable->import(search_path=>$POLICY_NAMESPACE,require=>1,inner=>0);@site_policy_names=plugins();1};if (not $eval_worked){if ($EVAL_ERROR){throw_generic qq<Can't load Policies from namespace "$POLICY_NAMESPACE": $EVAL_ERROR>}throw_generic qq<Can't load Policies from namespace "$POLICY_NAMESPACE" for an unknown reason.>}if (not @site_policy_names){throw_generic qq<No Policies found in namespace "$POLICY_NAMESPACE".>}}if ($test_mode && any {m/\b blib \b/xms}@INC){@site_policy_names=_modules_from_blib(@site_policy_names);if ($extra_test_policies){my@extra_policy_full_names=map {"${POLICY_NAMESPACE}::$_"}@{$extra_test_policies};push@site_policy_names,@extra_policy_full_names}}return 1}sub _modules_from_blib {my (@modules)=@_;return grep {_was_loaded_from_blib(_module2path($_))}@modules}sub _module2path {my$module=shift || return;return File::Spec::Unix->catdir(split m/::/xms,$module).'.pm'}sub _was_loaded_from_blib {my$path=shift || return;my$full_path=$INC{$path};return$full_path && $full_path =~ m/ (?: \A | \b b ) lib \b /xms}sub new {my ($class,%args)=@_;my$self=bless {},$class;$self->_init(%args);return$self}sub _init {my ($self,%args)=@_;my$profile=$args{-profile};$self->{_profile}=$profile or throw_internal q{The -profile argument is required};my$incoming_errors=$args{-errors};my$profile_strictness=$args{'-profile-strictness'};$profile_strictness ||= $PROFILE_STRICTNESS_DEFAULT;$self->{_profile_strictness}=$profile_strictness;if ($profile_strictness ne $PROFILE_STRICTNESS_QUIET){my$errors;if ($profile_strictness eq $PROFILE_STRICTNESS_FATAL or ($incoming_errors and @{$incoming_errors->exceptions()})){$errors=$incoming_errors ? $incoming_errors : Perl::Critic::Exception::AggregateConfiguration->new()}$self->_validate_policies_in_profile($errors);if (not $incoming_errors and $errors and $errors->has_exceptions()){$errors->rethrow()}}return$self}sub create_policy {my ($self,%args)=@_;my$policy_name=$args{-name}or throw_internal q{The -name argument is required};$policy_name=policy_long_name($policy_name);my$policy_short_name=policy_short_name($policy_name);my$profile=$self->_profile();my$policy_config;if ($args{-params}){$policy_config=Perl::Critic::PolicyConfig->new($policy_short_name,$args{-params})}else {$policy_config=$profile->policy_params($policy_name);$policy_config ||= Perl::Critic::PolicyConfig->new($policy_short_name)}return$self->_instantiate_policy($policy_name,$policy_config)}sub create_all_policies {my ($self,$incoming_errors)=@_;my$errors=$incoming_errors ? $incoming_errors : Perl::Critic::Exception::AggregateConfiguration->new();my@policies;for my$name (site_policy_names()){my$policy=eval {$self->create_policy(-name=>$name)};$errors->add_exception_or_rethrow($EVAL_ERROR);if ($policy){push@policies,$policy}}if (not $incoming_errors and $errors->has_exceptions()){$errors->rethrow()}return@policies}sub site_policy_names {my@sorted_policy_names=sort@site_policy_names;return@sorted_policy_names}sub _profile {my ($self)=@_;return$self->{_profile}}sub _instantiate_policy {my ($self,$policy_name,$policy_config)=@_;$policy_config->set_profile_strictness($self->{_profile_strictness});my$policy=eval {$policy_name->new(%{$policy_config})};_handle_policy_instantiation_exception($policy_name,$policy,$EVAL_ERROR,);$policy->__set_config($policy_config);my$eval_worked=eval {$policy->__set_base_parameters();1};_handle_policy_instantiation_exception($policy_name,$eval_worked,$EVAL_ERROR,);return$policy}sub _handle_policy_instantiation_exception {my ($policy_name,$eval_worked,$eval_error)=@_;if (not $eval_worked){if ($eval_error){my$exception=Exception::Class->caught();if (ref$exception){$exception->rethrow()}throw_policy_definition qq<Unable to create policy "$policy_name": $eval_error>}throw_policy_definition qq<Unable to create policy "$policy_name" for an unknown reason.>}return}sub _validate_policies_in_profile {my ($self,$errors)=@_;my$profile=$self->_profile();my%known_policies=hashify($self->site_policy_names());for my$policy_name ($profile->listed_policies()){if (not exists$known_policies{$policy_name}){my$message=qq{Policy "$policy_name" is not installed.};if ($errors){$errors->add_exception(Perl::Critic::Exception::Configuration::NonExistentPolicy->new(policy=>$policy_name,))}else {warn qq{$message\n}}}}return}1;
PERL_CRITIC_POLICYFACTORY

$fatpacked{"Perl/Critic/PolicyListing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYLISTING';
  package Perl::Critic::PolicyListing;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Perl::Critic::Policy qw();use overload (q<"">=>'to_string');our$VERSION='0.01';sub new {my ($class,%args)=@_;my$self=bless {},$class;my$policies=$args{-policies}|| [];$self->{_policies}=[sort _by_type @{$policies}];return$self}sub to_string {my ($self)=@_;Perl::Critic::Policy::set_format("%s %p [%t]\n");return join q{},map {"$_"}@{$self->{_policies}}}sub _by_type {return ref$a cmp ref$b}1;
PERL_CRITIC_POLICYLISTING

$fatpacked{"Perl/Critic/PolicyParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER';
  package Perl::Critic::PolicyParameter;use 5.006001;use strict;use warnings;use Readonly;use Exporter 'import';Readonly::Array our@EXPORT_OK=>qw{$NO_DESCRIPTION_AVAILABLE};use String::Format qw{stringf};use Perl::Critic::Exception::Fatal::PolicyDefinition qw{throw_policy_definition};use Perl::Critic::PolicyParameter::Behavior;use Perl::Critic::PolicyParameter::Behavior::Boolean;use Perl::Critic::PolicyParameter::Behavior::Enumeration;use Perl::Critic::PolicyParameter::Behavior::Integer;use Perl::Critic::PolicyParameter::Behavior::String;use Perl::Critic::PolicyParameter::Behavior::StringList;use Perl::Critic::Utils qw{:characters &interpolate};use Perl::Critic::Utils::DataConversion qw{&defined_or_empty};our$VERSION='0.01';Readonly::Scalar our$NO_DESCRIPTION_AVAILABLE=>'No description available.';Readonly::Hash my%BEHAVIORS=>('boolean'=>Perl::Critic::PolicyParameter::Behavior::Boolean->new(),'enumeration'=>Perl::Critic::PolicyParameter::Behavior::Enumeration->new(),'integer'=>Perl::Critic::PolicyParameter::Behavior::Integer->new(),'string'=>Perl::Critic::PolicyParameter::Behavior::String->new(),'string list'=>Perl::Critic::PolicyParameter::Behavior::StringList->new(),);sub _get_behavior_for_name {my$behavior_name=shift;my$behavior=$BEHAVIORS{$behavior_name}or throw_policy_definition qq{There's no "$behavior_name" behavior.};return$behavior}sub new {my ($class,$specification)=@_;my$self=bless {},$class;defined$specification or throw_policy_definition 'Attempt to create a ',__PACKAGE__,' without a specification.';my$behavior_specification;my$specification_type=ref$specification;if (not $specification_type){$self->{_name}=$specification;$behavior_specification={}}else {$specification_type eq 'HASH' or throw_policy_definition 'Attempt to create a ',__PACKAGE__," with a $specification_type as a specification.",;defined$specification->{name}or throw_policy_definition 'Attempt to create a ',__PACKAGE__,' without a name.';$self->{_name}=$specification->{name};$behavior_specification=$specification}$self->_initialize_from_behavior($behavior_specification);$self->_finish_standard_initialization($behavior_specification);return$self}sub _initialize_from_behavior {my ($self,$specification)=@_;my$behavior_name=$specification->{behavior};my$behavior;if ($behavior_name){$behavior=_get_behavior_for_name($behavior_name)}else {$behavior=_get_behavior_for_name('string')}$self->{_behavior}=$behavior;$self->{_behavior_values}={};$behavior->initialize_parameter($self,$specification);return}sub _finish_standard_initialization {my ($self,$specification)=@_;my$description=$specification->{description}|| $NO_DESCRIPTION_AVAILABLE;$self->_set_description($description);$self->_set_default_string($specification->{default_string});$self->_set_parser($specification->{parser});return}sub get_name {my$self=shift;return$self->{_name}}sub get_description {my$self=shift;return$self->{_description}}sub _set_description {my ($self,$new_value)=@_;return if not defined$new_value;$self->{_description}=$new_value;return}sub _get_description_with_trailing_period {my$self=shift;my$description=$self->get_description();if ($description){if ($PERIOD ne substr$description,(length$description)- 1){$description .= $PERIOD}}else {$description=$EMPTY}return$description}sub get_default_string {my$self=shift;return$self->{_default_string}}sub _set_default_string {my ($self,$new_value)=@_;return if not defined$new_value;$self->{_default_string}=$new_value;return}sub _get_behavior {my$self=shift;return$self->{_behavior}}sub _get_behavior_values {my$self=shift;return$self->{_behavior_values}}sub _get_parser {my$self=shift;return$self->{_parser}}sub _set_parser {my ($self,$new_value)=@_;return if not defined$new_value;$self->{_parser}=$new_value;return}sub parse_and_validate_config_value {my ($self,$policy,$config)=@_;my$config_string=$config->{$self->get_name()};my$parser=$self->_get_parser();if ($parser){$parser->($policy,$self,$config_string)}return}sub generate_full_description {my ($self)=@_;return$self->_get_behavior()->generate_parameter_description($self)}sub _generate_full_description {my ($self,$prefix)=@_;my$description=$self->generate_full_description();if (not $description){return$EMPTY}if ($prefix){$description =~ s/ ^ /$prefix/xmsg}return$description}sub to_formatted_string {my ($self,$format)=@_;my%specification=(n=>sub {$self->get_name()},d=>sub {defined_or_empty($self->get_description())},D=>sub {defined_or_empty($self->get_default_string())},f=>sub {$self->_generate_full_description(@_)},);return stringf(interpolate($format),%specification)}1;
PERL_CRITIC_POLICYPARAMETER

$fatpacked{"Perl/Critic/PolicyParameter/Behavior.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR';
  package Perl::Critic::PolicyParameter::Behavior;use 5.006001;use strict;use warnings;use Perl::Critic::Utils qw{:characters};our$VERSION='0.01';sub new {my$class=shift;return bless {},$class}sub initialize_parameter {my ($self,$parameter,$specification)=@_;return}sub generate_parameter_description {my ($self,$parameter)=@_;return$parameter->_get_description_with_trailing_period()}1;
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_BOOLEAN';
  package Perl::Critic::PolicyParameter::Behavior::Boolean;use 5.006001;use strict;use warnings;use Perl::Critic::Utils;use base qw{Perl::Critic::PolicyParameter::Behavior};our$VERSION='0.01';sub _parse {my ($policy,$parameter,$config_string)=@_;my$value;my$value_string=$parameter->get_default_string();if (defined$config_string){$value_string=$config_string}if ($value_string){$value=$TRUE}else {$value=$FALSE}$policy->__set_parameter_value($parameter,$value);return}sub initialize_parameter {my ($self,$parameter,$specification)=@_;$parameter->_set_parser(\&_parse);return}1;
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_BOOLEAN

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/Enumeration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_ENUMERATION';
  package Perl::Critic::PolicyParameter::Behavior::Enumeration;use 5.006001;use strict;use warnings;use Perl::Critic::Exception::Fatal::PolicyDefinition qw{&throw_policy_definition};use Perl::Critic::Utils qw{:characters &words_from_string &hashify};use base qw{Perl::Critic::PolicyParameter::Behavior};our$VERSION='0.01';sub initialize_parameter {my ($self,$parameter,$specification)=@_;my$valid_values=$specification->{enumeration_values}or throw_policy_definition 'No enumeration_values given for ' .$parameter->get_name().$PERIOD;ref$valid_values eq 'ARRAY' or throw_policy_definition 'The value given for enumeration_values for ' .$parameter->get_name().' is not an array reference.';scalar @{$valid_values}> 1 or throw_policy_definition 'There were not at least two valid values given for' .' enumeration_values for ' .$parameter->get_name().$PERIOD;my$value_lookup={hashify(@{$valid_values})};$parameter->_get_behavior_values()->{enumeration_values}=$value_lookup;my$allow_multiple_values=$specification->{enumeration_allow_multiple_values};if ($allow_multiple_values){$parameter->_set_parser(sub {my ($policy,$parameter,$config_string)=@_;my@potential_values;my$value_string=$parameter->get_default_string();if (defined$config_string){$value_string=$config_string}if (defined$value_string){@potential_values=words_from_string($value_string);my@bad_values=grep {not exists$value_lookup->{$_}}@potential_values;if (@bad_values){$policy->throw_parameter_value_exception($parameter->get_name(),$value_string,undef,q{contains invalid values: } .join (q{, },@bad_values).q{. Allowed values are: } .join (q{, },sort keys %{$value_lookup}).qq{.\n},)}}my%actual_values=hashify(@potential_values);$policy->__set_parameter_value($parameter,\%actual_values);return})}else {$parameter->_set_parser(sub {my ($policy,$parameter,$config_string)=@_;my$value_string=$parameter->get_default_string();if (defined$config_string){$value_string=$config_string}if (defined$value_string and $EMPTY ne $value_string and not defined$value_lookup->{$value_string}){$policy->throw_parameter_value_exception($parameter->get_name(),$value_string,undef,q{is not one of the allowed values: } .join (q{, },sort keys %{$value_lookup}).qq{.\n},)}$policy->__set_parameter_value($parameter,$value_string);return})}return}sub generate_parameter_description {my ($self,$parameter)=@_;my$description=$parameter->_get_description_with_trailing_period();if ($description){$description .= qq{\n}}my%values=%{$parameter->_get_behavior_values()->{enumeration_values}};return $description .'Valid values: ' .join (', ',sort keys%values).$PERIOD}1;
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_ENUMERATION

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/Integer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_INTEGER';
  package Perl::Critic::PolicyParameter::Behavior::Integer;use 5.006001;use strict;use warnings;use Perl::Critic::Utils qw{:characters};use base qw{Perl::Critic::PolicyParameter::Behavior};our$VERSION='0.01';sub initialize_parameter {my ($self,$parameter,$specification)=@_;my$minimum=$specification->{integer_minimum};my$maximum=$specification->{integer_maximum};$parameter->_get_behavior_values()->{minimum}=$minimum;$parameter->_get_behavior_values()->{maximum}=$maximum;$parameter->_set_parser(sub {my ($policy,$parameter,$config_string)=@_;my$value_string=$parameter->get_default_string();if (defined$config_string){$value_string=$config_string}my$value;if (defined$value_string){if ($value_string !~ m/ \A [-+]? [1-9] [\d_]* \z /xms and $value_string ne '0'){$policy->throw_parameter_value_exception($parameter->get_name(),$value_string,undef,'does not look like an integer.',)}$value_string =~ tr/_//d;$value=$value_string + 0;if (defined$minimum and $minimum > $value){$policy->throw_parameter_value_exception($parameter->get_name(),$value_string,undef,qq{is less than $minimum.},)}if (defined$maximum and $maximum < $value){$policy->throw_parameter_value_exception($parameter->get_name(),$value_string,undef,qq{is greater than $maximum.},)}}$policy->__set_parameter_value($parameter,$value);return});return}sub generate_parameter_description {my ($self,$parameter)=@_;my$minimum=$parameter->_get_behavior_values()->{minimum};my$maximum=$parameter->_get_behavior_values()->{maximum};my$description=$parameter->_get_description_with_trailing_period();if ($description){$description .= qq{\n}}if (defined$minimum or defined$maximum){if (defined$minimum){$description .= "Minimum value $minimum. "}else {$description .= 'No minimum. '}if (defined$maximum){$description .= "Maximum value $maximum."}else {$description .= 'No maximum.'}}else {$description .= 'No limits.'}return$description}1;
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_INTEGER

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_STRING';
  package Perl::Critic::PolicyParameter::Behavior::String;use 5.006001;use strict;use warnings;use Perl::Critic::Utils;use base qw{Perl::Critic::PolicyParameter::Behavior};our$VERSION='0.01';sub _parse {my ($policy,$parameter,$config_string)=@_;my$value=$parameter->get_default_string();if (defined$config_string){$value=$config_string}$policy->__set_parameter_value($parameter,$value);return}sub initialize_parameter {my ($self,$parameter,$specification)=@_;$parameter->_set_parser(\&_parse);return}1;
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_STRING

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/StringList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_STRINGLIST';
  package Perl::Critic::PolicyParameter::Behavior::StringList;use 5.006001;use strict;use warnings;use Perl::Critic::Utils qw{:characters &words_from_string &hashify};use base qw{Perl::Critic::PolicyParameter::Behavior};our$VERSION='0.01';sub initialize_parameter {my ($self,$parameter,$specification)=@_;my$always_present_values=$specification->{list_always_present_values};$parameter->_get_behavior_values()->{always_present_values}=$always_present_values;if (not $always_present_values){$always_present_values=[]}$parameter->_set_parser(sub {my ($policy,$parameter,$config_string)=@_;my@values=@{$always_present_values};my$value_string=$parameter->get_default_string();if (defined$config_string){$value_string=$config_string}if (defined$value_string){push@values,words_from_string($value_string)}my%values=hashify(@values);$policy->__set_parameter_value($parameter,\%values);return});return}sub generate_parameter_description {my ($self,$parameter)=@_;my$always_present_values=$parameter->_get_behavior_values()->{always_present_values};my$description=$parameter->_get_description_with_trailing_period();if ($description and $always_present_values){$description .= qq{\n}}if ($always_present_values){$description .= 'Values that are always included: ';$description .= join ', ',sort @{$always_present_values};$description .= $PERIOD}return$description}1;
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_STRINGLIST

$fatpacked{"Perl/Critic/ProfilePrototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_PROFILEPROTOTYPE';
  package Perl::Critic::ProfilePrototype;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Perl::Critic::Config qw{};use Perl::Critic::Policy qw{};use Perl::Critic::Utils qw{:characters};use overload (q{""}=>'to_string');our$VERSION='0.01';sub new {my ($class,%args)=@_;my$self=bless {},$class;my$policies=$args{-policies}|| [];$self->{_policies}=[sort _by_type @{$policies}];my$comment_out_parameters=$args{'-comment-out-parameters'};if (not defined$comment_out_parameters){$comment_out_parameters=1}$self->{_comment_out_parameters}=$comment_out_parameters;my$configuration=$args{'-config'};if (not $configuration){$configuration=Perl::Critic::Config->new(-profile=>$EMPTY)}$self->{_configuration}=$configuration;return$self}sub _get_policies {my ($self)=@_;return$self->{_policies}}sub _comment_out_parameters {my ($self)=@_;return$self->{_comment_out_parameters}}sub _configuration {my ($self)=@_;return$self->{_configuration}}sub _line_prefix {my ($self)=@_;return$self->_comment_out_parameters()? q{# } : $EMPTY}sub to_string {my ($self)=@_;my$prefix=$self->_line_prefix();my$configuration=$self->_configuration();my$prototype="# Globals\n";$prototype .= $prefix;$prototype .= q{severity = };$prototype .= $configuration->severity();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{force = };$prototype .= $configuration->force();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{only = };$prototype .= $configuration->only();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{allow-unsafe = };$prototype .= $configuration->unsafe_allowed();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{profile-strictness = };$prototype .= $configuration->profile_strictness();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{color = };$prototype .= $configuration->color();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{pager = };$prototype .= $configuration->pager();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{top = };$prototype .= $configuration->top();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{verbose = };$prototype .= $configuration->verbose();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{include = };$prototype .= join$SPACE,$configuration->include();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{exclude = };$prototype .= join$SPACE,$configuration->exclude();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{single-policy = };$prototype .= join$SPACE,$configuration->single_policy();$prototype .= "\n";$prototype .= $prefix;$prototype .= q{theme = };$prototype .= $configuration->theme()->rule();$prototype .= "\n";for my$item (qw<color-severity-highest color-severity-high color-severity-medium color-severity-low color-severity-lowest>){(my$accessor=$item)=~ s/ - /_/gmsx;$prototype .= $prefix;$prototype .= "$item = ";$prototype .= $configuration->$accessor;$prototype .= "\n"}$prototype .= $prefix;$prototype .= q{program-extensions = };$prototype .= join$SPACE,$configuration->program_extensions();Perl::Critic::Policy::set_format($self->_proto_format());my$policy_prototypes=join qq{\n},map {"$_"}@{$self->_get_policies()};$policy_prototypes =~ s/\s+ \z//xms;return$prototype ."\n\n" .$policy_prototypes ."\n"}sub _proto_format {my ($self)=@_;my$prefix=$self->_line_prefix();return <<"END_OF_FORMAT"}sub _by_type {return ref$a cmp ref$b}1;
  # %a
  [%p]
  ${prefix}set_themes                         = %t
  ${prefix}add_themes                         =
  ${prefix}severity                           = %s
  ${prefix}maximum_violations_per_document    = %v
  %{\\n%\\x7b# \\x7df\\n${prefix}%n = %D\\n}O%{${prefix}Cannot programmatically discover what parameters this policy takes.\\n}U
  END_OF_FORMAT
PERL_CRITIC_PROFILEPROTOTYPE

$fatpacked{"Perl/Critic/Statistics.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_STATISTICS';
  package Perl::Critic::Statistics;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Perl::Critic::Utils::McCabe qw{calculate_mccabe_of_sub};our$VERSION='0.01';sub new {my ($class)=@_;my$self=bless {},$class;$self->{_modules}=0;$self->{_subs}=0;$self->{_statements}=0;$self->{_lines}=0;$self->{_lines_of_blank}=0;$self->{_lines_of_comment}=0;$self->{_lines_of_data}=0;$self->{_lines_of_perl}=0;$self->{_lines_of_pod}=0;$self->{_violations_by_policy}={};$self->{_violations_by_severity}={};$self->{_total_violations}=0;return$self}sub accumulate {my ($self,$doc,$violations)=@_;$self->{_modules}++;my$subs=$doc->find('PPI::Statement::Sub');if ($subs){for my$sub (@{$subs}){$self->{_subs}++;$self->{_subs_total_mccabe}+= calculate_mccabe_of_sub($sub)}}my$statements=$doc->find('PPI::Statement');$self->{_statements}+= $statements ? scalar @{$statements}: 0;my@lines=split /$INPUT_RECORD_SEPARATOR/,$doc->serialize();$self->{_lines}+= scalar@lines;{my ($in_data,$in_pod);for (@lines){if (q{=} eq substr $_,0,1){$in_pod=not m/ \A \s* =cut \b /smx;$self->{_lines_of_pod}++}elsif ($in_pod){$self->{_lines_of_pod}++}elsif (q{__END__} eq $_ || q{__DATA__} eq $_){$in_data=1;$self->{_lines_of_perl}++}elsif ($in_data){$self->{_lines_of_data}++}elsif (m/ \A \s* \# /smx){$self->{_lines_of_comment}++}elsif (m/ \A \s* \z /smx){$self->{_lines_of_blank}++}else {$self->{_lines_of_perl}++}}}for my$violation (@{$violations}){$self->{_violations_by_severity}->{$violation->severity()}++;$self->{_violations_by_policy}->{$violation->policy()}++;$self->{_total_violations}++}return}sub modules {my ($self)=@_;return$self->{_modules}}sub subs {my ($self)=@_;return$self->{_subs}}sub statements {my ($self)=@_;return$self->{_statements}}sub lines {my ($self)=@_;return$self->{_lines}}sub lines_of_blank {my ($self)=@_;return$self->{_lines_of_blank}}sub lines_of_comment {my ($self)=@_;return$self->{_lines_of_comment}}sub lines_of_data {my ($self)=@_;return$self->{_lines_of_data}}sub lines_of_perl {my ($self)=@_;return$self->{_lines_of_perl}}sub lines_of_pod {my ($self)=@_;return$self->{_lines_of_pod}}sub _subs_total_mccabe {my ($self)=@_;return$self->{_subs_total_mccabe}}sub violations_by_severity {my ($self)=@_;return$self->{_violations_by_severity}}sub violations_by_policy {my ($self)=@_;return$self->{_violations_by_policy}}sub total_violations {my ($self)=@_;return$self->{_total_violations}}sub statements_other_than_subs {my ($self)=@_;return$self->statements()- $self->subs()}sub average_sub_mccabe {my ($self)=@_;return if$self->subs()==0;return$self->_subs_total_mccabe()/ $self->subs()}sub violations_per_file {my ($self)=@_;return if$self->modules()==0;return$self->total_violations()/ $self->modules()}sub violations_per_statement {my ($self)=@_;my$statements=$self->statements_other_than_subs();return if$statements==0;return$self->total_violations()/ $statements}sub violations_per_line_of_code {my ($self)=@_;return if$self->lines()==0;return$self->total_violations()/ $self->lines()}1;
PERL_CRITIC_STATISTICS

$fatpacked{"Perl/Critic/TestUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_TESTUTILS';
  package Perl::Critic::TestUtils;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use Exporter 'import';use File::Path ();use File::Spec ();use File::Spec::Unix ();use File::Temp ();use File::Find qw(find);use Perl::Critic;use Perl::Critic::Config;use Perl::Critic::Exception::Fatal::Generic qw{&throw_generic};use Perl::Critic::Exception::Fatal::Internal qw{&throw_internal};use Perl::Critic::Utils qw{:severities :data_conversion policy_long_name};use Perl::Critic::PolicyFactory (-test=>1);our$VERSION='0.01';Readonly::Array our@EXPORT_OK=>qw(pcritique pcritique_with_violations critique critique_with_violations fcritique fcritique_with_violations subtests_in_tree should_skip_author_tests get_author_test_skip_message starting_points_including_examples bundled_policy_names names_of_policies_willing_to_work);sub block_perlcriticrc {no warnings 'redefine';*Perl::Critic::UserProfile::_find_profile_path=sub {return};return 1}sub pcritique_with_violations {my($policy,$code_ref,$config_ref)=@_;my$c=Perl::Critic->new(-profile=>'NONE');$c->add_policy(-policy=>$policy,-config=>$config_ref);return$c->critique($code_ref)}sub pcritique {return scalar pcritique_with_violations(@_)}sub critique_with_violations {my ($code_ref,$config_ref)=@_;my$c=Perl::Critic->new(%{$config_ref});return$c->critique($code_ref)}sub critique {return scalar critique_with_violations(@_)}Readonly::Scalar my$TEMP_FILE_PERMISSIONS=>oct 700;sub fcritique_with_violations {my($policy,$code_ref,$filename,$config_ref)=@_;my$c=Perl::Critic->new(-profile=>'NONE');$c->add_policy(-policy=>$policy,-config=>$config_ref);my$dir=File::Temp::tempdir('PerlCritic-tmpXXXXXX',TMPDIR=>1);$filename ||= 'Temp.pm';my@fileparts=File::Spec::Unix->splitdir($filename);if (@fileparts > 1){my$subdir=File::Spec->catdir($dir,@fileparts[0..$#fileparts-1]);File::Path::mkpath($subdir,0,$TEMP_FILE_PERMISSIONS)}my$file=File::Spec->catfile($dir,@fileparts);if (open my$fh,'>',$file){print {$fh}${$code_ref};close$fh or throw_generic "unable to close $file: $OS_ERROR"}my@v=eval {$c->critique($file)};my$err=$EVAL_ERROR;File::Path::rmtree($dir,0,1);if ($err){throw_generic$err}return@v}sub fcritique {return scalar fcritique_with_violations(@_)}sub subtests_in_tree {my ($start,$include_extras)=@_;my%subtests;find({wanted=>sub {return if not -f;my ($fileroot)=m{(.+)[.]run\z}xms;return if not $fileroot;my@pathparts=File::Spec->splitdir($fileroot);if (@pathparts < 2){throw_internal 'confusing policy test filename ' .$_}my$policy=join q{::},@pathparts[-2,-1];my$globals=_globals_from_file($_);if (my$prerequisites=$globals->{prerequisites}){for my$prerequisite (keys %{$prerequisites}){eval "require $prerequisite; 1" or return}}my@subtests=_subtests_from_file($_);if ($include_extras){$subtests{$policy}={subtests=>[@subtests ],globals=>$globals }}else {$subtests{$policy}=[@subtests ]}return},no_chdir=>1,},$start);return \%subtests}sub should_skip_author_tests {return not $ENV{TEST_AUTHOR_PERL_CRITIC}}sub get_author_test_skip_message {return 'Author test.  Set $ENV{TEST_AUTHOR_PERL_CRITIC} to a true value to run.'}sub starting_points_including_examples {return (-e 'blib' ? 'blib' : 'lib','examples')}sub _globals_from_file {my$test_file=shift;my%valid_keys=hashify qw<prerequisites>;return if -z $test_file;my%globals;open my$handle,'<',$test_file or throw_internal "Couldn't open $test_file: $OS_ERROR";while (my$line=<$handle>){chomp;if (my ($key,$value)=$line =~ m<\A [#][#] [ ] global [ ] (\S+) (?:\s+(.+))? >xms){next if not $key;if (not $valid_keys{$key}){throw_internal "Unknown global key $key in $test_file"}if ($key eq 'prerequisites'){$value={hashify(words_from_string($value))}}$globals{$key}=$value}}close$handle or throw_generic "unable to close $test_file: $OS_ERROR";return \%globals}sub _subtests_from_file {my$test_file=shift;my%valid_keys=hashify qw(name failures parms TODO error filename optional_modules);return if -z $test_file;open my$fh,'<',$test_file or throw_internal "Couldn't open $test_file: $OS_ERROR";my@subtests;my$incode=0;my$cut_in_code=0;my$subtest;my$lineno;while (<$fh>){++$lineno;chomp;my$inheader=/^## name/ .. /^## cut/;my$line=$_;if ($inheader){$line =~ m/\A [#]/xms or throw_internal "Code before cut: $test_file";my ($key,$value)=$line =~ m/\A [#][#] [ ] (\S+) (?:\s+(.+))? /xms;next if!$key;next if$key eq 'cut';if (not $valid_keys{$key}){throw_internal "Unknown key $key in $test_file"}if ($key eq 'name'){if ($subtest){push@subtests,_finalize_subtest($subtest);undef$subtest}$subtest->{lineno}=$lineno;$incode=0;$cut_in_code=0}if ($incode){throw_internal "Header line found while still in code: $test_file"}$subtest->{$key}=$value}elsif ($subtest){$incode=1;$cut_in_code ||= $line =~ m/ \A [#][#] [ ] cut \z /smx;$cut_in_code or push @{$subtest->{code}},$line}elsif (@subtests){throw_internal "Got some code but I'm not in a subtest: $test_file"}}close$fh or throw_generic "unable to close $test_file: $OS_ERROR";if ($subtest){if ($incode){push@subtests,_finalize_subtest($subtest)}else {throw_internal "Incomplete subtest in $test_file"}}return@subtests}sub _finalize_subtest {my$subtest=shift;if ($subtest->{code}){$subtest->{code}=join "\n",@{$subtest->{code}}}else {throw_internal "$subtest->{name} has no code lines"}if (!defined$subtest->{failures}){throw_internal "$subtest->{name} does not specify failures"}if ($subtest->{parms}){$subtest->{parms}=eval$subtest->{parms};if ($EVAL_ERROR){throw_internal "$subtest->{name} has an error in the 'parms' property:\n" .$EVAL_ERROR}if ('HASH' ne ref$subtest->{parms}){throw_internal "$subtest->{name} 'parms' did not evaluate to a hashref"}}else {$subtest->{parms}={}}if (defined$subtest->{error}){if ($subtest->{error}=~ m{ \A / (.*) / \z }xms){$subtest->{error}=eval {qr/$1/};if ($EVAL_ERROR){throw_internal "$subtest->{name} 'error' has a malformed regular expression"}}}return$subtest}sub bundled_policy_names {require ExtUtils::Manifest;my$manifest=ExtUtils::Manifest::maniread();my@policy_paths=map {m{\A lib/(Perl/Critic/Policy/.*).pm \z}xms}keys %{$manifest};my@policies=map {join q{::},split m{/}xms}@policy_paths;my@sorted_policies=sort@policies;return@sorted_policies}sub names_of_policies_willing_to_work {my%configuration=@_;my@policies_willing_to_work=Perl::Critic::Config ->new(%configuration)->policies();return map {ref}@policies_willing_to_work}1;
PERL_CRITIC_TESTUTILS

$fatpacked{"Perl/Critic/Theme.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_THEME';
  package Perl::Critic::Theme;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use Exporter 'import';use List::MoreUtils qw(any);use Perl::Critic::Utils qw{:characters :data_conversion};use Perl::Critic::Exception::Fatal::Internal qw{&throw_internal};use Perl::Critic::Exception::Configuration::Option::Global::ParameterValue qw{&throw_global_value};our$VERSION='0.01';Readonly::Array our@EXPORT_OK=>qw{$RULE_INVALID_CHARACTER_REGEX cook_rule};Readonly::Scalar our$RULE_INVALID_CHARACTER_REGEX=>qr/ ( [^()\s\w\d+\-*&|!] ) /xms;Readonly::Scalar my$CONFIG_KEY=>'theme';sub new {my ($class,%args)=@_;my$self=bless {},$class;$self->_init(%args);return$self}sub _init {my ($self,%args)=@_;my$rule=$args{-rule}|| $EMPTY;if ($rule =~ m/$RULE_INVALID_CHARACTER_REGEX/xms){throw_global_value option_name=>$CONFIG_KEY,option_value=>$rule,message_suffix=>qq{contains an invalid character: "$1".}}$self->{_rule}=cook_rule($rule);return$self}sub rule {my$self=shift;return$self->{_rule}}sub policy_is_thematic {my ($self,%args)=@_;my$policy=$args{-policy}|| throw_internal 'The -policy argument is required';ref$policy || throw_internal 'The -policy must be an object';my$rule=$self->{_rule}or return 1;my%themes=hashify($policy->get_themes());my$as_code=$rule;$as_code =~ s/ ( [\w\d]+ ) /exists $themes{$1} || 0/gexms;my$is_thematic=eval$as_code;if ($EVAL_ERROR){throw_global_value option_name=>$CONFIG_KEY,option_value=>$rule,message_suffix=>q{contains a syntax error.}}return$is_thematic}sub cook_rule {my ($raw_rule)=@_;return if not defined$raw_rule;$raw_rule =~ s{\b not \b}{!}ixmsg;$raw_rule =~ s{\b and \b}{&&}ixmsg;$raw_rule =~ s{\b or  \b}{||}ixmsg;$raw_rule =~ s{\A [-] }{!}ixmsg;$raw_rule =~ s{   [-] }{&& !}ixmsg;$raw_rule =~ s{   [*] }{&&}ixmsg;$raw_rule =~ s{   [+] }{||}ixmsg;my$cooked_rule=lc$raw_rule;return$cooked_rule}1;
PERL_CRITIC_THEME

$fatpacked{"Perl/Critic/ThemeListing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_THEMELISTING';
  package Perl::Critic::ThemeListing;use 5.006001;use strict;use warnings;use English qw<-no_match_vars>;use Perl::Critic::Utils qw<hashify>;use overload (q<"">=>'to_string');our$VERSION='0.01';sub new {my ($class,%args)=@_;my$self=bless {},$class;$self->{_policies}=$args{-policies}|| [];return$self}sub to_string {my ($self)=@_;my%themes;for my$policy (@{$self->{_policies}}){my@themes=$policy->get_themes();@themes{@themes }=@themes}return join ("\n",sort keys%themes)."\n"}1;
PERL_CRITIC_THEMELISTING

$fatpacked{"Perl/Critic/UserProfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_USERPROFILE';
  package Perl::Critic::UserProfile;use 5.006001;use strict;use warnings;use English qw(-no_match_vars);use Readonly;use Config::Tiny qw();use File::Spec qw();use Perl::Critic::OptionsProcessor qw();use Perl::Critic::Utils qw{$EMPTY policy_long_name policy_short_name};use Perl::Critic::Exception::Fatal::Internal qw{throw_internal};use Perl::Critic::Exception::Configuration::Generic qw{throw_generic};use Perl::Critic::PolicyConfig;our$VERSION='0.01';sub new {my ($class,%args)=@_;my$self=bless {},$class;$self->_init(%args);return$self}sub _init {my ($self,%args)=@_;my$profile=defined$args{-profile}? $args{-profile}: _find_profile_path();$self->_load_profile($profile);$self->_set_options_processor();return$self}sub options_processor {my ($self)=@_;return$self->{_options_processor}}sub policy_params {my ($self,$policy)=@_;my$short_name=policy_short_name($policy);return Perl::Critic::PolicyConfig->new($short_name,$self->raw_policy_params($policy),)}sub raw_policy_params {my ($self,$policy)=@_;my$profile=$self->{_profile};my$long_name=ref$policy || policy_long_name($policy);my$short_name=policy_short_name($long_name);return $profile->{$short_name}|| $profile->{$long_name}|| $profile->{"-$short_name"}|| $profile->{"-$long_name"}|| {}}sub policy_is_disabled {my ($self,$policy)=@_;my$profile=$self->{_profile};my$long_name=ref$policy || policy_long_name($policy);my$short_name=policy_short_name($long_name);return exists$profile->{"-$short_name"}|| exists$profile->{"-$long_name"}}sub policy_is_enabled {my ($self,$policy)=@_;my$profile=$self->{_profile};my$long_name=ref$policy || policy_long_name($policy);my$short_name=policy_short_name($long_name);return exists$profile->{$short_name}|| exists$profile->{$long_name}}sub listed_policies {my ($self,$policy)=@_;my@normalized_policy_names=();for my$policy_name (sort keys %{$self->{_profile}}){$policy_name =~ s/\A - //xmso;my$policy_long_name=policy_long_name($policy_name);push@normalized_policy_names,$policy_long_name}return@normalized_policy_names}sub source {my ($self)=@_;return$self->{_source}}sub _set_source {my ($self,$source)=@_;$self->{_source}=$source;return}Readonly::Hash my%LOADER_FOR=>(ARRAY=>\&_load_profile_from_array,DEFAULT=>\&_load_profile_from_file,HASH=>\&_load_profile_from_hash,SCALAR=>\&_load_profile_from_string,);sub _load_profile {my ($self,$profile)=@_;my$ref_type=ref$profile || 'DEFAULT';my$loader=$LOADER_FOR{$ref_type};if (not $loader){throw_internal qq{Can't load UserProfile from type "$ref_type"}}$self->{_profile}=$loader->($self,$profile);return$self}sub _set_options_processor {my ($self)=@_;my$profile=$self->{_profile};my$defaults=delete$profile->{__defaults__}|| {};$self->{_options_processor}=Perl::Critic::OptionsProcessor->new(%{$defaults});return$self}sub _load_profile_from_file {my ($self,$file)=@_;return {}if not defined$file;return {}if$file eq $EMPTY;return {}if$file eq 'NONE';$self->_set_source($file);my$profile=Config::Tiny->read($file);if (not defined$profile){my$errstr=Config::Tiny::errstr();throw_generic message=>qq{Could not parse profile "$file": $errstr},source=>$file}_fix_defaults_key($profile);return$profile}sub _load_profile_from_array {my ($self,$array_ref)=@_;my$joined=join qq{\n},@{$array_ref};my$profile=Config::Tiny->read_string($joined);if (not defined$profile){throw_generic 'Profile error: ' .Config::Tiny::errstr()}_fix_defaults_key($profile);return$profile}sub _load_profile_from_string {my ($self,$string)=@_;my$profile=Config::Tiny->read_string(${$string});if (not defined$profile){throw_generic 'Profile error: ' .Config::Tiny::errstr()}_fix_defaults_key($profile);return$profile}sub _load_profile_from_hash {my ($self,$hash_ref)=@_;return$hash_ref}sub _find_profile_path {my$rc_file='.perlcriticrc';return$ENV{PERLCRITIC}if exists$ENV{PERLCRITIC};return$rc_file if -f $rc_file;if (my$home_dir=_find_home_dir()){my$path=File::Spec->catfile($home_dir,$rc_file);return$path if -f $path}return}sub _find_home_dir {if (eval {require File::HomeDir}){return File::HomeDir->my_home()}for my$key (qw(HOME USERPROFILE HOMESHARE)){next if not defined$ENV{$key};return$ENV{$key}if -d $ENV{$key}}return}sub _fix_defaults_key {my ($profile)=@_;my$defaults=delete$profile->{_};if ($defaults){$profile->{__defaults__}=$defaults}return}1;
PERL_CRITIC_USERPROFILE

$fatpacked{"Perl/Critic/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS';
  package Perl::Critic::Utils;use 5.006001;use strict;use warnings;use Readonly;use Carp qw(confess);use English qw(-no_match_vars);use File::Spec qw();use Scalar::Util qw(blessed);use B::Keywords qw();use PPI::Token::Quote::Single;use Perl::Critic::Exception::Fatal::Generic qw{throw_generic};use Perl::Critic::Utils::PPI qw<is_ppi_expression_or_generic_statement>;use Exporter 'import';our$VERSION='0.01';Readonly::Array our@EXPORT_OK=>qw($TRUE $FALSE $POLICY_NAMESPACE $SEVERITY_HIGHEST $SEVERITY_HIGH $SEVERITY_MEDIUM $SEVERITY_LOW $SEVERITY_LOWEST @SEVERITY_NAMES $DEFAULT_VERBOSITY $DEFAULT_VERBOSITY_WITH_FILE_NAME $COLON $COMMA $DQUOTE $EMPTY $EQUAL $FATCOMMA $PERIOD $PIPE $QUOTE $BACKTICK $SCOLON $SPACE $SLASH $BSLASH $LEFT_PAREN $RIGHT_PAREN all_perl_files find_keywords first_arg hashify interpolate is_assignment_operator is_class_name is_function_call is_hash_key is_in_void_context is_included_module_name is_integer is_label_pointer is_method_call is_package_declaration is_perl_bareword is_perl_builtin is_perl_builtin_with_list_context is_perl_builtin_with_multiple_arguments is_perl_builtin_with_no_arguments is_perl_builtin_with_one_argument is_perl_builtin_with_optional_argument is_perl_builtin_with_zero_and_or_one_arguments is_perl_filehandle is_perl_global is_qualified_name is_script is_subroutine_name is_unchecked_call is_valid_numeric_verbosity parse_arg_list policy_long_name policy_short_name precedence_of severity_to_number shebang_line split_nodes_on_comma verbosity_to_format words_from_string);Readonly::Array our@EXPORT=>@EXPORT_OK;Readonly::Hash our%EXPORT_TAGS=>(all=>[@EXPORT_OK ],booleans=>[qw{$TRUE $FALSE} ],severities=>[qw{$SEVERITY_HIGHEST $SEVERITY_HIGH $SEVERITY_MEDIUM $SEVERITY_LOW $SEVERITY_LOWEST @SEVERITY_NAMES} ],characters=>[qw{$COLON $COMMA $DQUOTE $EMPTY $EQUAL $FATCOMMA $PERIOD $PIPE $QUOTE $BACKTICK $SCOLON $SPACE $SLASH $BSLASH $LEFT_PAREN $RIGHT_PAREN} ],classification=>[qw{is_assignment_operator is_class_name is_function_call is_hash_key is_included_module_name is_integer is_label_pointer is_method_call is_package_declaration is_perl_bareword is_perl_builtin is_perl_filehandle is_perl_global is_perl_builtin_with_list_context is_perl_builtin_with_multiple_arguments is_perl_builtin_with_no_arguments is_perl_builtin_with_one_argument is_perl_builtin_with_optional_argument is_perl_builtin_with_zero_and_or_one_arguments is_qualified_name is_script is_subroutine_name is_unchecked_call is_valid_numeric_verbosity} ],data_conversion=>[qw{hashify words_from_string interpolate} ],ppi=>[qw{first_arg parse_arg_list} ],internal_lookup=>[qw{severity_to_number verbosity_to_format} ],language=>[qw{precedence_of} ],deprecated=>[qw{find_keywords} ],);Readonly::Scalar our$POLICY_NAMESPACE=>'Perl::Critic::Policy';Readonly::Scalar our$SEVERITY_HIGHEST=>5;Readonly::Scalar our$SEVERITY_HIGH=>4;Readonly::Scalar our$SEVERITY_MEDIUM=>3;Readonly::Scalar our$SEVERITY_LOW=>2;Readonly::Scalar our$SEVERITY_LOWEST=>1;Readonly::Scalar our$COMMA=>q{,};Readonly::Scalar our$EQUAL=>q{=};Readonly::Scalar our$FATCOMMA=>q{=>};Readonly::Scalar our$COLON=>q{:};Readonly::Scalar our$SCOLON=>q{;};Readonly::Scalar our$QUOTE=>q{'};Readonly::Scalar our$DQUOTE=>q{"};Readonly::Scalar our$BACKTICK=>q{`};Readonly::Scalar our$PERIOD=>q{.};Readonly::Scalar our$PIPE=>q{|};Readonly::Scalar our$SPACE=>q{ };Readonly::Scalar our$SLASH=>q{/};Readonly::Scalar our$BSLASH=>q{\\};Readonly::Scalar our$LEFT_PAREN=>q{(};Readonly::Scalar our$RIGHT_PAREN=>q{)};Readonly::Scalar our$EMPTY=>q{};Readonly::Scalar our$TRUE=>1;Readonly::Scalar our$FALSE=>0;Readonly::Hash my%PRECEDENCE_OF=>('->'=>1,'++'=>2,'--'=>2,'**'=>3,'!'=>4,'~'=>4,'\\'=>4,'=~'=>5,'!~'=>5,'*'=>6,'/'=>6,'%'=>6,'x'=>6,'+'=>7,'-'=>7,'.'=>7,'<<'=>8,'>>'=>8,'-R'=>9,'-W'=>9,'-X'=>9,'-r'=>9,'-w'=>9,'-x'=>9,'-e'=>9,'-O'=>9,'-o'=>9,'-z'=>9,'-s'=>9,'-M'=>9,'-A'=>9,'-C'=>9,'-S'=>9,'-c'=>9,'-b'=>9,'-f'=>9,'-d'=>9,'-p'=>9,'-l'=>9,'-u'=>9,'-g'=>9,'-k'=>9,'-t'=>9,'-T'=>9,'-B'=>9,'<'=>10,'>'=>10,'<='=>10,'>='=>10,'lt'=>10,'gt'=>10,'le'=>10,'ge'=>10,'=='=>11,'!='=>11,'<=>'=>11,'eq'=>11,'ne'=>11,'cmp'=>11,'~~'=>11,'&'=>12,'|'=>13,'^'=>13,'&&'=>14,'//'=>15,'||'=>15,'..'=>16,'...'=>17,'?'=>18,':'=>18,'='=>19,'+='=>19,'-='=>19,'*='=>19,'/='=>19,'%='=>19,'||='=>19,'&&='=>19,'|='=>19,'&='=>19,'**='=>19,'x='=>19,'.='=>19,'^='=>19,'<<='=>19,'>>='=>19,'//='=>19,','=>20,'=>'=>20,'not'=>22,'and'=>23,'or'=>24,'xor'=>24,);Readonly::Scalar my$MIN_PRECEDENCE_TO_TERMINATE_PARENLESS_ARG_LIST=>precedence_of('not');sub hashify {return map {$_=>1}@_}sub interpolate {my ($literal)=@_;return eval "\"$literal\"" || confess$EVAL_ERROR}sub find_keywords {my ($doc,$keyword)=@_;my$nodes_ref=$doc->find('PPI::Token::Word');return if!$nodes_ref;my@matches=grep {$_ eq $keyword}@{$nodes_ref};return@matches ? \@matches : undef}sub _name_for_sub_or_stringified_element {my$elem=shift;if (blessed$elem and $elem->isa('PPI::Statement::Sub')){return$elem->name()}return "$elem"}Readonly::Hash my%BUILTINS=>hashify(@B::Keywords::Functions);sub is_perl_builtin {my$elem=shift;return if!$elem;return exists$BUILTINS{_name_for_sub_or_stringified_element($elem)}}Readonly::Hash my%BAREWORDS=>hashify(@B::Keywords::Barewords);sub is_perl_bareword {my$elem=shift;return if!$elem;return exists$BAREWORDS{_name_for_sub_or_stringified_element($elem)}}sub _build_globals_without_sigils {my@globals=map {substr $_,1}@B::Keywords::Arrays,@B::Keywords::Hashes,@B::Keywords::Scalars,'$\\';for my$filehandle (@B::Keywords::Filehandles){(my$stripped=$filehandle)=~ s< \A [*] ><>xms;push@globals,$stripped}return@globals}Readonly::Array my@GLOBALS_WITHOUT_SIGILS=>_build_globals_without_sigils();Readonly::Hash my%GLOBALS=>hashify(@GLOBALS_WITHOUT_SIGILS);sub is_perl_global {my$elem=shift;return if!$elem;my$var_name="$elem";$var_name =~ s{\A [\$@%*] }{}xms;return exists$GLOBALS{$var_name }}Readonly::Hash my%FILEHANDLES=>hashify(@B::Keywords::Filehandles);sub is_perl_filehandle {my$elem=shift;return if!$elem;return exists$FILEHANDLES{_name_for_sub_or_stringified_element($elem)}}Readonly::Hash my%BUILTINS_WHICH_PROVIDE_LIST_CONTEXT=>hashify(qw{chmod chown die exec formline grep import join kill map no open pack print printf push reverse say sort splice sprintf syscall system tie unlink unshift use utime warn},);sub is_perl_builtin_with_list_context {my$elem=shift;return exists $BUILTINS_WHICH_PROVIDE_LIST_CONTEXT{_name_for_sub_or_stringified_element($elem)}}Readonly::Hash my%BUILTINS_WHICH_TAKE_MULTIPLE_ARGUMENTS=>hashify(qw{accept atan2 bind binmode bless connect crypt dbmopen fcntl flock gethostbyaddr getnetbyaddr getpriority getservbyname getservbyport getsockopt index ioctl link listen mkdir msgctl msgget msgrcv msgsnd open opendir pipe read recv rename rindex seek seekdir select semctl semget semop send setpgrp setpriority setsockopt shmctl shmget shmread shmwrite shutdown socket socketpair splice split substr symlink sysopen sysread sysseek syswrite truncate unpack vec waitpid},keys%BUILTINS_WHICH_PROVIDE_LIST_CONTEXT);sub is_perl_builtin_with_multiple_arguments {my$elem=shift;return exists $BUILTINS_WHICH_TAKE_MULTIPLE_ARGUMENTS{_name_for_sub_or_stringified_element($elem)}}Readonly::Hash my%BUILTINS_WHICH_TAKE_NO_ARGUMENTS=>hashify(qw{endgrent endhostent endnetent endprotoent endpwent endservent fork format getgrent gethostent getlogin getnetent getppid getprotoent getpwent getservent setgrent setpwent split time times wait wantarray});sub is_perl_builtin_with_no_arguments {my$elem=shift;return exists $BUILTINS_WHICH_TAKE_NO_ARGUMENTS{_name_for_sub_or_stringified_element($elem)}}Readonly::Hash my%BUILTINS_WHICH_TAKE_ONE_ARGUMENT=>hashify(qw{closedir dbmclose delete each exists fileno getgrgid getgrnam gethostbyname getnetbyname getpeername getpgrp getprotobyname getprotobynumber getpwnam getpwuid getsockname goto keys local prototype readdir readline readpipe rewinddir scalar sethostent setnetent setprotoent setservent telldir tied untie values});sub is_perl_builtin_with_one_argument {my$elem=shift;return exists $BUILTINS_WHICH_TAKE_ONE_ARGUMENT{_name_for_sub_or_stringified_element($elem)}}Readonly::Hash my%BUILTINS_WHICH_TAKE_OPTIONAL_ARGUMENT=>hashify(grep {not exists$BUILTINS_WHICH_TAKE_ONE_ARGUMENT{$_ }}grep {not exists$BUILTINS_WHICH_TAKE_NO_ARGUMENTS{$_ }}grep {not exists$BUILTINS_WHICH_TAKE_MULTIPLE_ARGUMENTS{$_ }}@B::Keywords::Functions);sub is_perl_builtin_with_optional_argument {my$elem=shift;return exists $BUILTINS_WHICH_TAKE_OPTIONAL_ARGUMENT{_name_for_sub_or_stringified_element($elem)}}sub is_perl_builtin_with_zero_and_or_one_arguments {my$elem=shift;return if not $elem;my$name=_name_for_sub_or_stringified_element($elem);return (exists$BUILTINS_WHICH_TAKE_ONE_ARGUMENT{$name }or exists$BUILTINS_WHICH_TAKE_NO_ARGUMENTS{$name }or exists$BUILTINS_WHICH_TAKE_OPTIONAL_ARGUMENT{$name })}sub is_qualified_name {my$name=shift;return if not $name;return index ($name,q{::})>= 0}sub precedence_of {my$elem=shift;return if!$elem;return$PRECEDENCE_OF{ref$elem ? "$elem" : $elem }}sub is_hash_key {my$elem=shift;return if!$elem;return if _is_followed_by_parens($elem);my$parent=$elem->parent();return if!$parent;my$grandparent=$parent->parent();return if!$grandparent;return 1 if$grandparent->isa('PPI::Structure::Subscript');my$sib=$elem->snext_sibling();return if!$sib;return 1 if$sib->isa('PPI::Token::Operator')&& $sib eq '=>';return}sub _is_followed_by_parens {my$elem=shift;return if!$elem;my$sibling=$elem->snext_sibling()|| return;return$sibling->isa('PPI::Structure::List')}sub is_included_module_name {my$elem=shift;return if!$elem;my$stmnt=$elem->statement();return if!$stmnt;return if!$stmnt->isa('PPI::Statement::Include');return$stmnt->schild(1)==$elem}sub is_integer {my ($value)=@_;return 0 if not defined$value;return$value =~ m{ \A [+-]? \d+ \z }xms}sub is_label_pointer {my$elem=shift;return if!$elem;my$statement=$elem->statement();return if!$statement;my$psib=$elem->sprevious_sibling();return if!$psib;return$statement->isa('PPI::Statement::Break')&& $psib =~ m/(?:redo|goto|next|last)/xmso}sub is_method_call {my$elem=shift;return if!$elem;return _is_dereference_operator($elem->sprevious_sibling())}sub is_class_name {my$elem=shift;return if!$elem;return _is_dereference_operator($elem->snext_sibling())&&!_is_dereference_operator($elem->sprevious_sibling())}sub _is_dereference_operator {my$elem=shift;return if!$elem;return$elem->isa('PPI::Token::Operator')&& $elem eq q{->}}sub is_package_declaration {my$elem=shift;return if!$elem;my$stmnt=$elem->statement();return if!$stmnt;return if!$stmnt->isa('PPI::Statement::Package');return$stmnt->schild(1)==$elem}sub is_subroutine_name {my$elem=shift;return if!$elem;my$sib=$elem->sprevious_sibling();return if!$sib;my$stmnt=$elem->statement();return if!$stmnt;return$stmnt->isa('PPI::Statement::Sub')&& $sib eq 'sub'}sub is_function_call {my$elem=shift or return;return if is_perl_bareword($elem);return if is_perl_filehandle($elem);return if is_package_declaration($elem);return if is_included_module_name($elem);return if is_method_call($elem);return if is_class_name($elem);return if is_subroutine_name($elem);return if is_label_pointer($elem);return if is_hash_key($elem);return 1}sub is_script {my$doc=shift;warnings::warnif('deprecated','Perl::Critic::Utils::is_script($doc) deprecated, use $doc->is_program() instead.',);return$doc->is_program()if blessed($doc)&& $doc->isa('Perl::Critic::Document');return 1 if shebang_line($doc);return 1 if _is_PL_file($doc);return 0}sub _is_PL_file {my ($doc)=@_;return if not $doc->can('filename');my$filename=$doc->filename()|| return;return 1 if$filename =~ m/[.] PL \z/xms;return 0}sub is_in_void_context {my ($token)=@_;return if$token->sprevious_sibling();my$parent=$token->statement()->parent();if ($parent){return if$parent->isa('PPI::Structure::List');return if$parent->isa('PPI::Structure::For');return if$parent->isa('PPI::Structure::Condition');return if$parent->isa('PPI::Structure::Constructor');return if$parent->isa('PPI::Structure::Subscript');my$grand_parent=$parent->parent();if ($grand_parent){return if $parent->isa('PPI::Structure::Block')and not $grand_parent->isa('PPI::Statement::Compound')}}return$TRUE}sub policy_long_name {my ($policy_name)=@_;if ($policy_name !~ m{ \A $POLICY_NAMESPACE }xms){$policy_name=$POLICY_NAMESPACE .q{::} .$policy_name}return$policy_name}sub policy_short_name {my ($policy_name)=@_;$policy_name =~ s{\A $POLICY_NAMESPACE ::}{}xms;return$policy_name}sub first_arg {my$elem=shift;my$sib=$elem->snext_sibling();return if!$sib;if ($sib->isa('PPI::Structure::List')){my$expr=$sib->schild(0);return if!$expr;return$expr->isa('PPI::Statement')? $expr->schild(0): $expr}return$sib}sub parse_arg_list {my$elem=shift;my$sib=$elem->snext_sibling();return if!$sib;if ($sib->isa('PPI::Structure::List')){my@list_contents=$sib->schildren();return if not @list_contents;my@list_expressions;for my$item (@list_contents){if (is_ppi_expression_or_generic_statement($item)){push @list_expressions,split_nodes_on_comma($item->schildren())}else {push@list_expressions,$item}}return@list_expressions}else {my$iter=$elem;my@arg_list=();while ($iter=$iter->snext_sibling()){last if$iter->isa('PPI::Token::Structure')and $iter eq $SCOLON;last if$iter->isa('PPI::Token::Operator')and $MIN_PRECEDENCE_TO_TERMINATE_PARENLESS_ARG_LIST <= precedence_of($iter);push@arg_list,$iter}return split_nodes_on_comma(@arg_list)}}sub split_nodes_on_comma {my@nodes=@_;my$i=0;my@node_stacks;for my$node (@nodes){if ($node->isa('PPI::Token::Operator')and ($node eq $COMMA or $node eq $FATCOMMA)){if (@node_stacks){$i++}next}elsif ($node->isa('PPI::Token::QuoteLike::Words')){my$section=$node->{sections}->[0];my@words=words_from_string(substr$node->content,$section->{position},$section->{size});my$loc=$node->location;for my$word (@words){my$token=PPI::Token::Quote::Single->new(q{'} .$word .q{'});$token->{_location}=$loc;push @{$node_stacks[$i++]},$token}next}push @{$node_stacks[$i]},$node}return@node_stacks}Readonly::Hash my%FORMAT_OF=>(1=>"%f:%l:%c:%m\n",2=>"%f: (%l:%c) %m\n",3=>"%m at %f line %l\n",4=>"%m at line %l, column %c.  %e.  (Severity: %s)\n",5=>"%f: %m at line %l, column %c.  %e.  (Severity: %s)\n",6=>"%m at line %l, near '%r'.  (Severity: %s)\n",7=>"%f: %m at line %l near '%r'.  (Severity: %s)\n",8=>"[%p] %m at line %l, column %c.  (Severity: %s)\n",9=>"[%p] %m at line %l, near '%r'.  (Severity: %s)\n",10=>"%m at line %l, column %c.\n  %p (Severity: %s)\n%d\n",11=>"%m at line %l, near '%r'.\n  %p (Severity: %s)\n%d\n",);Readonly::Scalar our$DEFAULT_VERBOSITY=>4;Readonly::Scalar our$DEFAULT_VERBOSITY_WITH_FILE_NAME=>5;Readonly::Scalar my$DEFAULT_FORMAT=>$FORMAT_OF{$DEFAULT_VERBOSITY};sub is_valid_numeric_verbosity {my ($verbosity)=@_;return exists$FORMAT_OF{$verbosity}}sub verbosity_to_format {my ($verbosity)=@_;return$DEFAULT_FORMAT if not defined$verbosity;return$FORMAT_OF{abs int$verbosity}|| $DEFAULT_FORMAT if is_integer($verbosity);return interpolate($verbosity)}Readonly::Hash my%SEVERITY_NUMBER_OF=>(gentle=>5,stern=>4,harsh=>3,cruel=>2,brutal=>1,);Readonly::Array our@SEVERITY_NAMES=>sort {$SEVERITY_NUMBER_OF{$a}<=> $SEVERITY_NUMBER_OF{$b}}keys%SEVERITY_NUMBER_OF;sub severity_to_number {my ($severity)=@_;return _normalize_severity($severity)if is_integer($severity);my$severity_number=$SEVERITY_NUMBER_OF{lc$severity};if (not defined$severity_number){throw_generic qq{Invalid severity: "$severity"}}return$severity_number}sub _normalize_severity {my$s=shift || return$SEVERITY_HIGHEST;$s=$s > $SEVERITY_HIGHEST ? $SEVERITY_HIGHEST : $s;$s=$s < $SEVERITY_LOWEST ? $SEVERITY_LOWEST : $s;return$s}Readonly::Array my@SKIP_DIR=>qw(CVS RCS .svn _darcs {arch} .bzr .cdv .git .hg .pc _build blib);Readonly::Hash my%SKIP_DIR=>hashify(@SKIP_DIR);sub all_perl_files {my@queue=@_;my@code_files=();while (@queue){my$file=shift@queue;if (-d $file){opendir my ($dh),$file or next;my@newfiles=sort readdir$dh;closedir$dh;@newfiles=File::Spec->no_upwards(@newfiles);@newfiles=grep {not $SKIP_DIR{$_}}@newfiles;push@queue,map {File::Spec->catfile($file,$_)}@newfiles}if ((-f $file)&&!_is_backup($file)&& _is_perl($file)){push@code_files,$file}}return@code_files}sub _is_backup {my ($file)=@_;return 1 if$file =~ m{ [.] swp \z}xms;return 1 if$file =~ m{ [.] bak \z}xms;return 1 if$file =~ m{  ~ \z}xms;return 1 if$file =~ m{ \A [#] .+ [#] \z}xms;return}sub _is_perl {my ($file)=@_;return 1 if$file =~ m{ [.] PL    \z}xms;return 1 if$file =~ m{ [.] p[lm] \z}xms;return 1 if$file =~ m{ [.] t     \z}xms;open my$fh,'<',$file or return;my$first=<$fh>;close$fh or throw_generic "unable to close $file: $OS_ERROR";return 1 if defined$first && ($first =~ m{ \A [#]!.*perl }xms);return}sub shebang_line {my$doc=shift;my$first_element=$doc->first_element();return if not $first_element;return if not $first_element->isa('PPI::Token::Comment');my$location=$first_element->location();return if!$location;return if$location->[0]!=1;return if$location->[1]!=1;my$shebang=$first_element->content;return if$shebang !~ m{ \A [#]! }xms;return$shebang}sub words_from_string {my$str=shift;return split q{ },$str}Readonly::Hash my%ASSIGNMENT_OPERATORS=>hashify(qw(= **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //=));sub is_assignment_operator {my$elem=shift;return$ASSIGNMENT_OPERATORS{$elem }}sub is_unchecked_call {my$elem=shift;return if not is_function_call($elem);if(my$sib=$elem->sprevious_sibling()){return if$sib}if(my$statement=$elem->statement()){my$or_operators=sub {my (undef,$elem)=@_;return if not $elem->isa('PPI::Token::Operator');return if$elem ne q{or} && $elem ne q{||};return 1};return if$statement->find($or_operators);if(my$parent=$elem->statement()->parent()){return if$parent->isa('PPI::Structure::Condition');return if$parent->isa('PPI::Structure::Constructor');if ($parent->isa('PPI::Structure::List')){if(my$uncle=$parent->sprevious_sibling()){return if$uncle}}}}return if _is_fatal($elem);return 1}Readonly::Hash my%AUTODIE_PARAMETER_TO_AFFECTED_BUILTINS_MAP=>((map {$_=>{hashify($_)}}qw<accept bind binmode chdir chmod close closedir connect dbmclose dbmopen exec fcntl fileno flock fork getsockopt ioctl link listen mkdir msgctl msgget msgrcv msgsnd open opendir pipe read readlink recv rename rmdir seek semctl semget semop send setsockopt shmctl shmget shmread shutdown socketpair symlink sysopen sysread sysseek system syswrite truncate umask unlink>),':threads'=>{hashify(qw<fork>)},':system'=>{hashify(qw<exec system>)},':dbm'=>{hashify(qw<dbmclose dbmopen>)},':semaphore'=>{hashify(qw<semctl semget semop>)},':shm'=>{hashify(qw<shmctl shmget shmread>)},':msg'=>{hashify(qw<msgctl msgget msgrcv msgsnd>)},':file'=>{hashify(qw<binmode chmod close fcntl fileno flock ioctl open sysopen truncate>)},':filesys'=>{hashify(qw<chdir closedir link mkdir opendir readlink rename rmdir symlink umask unlink>)},':ipc'=>{hashify(qw<msgctl msgget msgrcv msgsnd pipe semctl semget semop shmctl shmget shmread>)},':socket'=>{hashify(qw<accept bind connect getsockopt listen recv send setsockopt shutdown socketpair>)},':io'=>{hashify(qw<accept bind binmode chdir chmod close closedir connect dbmclose dbmopen fcntl fileno flock getsockopt ioctl link listen mkdir msgctl msgget msgrcv msgsnd open opendir pipe read readlink recv rename rmdir seek semctl semget semop send setsockopt shmctl shmget shmread shutdown socketpair symlink sysopen sysread sysseek syswrite truncate umask unlink>)},':default'=>{hashify(qw<accept bind binmode chdir chmod close closedir connect dbmclose dbmopen fcntl fileno flock fork getsockopt ioctl link listen mkdir msgctl msgget msgrcv msgsnd open opendir pipe read readlink recv rename rmdir seek semctl semget semop send setsockopt shmctl shmget shmread shutdown socketpair symlink sysopen sysread sysseek syswrite truncate umask unlink>)},':all'=>{hashify(qw<accept bind binmode chdir chmod close closedir connect dbmclose dbmopen exec fcntl fileno flock fork getsockopt ioctl link listen mkdir msgctl msgget msgrcv msgsnd open opendir pipe read readlink recv rename rmdir seek semctl semget semop send setsockopt shmctl shmget shmread shutdown socketpair symlink sysopen sysread sysseek system syswrite truncate umask unlink>)},);sub _is_fatal {my ($elem)=@_;my$top=$elem->top();return if not $top->isa('PPI::Document');my$includes=$top->find('PPI::Statement::Include');return if not $includes;for my$include (@{$includes}){next if 'use' ne $include->type();if ('Fatal' eq $include->module()){my@args=parse_arg_list($include->schild(1));for my$arg (@args){return$TRUE if$arg->[0]->isa('PPI::Token::Quote')&& $elem eq $arg->[0]->string()}}elsif ('Fatal::Exception' eq $include->module()){my@args=parse_arg_list($include->schild(1));shift@args;for my$arg (@args){return$TRUE if$arg->[0]->isa('PPI::Token::Quote')&& $elem eq $arg->[0]->string()}}elsif ('autodie' eq $include->pragma()){return _is_covered_by_autodie($elem,$include)}}return}sub _is_covered_by_autodie {my ($elem,$include)=@_;my$autodie=$include->schild(1);my@args=parse_arg_list($autodie);my$first_arg=first_arg($autodie);if ($first_arg and $first_arg->isa('PPI::Token::Number')){shift@args};if (@args){for my$arg (@args){my$builtins=$AUTODIE_PARAMETER_TO_AFFECTED_BUILTINS_MAP{$arg->[0]->string };return$TRUE if$builtins and $builtins->{$elem->content()}}}else {my$builtins=$AUTODIE_PARAMETER_TO_AFFECTED_BUILTINS_MAP{':default'};return$TRUE if$builtins and $builtins->{$elem->content()}}return}1;
PERL_CRITIC_UTILS

$fatpacked{"Perl/Critic/Utils/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_CONSTANTS';
  package Perl::Critic::Utils::Constants;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{$EMPTY hashify};use Exporter 'import';our$VERSION='0.01';our@EXPORT_OK=qw{$PROFILE_STRICTNESS_WARN $PROFILE_STRICTNESS_FATAL $PROFILE_STRICTNESS_QUIET $PROFILE_STRICTNESS_DEFAULT %PROFILE_STRICTNESSES $PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT $PROFILE_COLOR_SEVERITY_HIGH_DEFAULT $PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT $PROFILE_COLOR_SEVERITY_LOW_DEFAULT $PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT $_MODULE_VERSION_TERM_ANSICOLOR @STRICT_EQUIVALENT_MODULES @WARNINGS_EQUIVALENT_MODULES};our%EXPORT_TAGS=(all=>\@EXPORT_OK,profile_strictness=>[qw{$PROFILE_STRICTNESS_WARN $PROFILE_STRICTNESS_FATAL $PROFILE_STRICTNESS_QUIET $PROFILE_STRICTNESS_DEFAULT %PROFILE_STRICTNESSES} ],color_severity=>[qw{$PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT $PROFILE_COLOR_SEVERITY_HIGH_DEFAULT $PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT $PROFILE_COLOR_SEVERITY_LOW_DEFAULT $PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT} ],equivalent_modules=>[qw{@STRICT_EQUIVALENT_MODULES @WARNINGS_EQUIVALENT_MODULES} ],);Readonly::Scalar our$PROFILE_STRICTNESS_WARN=>'warn';Readonly::Scalar our$PROFILE_STRICTNESS_FATAL=>'fatal';Readonly::Scalar our$PROFILE_STRICTNESS_QUIET=>'quiet';Readonly::Scalar our$PROFILE_STRICTNESS_DEFAULT=>$PROFILE_STRICTNESS_WARN;Readonly::Hash our%PROFILE_STRICTNESSES=>hashify($PROFILE_STRICTNESS_WARN,$PROFILE_STRICTNESS_FATAL,$PROFILE_STRICTNESS_QUIET,);Readonly::Scalar our$PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT=>'bold red';Readonly::Scalar our$PROFILE_COLOR_SEVERITY_HIGH_DEFAULT=>'magenta';Readonly::Scalar our$PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT=>$EMPTY;Readonly::Scalar our$PROFILE_COLOR_SEVERITY_LOW_DEFAULT=>$EMPTY;Readonly::Scalar our$PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT=>$EMPTY;Readonly::Scalar our$_MODULE_VERSION_TERM_ANSICOLOR=>2.02;Readonly::Array our@STRICT_EQUIVALENT_MODULES=>qw(Mo Moo Moo::Role Moose Moose::Role Moose::Exporter Moose::Util::TypeConstraints MooseX::NonMoose MooseX::Singleton MooseX::Role::Parameterized Mouse Mouse::Role Mouse::Exporter Mouse::Util Mouse::Util::TypeConstraints Moos Mousse Any::Moose Modern::Perl Dancer Dancer2 Mojolicious::Lite Mojo::Base sane shit strictures);Readonly::Array our@WARNINGS_EQUIVALENT_MODULES =>@STRICT_EQUIVALENT_MODULES;1;
PERL_CRITIC_UTILS_CONSTANTS

$fatpacked{"Perl/Critic/Utils/DataConversion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_DATACONVERSION';
  package Perl::Critic::Utils::DataConversion;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:characters :booleans};use Exporter 'import';our$VERSION='0.01';Readonly::Array our@EXPORT_OK=>qw(boolean_to_number dor defined_or_empty);sub boolean_to_number {return $_[0]? $TRUE : $FALSE}sub dor {for (@_){return $_ if defined}return}sub defined_or_empty {return defined $_[0]? $_[0]: $EMPTY}1;
PERL_CRITIC_UTILS_DATACONVERSION

$fatpacked{"Perl/Critic/Utils/McCabe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_MCCABE';
  package Perl::Critic::Utils::McCabe;use 5.006001;use strict;use warnings;use Readonly;use Perl::Critic::Utils qw{:data_conversion :classification};use Exporter 'import';our$VERSION='0.01';Readonly::Array our@EXPORT_OK=>qw(calculate_mccabe_of_sub calculate_mccabe_of_main);Readonly::Hash my%LOGIC_OPS=>hashify(qw(&& || ||= &&= or and xor ? <<= >>=));Readonly::Hash my%LOGIC_KEYWORDS=>hashify(qw(if else elsif unless until while for foreach));sub calculate_mccabe_of_sub {my ($sub)=@_;my$count=1;$count += _count_logic_keywords($sub);$count += _count_logic_operators($sub);return$count}sub calculate_mccabe_of_main {my ($doc)=@_;my$count=1;$count += _count_main_logic_operators_and_keywords($doc);return$count}sub _count_main_logic_operators_and_keywords {my ($doc)=@_;my$wanted=sub {my (undef,$elem)=@_;return undef if$elem->isa('PPI::Statement::Sub');if ($elem->isa('PPI::Token::Word')){return 0 if is_hash_key($elem);return exists$LOGIC_KEYWORDS{$elem}}elsif ($elem->isa('PPI::Token::Operator')){return exists$LOGIC_OPS{$elem}}};my$logic_operators_and_keywords=$doc->find($wanted);my$count=$logic_operators_and_keywords ? scalar @{$logic_operators_and_keywords}: 0;return$count}sub _count_logic_keywords {my ($sub)=@_;my$count=0;my$keywords_ref=$sub->find('PPI::Token::Word');if ($keywords_ref){my@filtered=grep {!is_hash_key($_)}@{$keywords_ref};$count=grep {exists$LOGIC_KEYWORDS{$_}}@filtered}return$count}sub _count_logic_operators {my ($sub)=@_;my$count=0;my$operators_ref=$sub->find('PPI::Token::Operator');if ($operators_ref){$count=grep {exists$LOGIC_OPS{$_}}@{$operators_ref}}return$count}1;
PERL_CRITIC_UTILS_MCCABE

$fatpacked{"Perl/Critic/Utils/POD.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_POD';
  package Perl::Critic::Utils::POD;use 5.006001;use strict;use warnings;use English qw<-no_match_vars>;use IO::String ();use Pod::PlainText ();use Pod::Select ();use Perl::Critic::Exception::Fatal::Generic qw<throw_generic>;use Perl::Critic::Exception::IO qw<throw_io>;use Perl::Critic::Utils qw<:characters>;use Exporter 'import';our$VERSION='0.01';our@EXPORT_OK=qw(get_pod_file_for_module get_raw_pod_section_from_file get_raw_pod_section_from_filehandle get_raw_pod_section_from_string get_raw_pod_section_for_module get_pod_section_from_file get_pod_section_from_filehandle get_pod_section_from_string get_pod_section_for_module trim_raw_pod_section trim_pod_section get_raw_module_abstract_from_file get_raw_module_abstract_from_filehandle get_raw_module_abstract_from_string get_raw_module_abstract_for_module get_module_abstract_from_file get_module_abstract_from_filehandle get_module_abstract_from_string get_module_abstract_for_module);our%EXPORT_TAGS=(all=>\@EXPORT_OK,);sub get_pod_file_for_module {my ($module_name)=@_;(my$relative_path=$module_name)=~ s< :: ></>xmsg;$relative_path .= '.pm';my$absolute_path=$INC{$relative_path}or return;(my$pod_path=$absolute_path)=~ s< [.] [^.]+ \z><.pod>xms;return$pod_path if -f $pod_path;return$absolute_path}sub get_raw_pod_section_from_file {my ($file_name,$section_name)=@_;return _get_pod_section_from_file($file_name,$section_name,Pod::Select->new(),)}sub get_raw_pod_section_from_filehandle {my ($file_handle,$section_name)=@_;return _get_pod_section_from_filehandle($file_handle,$section_name,Pod::Select->new(),)}sub get_raw_pod_section_from_string {my ($source,$section_name)=@_;return _get_pod_section_from_string($source,$section_name,Pod::Select->new(),)}sub get_raw_pod_section_for_module {my ($module_name,$section_name)=@_;my$file_name=get_pod_file_for_module($module_name)or throw_generic qq<Could not find POD for "$module_name".>;return get_raw_pod_section_from_file($file_name,$section_name)}sub get_pod_section_from_file {my ($file_name,$section_name)=@_;return _get_pod_section_from_file($file_name,$section_name,Pod::PlainText->new(),)}sub get_pod_section_from_filehandle {my ($file_handle,$section_name)=@_;return _get_pod_section_from_filehandle($file_handle,$section_name,Pod::PlainText->new(),)}sub get_pod_section_from_string {my ($source,$section_name)=@_;return _get_pod_section_from_string($source,$section_name,Pod::PlainText->new(),)}sub get_pod_section_for_module {my ($module_name,$section_name)=@_;my$file_name=get_pod_file_for_module($module_name)or throw_generic qq<Could not find POD for "$module_name".>;return get_pod_section_from_file($file_name,$section_name)}sub _get_pod_section_from_file {my ($file_name,$section_name,$parser)=@_;open my$file_handle,'<',$file_name or throw_io message=>qq<Could not open "$file_name": $ERRNO>,file_name=>$file_name,errno=>$ERRNO;my$content=_get_pod_section_from_filehandle($file_handle,$section_name,$parser,);close$file_handle or throw_io message=>qq<Could not close "$file_name": $ERRNO>,file_name=>$file_name,errno=>$ERRNO;return$content}sub _get_pod_section_from_filehandle {my ($file_handle,$section_name,$parser)=@_;$parser->select($section_name);my$content=$EMPTY;my$content_handle=IO::String->new(\$content);$parser->parse_from_filehandle($file_handle,$content_handle);return if$content eq $EMPTY;return$content}sub _get_pod_section_from_string {my ($source,$section_name,$parser)=@_;my$source_handle=IO::String->new(\$source);return _get_pod_section_from_filehandle($source_handle,$section_name,$parser,)}sub trim_raw_pod_section {my ($pod)=@_;return if not defined$pod;$pod =~ s< \A =head1 \b [^\n]* \n $ ><>xms;$pod =~ s< \A \s+ ><>xms;$pod =~ s< \s+ \z ><>xms;return$pod}sub trim_pod_section {my ($pod)=@_;return if not defined$pod;$pod =~ s< \A [^\n]* \n ><>xms;$pod =~ s< \A \s* \n ><>xms;$pod =~ s< \s+ \z ><>xms;return$pod}sub get_raw_module_abstract_from_file {my ($file_name)=@_;return _get_module_abstract_from_file($file_name,Pod::Select->new(),\&trim_raw_pod_section,)}sub get_raw_module_abstract_from_filehandle {my ($file_handle)=@_;return _get_module_abstract_from_filehandle($file_handle,Pod::Select->new(),\&trim_raw_pod_section,)}sub get_raw_module_abstract_from_string {my ($source)=@_;return _get_module_abstract_from_string($source,Pod::Select->new(),\&trim_raw_pod_section,)}sub get_raw_module_abstract_for_module {my ($module_name)=@_;my$file_name=get_pod_file_for_module($module_name)or throw_generic qq<Could not find POD for "$module_name".>;return get_raw_module_abstract_from_file($file_name)}sub get_module_abstract_from_file {my ($file_name)=@_;return _get_module_abstract_from_file($file_name,Pod::PlainText->new(),\&trim_pod_section,)}sub get_module_abstract_from_filehandle {my ($file_handle)=@_;return _get_module_abstract_from_filehandle($file_handle,Pod::PlainText->new(),\&trim_pod_section,)}sub get_module_abstract_from_string {my ($source)=@_;return _get_module_abstract_from_string($source,Pod::PlainText->new(),\&trim_pod_section,)}sub get_module_abstract_for_module {my ($module_name)=@_;my$file_name=get_pod_file_for_module($module_name)or throw_generic qq<Could not find POD for "$module_name".>;return get_module_abstract_from_file($file_name)}sub _get_module_abstract_from_file {my ($file_name,$parser,$trimmer)=@_;open my$file_handle,'<',$file_name or throw_io message=>qq<Could not open "$file_name": $ERRNO>,file_name=>$file_name,errno=>$ERRNO;my$module_abstract=_get_module_abstract_from_filehandle($file_handle,$parser,$trimmer,);close$file_handle or throw_io message=>qq<Could not close "$file_name": $ERRNO>,file_name=>$file_name,errno=>$ERRNO;return$module_abstract}sub _get_module_abstract_from_filehandle {my ($file_handle,$parser,$trimmer)=@_;my$name_section=_get_pod_section_from_filehandle($file_handle,'NAME',$parser);return if not $name_section;$name_section=$trimmer->($name_section);return if not $name_section;if ('Pod::Select' eq ref$parser){if ($name_section =~ m< \n >xms){throw_generic qq<Malformed NAME section in "$name_section". > .q<It must be on a single line>}}else {$name_section =~ s< \s+ >< >xmsg;if ($name_section =~ m<
                  \A
                  \s*
                  (
                      \w [ \w:]+ \w
                  )
                  (
                      \s*
                      -
                      .*
                  )?
                  \z
              >xms){my ($module_name,$rest)=($1,$2);$module_name =~ s/ [ ] //xms;$name_section=$module_name .($rest ? $rest : $EMPTY)}}if ($name_section =~ m<
              \A
              \s*
              [\w:]+              # Module name.
              \s+
              -                   # The required single hyphen.
              \s+
              (
                  \S              # At least one non-whitespace.
                  (?: .* \S)?     # Everything up to the last non-whitespace.
              )
              \s*
              \z
          >xms){my$module_abstract=$1;return$module_abstract}if ($name_section =~ m<
              \A
              \s*
              [\w:]+              # Module name.
              (?: \s* - )?        # The single hyphen is now optional.
              \s*
              \z
          >xms){return}throw_generic qq<Malformed NAME section in "$name_section".>}sub _get_module_abstract_from_string {my ($source,$parser,$trimmer)=@_;my$source_handle=IO::String->new(\$source);return _get_module_abstract_from_filehandle($source_handle,$parser,$trimmer,)}1;
PERL_CRITIC_UTILS_POD

$fatpacked{"Perl/Critic/Utils/POD/ParseInteriorSequence.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_POD_PARSEINTERIORSEQUENCE';
  package Perl::Critic::Utils::POD::ParseInteriorSequence;use 5.006001;use strict;use warnings;use base qw{Pod::Parser};use IO::String;our$VERSION='0.01';sub interior_sequence {my ($self,$seq_cmd,$seq_arg,$pod_seq)=@_;push @{$self->{+__PACKAGE__}{interior_sequence}||= []},$pod_seq;return$self->SUPER::interior_sequence($seq_cmd,$seq_arg,$pod_seq)}sub get_interior_sequences {my ($self,$pod)=@_;$self->{+__PACKAGE__}{interior_sequence}=[];my$result;$self->parse_from_filehandle(IO::String->new(\$pod),IO::String->new(\$result));return @{$self->{+__PACKAGE__}{interior_sequence}}}1;
PERL_CRITIC_UTILS_POD_PARSEINTERIORSEQUENCE

$fatpacked{"Perl/Critic/Utils/PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_PPI';
  package Perl::Critic::Utils::PPI;use 5.006001;use strict;use warnings;use Readonly;use Scalar::Util qw<blessed readonly>;use Exporter 'import';our$VERSION='0.01';our@EXPORT_OK=qw(is_ppi_expression_or_generic_statement is_ppi_generic_statement is_ppi_statement_subclass is_ppi_simple_statement is_ppi_constant_element is_subroutine_declaration is_in_subroutine get_constant_name_element_from_declaring_statement get_next_element_in_same_simple_statement get_previous_module_used_on_same_line);our%EXPORT_TAGS=(all=>\@EXPORT_OK,);sub is_ppi_expression_or_generic_statement {my$element=shift;return if not $element;return if not $element->isa('PPI::Statement');return 1 if$element->isa('PPI::Statement::Expression');my$element_class=blessed($element);return if not $element_class;return$element_class eq 'PPI::Statement'}sub is_ppi_generic_statement {my$element=shift;my$element_class=blessed($element);return if not $element_class;return if not $element->isa('PPI::Statement');return$element_class eq 'PPI::Statement'}sub is_ppi_statement_subclass {my$element=shift;my$element_class=blessed($element);return if not $element_class;return if not $element->isa('PPI::Statement');return$element_class ne 'PPI::Statement'}Readonly::Hash my%SIMPLE_STATEMENT_CLASS=>map {$_=>1}qw<PPI::Statement PPI::Statement::Break PPI::Statement::Include PPI::Statement::Null PPI::Statement::Package PPI::Statement::Variable>;sub is_ppi_simple_statement {my$element=shift or return;my$element_class=blessed($element)or return;return$SIMPLE_STATEMENT_CLASS{$element_class }}sub is_ppi_constant_element {my$element=shift or return;blessed($element)or return;return $element->isa('PPI::Token::Number')|| $element->isa('PPI::Token::Quote::Literal')|| $element->isa('PPI::Token::Quote::Single')|| $element->isa('PPI::Token::QuoteLike::Words')|| ($element->isa('PPI::Token::Quote::Double')|| $element->isa('PPI::Token::Quote::Interpolate'))&& $element->string()!~ m< (?: \A | [^\\] ) (?: \\\\)* [\$\@] >smx }sub is_subroutine_declaration {my$element=shift;return if not $element;return 1 if$element->isa('PPI::Statement::Sub');if (is_ppi_generic_statement($element)){my$first_element=$element->first_element();return 1 if $first_element and $first_element->isa('PPI::Token::Word')and $first_element->content()eq 'sub'}return}sub is_in_subroutine {my ($element)=@_;return if not $element;return 1 if is_subroutine_declaration($element);while ($element=$element->parent()){return 1 if is_subroutine_declaration($element)}return}sub get_constant_name_element_from_declaring_statement {my ($element)=@_;warnings::warnif('deprecated','Perl::Critic::Utils::PPI::get_constant_name_element_from_declaring_statement() is deprecated. Use PPIx::Utilities::Statement::get_constant_name_elements_from_declaring_statement() instead.',);return if not $element;return if not $element->isa('PPI::Statement');if ($element->isa('PPI::Statement::Include')){my$pragma;if ($pragma=$element->pragma()and $pragma eq 'constant'){return _constant_name_from_constant_pragma($element)}}elsif (is_ppi_generic_statement($element)and $element->schild(0)->content()=~ m< \A Readonly \b >xms){return$element->schild(2)}return}sub _constant_name_from_constant_pragma {my ($include)=@_;my@arguments=$include->arguments()or return;my$follower=$arguments[0];return if not defined$follower;return$follower}sub get_next_element_in_same_simple_statement {my$element=shift or return;while ($element and (not is_ppi_simple_statement($element)or $element->parent()and $element->parent()->isa('PPI::Structure::List'))){my$next;$next=$element->snext_sibling()and return$next;$element=$element->parent()}return}sub get_previous_module_used_on_same_line {my$element=shift or return;my ($line)=@{$element->location()|| []};while (not is_ppi_simple_statement($element)){$element=$element->parent()or return}while ($element=$element->sprevious_sibling()){(@{$element->location()|| []})[0]==$line or return;$element->isa('PPI::Statement::Include')and return$element->schild(1)}return}1;
PERL_CRITIC_UTILS_PPI

$fatpacked{"Perl/Critic/Utils/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_PERL';
  package Perl::Critic::Utils::Perl;use 5.006001;use strict;use warnings;use Exporter 'import';our$VERSION='0.01';our@EXPORT_OK=qw(symbol_without_sigil);our%EXPORT_TAGS=(all=>\@EXPORT_OK,);sub symbol_without_sigil {my ($symbol)=@_;(my$without_sigil=$symbol)=~ s< \A [\$@%*&] ><>xms;return$without_sigil}1;
PERL_CRITIC_UTILS_PERL

$fatpacked{"Perl/Critic/Violation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_VIOLATION';
  package Perl::Critic::Violation;use 5.006001;use strict;use warnings;use English qw<-no_match_vars>;use Readonly;use File::Basename qw<basename>;use IO::String qw<>;use Pod::PlainText qw<>;use Scalar::Util qw<blessed>;use String::Format qw<stringf>;use overload (q{""}=>'to_string',cmp=>'_compare');use Perl::Critic::Utils qw<:characters :internal_lookup>;use Perl::Critic::Utils::POD qw<get_pod_section_for_module trim_pod_section>;use Perl::Critic::Exception::Fatal::Internal qw<throw_internal>;our$VERSION='0.01';Readonly::Scalar my$LOCATION_LINE_NUMBER=>0;Readonly::Scalar my$LOCATION_COLUMN_NUMBER=>1;Readonly::Scalar my$LOCATION_VISUAL_COLUMN_NUMBER=>2;Readonly::Scalar my$LOCATION_LOGICAL_LINE_NUMBER=>3;Readonly::Scalar my$LOCATION_LOGICAL_FILENAME=>4;my$format="%m at line %l, column %c. %e.\n";my%diagnostics=();Readonly::Scalar my$CONSTRUCTOR_ARG_COUNT=>5;sub new {my ($class,$desc,$expl,$elem,$sev)=@_;if (@_!=$CONSTRUCTOR_ARG_COUNT){throw_internal 'Wrong number of args to Violation->new()'}if (eval {$elem->isa('Perl::Critic::Document')}){$elem=$elem->ppi_document()}if (not eval {$elem->isa('PPI::Element')}){throw_internal '3rd arg to Violation->new() must be a PPI::Element'}($desc,$expl)=_chomp_periods($desc,$expl);my$self=bless {},$class;$self->{_description}=$desc;$self->{_explanation}=$expl;$self->{_severity}=$sev;$self->{_policy}=caller;$self->{_element_class}=blessed$elem;my$top=$elem->top();$self->{_filename}=$top->can('filename')? $top->filename(): undef;$self->{_source}=_line_containing_violation($elem);$self->{_location}=$elem->location()|| [0,0,0,0,$self->filename()];return$self}sub set_format {return$format=verbosity_to_format($_[0])}sub get_format {return$format}sub sort_by_location {ref $_[0]|| shift;return scalar @_ if!wantarray;return map {$_->[0]}sort {($a->[1]<=> $b->[1])|| ($a->[2]<=> $b->[2])}map {[$_,$_->location->[0]|| 0,$_->location->[1]|| 0]}@_}sub sort_by_severity {ref $_[0]|| shift;return scalar @_ if!wantarray;return map {$_->[0]}sort {$a->[1]<=> $b->[1]}map {[$_,$_->severity()|| 0]}@_}sub location {my$self=shift;return$self->{_location}}sub line_number {my ($self)=@_;return$self->location()->[$LOCATION_LINE_NUMBER]}sub logical_line_number {my ($self)=@_;return$self->location()->[$LOCATION_LOGICAL_LINE_NUMBER]}sub column_number {my ($self)=@_;return$self->location()->[$LOCATION_COLUMN_NUMBER]}sub visual_column_number {my ($self)=@_;return$self->location()->[$LOCATION_VISUAL_COLUMN_NUMBER]}sub diagnostics {my ($self)=@_;my$policy=$self->policy();if (not $diagnostics{$policy}){eval {my$module_name=ref$policy || $policy;$diagnostics{$policy}=trim_pod_section(get_pod_section_for_module($module_name,'DESCRIPTION'))};$diagnostics{$policy}||= "    No diagnostics available\n"}return$diagnostics{$policy}}sub description {my$self=shift;return$self->{_description}}sub explanation {my$self=shift;my$expl=$self->{_explanation};if (!$expl){$expl='(no explanation)'}if (ref$expl eq 'ARRAY'){my$page=@{$expl}> 1 ? 'pages' : 'page';$page .= $SPACE .join$COMMA,@{$expl};$expl="See $page of PBP"}return$expl}sub severity {my$self=shift;return$self->{_severity}}sub policy {my$self=shift;return$self->{_policy}}sub filename {my$self=shift;return$self->{_filename}}sub logical_filename {my ($self)=@_;return$self->location()->[$LOCATION_LOGICAL_FILENAME]}sub source {my$self=shift;return$self->{_source}}sub element_class {my ($self)=@_;return$self->{_element_class}}sub to_string {my$self=shift;my$long_policy=$self->policy();(my$short_policy=$long_policy)=~ s/ \A Perl::Critic::Policy:: //xms;my%fspec=('f'=>sub {$self->logical_filename()},'F'=>sub {basename($self->logical_filename())},'g'=>sub {$self->filename()},'G'=>sub {basename($self->filename())},'l'=>sub {$self->logical_line_number()},'L'=>sub {$self->line_number()},'c'=>sub {$self->visual_column_number()},'C'=>sub {$self->element_class()},'m'=>$self->description(),'e'=>$self->explanation(),'s'=>$self->severity(),'d'=>sub {$self->diagnostics()},'r'=>sub {$self->source()},'P'=>$long_policy,'p'=>$short_policy,);return stringf($format,%fspec)}sub _compare {return "$_[0]" cmp "$_[1]"}sub _line_containing_violation {my ($elem)=@_;my$stmnt=$elem->statement()|| $elem;my$code_string=$stmnt->content()|| $EMPTY;my@lines=split qr{ \n\s* }xms,$code_string;my$inx=($elem->line_number()|| 0)- ($stmnt->line_number()|| 0);$inx > @lines and return$EMPTY;return$lines[$inx]}sub _chomp_periods {my@args=@_;for (@args){next if not defined or ref;s{ [.]+ \z }{}xms}return@args}1;
PERL_CRITIC_VIOLATION

$fatpacked{"Perl/Tidy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TIDY';
  package Perl::Tidy;use 5.004;use warnings;use strict;use Exporter;use Carp;$|++;use vars qw{$VERSION @ISA @EXPORT $missing_file_spec $fh_stderr $rOpts_character_encoding};@ISA=qw(Exporter);@EXPORT=qw(&perltidy);use Cwd;use Encode ();use IO::File;use File::Basename;use File::Copy;use File::Temp qw(tempfile);BEGIN {($VERSION=q($Id: Tidy.pm,v 0.01 2016/03/02 13:56:49 perltidy Exp $))=~ s/^.*\s+(\d+)\/(\d+)\/(\d+).*$/$1$2$3/}sub streamhandle {my$ref=ref(my$filename=shift);my$mode=shift;my$New;my$fh;if ($ref){if ($ref eq 'ARRAY'){$New=sub {Perl::Tidy::IOScalarArray->new(@_)}}elsif ($ref eq 'SCALAR'){$New=sub {Perl::Tidy::IOScalar->new(@_)}}else {if ($mode =~ /[rR]/){if ($ref->can('getline')){$New=sub {$filename}}else {$New=sub {undef};confess <<EOM}}if ($mode =~ /[wW]/){if ($ref->can('print')){$New=sub {$filename}}else {$New=sub {undef};confess <<EOM}}}}else {if ($filename eq '-'){$New=sub {$mode eq 'w' ? *STDOUT : *STDIN}}else {$New=sub {IO::File->new(@_)}}}$fh=$New->($filename,$mode)or Warn("Couldn't open file:$filename in mode:$mode : $!\n");return$fh,($ref or $filename)}sub find_input_line_ending {my ($input_file)=@_;my$ending;if (ref($input_file)|| $input_file eq '-'){return$ending}open(INFILE,$input_file)|| return$ending;binmode INFILE;my$buf;read(INFILE,$buf,1024);close INFILE;if ($buf && $buf =~ /([\012\015]+)/){my$test=$1;if ($test =~ /^(\015\012)+$/){$ending="\015\012"}elsif ($test =~ /^\015+$/){$ending="\015"}elsif ($test =~ /^\012+$/){$ending="\012"}else {}}else {}return$ending}sub catfile {BEGIN {eval "require File::Spec";$missing_file_spec=$@}unless ($missing_file_spec){return File::Spec->catfile(@_)}my$name=pop @_;my$path=join '/',@_;my$test_file=$path .$name;my ($test_name,$test_path)=fileparse($test_file);return$test_file if ($test_name eq $name);return undef if ($^O eq 'VMS');$test_file=$path .'/' .$name;($test_name,$test_path)=fileparse($test_file);return$test_file if ($test_name eq $name);return undef}sub perltidy {my%defaults=(argv=>undef,destination=>undef,formatter=>undef,logfile=>undef,errorfile=>undef,perltidyrc=>undef,source=>undef,stderr=>undef,dump_options=>undef,dump_options_type=>undef,dump_getopt_flags=>undef,dump_options_category=>undef,dump_options_range=>undef,dump_abbreviations=>undef,prefilter=>undef,postfilter=>undef,);local@ARGV=@ARGV;local*STDERR=*STDERR;my%input_hash=@_;if (my@bad_keys=grep {!exists$defaults{$_}}keys%input_hash){local $"=')(';my@good_keys=sort keys%defaults;@bad_keys=sort@bad_keys;confess <<EOM}my$get_hash_ref=sub {my ($key)=@_;my$hash_ref=$input_hash{$key};if (defined($hash_ref)){unless (ref($hash_ref)eq 'HASH'){my$what=ref($hash_ref);my$but_is=$what ? "but is ref to $what" : "but is not a reference";croak <<EOM}}return$hash_ref};%input_hash=(%defaults,%input_hash);my$argv=$input_hash{'argv'};my$destination_stream=$input_hash{'destination'};my$errorfile_stream=$input_hash{'errorfile'};my$logfile_stream=$input_hash{'logfile'};my$perltidyrc_stream=$input_hash{'perltidyrc'};my$source_stream=$input_hash{'source'};my$stderr_stream=$input_hash{'stderr'};my$user_formatter=$input_hash{'formatter'};my$prefilter=$input_hash{'prefilter'};my$postfilter=$input_hash{'postfilter'};if ($stderr_stream){($fh_stderr,my$stderr_file)=Perl::Tidy::streamhandle($stderr_stream,'w');if (!$fh_stderr){croak <<EOM}}else {$fh_stderr=*STDERR}sub Warn ($) {$fh_stderr->print($_[0])}sub Exit ($) {if ($_[0]){goto ERROR_EXIT}else {goto NORMAL_EXIT}}sub Die ($) {Warn $_[0];Exit(1)}my$dump_options_type=$input_hash{'dump_options_type'};my$dump_options=$get_hash_ref->('dump_options');my$dump_getopt_flags=$get_hash_ref->('dump_getopt_flags');my$dump_options_category=$get_hash_ref->('dump_options_category');my$dump_abbreviations=$get_hash_ref->('dump_abbreviations');my$dump_options_range=$get_hash_ref->('dump_options_range');if (defined($dump_options)){unless (defined($dump_options_type)){$dump_options_type='perltidyrc'}unless ($dump_options_type =~ /^(perltidyrc|full)$/){croak <<EOM}}else {$dump_options_type=""}if ($user_formatter){$destination_stream=Perl::Tidy::DevNull->new()}if (defined($argv)){my$rargv=ref$argv;if ($rargv eq 'SCALAR'){$argv=$$argv;$rargv=undef}if ($rargv){if ($rargv eq 'ARRAY'){@ARGV=@$argv}else {croak <<EOM}}else {my ($rargv,$msg)=parse_args($argv);if ($msg){Die <<EOM}@ARGV=@{$rargv}}}my$rpending_complaint;$$rpending_complaint="";my$rpending_logfile_message;$$rpending_logfile_message="";my ($is_Windows,$Windows_type)=look_for_Windows($rpending_complaint);my$dot;my$dot_pattern;if ($^O eq 'VMS'){$dot='_';$dot_pattern='_'}else {$dot='.';$dot_pattern='\.'}my ($rOpts,$config_file,$rraw_options,$roption_string,$rexpansion,$roption_category,$roption_range)=process_command_line($perltidyrc_stream,$is_Windows,$Windows_type,$rpending_complaint,$dump_options_type,);my$saw_extrude=(grep m/^-extrude$/,@$rraw_options)? 1 : 0;my$saw_pbp=(grep m/^-(pbp|perl-best-practices)$/,@$rraw_options)? 1 : 0;my$quit_now=0;if (defined($dump_getopt_flags)){$quit_now=1;for my$op (@{$roption_string}){my$opt=$op;my$flag="";if ($opt =~ /(.*)(!|=.*|:.*)$/){$opt=$1;$flag=$2}$dump_getopt_flags->{$opt}=$flag}}if (defined($dump_options_category)){$quit_now=1;%{$dump_options_category}=%{$roption_category}}if (defined($dump_options_range)){$quit_now=1;%{$dump_options_range}=%{$roption_range}}if (defined($dump_abbreviations)){$quit_now=1;%{$dump_abbreviations}=%{$rexpansion}}if (defined($dump_options)){$quit_now=1;%{$dump_options}=%{$rOpts}}Exit 0 if ($quit_now);my$readable_options=readable_options($rOpts,$roption_string);if ($rOpts->{'dump-options'}){print STDOUT$readable_options;Exit 0}my$tabsize=check_options($rOpts,$is_Windows,$Windows_type,$rpending_complaint);if ($user_formatter){$rOpts->{'format'}='user'}my%default_file_extension=(tidy=>'tdy',html=>'html',user=>'',);$rOpts_character_encoding=$rOpts->{'character-encoding'};unless (exists$default_file_extension{$rOpts->{'format'}}){my$formats=join ' ',sort map {"'" .$_ ."'"}keys%default_file_extension;my$fmt=$rOpts->{'format'};Die "-format='$fmt' but must be one of: $formats\n"}my$output_extension=make_extension($rOpts->{'output-file-extension'},$default_file_extension{$rOpts->{'format'}},$dot);my$bext=$rOpts->{'backup-file-extension'};my$delete_backup=($rOpts->{'backup-file-extension'}=~ s/\///g);if ($delete_backup > 1){Die "-bext=$bext contains more than one '/'\n"}my$backup_extension=make_extension($rOpts->{'backup-file-extension'},'bak',$dot);my$html_toc_extension=make_extension($rOpts->{'html-toc-extension'},'toc',$dot);my$html_src_extension=make_extension($rOpts->{'html-src-extension'},'src',$dot);my$in_place_modify=$rOpts->{'backup-and-modify-in-place'}&& $rOpts->{'format'}eq 'tidy';if ($in_place_modify){if ($rOpts->{'standard-output'}){$in_place_modify=0}if ($destination_stream){$in_place_modify=0}if (ref($source_stream)){$in_place_modify=0}if ($rOpts->{'outfile'}){$in_place_modify=0}if (defined($rOpts->{'output-path'})){$in_place_modify=0}}Perl::Tidy::Formatter::check_options($rOpts);if ($rOpts->{'format'}eq 'html'){Perl::Tidy::HtmlWriter->check_options($rOpts)}my$forbidden_file_extensions="(($dot_pattern)(LOG|DEBUG|ERR|TEE)";if ($output_extension){my$ext=quotemeta($output_extension);$forbidden_file_extensions .= "|$ext"}if ($in_place_modify && $backup_extension){my$ext=quotemeta($backup_extension);$forbidden_file_extensions .= "|$ext"}$forbidden_file_extensions .= ')$';my$diagnostics_object=undef;if ($rOpts->{'DIAGNOSTICS'}){$diagnostics_object=Perl::Tidy::Diagnostics->new()}if ($source_stream){if (@ARGV > 0){Die "You may not specify any filenames when a source array is given\n"}unshift(@ARGV,$source_stream);$source_stream=undef unless ref($source_stream)}else {unshift(@ARGV,'-')unless@ARGV}my$number_of_files=@ARGV;my$formatter=undef;my$tokenizer=undef;while (my$input_file=shift@ARGV){my$fileroot;my$input_file_permissions;if ($source_stream){$fileroot="perltidy";if (!defined($logfile_stream)){$logfile_stream=Perl::Tidy::DevNull->new()}}elsif ($input_file eq '-'){$fileroot="perltidy";$in_place_modify=0}else {$fileroot=$input_file;unless (-e $input_file){if ($input_file =~ /([\?\*\[\{])/){my$input_file=$input_file;if ($input_file =~ /^\'(.+)\'$/){$input_file=$1}if ($input_file =~ /^\"(.+)\"$/){$input_file=$1}my$pattern=fileglob_to_re($input_file);if (!$@ && opendir(DIR,'./')){my@files=grep {/$pattern/ &&!-d $_}readdir(DIR);closedir(DIR);if (@files){unshift@ARGV,@files;next}}}Warn "skipping file: '$input_file': no matches found\n";next}unless (-f $input_file){Warn "skipping file: $input_file: not a regular file\n";next}unless (-s $input_file){Warn "skipping file: $input_file: Zero size\n";next}unless ((-T $input_file)|| $rOpts->{'force-read-binary'}){Warn "skipping file: $input_file: Non-text (override with -f)\n";next}$fileroot=$input_file;$input_file_permissions=(stat$input_file)[2]& 07777;if ($^O eq 'VMS'){($fileroot,$dot)=check_vms_filename($fileroot)}if (defined($rOpts->{'output-path'})){my ($base,$old_path)=fileparse($fileroot);my$new_path=$rOpts->{'output-path'};unless (-d $new_path){unless (mkdir$new_path,0777){Die "unable to create directory $new_path: $!\n"}}my$path=$new_path;$fileroot=catfile($path,$base);unless ($fileroot){Die <<EOM}}}if (!$source_stream && ($input_file =~ /$forbidden_file_extensions/o || $input_file eq 'DIAGNOSTICS')){Warn "skipping file: $input_file: wrong extension\n";next}my$source_object=Perl::Tidy::LineSource->new($input_file,$rOpts,$rpending_logfile_message);next unless ($source_object);if ($prefilter || ($rOpts_character_encoding && $rOpts_character_encoding eq 'utf8')){my$buf='';while (my$line=$source_object->get_line()){$buf .= $line}$buf=$prefilter->($buf)if$prefilter;if ($rOpts_character_encoding && $rOpts_character_encoding eq 'utf8' &&!utf8::is_utf8($buf)){eval {$buf=Encode::decode('UTF-8',$buf,Encode::FB_CROAK | Encode::LEAVE_SRC)};if ($@){Warn "skipping file: $input_file: Unable to decode source as UTF-8\n";next}}$source_object=Perl::Tidy::LineSource->new(\$buf,$rOpts,$rpending_logfile_message)}$diagnostics_object->set_input_file($input_file)if$diagnostics_object;my$output_file=undef;my$actual_output_extension;if ($rOpts->{'outfile'}){if ($number_of_files <= 1){if ($rOpts->{'standard-output'}){my$msg="You may not use -o and -st together";$msg .= " (-pbp contains -st; see manual)" if ($saw_pbp);Die "$msg\n"}elsif ($destination_stream){Die "You may not specify a destination array and -o together\n"}elsif (defined($rOpts->{'output-path'})){Die "You may not specify -o and -opath together\n"}elsif (defined($rOpts->{'output-file-extension'})){Die "You may not specify -o and -oext together\n"}$output_file=$rOpts->{outfile};if ($output_file =~ /^-/){Die "You must specify a valid filename after -o\n"}if (defined($input_file_permissions)&& ($output_file eq $input_file)){Die "Use 'perltidy -b $input_file' to modify in-place\n"}}else {Die "You may not use -o with more than one input file\n"}}elsif ($rOpts->{'standard-output'}){if ($destination_stream){my$msg="You may not specify a destination array and -st together\n";$msg .= " (-pbp contains -st; see manual)" if ($saw_pbp);Die "$msg\n"}$output_file='-';if ($number_of_files <= 1){}else {Die "You may not use -st with more than one input file\n"}}elsif ($destination_stream){$output_file=$destination_stream}elsif ($source_stream){$output_file='-'}elsif ($input_file eq '-'){$output_file='-'}else {if ($in_place_modify){$output_file=IO::File->new_tmpfile()or Die "cannot open temp file for -b option: $!\n"}else {$actual_output_extension=$output_extension;$output_file=$fileroot .$output_extension}}my$tee_file=$fileroot .$dot ."TEE";my$line_separator=$rOpts->{'output-line-ending'};if ($rOpts->{'preserve-line-endings'}){$line_separator=find_input_line_ending($input_file)}my$binmode=defined($line_separator)|| defined($rOpts_character_encoding);$line_separator="\n" unless defined($line_separator);my ($sink_object,$postfilter_buffer);if ($postfilter){$sink_object=Perl::Tidy::LineSink->new(\$postfilter_buffer,$tee_file,$line_separator,$rOpts,$rpending_logfile_message,$binmode)}else {$sink_object=Perl::Tidy::LineSink->new($output_file,$tee_file,$line_separator,$rOpts,$rpending_logfile_message,$binmode)}my$warning_file=$fileroot .$dot ."ERR";if ($errorfile_stream){$warning_file=$errorfile_stream}my$log_file=$fileroot .$dot ."LOG";if ($logfile_stream){$log_file=$logfile_stream}my$logger_object=Perl::Tidy::Logger->new($rOpts,$log_file,$warning_file,$fh_stderr,$saw_extrude);write_logfile_header($rOpts,$logger_object,$config_file,$rraw_options,$Windows_type,$readable_options,);if ($$rpending_logfile_message){$logger_object->write_logfile_entry($$rpending_logfile_message)}if ($$rpending_complaint){$logger_object->complain($$rpending_complaint)}my$debugger_object=undef;if ($rOpts->{DEBUG}){$debugger_object=Perl::Tidy::Debugger->new($fileroot .$dot ."DEBUG")}my$max_iterations=$rOpts->{'iterations'};my$convergence_log_message;my%saw_md5;my$do_convergence_test=$max_iterations > 2;if ($do_convergence_test){eval "use Digest::MD5 qw(md5_hex)";$do_convergence_test=!$@;eval {my$string="perltidy";utf8::encode($string)};$do_convergence_test=$do_convergence_test &&!$@}my$sink_object_final=$sink_object;my$debugger_object_final=$debugger_object;my$logger_object_final=$logger_object;for (my$iter=1 ;$iter <= $max_iterations ;$iter++ ){my$sink_buffer;if ($iter < $max_iterations){$sink_object=Perl::Tidy::LineSink->new(\$sink_buffer,$tee_file,$line_separator,$rOpts,$rpending_logfile_message,$binmode)}else {$sink_object=$sink_object_final}if ($iter > 1){$debugger_object=undef;$logger_object=undef}$formatter=undef;if ($user_formatter){$formatter=$user_formatter}elsif ($rOpts->{'format'}eq 'html'){$formatter=Perl::Tidy::HtmlWriter->new($fileroot,$output_file,$actual_output_extension,$html_toc_extension,$html_src_extension)}elsif ($rOpts->{'format'}eq 'tidy'){$formatter=Perl::Tidy::Formatter->new(logger_object=>$logger_object,diagnostics_object=>$diagnostics_object,sink_object=>$sink_object,)}else {Die "I don't know how to do -format=$rOpts->{'format'}\n"}unless ($formatter){Die "Unable to continue with $rOpts->{'format'} formatting\n"}$tokenizer=undef;$tokenizer=Perl::Tidy::Tokenizer->new(source_object=>$source_object,logger_object=>$logger_object,debugger_object=>$debugger_object,diagnostics_object=>$diagnostics_object,tabsize=>$tabsize,starting_level=>$rOpts->{'starting-indentation-level'},indent_columns=>$rOpts->{'indent-columns'},look_for_hash_bang=>$rOpts->{'look-for-hash-bang'},look_for_autoloader=>$rOpts->{'look-for-autoloader'},look_for_selfloader=>$rOpts->{'look-for-selfloader'},trim_qw=>$rOpts->{'trim-qw'},extended_syntax=>$rOpts->{'extended-syntax'},continuation_indentation=>$rOpts->{'continuation-indentation'},outdent_labels=>$rOpts->{'outdent-labels'},);process_this_file($tokenizer,$formatter);$source_object->close_input_file();if ($iter < $max_iterations){$sink_object->close_output_file();$source_object=Perl::Tidy::LineSource->new(\$sink_buffer,$rOpts,$rpending_logfile_message);my$stop_now=$logger_object->{_warning_count};if ($stop_now){$convergence_log_message=<<EOM}elsif ($do_convergence_test){my$digest=md5_hex(utf8::encode($sink_buffer));if (!$saw_md5{$digest}){$saw_md5{$digest}=$iter}else {$stop_now=1;my$iterm=$iter - 1;if ($saw_md5{$digest}!=$iterm){$convergence_log_message=<<EOM;$diagnostics_object->write_diagnostics($convergence_log_message)if$diagnostics_object}else {$convergence_log_message=<<EOM;$diagnostics_object->write_diagnostics($convergence_log_message)if$diagnostics_object && $iterm > 2}}}if ($stop_now){$sink_object=$sink_object_final;while (my$line=$source_object->get_line()){$sink_object->write_line($line)}$source_object->close_input_file();last}}}$debugger_object=$debugger_object_final;$logger_object=$logger_object_final;$logger_object->write_logfile_entry($convergence_log_message)if$convergence_log_message;if ($postfilter){$sink_object->close_output_file();$sink_object=Perl::Tidy::LineSink->new($output_file,$tee_file,$line_separator,$rOpts,$rpending_logfile_message,$binmode);my$buf=$postfilter->($postfilter_buffer);$source_object=Perl::Tidy::LineSource->new(\$buf,$rOpts,$rpending_logfile_message);while (my$line=$source_object->get_line()){$sink_object->write_line($line)}$source_object->close_input_file()}my$ifname=$input_file;my$ofname=$output_file;if ($in_place_modify){unless (-f $input_file){Die "problem with -b backing up input file '$input_file': not a file\n"}my$backup_name=$input_file .$backup_extension;if (-f $backup_name){unlink($backup_name)or Die "unable to remove previous '$backup_name' for -b option; check permissions: $!\n"}if (-l $input_file){File::Copy::copy($input_file,$backup_name)or Die "File::Copy failed trying to backup source: $!"}else {rename($input_file,$backup_name)or Die "problem renaming $input_file to $backup_name for -b option: $!\n"}$ifname=$backup_name;seek($output_file,0,0)or Die "unable to rewind a temporary file for -b option: $!\n";my$fout=IO::File->new("> $input_file")or Die "problem re-opening $input_file for write for -b option; check file and directory permissions: $!\n";binmode$fout;my$line;while ($line=$output_file->getline()){$fout->print($line)}$fout->close();$output_file=$input_file;$ofname=$input_file}$sink_object->close_output_file()if$sink_object;$debugger_object->close_debug_file()if$debugger_object;if ($output_file && -f $output_file &&!-l $output_file){if ($input_file_permissions){if ($rOpts->{'format'}eq 'tidy'){chmod($input_file_permissions | 0600,$output_file)}}}my$infile_syntax_ok=0;if ($logger_object && $rOpts->{'check-syntax'}&& $ifname && $ofname){$infile_syntax_ok=check_syntax($ifname,$ofname,$logger_object,$rOpts)}if ($in_place_modify && $delete_backup && -f $ifname && ($delete_backup > 1 ||!$logger_object->{_warning_count})){if (!-s $output_file && -s $ifname && $delete_backup==1){Warn("output file '$output_file' missing or zero length; original '$ifname' not deleted\n")}else {unlink($ifname)or Die "unable to remove previous '$ifname' for -b option; check permissions: $!\n"}}$logger_object->finish($infile_syntax_ok,$formatter)if$logger_object}NORMAL_EXIT: return 0;ERROR_EXIT: return 1}sub get_stream_as_named_file {my ($stream)=@_;my$is_tmpfile;my$fname;if ($stream){if (ref($stream)){my ($fh_stream,$fh_name)=Perl::Tidy::streamhandle($stream,'r');if ($fh_stream){my ($fout,$tmpnam)=File::Temp::tempfile();if ($fout){$fname=$tmpnam;$is_tmpfile=1;binmode$fout;while (my$line=$fh_stream->getline()){$fout->print($line)}$fout->close()}$fh_stream->close()}}elsif ($stream ne '-' && -f $stream){$fname=$stream}}return ($fname,$is_tmpfile)}sub fileglob_to_re {my$x=shift;$x =~ s#([./^\$()])#\\$1#g;$x =~ s#\*#.*#g;$x =~ s#\?#.#g;"^$x\\z"}sub make_extension {my ($extension,$default,$dot)=@_;$extension=$default unless ($extension);if ($extension =~ /^[a-zA-Z0-9]/){$extension=$dot .$extension}return$extension}sub write_logfile_header {my ($rOpts,$logger_object,$config_file,$rraw_options,$Windows_type,$readable_options)=@_;$logger_object->write_logfile_entry("perltidy version $VERSION log file on a $^O system, OLD_PERL_VERSION=$]\n");if ($Windows_type){$logger_object->write_logfile_entry("Windows type is $Windows_type\n")}my$options_string=join(' ',@$rraw_options);if ($config_file){$logger_object->write_logfile_entry("Found Configuration File >>> $config_file \n")}$logger_object->write_logfile_entry("Configuration and command line parameters for this run:\n");$logger_object->write_logfile_entry("$options_string\n");if ($rOpts->{'DEBUG'}|| $rOpts->{'show-options'}){$rOpts->{'logfile'}=1;$logger_object->write_logfile_entry("Final parameter set for this run\n");$logger_object->write_logfile_entry("------------------------------------\n");$logger_object->write_logfile_entry($readable_options);$logger_object->write_logfile_entry("------------------------------------\n")}$logger_object->write_logfile_entry("To find error messages search for 'WARNING' with your editor\n")}sub generate_options {my@option_string=();my%expansion=();my%option_category=();my%option_range=();my$rexpansion=\%expansion;my@category_name=('0. I/O control','1. Basic formatting options','2. Code indentation control','3. Whitespace control','4. Comment controls','5. Linebreak controls','6. Controlling list formatting','7. Retaining or ignoring existing line breaks','8. Blank line control','9. Other controls','10. HTML options','11. pod2html options','12. Controlling HTML properties','13. Debugging',);@option_string=qw(html! noprofile no-profile npro recombine! valign! notidy);my$category=13;for (@option_string){my$opt=$_;$opt =~ s/!$//;$option_category{$opt}=$category_name[$category]}$category=11;$option_category{html}=$category_name[$category];my$add_option=sub {my ($long_name,$short_name,$flag)=@_;push@option_string,$long_name .$flag;$option_category{$long_name}=$category_name[$category];if ($short_name){if ($expansion{$short_name}){my$existing_name=$expansion{$short_name}[0];Die "redefining abbreviation $short_name for $long_name; already used for $existing_name\n"}$expansion{$short_name}=[$long_name];if ($flag eq '!'){my$nshort_name='n' .$short_name;my$nolong_name='no' .$long_name;if ($expansion{$nshort_name}){my$existing_name=$expansion{$nshort_name}[0];Die "attempting to redefine abbreviation $nshort_name for $nolong_name; already used for $existing_name\n"}$expansion{$nshort_name}=[$nolong_name]}}};$category=0;$add_option->('backup-and-modify-in-place','b','!');$add_option->('backup-file-extension','bext','=s');$add_option->('force-read-binary','f','!');$add_option->('format','fmt','=s');$add_option->('iterations','it','=i');$add_option->('logfile','log','!');$add_option->('logfile-gap','g',':i');$add_option->('outfile','o','=s');$add_option->('output-file-extension','oext','=s');$add_option->('output-path','opath','=s');$add_option->('profile','pro','=s');$add_option->('quiet','q','!');$add_option->('standard-error-output','se','!');$add_option->('standard-output','st','!');$add_option->('warning-output','w','!');$add_option->('character-encoding','enc','=s');$add_option->('output-line-ending','ole','=s');$add_option->('starting-indentation-level','sil','=i');$category=1;$add_option->('check-syntax','syn','!');$add_option->('entab-leading-whitespace','et','=i');$add_option->('indent-columns','i','=i');$add_option->('maximum-line-length','l','=i');$add_option->('variable-maximum-line-length','vmll','!');$add_option->('whitespace-cycle','wc','=i');$add_option->('perl-syntax-check-flags','pscf','=s');$add_option->('preserve-line-endings','ple','!');$add_option->('tabs','t','!');$add_option->('default-tabsize','dt','=i');$add_option->('extended-syntax','xs','!');$category=2;$add_option->('continuation-indentation','ci','=i');$add_option->('line-up-parentheses','lp','!');$add_option->('outdent-keyword-list','okwl','=s');$add_option->('outdent-keywords','okw','!');$add_option->('outdent-labels','ola','!');$add_option->('outdent-long-quotes','olq','!');$add_option->('indent-closing-brace','icb','!');$add_option->('closing-token-indentation','cti','=i');$add_option->('closing-paren-indentation','cpi','=i');$add_option->('closing-brace-indentation','cbi','=i');$add_option->('closing-square-bracket-indentation','csbi','=i');$add_option->('brace-left-and-indent','bli','!');$add_option->('brace-left-and-indent-list','blil','=s');$category=3;$add_option->('add-semicolons','asc','!');$add_option->('add-whitespace','aws','!');$add_option->('block-brace-tightness','bbt','=i');$add_option->('brace-tightness','bt','=i');$add_option->('delete-old-whitespace','dws','!');$add_option->('delete-semicolons','dsm','!');$add_option->('nospace-after-keyword','nsak','=s');$add_option->('nowant-left-space','nwls','=s');$add_option->('nowant-right-space','nwrs','=s');$add_option->('paren-tightness','pt','=i');$add_option->('space-after-keyword','sak','=s');$add_option->('space-for-semicolon','sfs','!');$add_option->('space-function-paren','sfp','!');$add_option->('space-keyword-paren','skp','!');$add_option->('space-terminal-semicolon','sts','!');$add_option->('square-bracket-tightness','sbt','=i');$add_option->('square-bracket-vertical-tightness','sbvt','=i');$add_option->('square-bracket-vertical-tightness-closing','sbvtc','=i');$add_option->('tight-secret-operators','tso','!');$add_option->('trim-qw','tqw','!');$add_option->('trim-pod','trp','!');$add_option->('want-left-space','wls','=s');$add_option->('want-right-space','wrs','=s');$category=4;$add_option->('closing-side-comment-else-flag','csce','=i');$add_option->('closing-side-comment-interval','csci','=i');$add_option->('closing-side-comment-list','cscl','=s');$add_option->('closing-side-comment-maximum-text','csct','=i');$add_option->('closing-side-comment-prefix','cscp','=s');$add_option->('closing-side-comment-warnings','cscw','!');$add_option->('closing-side-comments','csc','!');$add_option->('closing-side-comments-balanced','cscb','!');$add_option->('format-skipping','fs','!');$add_option->('format-skipping-begin','fsb','=s');$add_option->('format-skipping-end','fse','=s');$add_option->('hanging-side-comments','hsc','!');$add_option->('indent-block-comments','ibc','!');$add_option->('indent-spaced-block-comments','isbc','!');$add_option->('fixed-position-side-comment','fpsc','=i');$add_option->('minimum-space-to-comment','msc','=i');$add_option->('outdent-long-comments','olc','!');$add_option->('outdent-static-block-comments','osbc','!');$add_option->('static-block-comment-prefix','sbcp','=s');$add_option->('static-block-comments','sbc','!');$add_option->('static-side-comment-prefix','sscp','=s');$add_option->('static-side-comments','ssc','!');$add_option->('ignore-side-comment-lengths','iscl','!');$category=5;$add_option->('add-newlines','anl','!');$add_option->('block-brace-vertical-tightness','bbvt','=i');$add_option->('block-brace-vertical-tightness-list','bbvtl','=s');$add_option->('brace-vertical-tightness','bvt','=i');$add_option->('brace-vertical-tightness-closing','bvtc','=i');$add_option->('cuddled-else','ce','!');$add_option->('delete-old-newlines','dnl','!');$add_option->('opening-brace-always-on-right','bar','!');$add_option->('opening-brace-on-new-line','bl','!');$add_option->('opening-hash-brace-right','ohbr','!');$add_option->('opening-paren-right','opr','!');$add_option->('opening-square-bracket-right','osbr','!');$add_option->('opening-anonymous-sub-brace-on-new-line','asbl','!');$add_option->('opening-sub-brace-on-new-line','sbl','!');$add_option->('paren-vertical-tightness','pvt','=i');$add_option->('paren-vertical-tightness-closing','pvtc','=i');$add_option->('stack-closing-block-brace','scbb','!');$add_option->('stack-closing-hash-brace','schb','!');$add_option->('stack-closing-paren','scp','!');$add_option->('stack-closing-square-bracket','scsb','!');$add_option->('stack-opening-block-brace','sobb','!');$add_option->('stack-opening-hash-brace','sohb','!');$add_option->('stack-opening-paren','sop','!');$add_option->('stack-opening-square-bracket','sosb','!');$add_option->('vertical-tightness','vt','=i');$add_option->('vertical-tightness-closing','vtc','=i');$add_option->('want-break-after','wba','=s');$add_option->('want-break-before','wbb','=s');$add_option->('break-after-all-operators','baao','!');$add_option->('break-before-all-operators','bbao','!');$add_option->('keep-interior-semicolons','kis','!');$category=6;$add_option->('break-at-old-comma-breakpoints','boc','!');$add_option->('comma-arrow-breakpoints','cab','=i');$add_option->('maximum-fields-per-table','mft','=i');$category=7;$add_option->('break-at-old-keyword-breakpoints','bok','!');$add_option->('break-at-old-logical-breakpoints','bol','!');$add_option->('break-at-old-ternary-breakpoints','bot','!');$add_option->('break-at-old-attribute-breakpoints','boa','!');$add_option->('ignore-old-breakpoints','iob','!');$category=8;$add_option->('blanks-before-blocks','bbb','!');$add_option->('blanks-before-comments','bbc','!');$add_option->('blank-lines-before-subs','blbs','=i');$add_option->('blank-lines-before-packages','blbp','=i');$add_option->('long-block-line-count','lbl','=i');$add_option->('maximum-consecutive-blank-lines','mbl','=i');$add_option->('keep-old-blank-lines','kbl','=i');$category=9;$add_option->('delete-block-comments','dbc','!');$add_option->('delete-closing-side-comments','dcsc','!');$add_option->('delete-pod','dp','!');$add_option->('delete-side-comments','dsc','!');$add_option->('tee-block-comments','tbc','!');$add_option->('tee-pod','tp','!');$add_option->('tee-side-comments','tsc','!');$add_option->('look-for-autoloader','lal','!');$add_option->('look-for-hash-bang','x','!');$add_option->('look-for-selfloader','lsl','!');$add_option->('pass-version-line','pvl','!');$category=13;$add_option->('DEBUG','D','!');$add_option->('DIAGNOSTICS','I','!');$add_option->('dump-defaults','ddf','!');$add_option->('dump-long-names','dln','!');$add_option->('dump-options','dop','!');$add_option->('dump-profile','dpro','!');$add_option->('dump-short-names','dsn','!');$add_option->('dump-token-types','dtt','!');$add_option->('dump-want-left-space','dwls','!');$add_option->('dump-want-right-space','dwrs','!');$add_option->('fuzzy-line-length','fll','!');$add_option->('help','h','');$add_option->('short-concatenation-item-length','scl','=i');$add_option->('show-options','opt','!');$add_option->('version','v','');$add_option->('memoize','mem','!');Perl::Tidy::HtmlWriter->make_getopt_long_names(\@option_string);$category=12;for my$opt (@option_string){my$long_name=$opt;$long_name =~ s/(!|=.*|:.*)$//;unless (defined($option_category{$long_name})){if ($long_name =~ /^html-linked/){$category=10}elsif ($long_name =~ /^pod2html/){$category=11}$option_category{$long_name}=$category_name[$category]}}%option_range=('format'=>['tidy','html','user' ],'output-line-ending'=>['dos','win','mac','unix' ],'character-encoding'=>['none','utf8' ],'block-brace-tightness'=>[0,2 ],'brace-tightness'=>[0,2 ],'paren-tightness'=>[0,2 ],'square-bracket-tightness'=>[0,2 ],'block-brace-vertical-tightness'=>[0,2 ],'brace-vertical-tightness'=>[0,2 ],'brace-vertical-tightness-closing'=>[0,2 ],'paren-vertical-tightness'=>[0,2 ],'paren-vertical-tightness-closing'=>[0,2 ],'square-bracket-vertical-tightness'=>[0,2 ],'square-bracket-vertical-tightness-closing'=>[0,2 ],'vertical-tightness'=>[0,2 ],'vertical-tightness-closing'=>[0,2 ],'closing-brace-indentation'=>[0,3 ],'closing-paren-indentation'=>[0,3 ],'closing-square-bracket-indentation'=>[0,3 ],'closing-token-indentation'=>[0,3 ],'closing-side-comment-else-flag'=>[0,2 ],'comma-arrow-breakpoints'=>[0,5 ],);my@defaults=qw(add-newlines add-semicolons add-whitespace blanks-before-blocks blanks-before-comments blank-lines-before-subs=1 blank-lines-before-packages=1 block-brace-tightness=0 block-brace-vertical-tightness=0 brace-tightness=1 brace-vertical-tightness-closing=0 brace-vertical-tightness=0 break-at-old-logical-breakpoints break-at-old-ternary-breakpoints break-at-old-attribute-breakpoints break-at-old-keyword-breakpoints comma-arrow-breakpoints=5 nocheck-syntax closing-side-comment-interval=6 closing-side-comment-maximum-text=20 closing-side-comment-else-flag=0 closing-side-comments-balanced closing-paren-indentation=0 closing-brace-indentation=0 closing-square-bracket-indentation=0 continuation-indentation=2 delete-old-newlines delete-semicolons extended-syntax fuzzy-line-length hanging-side-comments indent-block-comments indent-columns=4 iterations=1 keep-old-blank-lines=1 long-block-line-count=8 look-for-autoloader look-for-selfloader maximum-consecutive-blank-lines=1 maximum-fields-per-table=0 maximum-line-length=80 memoize minimum-space-to-comment=4 nobrace-left-and-indent nocuddled-else nodelete-old-whitespace nohtml nologfile noquiet noshow-options nostatic-side-comments notabs nowarning-output character-encoding=none outdent-labels outdent-long-quotes outdent-long-comments paren-tightness=1 paren-vertical-tightness-closing=0 paren-vertical-tightness=0 pass-version-line recombine valign short-concatenation-item-length=8 space-for-semicolon square-bracket-tightness=1 square-bracket-vertical-tightness-closing=0 square-bracket-vertical-tightness=0 static-block-comments trim-qw format=tidy backup-file-extension=bak format-skipping default-tabsize=8 pod2html html-table-of-contents html-entities);push@defaults,"perl-syntax-check-flags=-c -T";%expansion=(%expansion,'freeze-newlines'=>[qw(noadd-newlines nodelete-old-newlines)],'fnl'=>[qw(freeze-newlines)],'freeze-whitespace'=>[qw(noadd-whitespace nodelete-old-whitespace)],'fws'=>[qw(freeze-whitespace)],'freeze-blank-lines'=>[qw(maximum-consecutive-blank-lines=0 keep-old-blank-lines=2)],'fbl'=>[qw(freeze-blank-lines)],'indent-only'=>[qw(freeze-newlines freeze-whitespace)],'outdent-long-lines'=>[qw(outdent-long-quotes outdent-long-comments)],'nooutdent-long-lines'=>[qw(nooutdent-long-quotes nooutdent-long-comments)],'noll'=>[qw(nooutdent-long-lines)],'io'=>[qw(indent-only)],'delete-all-comments'=>[qw(delete-block-comments delete-side-comments delete-pod)],'nodelete-all-comments'=>[qw(nodelete-block-comments nodelete-side-comments nodelete-pod)],'dac'=>[qw(delete-all-comments)],'ndac'=>[qw(nodelete-all-comments)],'gnu'=>[qw(gnu-style)],'pbp'=>[qw(perl-best-practices)],'tee-all-comments'=>[qw(tee-block-comments tee-side-comments tee-pod)],'notee-all-comments'=>[qw(notee-block-comments notee-side-comments notee-pod)],'tac'=>[qw(tee-all-comments)],'ntac'=>[qw(notee-all-comments)],'html'=>[qw(format=html)],'nhtml'=>[qw(format=tidy)],'tidy'=>[qw(format=tidy)],'utf8'=>[qw(character-encoding=utf8)],'UTF8'=>[qw(character-encoding=utf8)],'swallow-optional-blank-lines'=>[qw(kbl=0)],'noswallow-optional-blank-lines'=>[qw(kbl=1)],'sob'=>[qw(kbl=0)],'nsob'=>[qw(kbl=1)],'break-after-comma-arrows'=>[qw(cab=0)],'nobreak-after-comma-arrows'=>[qw(cab=1)],'baa'=>[qw(cab=0)],'nbaa'=>[qw(cab=1)],'blanks-before-subs'=>[qw(blbs=1 blbp=1)],'bbs'=>[qw(blbs=1 blbp=1)],'noblanks-before-subs'=>[qw(blbs=0 blbp=0)],'nbbs'=>[qw(blbs=0 blbp=0)],'break-at-old-trinary-breakpoints'=>[qw(bot)],'cti=0'=>[qw(cpi=0 cbi=0 csbi=0)],'cti=1'=>[qw(cpi=1 cbi=1 csbi=1)],'cti=2'=>[qw(cpi=2 cbi=2 csbi=2)],'icp'=>[qw(cpi=2 cbi=2 csbi=2)],'nicp'=>[qw(cpi=0 cbi=0 csbi=0)],'closing-token-indentation=0'=>[qw(cpi=0 cbi=0 csbi=0)],'closing-token-indentation=1'=>[qw(cpi=1 cbi=1 csbi=1)],'closing-token-indentation=2'=>[qw(cpi=2 cbi=2 csbi=2)],'indent-closing-paren'=>[qw(cpi=2 cbi=2 csbi=2)],'noindent-closing-paren'=>[qw(cpi=0 cbi=0 csbi=0)],'vt=0'=>[qw(pvt=0 bvt=0 sbvt=0)],'vt=1'=>[qw(pvt=1 bvt=1 sbvt=1)],'vt=2'=>[qw(pvt=2 bvt=2 sbvt=2)],'vertical-tightness=0'=>[qw(pvt=0 bvt=0 sbvt=0)],'vertical-tightness=1'=>[qw(pvt=1 bvt=1 sbvt=1)],'vertical-tightness=2'=>[qw(pvt=2 bvt=2 sbvt=2)],'vtc=0'=>[qw(pvtc=0 bvtc=0 sbvtc=0)],'vtc=1'=>[qw(pvtc=1 bvtc=1 sbvtc=1)],'vtc=2'=>[qw(pvtc=2 bvtc=2 sbvtc=2)],'vertical-tightness-closing=0'=>[qw(pvtc=0 bvtc=0 sbvtc=0)],'vertical-tightness-closing=1'=>[qw(pvtc=1 bvtc=1 sbvtc=1)],'vertical-tightness-closing=2'=>[qw(pvtc=2 bvtc=2 sbvtc=2)],'otr'=>[qw(opr ohbr osbr)],'opening-token-right'=>[qw(opr ohbr osbr)],'notr'=>[qw(nopr nohbr nosbr)],'noopening-token-right'=>[qw(nopr nohbr nosbr)],'sot'=>[qw(sop sohb sosb)],'nsot'=>[qw(nsop nsohb nsosb)],'stack-opening-tokens'=>[qw(sop sohb sosb)],'nostack-opening-tokens'=>[qw(nsop nsohb nsosb)],'sct'=>[qw(scp schb scsb)],'stack-closing-tokens'=>=>[qw(scp schb scsb)],'nsct'=>[qw(nscp nschb nscsb)],'nostack-closing-tokens'=>[qw(nscp nschb nscsb)],'sac'=>[qw(sot sct)],'nsac'=>[qw(nsot nsct)],'stack-all-containers'=>[qw(sot sct)],'nostack-all-containers'=>[qw(nsot nsct)],'act=0'=>[qw(pt=0 sbt=0 bt=0 bbt=0)],'act=1'=>[qw(pt=1 sbt=1 bt=1 bbt=1)],'act=2'=>[qw(pt=2 sbt=2 bt=2 bbt=2)],'all-containers-tightness=0'=>[qw(pt=0 sbt=0 bt=0 bbt=0)],'all-containers-tightness=1'=>[qw(pt=1 sbt=1 bt=1 bbt=1)],'all-containers-tightness=2'=>[qw(pt=2 sbt=2 bt=2 bbt=2)],'stack-opening-block-brace'=>[qw(bbvt=2 bbvtl=*)],'sobb'=>[qw(bbvt=2 bbvtl=*)],'nostack-opening-block-brace'=>[qw(bbvt=0)],'nsobb'=>[qw(bbvt=0)],'converge'=>[qw(it=4)],'noconverge'=>[qw(it=1)],'conv'=>[qw(it=4)],'nconv'=>[qw(it=1)],'mangle'=>[qw(check-syntax keep-old-blank-lines=0 delete-old-newlines delete-old-whitespace delete-semicolons indent-columns=0 maximum-consecutive-blank-lines=0 maximum-line-length=100000 noadd-newlines noadd-semicolons noadd-whitespace noblanks-before-blocks blank-lines-before-subs=0 blank-lines-before-packages=0 notabs) ],'extrude'=>[qw(check-syntax ci=0 delete-old-newlines delete-old-whitespace delete-semicolons indent-columns=0 maximum-consecutive-blank-lines=0 maximum-line-length=1 noadd-semicolons noadd-whitespace noblanks-before-blocks blank-lines-before-subs=0 blank-lines-before-packages=0 nofuzzy-line-length notabs norecombine) ],'gnu-style'=>[qw(lp bl noll pt=2 bt=2 sbt=2 cpi=1 csbi=1 cbi=1) ],'perl-best-practices'=>[qw(l=78 i=4 ci=4 st se vt=2 cti=0 pt=1 bt=1 sbt=1 bbt=1 nsfs nolq),q(wbb=% + - * / x != == >= <= =~ !~ < > | & = **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= x=) ],);Perl::Tidy::HtmlWriter->make_abbreviated_names(\%expansion);return (\@option_string,\@defaults,\%expansion,\%option_category,\%option_range)}my%process_command_line_cache;sub process_command_line {my ($perltidyrc_stream,$is_Windows,$Windows_type,$rpending_complaint,$dump_options_type)=@_;my$use_cache=!defined($perltidyrc_stream)&&!$dump_options_type;if ($use_cache){my$cache_key=join(chr(28),@ARGV);if (my$result=$process_command_line_cache{$cache_key}){my ($argv,@retvals)=@$result;@ARGV=@$argv;return@retvals}else {my@retvals=_process_command_line(@_);$process_command_line_cache{$cache_key}=[\@ARGV,@retvals ]if$retvals[0]->{'memoize'};return@retvals}}else {return _process_command_line(@_)}}sub _process_command_line {my ($perltidyrc_stream,$is_Windows,$Windows_type,$rpending_complaint,$dump_options_type)=@_;use Getopt::Long;my ($roption_string,$rdefaults,$rexpansion,$roption_category,$roption_range)=generate_options();my%Opts=();{local@ARGV;my$i;unless ($dump_options_type eq 'perltidyrc'){for$i (@$rdefaults){push@ARGV,"--" .$i}}my$glc;eval {$glc=Getopt::Long::Configure()};unless ($@){eval {Getopt::Long::ConfigDefaults()}}else {$glc=undef}if (!GetOptions(\%Opts,@$roption_string)){Die "Programming Bug: error in setting default options"}eval {Getopt::Long::Configure($glc)}if defined$glc}my$word;my@raw_options=();my$config_file="";my$saw_ignore_profile=0;my$saw_dump_profile=0;my$i;for$i (@ARGV){$i =~ s/^--/-/;if ($i =~ /^-(npro|noprofile|no-profile)$/){$saw_ignore_profile=1}elsif ($i =~ /^-(dump-profile|dpro)$/){$saw_dump_profile=1}elsif ($i =~ /^-(pro|profile)=(.+)/){if ($config_file){Warn "Only one -pro=filename allowed, using '$2' instead of '$config_file'\n"}$config_file=$2;if (defined($config_file)){if (my ($start_dir,$search_file)=($config_file =~ m{^(.*)\.\.\./(.*)$})){$start_dir='.' if!$start_dir;$start_dir=Cwd::realpath($start_dir);if (my$found_file=find_file_upwards($start_dir,$search_file)){$config_file=$found_file}}}unless (-e $config_file){Warn "cannot find file given with -pro=$config_file: $!\n";$config_file=""}}elsif ($i =~ /^-(pro|profile)=?$/){Die "usage: -pro=filename or --profile=filename, no spaces\n"}elsif ($i =~ /^-(help|h|HELP|H|\?)$/){usage();Exit 0}elsif ($i =~ /^-(version|v)$/){show_version();Exit 0}elsif ($i =~ /^-(dump-defaults|ddf)$/){dump_defaults(@$rdefaults);Exit 0}elsif ($i =~ /^-(dump-long-names|dln)$/){dump_long_names(@$roption_string);Exit 0}elsif ($i =~ /^-(dump-short-names|dsn)$/){dump_short_names($rexpansion);Exit 0}elsif ($i =~ /^-(dump-token-types|dtt)$/){Perl::Tidy::Tokenizer->dump_token_types(*STDOUT);Exit 0}}if ($saw_dump_profile && $saw_ignore_profile){Warn "No profile to dump because of -npro\n";Exit 1}unless ($saw_ignore_profile){if ($perltidyrc_stream){if ($config_file){Warn <<EOM}else {$config_file=$perltidyrc_stream}}my$rconfig_file_chatter;$$rconfig_file_chatter="";$config_file=find_config_file($is_Windows,$Windows_type,$rconfig_file_chatter,$rpending_complaint)unless$config_file;my$fh_config;if ($config_file){($fh_config,$config_file)=Perl::Tidy::streamhandle($config_file,'r');unless ($fh_config){$$rconfig_file_chatter .= "# $config_file exists but cannot be opened\n"}}if ($saw_dump_profile){dump_config_file($fh_config,$config_file,$rconfig_file_chatter);Exit 0}if ($fh_config){my ($rconfig_list,$death_message)=read_config_file($fh_config,$config_file,$rexpansion);Die$death_message if ($death_message);if (@$rconfig_list){local@ARGV=@$rconfig_list;expand_command_abbreviations($rexpansion,\@raw_options,$config_file);if (!GetOptions(\%Opts,@$roption_string)){Die "Error in this config file: $config_file  \nUse -npro to ignore this file, -h for help'\n"}if (@ARGV){my$count=@ARGV;my$str="\'" .pop(@ARGV)."\'";while (my$param=pop(@ARGV)){if (length($str)< 70){$str .= ", '$param'"}else {$str .= ", ...";last}}Die <<EOM}for (qw{dump-defaults dump-long-names dump-options dump-profile dump-short-names dump-token-types dump-want-left-space dump-want-right-space help stylesheet version}){if (defined($Opts{$_})){delete$Opts{$_};Warn "ignoring --$_ in config file: $config_file\n"}}}}}expand_command_abbreviations($rexpansion,\@raw_options,$config_file);local$SIG{'__WARN__'}=sub {Warn $_[0]};if (!GetOptions(\%Opts,@$roption_string)){Die "Error on command line; for help try 'perltidy -h'\n"}return (\%Opts,$config_file,\@raw_options,$roption_string,$rexpansion,$roption_category,$roption_range)}sub check_options {my ($rOpts,$is_Windows,$Windows_type,$rpending_complaint)=@_;if (defined$rOpts->{'vertical-tightness'}){my$vt=$rOpts->{'vertical-tightness'};$rOpts->{'paren-vertical-tightness'}=$vt;$rOpts->{'square-bracket-vertical-tightness'}=$vt;$rOpts->{'brace-vertical-tightness'}=$vt}if (defined$rOpts->{'vertical-tightness-closing'}){my$vtc=$rOpts->{'vertical-tightness-closing'};$rOpts->{'paren-vertical-tightness-closing'}=$vtc;$rOpts->{'square-bracket-vertical-tightness-closing'}=$vtc;$rOpts->{'brace-vertical-tightness-closing'}=$vtc}if (defined$rOpts->{'closing-token-indentation'}){my$cti=$rOpts->{'closing-token-indentation'};$rOpts->{'closing-square-bracket-indentation'}=$cti;$rOpts->{'closing-brace-indentation'}=$cti;$rOpts->{'closing-paren-indentation'}=$cti}if ($rOpts->{'quiet'}){$rOpts->{'check-syntax'}=0}if ($rOpts->{'format'}ne 'tidy'){$rOpts->{'check-syntax'}=0}if ($rOpts->{'check-syntax'}&& $is_Windows && (!$Windows_type || $Windows_type =~ /^(9|Me)/)){$rOpts->{'check-syntax'}=0}unless ($is_Windows){if ($<==0 && $rOpts->{'check-syntax'}){$rOpts->{'check-syntax'}=0;$$rpending_complaint .= "Syntax check deactivated for safety; you shouldn't run this as root\n"}}if ($rOpts->{'format'}ne 'tidy'){$rOpts->{'iterations'}=1}elsif (defined($rOpts->{'iterations'})){if ($rOpts->{'iterations'}<= 0){$rOpts->{'iterations'}=1}elsif ($rOpts->{'iterations'}> 6){$rOpts->{'iterations'}=6}}else {$rOpts->{'iterations'}=1}if ($rOpts->{'blank-lines-before-subs'}){if ($rOpts->{'blank-lines-before-subs'}< 0){$rOpts->{'blank-lines-before-subs'}=0;Warn "negative value of -blbs, setting 0\n"}if ($rOpts->{'blank-lines-before-subs'}> 100){Warn "unreasonably large value of -blbs, reducing\n";$rOpts->{'blank-lines-before-subs'}=100}}if ($rOpts->{'blank-lines-before-packages'}){if ($rOpts->{'blank-lines-before-packages'}< 0){Warn "negative value of -blbp, setting 0\n";$rOpts->{'blank-lines-before-packages'}=0}if ($rOpts->{'blank-lines-before-packages'}> 100){Warn "unreasonably large value of -blbp, reducing\n";$rOpts->{'blank-lines-before-packages'}=100}}if (defined($rOpts->{'logfile-gap'})&& $rOpts->{'logfile-gap'}>= 0){$rOpts->{'logfile'}=1}if (!$rOpts->{'add-whitespace'}&&!$rOpts->{'delete-old-whitespace'}&&!$rOpts->{'add-newlines'}&&!$rOpts->{'delete-old-newlines'}){$rOpts->{'indent-only'}=1}if ($rOpts->{'indent-spaced-block-comments'}){$rOpts->{'indent-block-comments'}=1}if ($rOpts->{'brace-left-and-indent'}){$rOpts->{'opening-brace-on-new-line'}=1}if ($rOpts->{'opening-brace-always-on-right'}&& $rOpts->{'opening-brace-on-new-line'}){Warn <<EOM;$rOpts->{'opening-brace-on-new-line'}=0}if (!defined($rOpts->{'opening-brace-on-new-line'})){$rOpts->{'opening-brace-on-new-line'}=0}if (!defined($rOpts->{'opening-sub-brace-on-new-line'})){$rOpts->{'opening-sub-brace-on-new-line'}=$rOpts->{'opening-brace-on-new-line'}}if ($rOpts->{'entab-leading-whitespace'}){if ($rOpts->{'entab-leading-whitespace'}< 0){Warn "-et=n must use a positive integer; ignoring -et\n";$rOpts->{'entab-leading-whitespace'}=undef}if ($rOpts->{'tabs'}){$rOpts->{'tabs'}=0}}if ($rOpts->{'default-tabsize'}){if ($rOpts->{'default-tabsize'}< 0){Warn "negative value of -dt, setting 0\n";$rOpts->{'default-tabsize'}=0}if ($rOpts->{'default-tabsize'}> 20){Warn "unreasonably large value of -dt, reducing\n";$rOpts->{'default-tabsize'}=20}}else {$rOpts->{'default-tabsize'}=8}my$tabsize=$rOpts->{'entab-leading-whitespace'}? $rOpts->{'entab-leading-whitespace'}: $rOpts->{'tabs'}? $rOpts->{'indent-columns'}: $rOpts->{'default-tabsize'};return$tabsize}sub find_file_upwards {my ($search_dir,$search_file)=@_;$search_dir =~ s{/+$}{};$search_file =~ s{^/+}{};while (1){my$try_path="$search_dir/$search_file";if (-f $try_path){return$try_path}elsif ($search_dir eq '/'){return undef}else {$search_dir=dirname($search_dir)}}}sub expand_command_abbreviations {my ($rexpansion,$rraw_options,$config_file)=@_;my ($word);my$max_passes=10;my@new_argv=();for (my$pass_count=0 ;$pass_count <= $max_passes ;$pass_count++ ){my@new_argv=();my$abbrev_count=0;for$word (@ARGV){if ($word =~ /^(-[-]?no)-(.*)/){$word=$1 .$2}if ($word =~ /^-[-]?([\w\-]+)(.*)/){my$abr=$1;my$flags=$2;if ($pass_count==0){push(@$rraw_options,$word)}if ($rexpansion->{$abr .$flags }){$abr=$abr .$flags;$flags=""}if ($rexpansion->{$abr}){$abbrev_count++;for my$abbrev (@{$rexpansion->{$abr}}){next unless$abbrev;push(@new_argv,'--' .$abbrev .$flags)}}else {push(@new_argv,$word)}}else {push(@new_argv,$word)}}@ARGV=@new_argv;last unless ($abbrev_count > 0);if ($pass_count==$max_passes){local $"=')(';Warn <<EOM;my$num=@new_argv;if ($num < 50){Warn <<EOM}else {Warn <<EOM}if ($config_file){Die <<"DIE"}else {Die <<'DIE'}}}}sub dump_short_names {my$rexpansion=shift;print STDOUT <<EOM;for my$abbrev (sort keys %$rexpansion){my@list=@{$$rexpansion{$abbrev}};print STDOUT "$abbrev --> @list\n"}}sub check_vms_filename {my ($base,$path)=fileparse($_[0]);$base =~ s/;-?\d*$// or $base =~ s/(          # begin capture $1
  ------------------------------------------------------------------------
  No 'getline' method is defined for object of class $ref
  Please check your call to Perl::Tidy::perltidy.  Trace follows.
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  No 'print' method is defined for object of class $ref
  Please check your call to Perl::Tidy::perltidy. Trace follows.
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  Unknown perltidy parameter : (@bad_keys)
  perltidy only understands : (@good_keys)
  ------------------------------------------------------------------------
  
  EOM
  ------------------------------------------------------------------------
  error in call to perltidy:
  -$key must be reference to HASH $but_is
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  Unable to redirect STDERR to $stderr_stream
  Please check value of -stderr in call to perltidy
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  Please check value of -dump_options_type in call to perltidy;
  saw: '$dump_options_type' 
  expecting: 'perltidyrc' or 'full'
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  Please check value of -argv in call to perltidy;
  it must be a string or ref to ARRAY but is: $rargv
  ------------------------------------------------------------------------
  EOM
  Error parsing this string passed to to perltidy with 'argv': 
  $msg
  EOM
  ------------------------------------------------------------------------
  Problem combining $new_path and $base to make a filename; check -opath
  ------------------------------------------------------------------------
  EOM
  Stopping iterations because of errors.                       
  EOM
  Blinking. Output for iteration $iter same as for $saw_md5{$digest}. 
  EOM
  Converged.  Output for iteration $iter same as for iter $iterm.
  EOM
   Conflict: a perltidyrc configuration file was specified both as this
   perltidy call parameter: $perltidyrc_stream 
   and with this -profile=$config_file.
   Using -profile=$config_file.
  EOM
  There are $count unrecognized values in the configuration file '$config_file':
  $str
  Use leading dashes for parameters.  Use -npro to ignore this file.
  EOM
   Conflict: you specified both 'opening-brace-always-on-right' (-bar) and 
    'opening-brace-on-new-line' (-bl).  Ignoring -bl. 
  EOM
  I'm tired. We seem to be in an infinite loop trying to expand aliases.
  Here are the raw options;
  (rraw_options)
  EOM
  After $max_passes passes here is ARGV
  (@new_argv)
  EOM
  After $max_passes passes ARGV has $num entries
  EOM
  Please check your configuration file $config_file for circular-references. 
  To deactivate it, use -npro.
  DIE
  Program bug - circular-references in the %expansion hash, probably due to
  a recent program change.
  DIE
  List of short names.  This list shows how all abbreviations are
  translated into other abbreviations and, eventually, into long names.
  New abbreviations may be defined in a .perltidyrc file.  
  For a list of all long names, use perltidy --dump-long-names (-dln).
  --------------------------------------------------------------------------
  EOM
                    (?:^|[^^])\. # match a dot not preceded by a caret
                    (?:          # followed by nothing
                      |          # or
                      .*[^^]     # anything ending in a non caret
                    )
                  )              # end capture $1
                  \.-?\d*$       # match . version number
                /$1/x;$base .= '.' unless$base =~ /(?:^|[^^])\./;my$separator=($base =~ /\.$/)? "" : "_";return ($path .$base,$separator)}sub Win_OS_Type {my$rpending_complaint=shift;my$os="";return$os unless $^O =~ /win32|dos/i;my ($undef,$major,$minor,$build,$id);eval {($undef,$major,$minor,$build,$id)=Win32::GetOSVersion()};return "win32s" unless$id;$os={1=>{0=>"95",10=>"98",90=>"Me" },2=>{0=>"2000",1=>"XP/.Net",2=>"Win2003",51=>"NT3.51" }}->{$id}->{$minor};unless (defined$os){$os="";$$rpending_complaint .= <<EOS}return ($os eq "2000" && $major!=5)? "NT4" : $os}sub is_unix {return ($^O !~ /win32|dos/i)&& ($^O ne 'VMS')&& ($^O ne 'OS2')&& ($^O ne 'MacOS')}sub look_for_Windows {my$rpending_complaint=shift;my$is_Windows=($^O =~ /win32|dos/i);my$Windows_type=Win_OS_Type($rpending_complaint)if$is_Windows;return ($is_Windows,$Windows_type)}sub find_config_file {my ($is_Windows,$Windows_type,$rconfig_file_chatter,$rpending_complaint)=@_;$$rconfig_file_chatter .= "# Config file search...system reported as:";if ($is_Windows){$$rconfig_file_chatter .= "Windows $Windows_type\n"}else {$$rconfig_file_chatter .= " $^O\n"}my$exists_config_file=sub {my$config_file=shift;return 0 unless$config_file;$$rconfig_file_chatter .= "# Testing: $config_file\n";return -f $config_file};my$config_file;$config_file=".perltidyrc";return$config_file if$exists_config_file->($config_file);if ($is_Windows){$config_file="perltidy.ini";return$config_file if$exists_config_file->($config_file)}my@envs=qw(PERLTIDY HOME);push@envs,qw(USERPROFILE HOMESHARE) if $^O =~ /win32/i;for my$var (@envs){$$rconfig_file_chatter .= "# Examining: \$ENV{$var}";if (defined($ENV{$var})){$$rconfig_file_chatter .= " = $ENV{$var}\n";if ($var eq 'PERLTIDY'){$config_file="$ENV{$var}";return$config_file if$exists_config_file->($config_file)}$config_file=catfile($ENV{$var},".perltidyrc");return$config_file if$exists_config_file->($config_file);if ($is_Windows){$config_file=catfile($ENV{$var},"perltidy.ini");return$config_file if$exists_config_file->($config_file)}}else {$$rconfig_file_chatter .= "\n"}}if ($is_Windows){if ($Windows_type){my ($os,$system,$allusers)=Win_Config_Locs($rpending_complaint,$Windows_type);if ($allusers){$config_file=catfile($allusers,".perltidyrc");return$config_file if$exists_config_file->($config_file);$config_file=catfile($allusers,"perltidy.ini");return$config_file if$exists_config_file->($config_file)}$config_file=catfile($system,".perltidyrc");return$config_file if$exists_config_file->($config_file);$config_file=catfile($system,"perltidy.ini");return$config_file if$exists_config_file->($config_file)}}elsif ($^O eq 'OS2'){}elsif ($^O eq 'MacOS'){}elsif ($^O eq 'VMS'){}else {$config_file="/usr/local/etc/perltidyrc";return$config_file if$exists_config_file->($config_file);$config_file="/etc/perltidyrc";return$config_file if$exists_config_file->($config_file)}return}sub Win_Config_Locs {my$rpending_complaint=shift;my$os=(@_)? shift : Win_OS_Type();return unless$os;my$system="";my$allusers="";if ($os =~ /9[58]|Me/){$system="C:/Windows"}elsif ($os =~ /NT|XP|200?/){$system=($os =~ /XP/)? "C:/Windows/" : "C:/WinNT/";$allusers=($os =~ /NT/)? "C:/WinNT/profiles/All Users/" : "C:/Documents and Settings/All Users/"}else {$$rpending_complaint .= "I dont know a sensible place to look for config files on an $os system.\n";return}return wantarray ? ($os,$system,$allusers): $os}sub dump_config_file {my$fh=shift;my$config_file=shift;my$rconfig_file_chatter=shift;print STDOUT "$$rconfig_file_chatter";if ($fh){print STDOUT "# Dump of file: '$config_file'\n";while (my$line=$fh->getline()){print STDOUT$line}eval {$fh->close()}}else {print STDOUT "# ...no config file found\n"}}sub read_config_file {my ($fh,$config_file,$rexpansion)=@_;my@config_list=();my$death_message="";my$name=undef;my$line_no;my$opening_brace_line;while (my$line=$fh->getline()){$line_no++;chomp$line;($line,$death_message)=strip_comment($line,$config_file,$line_no);last if ($death_message);next unless$line;$line =~ s/^\s*(.*?)\s*$/$1/;next unless$line;my$body=$line;my$newname;if ($line =~ /^((\w+)\s*\{)(.*)?$/){my$oldname=$name;($name,$body)=($2,$3);last if ($opening_brace_line);$opening_brace_line=$line_no unless ($body && $body =~ s/\}$//);if (${$rexpansion}{$name}){local $"=')(';my@names=sort keys %$rexpansion;$death_message="Here is a list of all installed aliases\n(@names)\n" ."Attempting to redefine alias ($name) in config file $config_file line $.\n";last}${$rexpansion}{$name}=[]}elsif ($line =~ /^{/){$opening_brace_line=undef;$death_message="Unexpected '{' at line $line_no in config file '$config_file'\n";last}elsif ($line =~ /^(.*)?\}$/){$body=$1;if ($opening_brace_line){$opening_brace_line=undef}else {$death_message="Unexpected '}' at line $line_no in config file '$config_file'\n";last}}if ($body){my ($rbody_parts,$msg)=parse_args($body);if ($msg){$death_message=<<EOM;last}if ($name){for (@$rbody_parts){s/^\-+//}push @{${$rexpansion}{$name}},@$rbody_parts}else {push(@config_list,@$rbody_parts)}}}if ($opening_brace_line){$death_message="Didn't see a '}' to match the '{' at line $opening_brace_line in config file '$config_file'\n"}eval {$fh->close()};return (\@config_list,$death_message)}sub strip_comment {my ($instr,$config_file,$line_no)=@_;my$msg="";if ($instr =~ /^\s*#/){return ("",$msg)}if ($instr !~ /#/){return ($instr,$msg)}elsif ($instr !~ /['"]/){$instr =~ s/\s+\#.*$//;return ($instr,$msg)}my$outstr="";my$quote_char="";while (1){if ($quote_char){if ($instr =~ /\G($quote_char)/gc){$quote_char="";$outstr .= $1}elsif ($instr =~ /\G(.)/gc){$outstr .= $1}else {$msg=<<EOM;last}}else {if ($instr =~ /\G([\"\'])/gc){$outstr .= $1;$quote_char=$1}elsif ($instr =~ /\G#/gc){last}elsif ($instr =~ /\G(.)/gc){$outstr .= $1}else {last}}}return ($outstr,$msg)}sub parse_args {my ($body)=@_;my@body_parts=();my$quote_char="";my$part="";my$msg="";while (1){if ($quote_char){if ($body =~ /\G($quote_char)/gc){$quote_char=""}elsif ($body =~ /\G(.)/gc){$part .= $1}else {if (length($part)){push@body_parts,$part}$msg=<<EOM;last}}else {if ($body =~ /\G([\"\'])/gc){$quote_char=$1}elsif ($body =~ /\G(\s+)/gc){if (length($part)){push@body_parts,$part}$part=""}elsif ($body =~ /\G(.)/gc){$part .= $1}else {if (length($part)){push@body_parts,$part}last}}}return (\@body_parts,$msg)}sub dump_long_names {my@names=sort @_;print STDOUT <<EOM;for (@names){print STDOUT "$_\n"}}sub dump_defaults {my@defaults=sort @_;print STDOUT "Default command line options:\n";for (@_){print STDOUT "$_\n"}}sub readable_options {my ($rOpts,$roption_string)=@_;my%Getopt_flags;my$rGetopt_flags=\%Getopt_flags;my$readable_options="# Final parameter set for this run.\n";$readable_options .= "# See utility 'perltidyrc_dump.pl' for nicer formatting.\n";for my$opt (@{$roption_string}){my$flag="";if ($opt =~ /(.*)(!|=.*)$/){$opt=$1;$flag=$2}if (defined($rOpts->{$opt})){$rGetopt_flags->{$opt}=$flag}}for my$key (sort keys %{$rOpts}){my$flag=$rGetopt_flags->{$key};my$value=$rOpts->{$key};my$prefix='--';my$suffix="";if ($flag){if ($flag =~ /^=/){if ($value !~ /^\d+$/){$value='"' .$value .'"'}$suffix="=" .$value}elsif ($flag =~ /^!/){$prefix .= "no" unless ($value)}else {$readable_options .= "# ERROR in dump_options: unrecognized flag $flag for $key\n"}}$readable_options .= $prefix .$key .$suffix ."\n"}return$readable_options}sub show_version {print STDOUT <<"EOM"}sub usage {print STDOUT <<EOF}sub process_this_file {my ($truth,$beauty)=@_;while (my$line_of_tokens=$truth->get_line()){$beauty->write_line($line_of_tokens)}eval {$beauty->finish_formatting()};$truth->report_tokenization_errors()}sub check_syntax {my ($istream,$ostream,$logger_object,$rOpts)=@_;my$infile_syntax_ok=0;my$line_of_dashes='-' x 42 ."\n";my$flags=$rOpts->{'perl-syntax-check-flags'};if ($flags !~ /(^-c|\s+-c)/){$flags .= " -c"}if ($rOpts->{'look-for-hash-bang'}){if ($flags !~ /(^-x|\s+-x)/){$flags .= " -x"}}if ($istream eq '-'){$logger_object->write_logfile_entry("Cannot run perl -c on STDIN and STDOUT\n");return$infile_syntax_ok}$logger_object->write_logfile_entry("checking input file syntax with perl $flags\n");my$error_redirection=($^O eq 'VMS')? "" : '2>&1';my ($istream_filename,$perl_output)=do_syntax_check($istream,$flags,$error_redirection);$logger_object->write_logfile_entry("Input stream passed to Perl as file $istream_filename\n");$logger_object->write_logfile_entry($line_of_dashes);$logger_object->write_logfile_entry("$perl_output\n");if ($perl_output =~ /syntax\s*OK/){$infile_syntax_ok=1;$logger_object->write_logfile_entry($line_of_dashes);$logger_object->write_logfile_entry("checking output file syntax with perl $flags ...\n");my ($ostream_filename,$perl_output)=do_syntax_check($ostream,$flags,$error_redirection);$logger_object->write_logfile_entry("Output stream passed to Perl as file $ostream_filename\n");$logger_object->write_logfile_entry($line_of_dashes);$logger_object->write_logfile_entry("$perl_output\n");unless ($perl_output =~ /syntax\s*OK/){$logger_object->write_logfile_entry($line_of_dashes);$logger_object->warning("The output file has a syntax error when tested with perl $flags $ostream !\n");$logger_object->warning("This implies an error in perltidy; the file $ostream is bad\n");$logger_object->report_definite_bug();$logger_object->write_logfile_entry(qx/perl -v $error_redirection/ ."\n")}}else {$logger_object->complain("A syntax check using perl $flags\n");$logger_object->complain("for the output in file $istream_filename gives:\n");$logger_object->complain($line_of_dashes);$logger_object->complain("$perl_output\n");$logger_object->complain($line_of_dashes);$infile_syntax_ok=-1;$logger_object->write_logfile_entry($line_of_dashes);$logger_object->write_logfile_entry("The output file will not be checked because of input file problems\n")}return$infile_syntax_ok}sub do_syntax_check {my ($stream,$flags,$error_redirection)=@_;my ($stream_filename,$is_tmpfile)=get_stream_as_named_file($stream);if (!$stream_filename){return$stream_filename,""}my$quoted_stream_filename='"' .$stream_filename .'"';$flags='"' .$flags .'"';my$msg=qx/perl $flags $quoted_stream_filename $error_redirection/;unlink$stream_filename if ($is_tmpfile);return$stream_filename,$msg}package Perl::Tidy::IOScalar;use Carp;sub new {my ($package,$rscalar,$mode)=@_;my$ref=ref$rscalar;if ($ref ne 'SCALAR'){confess <<EOM}if ($mode eq 'w'){$$rscalar="";return bless [$rscalar,$mode ],$package}elsif ($mode eq 'r'){my@array;if ($rscalar && ${$rscalar}){@array=map {$_ .= "\n"}split /\n/,${$rscalar},-1;if (@array && $array[-1]eq "\n"){pop@array}}my$i_next=0;return bless [\@array,$mode,$i_next ],$package}else {confess <<EOM}}sub getline {my$self=shift;my$mode=$self->[1];if ($mode ne 'r'){confess <<EOM}my$i=$self->[2]++;return$self->[0]->[$i]}sub print {my$self=shift;my$mode=$self->[1];if ($mode ne 'w'){confess <<EOM}${$self->[0]}.= $_[0]}sub close {return}package Perl::Tidy::IOScalarArray;use Carp;sub new {my ($package,$rarray,$mode)=@_;my$ref=ref$rarray;if ($ref ne 'ARRAY'){confess <<EOM}if ($mode eq 'w'){@$rarray=();return bless [$rarray,$mode ],$package}elsif ($mode eq 'r'){my$i_next=0;return bless [$rarray,$mode,$i_next ],$package}else {confess <<EOM}}sub getline {my$self=shift;my$mode=$self->[1];if ($mode ne 'r'){confess <<EOM}my$i=$self->[2]++;return$self->[0]->[$i]}sub print {my$self=shift;my$mode=$self->[1];if ($mode ne 'w'){confess <<EOM}push @{$self->[0]},$_[0]}sub close {return}package Perl::Tidy::LineSource;sub new {my ($class,$input_file,$rOpts,$rpending_logfile_message)=@_;my$input_line_ending;if ($rOpts->{'preserve-line-endings'}){$input_line_ending=Perl::Tidy::find_input_line_ending($input_file)}(my$fh,$input_file)=Perl::Tidy::streamhandle($input_file,'r');return undef unless$fh;if (($input_file eq '-' || ref$input_file)&& $rOpts->{'check-syntax'}){$rOpts->{'check-syntax'}=0;$$rpending_logfile_message .= <<EOM}return bless {_fh=>$fh,_filename=>$input_file,_input_line_ending=>$input_line_ending,_rinput_buffer=>[],_started=>0,},$class}sub close_input_file {my$self=shift;my$filename=$self->{_filename};if ($filename ne '-' &&!ref$filename){eval {$self->{_fh}->close()}}}sub get_line {my$self=shift;my$line=undef;my$fh=$self->{_fh};my$rinput_buffer=$self->{_rinput_buffer};if (scalar(@$rinput_buffer)){$line=shift @$rinput_buffer}else {$line=$fh->getline();if ($line &&!$self->{_started}){if ($line =~ /[\015][^\015\012]/){@$rinput_buffer=map {$_ ."\n"}split /\015/,$line;my$count=@$rinput_buffer;$line=shift @$rinput_buffer}$self->{_started}++}}return$line}package Perl::Tidy::LineSink;sub new {my ($class,$output_file,$tee_file,$line_separator,$rOpts,$rpending_logfile_message,$binmode)=@_;my$fh=undef;my$fh_tee=undef;my$output_file_open=0;if ($rOpts->{'format'}eq 'tidy'){($fh,$output_file)=Perl::Tidy::streamhandle($output_file,'w');unless ($fh){Perl::Tidy::Die "Cannot write to output stream\n"}$output_file_open=1;if ($binmode){if (ref($fh)eq 'IO::File'){if ($rOpts->{'character-encoding'}&& $rOpts->{'character-encoding'}eq 'utf8'){binmode$fh,":encoding(UTF-8)"}else {binmode$fh}}if ($output_file eq '-'){binmode STDOUT}}}if ($output_file eq '-' || ref$output_file){if ($rOpts->{'check-syntax'}){$rOpts->{'check-syntax'}=0;$$rpending_logfile_message .= <<EOM}}bless {_fh=>$fh,_fh_tee=>$fh_tee,_output_file=>$output_file,_output_file_open=>$output_file_open,_tee_flag=>0,_tee_file=>$tee_file,_tee_file_opened=>0,_line_separator=>$line_separator,_binmode=>$binmode,},$class}sub write_line {my$self=shift;my$fh=$self->{_fh};my$output_file_open=$self->{_output_file_open};chomp $_[0];$_[0].= $self->{_line_separator};$fh->print($_[0])if ($self->{_output_file_open});if ($self->{_tee_flag}){unless ($self->{_tee_file_opened}){$self->really_open_tee_file()}my$fh_tee=$self->{_fh_tee};print$fh_tee $_[0]}}sub tee_on {my$self=shift;$self->{_tee_flag}=1}sub tee_off {my$self=shift;$self->{_tee_flag}=0}sub really_open_tee_file {my$self=shift;my$tee_file=$self->{_tee_file};my$fh_tee;$fh_tee=IO::File->new(">$tee_file")or Perl::Tidy::Die("couldn't open TEE file $tee_file: $!\n");binmode$fh_tee if$self->{_binmode};$self->{_tee_file_opened}=1;$self->{_fh_tee}=$fh_tee}sub close_output_file {my$self=shift;my$output_file=$self->{_output_file};if ($output_file ne '-' &&!ref$output_file){eval {$self->{_fh}->close()}if$self->{_output_file_open}}$self->close_tee_file()}sub close_tee_file {my$self=shift;if ($self->{_tee_file_opened}){my$tee_file=$self->{_tee_file};if ($tee_file ne '-' &&!ref$tee_file){eval {$self->{_fh_tee}->close()};$self->{_tee_file_opened}=0}}}package Perl::Tidy::Diagnostics;sub new {my$class=shift;bless {_write_diagnostics_count=>0,_last_diagnostic_file=>"",_input_file=>"",_fh=>undef,},$class}sub set_input_file {my$self=shift;$self->{_input_file}=$_[0]}sub write_diagnostics {my$self=shift;unless ($self->{_write_diagnostics_count}){open DIAGNOSTICS,">DIAGNOSTICS" or death("couldn't open DIAGNOSTICS: $!\n")}my$last_diagnostic_file=$self->{_last_diagnostic_file};my$input_file=$self->{_input_file};if ($last_diagnostic_file ne $input_file){print DIAGNOSTICS "\nFILE:$input_file\n"}$self->{_last_diagnostic_file}=$input_file;my$input_line_number=Perl::Tidy::Tokenizer::get_input_line_number();print DIAGNOSTICS "$input_line_number:\t@_";$self->{_write_diagnostics_count}++}package Perl::Tidy::Logger;sub new {my$class=shift;my$fh;my ($rOpts,$log_file,$warning_file,$fh_stderr,$saw_extrude,)=@_;my$fh_warnings=$rOpts->{'standard-error-output'}? $fh_stderr : undef;unless ($fh_warnings || ref($warning_file)){if (-e $warning_file){unlink($warning_file)}}my$logfile_gap=defined($rOpts->{'logfile-gap'})? $rOpts->{'logfile-gap'}: 50;if ($logfile_gap==0){$logfile_gap=1}bless {_log_file=>$log_file,_logfile_gap=>$logfile_gap,_rOpts=>$rOpts,_fh_warnings=>$fh_warnings,_last_input_line_written=>0,_at_end_of_file=>0,_use_prefix=>1,_block_log_output=>0,_line_of_tokens=>undef,_output_line_number=>undef,_wrote_line_information_string=>0,_wrote_column_headings=>0,_warning_file=>$warning_file,_warning_count=>0,_complaint_count=>0,_saw_code_bug=>-1,_saw_brace_error=>0,_saw_extrude=>$saw_extrude,_output_array=>[],},$class}sub get_warning_count {my$self=shift;return$self->{_warning_count}}sub get_use_prefix {my$self=shift;return$self->{_use_prefix}}sub block_log_output {my$self=shift;$self->{_block_log_output}=1}sub unblock_log_output {my$self=shift;$self->{_block_log_output}=0}sub interrupt_logfile {my$self=shift;$self->{_use_prefix}=0;$self->warning("\n");$self->write_logfile_entry('#' x 24 ."  WARNING  " .'#' x 25 ."\n")}sub resume_logfile {my$self=shift;$self->write_logfile_entry('#' x 60 ."\n");$self->{_use_prefix}=1}sub we_are_at_the_last_line {my$self=shift;unless ($self->{_wrote_line_information_string}){$self->write_logfile_entry("Last line\n\n")}$self->{_at_end_of_file}=1}sub black_box {my$self=shift;my ($line_of_tokens,$output_line_number)=@_;my$input_line=$line_of_tokens->{_line_text};my$input_line_number=$line_of_tokens->{_line_number};$self->{_line_of_tokens}=$line_of_tokens;$self->{_output_line_number}=$output_line_number;$self->{_wrote_line_information_string}=0;my$last_input_line_written=$self->{_last_input_line_written};my$rOpts=$self->{_rOpts};if ((($input_line_number - $last_input_line_written)>= $self->{_logfile_gap})|| ($input_line =~ /^\s*(sub|package)\s+(\w+)/)){my$rlevels=$line_of_tokens->{_rlevels};my$structural_indentation_level=$$rlevels[0];$self->{_last_input_line_written}=$input_line_number;(my$out_str=$input_line)=~ s/^\s*//;chomp$out_str;$out_str=('.' x $structural_indentation_level).$out_str;if (length($out_str)> 35){$out_str=substr($out_str,0,35)." ...."}$self->logfile_output("","$out_str\n")}}sub write_logfile_entry {my$self=shift;$self->logfile_output(">>>","@_")}sub write_column_headings {my$self=shift;$self->{_wrote_column_headings}=1;my$routput_array=$self->{_output_array};push @{$routput_array},<<EOM}sub make_line_information_string {my$self=shift;my$line_of_tokens=$self->{_line_of_tokens};my$input_line_number=$line_of_tokens->{_line_number};my$line_information_string="";if ($input_line_number){my$output_line_number=$self->{_output_line_number};my$brace_depth=$line_of_tokens->{_curly_brace_depth};my$paren_depth=$line_of_tokens->{_paren_depth};my$square_bracket_depth=$line_of_tokens->{_square_bracket_depth};my$guessed_indentation_level=$line_of_tokens->{_guessed_indentation_level};my$rlevels=$line_of_tokens->{_rlevels};my$rnesting_tokens=$line_of_tokens->{_rnesting_tokens};my$rci_levels=$line_of_tokens->{_rci_levels};my$rnesting_blocks=$line_of_tokens->{_rnesting_blocks};my$structural_indentation_level=$$rlevels[0];$self->write_column_headings()unless$self->{_wrote_column_headings};my$extra_space="";$extra_space .= ($input_line_number < 10)? "  " : ($input_line_number < 100)? " " : "";$extra_space .= ($output_line_number < 10)? "  " : ($output_line_number < 100)? " " : "";my$nesting_string="($paren_depth [$square_bracket_depth {$brace_depth";my$nesting_string_new=$$rnesting_tokens[0];my$ci_level=$$rci_levels[0];if ($ci_level > 9){$ci_level='*'}my$bk=($$rnesting_blocks[0]=~ /1$/)? '1' : '0';if (length($nesting_string_new)<= 8){$nesting_string=$nesting_string_new ." " x (8 - length($nesting_string_new))}$line_information_string="L$input_line_number:$output_line_number$extra_space i$guessed_indentation_level:$structural_indentation_level $ci_level $bk $nesting_string"}return$line_information_string}sub logfile_output {my$self=shift;my ($prompt,$msg)=@_;return if ($self->{_block_log_output});my$routput_array=$self->{_output_array};if ($self->{_at_end_of_file}||!$self->{_use_prefix}){push @{$routput_array},"$msg"}else {my$line_information_string=$self->make_line_information_string();$self->{_wrote_line_information_string}=1;if ($line_information_string){push @{$routput_array},"$line_information_string   $prompt$msg"}else {push @{$routput_array},"$msg"}}}sub get_saw_brace_error {my$self=shift;return$self->{_saw_brace_error}}sub increment_brace_error {my$self=shift;$self->{_saw_brace_error}++}sub brace_warning {my$self=shift;use constant BRACE_WARNING_LIMIT=>10;my$saw_brace_error=$self->{_saw_brace_error};if ($saw_brace_error < BRACE_WARNING_LIMIT){$self->warning(@_)}$saw_brace_error++;$self->{_saw_brace_error}=$saw_brace_error;if ($saw_brace_error==BRACE_WARNING_LIMIT){$self->warning("No further warnings of this type will be given\n")}}sub complain {my$self=shift;my$rOpts=$self->{_rOpts};if ($rOpts->{'warning-output'}){$self->warning(@_)}else {$self->{_complaint_count}++;$self->write_logfile_entry(@_)}}sub warning {my$self=shift;use constant WARNING_LIMIT=>50;my$rOpts=$self->{_rOpts};unless ($rOpts->{'quiet'}){my$warning_count=$self->{_warning_count};my$fh_warnings=$self->{_fh_warnings};if (!$fh_warnings){my$warning_file=$self->{_warning_file};($fh_warnings,my$filename)=Perl::Tidy::streamhandle($warning_file,'w');$fh_warnings or Perl::Tidy::Die("couldn't open $filename $!\n");Perl::Tidy::Warn "## Please see file $filename\n" unless ref($warning_file);$self->{_fh_warnings}=$fh_warnings;$fh_warnings->print("Perltidy version is $Perl::Tidy::VERSION\n")}if ($warning_count < WARNING_LIMIT){if ($self->get_use_prefix()> 0){my$input_line_number=Perl::Tidy::Tokenizer::get_input_line_number();if (!defined($input_line_number)){$input_line_number=-1}$fh_warnings->print("$input_line_number:\t@_");$self->write_logfile_entry("WARNING: @_")}else {$fh_warnings->print(@_);$self->write_logfile_entry(@_)}}$warning_count++;$self->{_warning_count}=$warning_count;if ($warning_count==WARNING_LIMIT){$fh_warnings->print("No further warnings will be given\n")}}}sub report_possible_bug {my$self=shift;my$saw_code_bug=$self->{_saw_code_bug};$self->{_saw_code_bug}=($saw_code_bug < 0)? 0 : $saw_code_bug}sub report_definite_bug {my$self=shift;$self->{_saw_code_bug}=1}sub ask_user_for_bug_report {my$self=shift;my ($infile_syntax_ok,$formatter)=@_;my$saw_code_bug=$self->{_saw_code_bug};if (($saw_code_bug==0)&& ($infile_syntax_ok==1)){$self->warning(<<EOM)}elsif ($saw_code_bug==1){if ($self->{_saw_extrude}){$self->warning(<<EOM)}else {$self->warning(<<EOM);my$added_semicolon_count=0;eval {$added_semicolon_count=$formatter->get_added_semicolon_count()};if ($added_semicolon_count > 0){$self->warning(<<EOM)}}}}sub finish {my$self=shift;my ($infile_syntax_ok,$formatter)=@_;my$rOpts=$self->{_rOpts};my$warning_count=$self->{_warning_count};my$saw_code_bug=$self->{_saw_code_bug};my$save_logfile=($saw_code_bug==0 && $infile_syntax_ok==1)|| $saw_code_bug==1 || $rOpts->{'logfile'};my$log_file=$self->{_log_file};if ($warning_count){if ($save_logfile){$self->block_log_output();$self->warning("The logfile $log_file may contain useful information\n");$self->unblock_log_output()}if ($self->{_complaint_count}> 0){$self->warning("To see $self->{_complaint_count} non-critical warnings rerun with -w\n")}if ($self->{_saw_brace_error}&& ($self->{_logfile_gap}> 1 ||!$save_logfile)){$self->warning("To save a full .LOG file rerun with -g\n")}}$self->ask_user_for_bug_report($infile_syntax_ok,$formatter);if ($save_logfile){my$log_file=$self->{_log_file};my ($fh,$filename)=Perl::Tidy::streamhandle($log_file,'w');if ($fh){my$routput_array=$self->{_output_array};for (@{$routput_array}){$fh->print($_)}if ($log_file ne '-' &&!ref$log_file){eval {$fh->close()}}}}}package Perl::Tidy::DevNull;sub new {return bless {},$_[0]}sub print {return}sub close {return}package Perl::Tidy::HtmlWriter;use File::Basename;use vars qw{%html_color %html_bold %html_italic %token_short_names %short_to_long_names $rOpts $css_filename $css_linkname $missing_html_entities};{eval "use HTML::Entities";$missing_html_entities=$@}sub new {my ($class,$input_file,$html_file,$extension,$html_toc_extension,$html_src_extension)=@_;my$html_file_opened=0;my$html_fh;($html_fh,my$html_filename)=Perl::Tidy::streamhandle($html_file,'w');unless ($html_fh){Perl::Tidy::Warn("can't open $html_file: $!\n");return undef}$html_file_opened=1;if (!$input_file || $input_file eq '-' || ref($input_file)){$input_file="NONAME"}my$toc_string;my$html_toc_fh=Perl::Tidy::IOScalar->new(\$toc_string,'w');my$html_pre_fh;my@pre_string_stack;if ($rOpts->{'html-pre-only'}){$html_pre_fh=$html_fh;$html_pre_fh->print(<<"PRE_END")}else {my$pre_string;$html_pre_fh=Perl::Tidy::IOScalar->new(\$pre_string,'w');push@pre_string_stack,\$pre_string}my$html_pod_fh;my$pod_string;if ($rOpts->{'pod2html'}){if ($rOpts->{'html-pre-only'}){undef$rOpts->{'pod2html'}}else {eval "use Pod::Html";if ($@){Perl::Tidy::Warn "unable to find Pod::Html; cannot use pod2html\n-npod disables this message\n";undef$rOpts->{'pod2html'}}else {$html_pod_fh=Perl::Tidy::IOScalar->new(\$pod_string,'w')}}}my$toc_filename;my$src_filename;if ($rOpts->{'frames'}){unless ($extension){Perl::Tidy::Warn "cannot use frames without a specified output extension; ignoring -frm\n";undef$rOpts->{'frames'}}else {$toc_filename=$input_file .$html_toc_extension .$extension;$src_filename=$input_file .$html_src_extension .$extension}}my$title=$rOpts->{'title'};unless ($title){($title,my$path)=fileparse($input_file)}my$toc_item_count=0;my$in_toc_package="";my$last_level=0;bless {_input_file=>$input_file,_title=>$title,_html_file=>$html_file,_toc_filename=>$toc_filename,_src_filename=>$src_filename,_html_file_opened=>$html_file_opened,_html_fh=>$html_fh,_html_pre_fh=>$html_pre_fh,_rpre_string_stack=>\@pre_string_stack,_html_pod_fh=>$html_pod_fh,_rpod_string=>\$pod_string,_pod_cut_count=>0,_html_toc_fh=>$html_toc_fh,_rtoc_string=>\$toc_string,_rtoc_item_count=>\$toc_item_count,_rin_toc_package=>\$in_toc_package,_rtoc_name_count=>{},_rpackage_stack=>[],_rlast_level=>\$last_level,},$class}sub add_toc_item {my$self=shift;my ($name,$type)=@_;my$html_toc_fh=$self->{_html_toc_fh};my$html_pre_fh=$self->{_html_pre_fh};my$rtoc_name_count=$self->{_rtoc_name_count};my$rtoc_item_count=$self->{_rtoc_item_count};my$rlast_level=$self->{_rlast_level};my$rin_toc_package=$self->{_rin_toc_package};my$rpackage_stack=$self->{_rpackage_stack};my$end_package_list=sub {if ($$rin_toc_package){$html_toc_fh->print("</ul>\n</li>\n");$$rin_toc_package=""}};my$start_package_list=sub {my ($unique_name,$package)=@_;if ($$rin_toc_package){$end_package_list->()}$html_toc_fh->print(<<EOM);$$rin_toc_package=$package};unless ($$rtoc_item_count){return if ($type eq 'EOF');$html_toc_fh->print(<<"TOC_END")}$$rtoc_item_count++;my$unique_name=$name;if ($type eq 'package'){$unique_name="package-$name"}if (my$count=$rtoc_name_count->{lc$unique_name }++){$unique_name .= "-$count"}if ($rOpts->{'pod2html'}){$unique_name .= '-'}if ($type eq 'sub'){my$package=$rpackage_stack->[$$rlast_level];unless ($package){$package='main'}if ($$rin_toc_package && $$rin_toc_package ne $package){$end_package_list->()}unless ($$rin_toc_package){$start_package_list->($unique_name,$package)}}if ($type eq 'package'){$start_package_list->($unique_name,$name)}elsif ($type eq 'sub'){$html_toc_fh->print("<li><a href=\"#$unique_name\">$name</a></li>\n")}else {$end_package_list->();$html_toc_fh->print("<li><a href=\"#$unique_name\">$name</a></li>\n")}$html_pre_fh->print("<a name=\"$unique_name\"></a>");if ($type eq 'EOF'){$html_toc_fh->print(<<"TOC_END")}}BEGIN {%short_to_long_names=('n'=>'numeric','p'=>'paren','q'=>'quote','s'=>'structure','c'=>'comment','v'=>'v-string','cm'=>'comma','w'=>'bareword','co'=>'colon','pu'=>'punctuation','i'=>'identifier','j'=>'label','h'=>'here-doc-target','hh'=>'here-doc-text','k'=>'keyword','sc'=>'semicolon','m'=>'subroutine','pd'=>'pod-text',);%token_short_names=('#'=>'c','n'=>'n','v'=>'v','k'=>'k','F'=>'k','Q'=>'q','q'=>'q','J'=>'j','j'=>'j','h'=>'h','H'=>'hh','w'=>'w',','=>'cm','=>'=>'cm',';'=>'sc',':'=>'co','f'=>'sc','('=>'p',')'=>'p','M'=>'m','P'=>'pd','A'=>'co',);my@identifier=qw"i t U C Y Z G :: CORE::";@token_short_names{@identifier}=('i')x scalar(@identifier);my@structure=qw"{ }";@token_short_names{@structure}=('s')x scalar(@structure)}sub make_getopt_long_names {my$class=shift;my ($rgetopt_names)=@_;while (my ($short_name,$name)=each%short_to_long_names){push @$rgetopt_names,"html-color-$name=s";push @$rgetopt_names,"html-italic-$name!";push @$rgetopt_names,"html-bold-$name!"}push @$rgetopt_names,"html-color-background=s";push @$rgetopt_names,"html-linked-style-sheet=s";push @$rgetopt_names,"nohtml-style-sheets";push @$rgetopt_names,"html-pre-only";push @$rgetopt_names,"html-line-numbers";push @$rgetopt_names,"html-entities!";push @$rgetopt_names,"stylesheet";push @$rgetopt_names,"html-table-of-contents!";push @$rgetopt_names,"pod2html!";push @$rgetopt_names,"frames!";push @$rgetopt_names,"html-toc-extension=s";push @$rgetopt_names,"html-src-extension=s";push @$rgetopt_names,"backlink=s";push @$rgetopt_names,"cachedir=s";push @$rgetopt_names,"htmlroot=s";push @$rgetopt_names,"libpods=s";push @$rgetopt_names,"podpath=s";push @$rgetopt_names,"podroot=s";push @$rgetopt_names,"title=s";push @$rgetopt_names,"podquiet!";push @$rgetopt_names,"podverbose!";push @$rgetopt_names,"podrecurse!";push @$rgetopt_names,"podflush";push @$rgetopt_names,"podheader!";push @$rgetopt_names,"podindex!"}sub make_abbreviated_names {my$class=shift;my ($rexpansion)=@_;while (my ($short_name,$long_name)=each%short_to_long_names){${$rexpansion}{"hc$short_name"}=["html-color-$long_name"];${$rexpansion}{"hb$short_name"}=["html-bold-$long_name"];${$rexpansion}{"hi$short_name"}=["html-italic-$long_name"];${$rexpansion}{"nhb$short_name"}=["nohtml-bold-$long_name"];${$rexpansion}{"nhi$short_name"}=["nohtml-italic-$long_name"]}${$rexpansion}{"hcbg"}=["html-color-background"];${$rexpansion}{"pre"}=["html-pre-only"];${$rexpansion}{"toc"}=["html-table-of-contents"];${$rexpansion}{"ntoc"}=["nohtml-table-of-contents"];${$rexpansion}{"nnn"}=["html-line-numbers"];${$rexpansion}{"hent"}=["html-entities"];${$rexpansion}{"nhent"}=["nohtml-entities"];${$rexpansion}{"css"}=["html-linked-style-sheet"];${$rexpansion}{"nss"}=["nohtml-style-sheets"];${$rexpansion}{"ss"}=["stylesheet"];${$rexpansion}{"pod"}=["pod2html"];${$rexpansion}{"npod"}=["nopod2html"];${$rexpansion}{"frm"}=["frames"];${$rexpansion}{"nfrm"}=["noframes"];${$rexpansion}{"text"}=["html-toc-extension"];${$rexpansion}{"sext"}=["html-src-extension"]}sub check_options {my$class=shift;$rOpts=shift;use constant ForestGreen=>"#228B22";use constant SaddleBrown=>"#8B4513";use constant magenta4=>"#8B008B";use constant IndianRed3=>"#CD5555";use constant DeepSkyBlue4=>"#00688B";use constant MediumOrchid3=>"#B452CD";use constant black=>"#000000";use constant white=>"#FFFFFF";use constant red=>"#FF0000";set_default_properties('c',ForestGreen,0,0);set_default_properties('pd',ForestGreen,0,1);set_default_properties('k',magenta4,1,0);set_default_properties('q',IndianRed3,0,0);set_default_properties('hh',IndianRed3,0,1);set_default_properties('h',IndianRed3,1,0);set_default_properties('i',DeepSkyBlue4,0,0);set_default_properties('w',black,0,0);set_default_properties('n',MediumOrchid3,0,0);set_default_properties('v',MediumOrchid3,0,0);set_default_properties('j',IndianRed3,1,0);set_default_properties('m',red,1,0);set_default_color('html-color-background',white);set_default_color('html-color-punctuation',black);while (my ($short_name,$long_name)=each%short_to_long_names){$html_color{$short_name}=$rOpts->{"html-color-$long_name"};$html_bold{$short_name}=$rOpts->{"html-bold-$long_name"};$html_italic{$short_name}=$rOpts->{"html-italic-$long_name"}}if (defined($rOpts->{'stylesheet'})){write_style_sheet_file('-');Perl::Tidy::Exit 0}if (defined($rOpts->{'html-linked-style-sheet'})){$css_linkname=$rOpts->{'html-linked-style-sheet'};if ($css_linkname =~ /^-/){Perl::Tidy::Die "You must specify a valid filename after -css\n"}}if ($css_linkname && $rOpts->{'nohtml-style-sheets'}){$rOpts->{'nohtml-style-sheets'}=0;warning("You can't specify both -css and -nss; -nss ignored\n")}if ($css_linkname){my$css_filename=$css_linkname;unless (-e $css_filename){write_style_sheet_file($css_filename)}}$missing_html_entities=1 unless$rOpts->{'html-entities'}}sub write_style_sheet_file {my$css_filename=shift;my$fh;unless ($fh=IO::File->new("> $css_filename")){Perl::Tidy::Die "can't open $css_filename: $!\n"}write_style_sheet_data($fh);eval {$fh->close}}sub write_style_sheet_data {my$fh=shift;my$bg_color=$rOpts->{'html-color-background'};my$text_color=$rOpts->{'html-color-punctuation'};my$pre_bg_color=$rOpts->{'html-pre-color-background'};$pre_bg_color=$bg_color unless$pre_bg_color;$fh->print(<<"EOM");for my$short_name (sort keys%short_to_long_names){my$long_name=$short_to_long_names{$short_name};my$abbrev='.' .$short_name;if (length($short_name)==1){$abbrev .= ' '}my$color=$html_color{$short_name};if (!defined($color)){$color=$text_color}$fh->print("$abbrev \{ color: $color;");if ($html_bold{$short_name}){$fh->print(" font-weight:bold;")}if ($html_italic{$short_name}){$fh->print(" font-style:italic;")}$fh->print("} /* $long_name */\n")}}sub set_default_color {my ($key,$color)=@_;if ($rOpts->{$key}){$color=$rOpts->{$key}}$rOpts->{$key}=check_RGB($color)}sub check_RGB {my ($color)=@_;if ($color =~ /^[0-9a-fA-F]{6,6}$/){$color="#$color"}return$color}sub set_default_properties {my ($short_name,$color,$bold,$italic)=@_;set_default_color("html-color-$short_to_long_names{$short_name}",$color);my$key;$key="html-bold-$short_to_long_names{$short_name}";$rOpts->{$key}=(defined$rOpts->{$key})? $rOpts->{$key}: $bold;$key="html-italic-$short_to_long_names{$short_name}";$rOpts->{$key}=(defined$rOpts->{$key})? $rOpts->{$key}: $italic}sub pod_to_html {my$self=shift;my ($pod_string,$css_string,$toc_string,$rpre_string_stack)=@_;my$input_file=$self->{_input_file};my$title=$self->{_title};my$success_flag=0;unless ($pod_string){return$success_flag}my ($fh_tmp,$tmpfile)=File::Temp::tempfile();unless ($fh_tmp){Perl::Tidy::Warn "unable to open temporary file $tmpfile; cannot use pod2html\n";return$success_flag}$fh_tmp->print($pod_string);$fh_tmp->close();{my@args;push@args,"--infile=$tmpfile","--outfile=$tmpfile","--title=$title";my$kw;for$kw (qw(backlink cachedir htmlroot libpods podpath podroot)){if ($rOpts->{$kw}){push@args,"--$kw=$rOpts->{$kw}"}}for$kw (qw(podheader podindex podrecurse podquiet podverbose)){my$kwd=$kw;if ($rOpts->{$kw}){$kwd =~ s/^pod//;push@args,"--$kwd"}elsif (defined($rOpts->{$kw})){$kwd =~ s/^pod//;push@args,"--no$kwd"}}$kw='podflush';if ($rOpts->{$kw}){$kw =~ s/^pod//;push@args,"--$kw"}local$SIG{__DIE__}=sub {unlink$tmpfile if -e $tmpfile;Perl::Tidy::Die $_[0]};pod2html(@args)}$fh_tmp=IO::File->new($tmpfile,'r');unless ($fh_tmp){Perl::Tidy::Warn "unable to open temporary file $tmpfile; cannot use pod2html\n";goto RETURN}my$html_fh=$self->{_html_fh};my@toc;my$in_toc;my$ul_level=0;my$no_print;my$html_print=sub {for (@_){$html_fh->print($_)unless ($no_print);if ($in_toc){push@toc,$_}}};my ($saw_body,$saw_index,$saw_body_end);while (my$line=$fh_tmp->getline()){if ($line =~ /^\s*<html>\s*$/i){my$date=localtime;$html_print->("<!-- Generated by perltidy on $date -->\n");$html_print->($line)}elsif ($line =~ /^\s*<body.*>\s*$/i){$saw_body=1;$html_print->($css_string)if$css_string;$html_print->($line);$html_print->("<a name=\"-top-\"></a>\n");$title=escape_html($title);$html_print->("<h1>$title</h1>\n")}elsif ($line =~ /^\s*<!-- INDEX BEGIN -->\s*$/i){$in_toc='INDEX';$no_print=$rOpts->{'frames'}||!$rOpts->{'html-table-of-contents'};$html_print->("<h2>Doc Index:</h2>\n")if$rOpts->{'frames'};$html_print->($line)}elsif ($line =~ /^\s*<ul\s+id="index">/i){$in_toc='UL';$ul_level=1;$no_print=$rOpts->{'frames'}||!$rOpts->{'html-table-of-contents'};$html_print->("<h2>Doc Index:</h2>\n")if$rOpts->{'frames'};$html_print->($line)}elsif ($line =~ /^\s*<!-- INDEX END -->\s*$/i){$saw_index=1;$html_print->($line);if ($toc_string){$html_print->("<hr />\n")if$rOpts->{'frames'};$html_print->("<h2>Code Index:</h2>\n");my@toc=map {$_ .= "\n"}split /\n/,$toc_string;$html_print->(@toc)}$in_toc="";$no_print=0}elsif ($line =~ /\s*<ul>\s*$/i && $in_toc eq 'UL'){$ul_level++;$html_print->($line)}elsif ($line =~ /\s*<\/ul>/i && $in_toc eq 'UL'){$ul_level--;$html_print->($line);if ($ul_level <= 0){$saw_index=1;if ($toc_string){$html_print->("<hr />\n")if$rOpts->{'frames'};$html_print->("<h2>Code Index:</h2>\n");my@toc=map {$_ .= "\n"}split /\n/,$toc_string;$html_print->(@toc)}$in_toc="";$ul_level=0;$no_print=0}}elsif ($line =~ /^(.*)<!-- pERLTIDY sECTION -->(.*)$/){$line=$2;$html_print->($1)if $1;if ($self->{_pod_cut_count}> 1){my$rpre_string=shift(@$rpre_string_stack);if ($$rpre_string){$html_print->('<pre>');$html_print->($$rpre_string);$html_print->('</pre>')}else {Perl::Tidy::Warn "Problem merging html stream with pod2html; order may be wrong\n"}$html_print->($line)}else {$html_print->($line)unless ($line =~ /^\s*<hr>\s*$/i)}}elsif ($line =~ /^\s*<\/body>\s*$/i){$saw_body_end=1;if (@$rpre_string_stack){unless ($self->{_pod_cut_count}> 1){$html_print->('<hr />')}while (my$rpre_string=shift(@$rpre_string_stack)){$html_print->('<pre>');$html_print->($$rpre_string);$html_print->('</pre>')}}$html_print->($line)}else {$html_print->($line)}}$success_flag=1;unless ($saw_body){Perl::Tidy::Warn "Did not see <body> in pod2html output\n";$success_flag=0}unless ($saw_body_end){Perl::Tidy::Warn "Did not see </body> in pod2html output\n";$success_flag=0}unless ($saw_index){Perl::Tidy::Warn "Did not find INDEX END in pod2html output\n";$success_flag=0}RETURN: eval {$html_fh->close()};unlink$tmpfile if -e $tmpfile;if ($success_flag && $rOpts->{'frames'}){$self->make_frame(\@toc)}return$success_flag}sub make_frame {my$self=shift;my ($rtoc)=@_;my$input_file=$self->{_input_file};my$html_filename=$self->{_html_file};my$toc_filename=$self->{_toc_filename};my$src_filename=$self->{_src_filename};my$title=$self->{_title};$title=escape_html($title);my$top_basename="";my ($toc_basename,$toc_path)=fileparse($toc_filename);my ($src_basename,$src_path)=fileparse($src_filename);my$src_frame_name='SRC';my$first_anchor=write_toc_html($title,$toc_filename,$src_basename,$rtoc,$src_frame_name);rename($html_filename,$src_filename)or Perl::Tidy::Die "Cannot rename $html_filename to $src_filename:$!\n";write_frame_html($title,$html_filename,$top_basename,$toc_basename,$src_basename,$src_frame_name)}sub write_toc_html {my ($title,$toc_filename,$src_basename,$rtoc,$src_frame_name)=@_;my$fh=IO::File->new($toc_filename,'w')or Perl::Tidy::Die "Cannot open $toc_filename:$!\n";$fh->print(<<EOM);my$first_anchor=change_anchor_names($rtoc,$src_basename,"$src_frame_name");$fh->print(join "",@$rtoc);$fh->print(<<EOM)}sub write_frame_html {my ($title,$frame_filename,$top_basename,$toc_basename,$src_basename,$src_frame_name)=@_;my$fh=IO::File->new($frame_filename,'w')or Perl::Tidy::Die "Cannot open $toc_basename:$!\n";$fh->print(<<EOM);if ($top_basename){$fh->print(<<EOM)}else {$fh->print(<<EOM)}$fh->print(<<EOM)}sub change_anchor_names {my ($rlines,$filename,$target)=@_;my$first_anchor;for my$line (@$rlines){if ($line =~ /^(.*)<a(.*)href\s*=\s*"([^#]*)#([^"]+)"[^>]*>(.*)$/i){my$pre=$1;my$name=$4;my$post=$5;my$href="$filename#$name";$line="$pre<a href=\"$href\" target=\"$target\">$post\n";unless ($first_anchor){$first_anchor=$href}}}return$first_anchor}sub close_html_file {my$self=shift;return unless$self->{_html_file_opened};my$html_fh=$self->{_html_fh};my$rtoc_string=$self->{_rtoc_string};if ($rOpts->{'html-pre-only'}){$html_fh->print(<<"PRE_END");eval {$html_fh->close()};return}$self->add_toc_item('EOF','EOF');my$rpre_string_stack=$self->{_rpre_string_stack};if ($rOpts->{pod2html}&& $self->{_pod_cut_count}>= 1 && $rOpts->{'html-color-background'}eq '#FFFFFF'){$rOpts->{'html-pre-color-background'}='#F0F0F0'}my$css_string;my$fh_css=Perl::Tidy::IOScalar->new(\$css_string,'w');if ($rOpts->{'html-linked-style-sheet'}){$fh_css->print(qq(<link rel="stylesheet" href="$css_linkname" type="text/css" />))}elsif (!$rOpts->{'nohtml-style-sheets'}){$fh_css->print(<<'ENDCSS');write_style_sheet_data($fh_css);$fh_css->print(<<"ENDCSS")}if ($rOpts->{'pod2html'}){my$rpod_string=$self->{_rpod_string};$self->pod_to_html($$rpod_string,$css_string,$$rtoc_string,$rpre_string_stack)&& return}my$input_file=$self->{_input_file};my$title=escape_html($input_file);my$date=localtime;$html_fh->print(<<"HTML_START");if ($css_string){$html_fh->print($css_string);$html_fh->print(<<"ENDCSS")}else {$html_fh->print(<<"HTML_START")}$html_fh->print("<a name=\"-top-\"></a>\n");$html_fh->print(<<"EOM");if ($$rtoc_string &&!$rOpts->{'frames'}&& $rOpts->{'html-table-of-contents'}){$html_fh->print($$rtoc_string)}my$fname_comment=$input_file;$fname_comment =~ s/--+/-/g;$html_fh->print(<<"END_PRE");for my$rpre_string (@$rpre_string_stack){$html_fh->print($$rpre_string)}$html_fh->print(<<"HTML_END");eval {$html_fh->close()};if ($rOpts->{'frames'}){my@toc=map {$_ .= "\n"}split /\n/,$$rtoc_string;$self->make_frame(\@toc)}}sub markup_tokens {my$self=shift;my ($rtokens,$rtoken_type,$rlevels)=@_;my (@colored_tokens,$j,$string,$type,$token,$level);my$rlast_level=$self->{_rlast_level};my$rpackage_stack=$self->{_rpackage_stack};for ($j=0 ;$j < @$rtoken_type ;$j++ ){$type=$$rtoken_type[$j];$token=$$rtokens[$j];$level=$$rlevels[$j];$level=0 if ($level < 0);if ($level > $$rlast_level){unless ($rpackage_stack->[$level - 1 ]){$rpackage_stack->[$level - 1 ]='main'}$rpackage_stack->[$level]=$rpackage_stack->[$level - 1 ]}elsif ($level < $$rlast_level){my$package=$rpackage_stack->[$level];unless ($package){$package='main'}if ($package ne $rpackage_stack->[$level + 1 ]){$self->add_toc_item($package,'package')}}$$rlast_level=$level;if ($type eq 'i' && $token =~ /^(sub\s+)(\w.*)$/){$token=$self->markup_html_element($1,'k');push@colored_tokens,$token;$token=$2;$type='M';my$signature=join "",@$rtoken_type;unless ($signature =~ /^i;/){my$subname=$token;$subname =~ s/[\s\(].*$//;$self->add_toc_item($subname,'sub')}}if ($type eq 'i' && $token =~ /^(package\s+)(\w.*)$/){$token=$self->markup_html_element($1,'k');push@colored_tokens,$token;$token=$2;$type='i';$self->add_toc_item("$token",'package');$rpackage_stack->[$level]=$token}$token=$self->markup_html_element($token,$type);push@colored_tokens,$token}return (\@colored_tokens)}sub markup_html_element {my$self=shift;my ($token,$type)=@_;return$token if ($type eq 'b');return$token if ($token =~ /^\s*$/);$token=escape_html($token);my$short_name=$token_short_names{$type};if (!defined($short_name)){$short_name="pu"}if (!$rOpts->{'nohtml-style-sheets'}){if ($short_name ne 'pu'){$token=qq(<span class="$short_name">) .$token ."</span>"}}else {my$color=$html_color{$short_name};if ($color && ($color ne $rOpts->{'html-color-punctuation'})){$token=qq(<font color="$color">) .$token ."</font>"}if ($html_italic{$short_name}){$token="<i>$token</i>"}if ($html_bold{$short_name}){$token="<b>$token</b>"}}return$token}sub escape_html {my$token=shift;if ($missing_html_entities){$token =~ s/\&/&amp;/g;$token =~ s/\</&lt;/g;$token =~ s/\>/&gt;/g;$token =~ s/\"/&quot;/g}else {HTML::Entities::encode_entities($token)}return$token}sub finish_formatting {my$self=shift;$self->close_html_file();return}sub write_line {my$self=shift;return unless$self->{_html_file_opened};my$html_pre_fh=$self->{_html_pre_fh};my ($line_of_tokens)=@_;my$line_type=$line_of_tokens->{_line_type};my$input_line=$line_of_tokens->{_line_text};my$line_number=$line_of_tokens->{_line_number};chomp$input_line;my$html_line;if ($line_type eq 'CODE'){my$rtoken_type=$line_of_tokens->{_rtoken_type};my$rtokens=$line_of_tokens->{_rtokens};my$rlevels=$line_of_tokens->{_rlevels};if ($input_line =~ /(^\s*)/){$html_line=$1}else {$html_line=""}my ($rcolored_tokens)=$self->markup_tokens($rtokens,$rtoken_type,$rlevels);$html_line .= join '',@$rcolored_tokens}else {my$line_character;if ($line_type eq 'HERE'){$line_character='H'}elsif ($line_type eq 'HERE_END'){$line_character='h'}elsif ($line_type eq 'FORMAT'){$line_character='H'}elsif ($line_type eq 'FORMAT_END'){$line_character='h'}elsif ($line_type eq 'SYSTEM'){$line_character='c'}elsif ($line_type eq 'END_START'){$line_character='k';$self->add_toc_item('__END__','__END__')}elsif ($line_type eq 'DATA_START'){$line_character='k';$self->add_toc_item('__DATA__','__DATA__')}elsif ($line_type =~ /^POD/){$line_character='P';if ($rOpts->{'pod2html'}){my$html_pod_fh=$self->{_html_pod_fh};if ($line_type eq 'POD_START'){my$rpre_string_stack=$self->{_rpre_string_stack};my$rpre_string=$rpre_string_stack->[-1];if ($$rpre_string =~ /\S/){my$pre_string;$html_pre_fh=Perl::Tidy::IOScalar->new(\$pre_string,'w');$self->{_html_pre_fh}=$html_pre_fh;push @$rpre_string_stack,\$pre_string;my$for_html='=for html';$html_pod_fh->print(<<EOM)}else {$$rpre_string="";$html_pod_fh->print("\n")}}$html_pod_fh->print($input_line ."\n");if ($line_type eq 'POD_END'){$self->{_pod_cut_count}++;$html_pod_fh->print("\n")}return}}else {$line_character='Q'}$html_line=$self->markup_html_element($input_line,$line_character)}if ($rOpts->{'html-line-numbers'}){my$extra_space .= ($line_number < 10)? "   " : ($line_number < 100)? "  " : ($line_number < 1000)? " " : "";$html_line=$extra_space .$line_number ." " .$html_line}$html_pre_fh->print("$html_line\n")}package Perl::Tidy::Formatter;BEGIN {use constant FORMATTER_DEBUG_FLAG_RECOMBINE=>0;use constant FORMATTER_DEBUG_FLAG_BOND_TABLES=>0;use constant FORMATTER_DEBUG_FLAG_BOND=>0;use constant FORMATTER_DEBUG_FLAG_BREAK=>0;use constant FORMATTER_DEBUG_FLAG_CI=>0;use constant FORMATTER_DEBUG_FLAG_FLUSH=>0;use constant FORMATTER_DEBUG_FLAG_FORCE=>0;use constant FORMATTER_DEBUG_FLAG_LIST=>0;use constant FORMATTER_DEBUG_FLAG_NOBREAK=>0;use constant FORMATTER_DEBUG_FLAG_OUTPUT=>0;use constant FORMATTER_DEBUG_FLAG_SPARSE=>0;use constant FORMATTER_DEBUG_FLAG_STORE=>0;use constant FORMATTER_DEBUG_FLAG_UNDOBP=>0;use constant FORMATTER_DEBUG_FLAG_WHITE=>0;my$debug_warning=sub {print STDOUT "FORMATTER_DEBUGGING with key $_[0]\n"};FORMATTER_DEBUG_FLAG_RECOMBINE && $debug_warning->('RECOMBINE');FORMATTER_DEBUG_FLAG_BOND_TABLES && $debug_warning->('BOND_TABLES');FORMATTER_DEBUG_FLAG_BOND && $debug_warning->('BOND');FORMATTER_DEBUG_FLAG_BREAK && $debug_warning->('BREAK');FORMATTER_DEBUG_FLAG_CI && $debug_warning->('CI');FORMATTER_DEBUG_FLAG_FLUSH && $debug_warning->('FLUSH');FORMATTER_DEBUG_FLAG_FORCE && $debug_warning->('FORCE');FORMATTER_DEBUG_FLAG_LIST && $debug_warning->('LIST');FORMATTER_DEBUG_FLAG_NOBREAK && $debug_warning->('NOBREAK');FORMATTER_DEBUG_FLAG_OUTPUT && $debug_warning->('OUTPUT');FORMATTER_DEBUG_FLAG_SPARSE && $debug_warning->('SPARSE');FORMATTER_DEBUG_FLAG_STORE && $debug_warning->('STORE');FORMATTER_DEBUG_FLAG_UNDOBP && $debug_warning->('UNDOBP');FORMATTER_DEBUG_FLAG_WHITE && $debug_warning->('WHITE')}use Carp;use vars qw{@gnu_stack $max_gnu_stack_index $gnu_position_predictor $line_start_index_to_go $last_indentation_written $last_unadjusted_indentation $last_leading_token $last_output_short_opening_token $saw_VERSION_in_this_file $saw_END_or_DATA_ @gnu_item_list $max_gnu_item_index $gnu_sequence_number $last_output_indentation %last_gnu_equals %gnu_comma_count %gnu_arrow_count @block_type_to_go @type_sequence_to_go @container_environment_to_go @bond_strength_to_go @forced_breakpoint_to_go @token_lengths_to_go @summed_lengths_to_go @levels_to_go @leading_spaces_to_go @reduced_spaces_to_go @matching_token_to_go @mate_index_to_go @nesting_blocks_to_go @ci_levels_to_go @nesting_depth_to_go @nobreak_to_go @old_breakpoint_to_go @tokens_to_go @types_to_go @inext_to_go @iprev_to_go %saved_opening_indentation $max_index_to_go $comma_count_in_batch $old_line_count_in_batch $last_nonblank_index_to_go $last_nonblank_type_to_go $last_nonblank_token_to_go $last_last_nonblank_index_to_go $last_last_nonblank_type_to_go $last_last_nonblank_token_to_go @nonblank_lines_at_depth $starting_in_quote $ending_in_quote @whitespace_level_stack $whitespace_last_level $in_format_skipping_section $format_skipping_pattern_begin $format_skipping_pattern_end $forced_breakpoint_count $forced_breakpoint_undo_count @forced_breakpoint_undo_stack %postponed_breakpoint $tabbing $embedded_tab_count $first_embedded_tab_at $last_embedded_tab_at $deleted_semicolon_count $first_deleted_semicolon_at $last_deleted_semicolon_at $added_semicolon_count $first_added_semicolon_at $last_added_semicolon_at $first_tabbing_disagreement $last_tabbing_disagreement $in_tabbing_disagreement $tabbing_disagreement_count $input_line_tabbing $last_line_type $last_line_leading_type $last_line_leading_level $last_last_line_leading_level %block_leading_text %block_opening_line_number $csc_new_statement_ok $csc_last_label %csc_block_label $accumulating_text_for_block $leading_block_text $rleading_block_if_elsif_text $leading_block_text_level $leading_block_text_length_exceeded $leading_block_text_line_length $leading_block_text_line_number $closing_side_comment_prefix_pattern $closing_side_comment_list_pattern $last_nonblank_token $last_nonblank_type $last_last_nonblank_token $last_last_nonblank_type $last_nonblank_block_type $last_output_level %is_do_follower %is_if_brace_follower %space_after_keyword $rbrace_follower $looking_for_else %is_last_next_redo_return %is_other_brace_follower %is_else_brace_follower %is_anon_sub_brace_follower %is_anon_sub_1_brace_follower %is_sort_map_grep %is_sort_map_grep_eval %is_sort_map_grep_eval_do %is_block_without_semicolon %is_if_unless %is_and_or %is_assignment %is_chain_operator %is_if_unless_and_or_last_next_redo_return %ok_to_add_semicolon_for_block_type @has_broken_sublist @dont_align @want_comma_break $is_static_block_comment $index_start_one_line_block $semicolons_before_block_self_destruct $index_max_forced_break $input_line_number $diagnostics_object $vertical_aligner_object $logger_object $file_writer_object $formatter_self @ci_stack $last_line_had_side_comment %want_break_before %outdent_keyword $static_block_comment_pattern $static_side_comment_pattern %opening_vertical_tightness %closing_vertical_tightness %closing_token_indentation $some_closing_token_indentation %opening_token_right %stack_opening_token %stack_closing_token $block_brace_vertical_tightness_pattern $rOpts_add_newlines $rOpts_add_whitespace $rOpts_block_brace_tightness $rOpts_block_brace_vertical_tightness $rOpts_brace_left_and_indent $rOpts_comma_arrow_breakpoints $rOpts_break_at_old_keyword_breakpoints $rOpts_break_at_old_comma_breakpoints $rOpts_break_at_old_logical_breakpoints $rOpts_break_at_old_ternary_breakpoints $rOpts_break_at_old_attribute_breakpoints $rOpts_closing_side_comment_else_flag $rOpts_closing_side_comment_maximum_text $rOpts_continuation_indentation $rOpts_cuddled_else $rOpts_delete_old_whitespace $rOpts_fuzzy_line_length $rOpts_indent_columns $rOpts_line_up_parentheses $rOpts_maximum_fields_per_table $rOpts_maximum_line_length $rOpts_variable_maximum_line_length $rOpts_short_concatenation_item_length $rOpts_keep_old_blank_lines $rOpts_ignore_old_breakpoints $rOpts_format_skipping $rOpts_space_function_paren $rOpts_space_keyword_paren $rOpts_keep_interior_semicolons $rOpts_ignore_side_comment_lengths $rOpts_stack_closing_block_brace $rOpts_whitespace_cycle $rOpts_tight_secret_operators %is_opening_type %is_closing_type %is_keyword_returning_list %tightness %matching_token $rOpts %right_bond_strength %left_bond_strength %binary_ws_rules %want_left_space %want_right_space %is_digraph %is_trigraph $bli_pattern $bli_list_string %is_closing_type %is_opening_type %is_closing_token %is_opening_token};BEGIN {$bli_list_string='if else elsif unless while for foreach do : sub';@_=qw(.. :: << >> ** && .. || // -> => += -= .= %= &= |= ^= *= <> <= >= == =~ !~ != ++ -- /= x=);@is_digraph{@_}=(1)x scalar(@_);@_=qw(... **= <<= >>= &&= ||= //= <=>);@is_trigraph{@_}=(1)x scalar(@_);@_=qw(= **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= x=);@is_assignment{@_}=(1)x scalar(@_);@_=qw(grep keys map reverse sort split);@is_keyword_returning_list{@_}=(1)x scalar(@_);@_=qw(is if unless and or err last next redo return);@is_if_unless_and_or_last_next_redo_return{@_}=(1)x scalar(@_);@_=qw(last next redo return);@is_last_next_redo_return{@_}=(1)x scalar(@_);@_=qw(sort map grep);@is_sort_map_grep{@_}=(1)x scalar(@_);@_=qw(sort map grep eval);@is_sort_map_grep_eval{@_}=(1)x scalar(@_);@_=qw(sort map grep eval do);@is_sort_map_grep_eval_do{@_}=(1)x scalar(@_);@_=qw(if unless);@is_if_unless{@_}=(1)x scalar(@_);@_=qw(and or err);@is_and_or{@_}=(1)x scalar(@_);@_=qw(&& || and or : ? . + - * /);@is_chain_operator{@_}=(1)x scalar(@_);@_=qw(BEGIN END CHECK INIT AUTOLOAD DESTROY UNITCHECK continue if elsif else unless while until for foreach given when default);@is_block_without_semicolon{@_}=(1)x scalar(@_);@_=qw(BEGIN END CHECK INIT AUTOLOAD DESTROY UNITCHECK continue if elsif else unless do while until eval for foreach);@ok_to_add_semicolon_for_block_type{@_}=(1)x scalar(@_);@_=qw"L { ( [";@is_opening_type{@_}=(1)x scalar(@_);@_=qw"R } ) ]";@is_closing_type{@_}=(1)x scalar(@_);@_=qw"{ ( [";@is_opening_token{@_}=(1)x scalar(@_);@_=qw"} ) ]";@is_closing_token{@_}=(1)x scalar(@_)}use constant WS_YES=>1;use constant WS_OPTIONAL=>0;use constant WS_NO=>-1;use constant NO_BREAK=>10000;use constant VERY_STRONG=>100;use constant STRONG=>2.1;use constant NOMINAL=>1.1;use constant WEAK=>0.8;use constant VERY_WEAK=>0.55;use constant UNDEFINED_INDEX=>-1;use constant MAX_NAG_MESSAGES=>6;use constant TYPE_SEQUENCE_INCREMENT=>4;{my$_count=0;sub get_count {$_count}sub _increment_count {++$_count}sub _decrement_count {--$_count}}sub trim {$_[0]=~ s/\s+$//;$_[0]=~ s/^\s+//;return $_[0]}sub max {my$max=shift;for (@_){$max=($max < $_)? $_ : $max}return$max}sub min {my$min=shift;for (@_){$min=($min > $_)? $_ : $min}return$min}sub split_words {my ($str)=@_;return unless$str;$str =~ s/\s+$//;$str =~ s/^\s+//;return split(/\s+/,$str)}sub warning {if ($logger_object){$logger_object->warning(@_)}}sub complain {if ($logger_object){$logger_object->complain(@_)}}sub write_logfile_entry {if ($logger_object){$logger_object->write_logfile_entry(@_)}}sub black_box {if ($logger_object){$logger_object->black_box(@_)}}sub report_definite_bug {if ($logger_object){$logger_object->report_definite_bug()}}sub get_saw_brace_error {if ($logger_object){$logger_object->get_saw_brace_error()}}sub we_are_at_the_last_line {if ($logger_object){$logger_object->we_are_at_the_last_line()}}sub write_diagnostics {if ($diagnostics_object){$diagnostics_object->write_diagnostics(@_)}}sub get_added_semicolon_count {my$self=shift;return$added_semicolon_count}sub DESTROY {$_[0]->_decrement_count()}sub new {my$class=shift;my%defaults=(sink_object=>undef,diagnostics_object=>undef,logger_object=>undef,);my%args=(%defaults,@_);$logger_object=$args{logger_object};$diagnostics_object=$args{diagnostics_object};my$sink_object=$args{sink_object};$file_writer_object=Perl::Tidy::FileWriter->new($sink_object,$rOpts,$logger_object);$gnu_position_predictor=0;$max_gnu_stack_index=0;$max_gnu_item_index=-1;$gnu_stack[0]=new_lp_indentation_item(0,-1,-1,0,0);@gnu_item_list=();$last_output_indentation=0;$last_indentation_written=0;$last_unadjusted_indentation=0;$last_leading_token="";$last_output_short_opening_token=0;$saw_VERSION_in_this_file=!$rOpts->{'pass-version-line'};$saw_END_or_DATA_=0;@block_type_to_go=();@type_sequence_to_go=();@container_environment_to_go=();@bond_strength_to_go=();@forced_breakpoint_to_go=();@summed_lengths_to_go=();@token_lengths_to_go=();@levels_to_go=();@matching_token_to_go=();@mate_index_to_go=();@nesting_blocks_to_go=();@ci_levels_to_go=();@nesting_depth_to_go=(0);@nobreak_to_go=();@old_breakpoint_to_go=();@tokens_to_go=();@types_to_go=();@leading_spaces_to_go=();@reduced_spaces_to_go=();@inext_to_go=();@iprev_to_go=();@whitespace_level_stack=();$whitespace_last_level=-1;@dont_align=();@has_broken_sublist=();@want_comma_break=();@ci_stack=("");$first_tabbing_disagreement=0;$last_tabbing_disagreement=0;$tabbing_disagreement_count=0;$in_tabbing_disagreement=0;$input_line_tabbing=undef;$last_line_type="";$last_last_line_leading_level=0;$last_line_leading_level=0;$last_line_leading_type='#';$last_nonblank_token=';';$last_nonblank_type=';';$last_last_nonblank_token=';';$last_last_nonblank_type=';';$last_nonblank_block_type="";$last_output_level=0;$looking_for_else=0;$embedded_tab_count=0;$first_embedded_tab_at=0;$last_embedded_tab_at=0;$deleted_semicolon_count=0;$first_deleted_semicolon_at=0;$last_deleted_semicolon_at=0;$added_semicolon_count=0;$first_added_semicolon_at=0;$last_added_semicolon_at=0;$last_line_had_side_comment=0;$is_static_block_comment=0;%postponed_breakpoint=();%block_leading_text=();%block_opening_line_number=();$csc_new_statement_ok=1;%csc_block_label=();%saved_opening_indentation=();$in_format_skipping_section=0;reset_block_text_accumulator();prepare_for_new_input_lines();$vertical_aligner_object=Perl::Tidy::VerticalAligner->initialize($rOpts,$file_writer_object,$logger_object,$diagnostics_object);if ($rOpts->{'entab-leading-whitespace'}){write_logfile_entry("Leading whitespace will be entabbed with $rOpts->{'entab-leading-whitespace'} spaces per tab\n")}elsif ($rOpts->{'tabs'}){write_logfile_entry("Indentation will be with a tab character\n")}else {write_logfile_entry("Indentation will be with $rOpts->{'indent-columns'} spaces\n")}$formatter_self={};bless$formatter_self,$class;if (_increment_count()> 1){confess "Attempt to create more than 1 object in $class, which is not a true class yet\n"}return$formatter_self}sub prepare_for_new_input_lines {$gnu_sequence_number++;%last_gnu_equals=();%gnu_comma_count=();%gnu_arrow_count=();$line_start_index_to_go=0;$max_gnu_item_index=UNDEFINED_INDEX;$index_max_forced_break=UNDEFINED_INDEX;$max_index_to_go=UNDEFINED_INDEX;$last_nonblank_index_to_go=UNDEFINED_INDEX;$last_nonblank_type_to_go='';$last_nonblank_token_to_go='';$last_last_nonblank_index_to_go=UNDEFINED_INDEX;$last_last_nonblank_type_to_go='';$last_last_nonblank_token_to_go='';$forced_breakpoint_count=0;$forced_breakpoint_undo_count=0;$rbrace_follower=undef;$summed_lengths_to_go[0]=0;$old_line_count_in_batch=1;$comma_count_in_batch=0;$starting_in_quote=0;destroy_one_line_block()}sub write_line {my$self=shift;my ($line_of_tokens)=@_;my$line_type=$line_of_tokens->{_line_type};my$input_line=$line_of_tokens->{_line_text};if ($rOpts->{notidy}){write_unindented_line($input_line);$last_line_type=$line_type;return}if ($last_line_type eq 'POD_END' &&!$saw_END_or_DATA_){$file_writer_object->reset_consecutive_blank_lines();if ($input_line !~ /^\s*$/){want_blank_line()}}if ($line_type eq 'CODE'){if ($input_line !~ /^\s*$/){my$output_line_number=$vertical_aligner_object->get_output_line_number();black_box($line_of_tokens,$output_line_number)}print_line_of_tokens($line_of_tokens)}else {my$skip_line=0;my$tee_line=0;if ($line_type =~ /^POD/){if ($rOpts->{'delete-pod'}){$skip_line=1}if ($rOpts->{'tee-pod'}){$tee_line=1}if ($rOpts->{'trim-pod'}){$input_line =~ s/\s+$//}if (!$skip_line && $line_type eq 'POD_START' &&!$saw_END_or_DATA_){want_blank_line()}}elsif ($line_type =~ /^(END_START|DATA_START)$/){$file_writer_object->reset_consecutive_blank_lines();$saw_END_or_DATA_=1}if (!$skip_line){if ($tee_line){$file_writer_object->tee_on()}write_unindented_line($input_line);if ($tee_line){$file_writer_object->tee_off()}}}$last_line_type=$line_type}sub create_one_line_block {$index_start_one_line_block=$_[0];$semicolons_before_block_self_destruct=$_[1]}sub destroy_one_line_block {$index_start_one_line_block=UNDEFINED_INDEX;$semicolons_before_block_self_destruct=0}sub leading_spaces_to_go {my$ii=shift;if ($ii < 0){$ii=0}return get_SPACES($leading_spaces_to_go[$ii])}sub get_SPACES {my$indentation=shift;return ref($indentation)? $indentation->get_SPACES(): $indentation}sub get_RECOVERABLE_SPACES {my$indentation=shift;return ref($indentation)? $indentation->get_RECOVERABLE_SPACES(): 0}sub get_AVAILABLE_SPACES_to_go {my$item=$leading_spaces_to_go[$_[0]];return ref($item)? $item->get_AVAILABLE_SPACES(): 0}sub new_lp_indentation_item {my ($spaces,$level,$ci_level,$available_spaces,$align_paren)=@_;my$index=0;if ($level >= 0){$index=++$max_gnu_item_index}my$item=Perl::Tidy::IndentationItem->new($spaces,$level,$ci_level,$available_spaces,$index,$gnu_sequence_number,$align_paren,$max_gnu_stack_index,$line_start_index_to_go,);if ($level >= 0){$gnu_item_list[$max_gnu_item_index]=$item}return$item}sub set_leading_whitespace {my ($level_abs,$ci_level,$in_continued_quote)=@_;my$level=$level_abs;if ($rOpts_whitespace_cycle && $rOpts_whitespace_cycle > 0){if ($level_abs < $whitespace_last_level){pop(@whitespace_level_stack)}if (!@whitespace_level_stack){push@whitespace_level_stack,$level_abs}elsif ($level_abs > $whitespace_last_level){$level=$whitespace_level_stack[-1]+ ($level_abs - $whitespace_last_level);if (($level > $rOpts_whitespace_cycle && $last_nonblank_type eq '{' && $last_nonblank_token eq '{')|| ($level > $rOpts_whitespace_cycle + 1 && $last_nonblank_token =~ /^[\{\[]$/)|| $level > $rOpts_whitespace_cycle + 2){$level=1}push@whitespace_level_stack,$level}$level=$whitespace_level_stack[-1]}$whitespace_last_level=$level_abs;if ($rOpts_brace_left_and_indent && $max_index_to_go==0 && $block_type_to_go[$max_index_to_go]=~ /$bli_pattern/o){$ci_level++}if ($level < 0){$level=0}unless ($rOpts_line_up_parentheses){my$space_count=$ci_level * $rOpts_continuation_indentation + $level * $rOpts_indent_columns;my$ci_spaces=($ci_level==0)? 0 : $rOpts_continuation_indentation;if ($in_continued_quote){$space_count=0;$ci_spaces=0}$leading_spaces_to_go[$max_index_to_go]=$space_count;$reduced_spaces_to_go[$max_index_to_go]=$space_count - $ci_spaces;return}if ($in_continued_quote){my$space_count=0;my$available_space=0;$level=-1;$leading_spaces_to_go[$max_index_to_go]=$reduced_spaces_to_go[$max_index_to_go]=new_lp_indentation_item($space_count,$level,$ci_level,$available_space,0);return}my$space_count=$gnu_stack[$max_gnu_stack_index]->get_SPACES();my$current_level=$gnu_stack[$max_gnu_stack_index]->get_LEVEL();my$current_ci_level=$gnu_stack[$max_gnu_stack_index]->get_CI_LEVEL();my$type=$types_to_go[$max_index_to_go];my$token=$tokens_to_go[$max_index_to_go];my$total_depth=$nesting_depth_to_go[$max_index_to_go];if ($type eq '{' || $type eq '('){$gnu_comma_count{$total_depth + 1 }=0;$gnu_arrow_count{$total_depth + 1 }=0;my$last_equals=$last_gnu_equals{$total_depth};if ($last_equals && $last_equals > $line_start_index_to_go){my$i_test=$last_equals;if ($types_to_go[$i_test + 1 ]eq 'b'){$i_test++}my$test_position=total_line_length($i_test,$max_index_to_go);my$mll=maximum_line_length($i_test);if ($gnu_position_predictor > $mll - $rOpts_maximum_line_length / 2 || ($gnu_position_predictor > $mll - $rOpts_maximum_line_length * 3 / 4 && ($old_breakpoint_to_go[$last_equals]|| ($last_equals > 0 && $old_breakpoint_to_go[$last_equals - 1 ])|| ($last_equals > 1 && $types_to_go[$last_equals - 1 ]eq 'b' && $old_breakpoint_to_go[$last_equals - 2 ])))){$line_start_index_to_go=$i_test + 1;$gnu_position_predictor=$test_position}}}my$halfway=maximum_line_length_for_level($level)- $rOpts_maximum_line_length / 2;if ($level < $current_level || $ci_level < $current_ci_level){my ($lev,$ci_lev);while (1){if ($max_gnu_stack_index){$gnu_stack[$max_gnu_stack_index]->set_CLOSED($max_index_to_go);my$available_spaces=$gnu_stack[$max_gnu_stack_index]->get_AVAILABLE_SPACES();my$comma_count=0;my$arrow_count=0;if ($type eq '}' || $type eq ')'){$comma_count=$gnu_comma_count{$total_depth};$arrow_count=$gnu_arrow_count{$total_depth};$comma_count=0 unless$comma_count;$arrow_count=0 unless$arrow_count}$gnu_stack[$max_gnu_stack_index]->set_COMMA_COUNT($comma_count);$gnu_stack[$max_gnu_stack_index]->set_ARROW_COUNT($arrow_count);if ($available_spaces > 0){if ($comma_count <= 0 || $arrow_count > 0){my$i=$gnu_stack[$max_gnu_stack_index]->get_INDEX();my$seqno=$gnu_stack[$max_gnu_stack_index]->get_SEQUENCE_NUMBER();if ($gnu_sequence_number!=$seqno || $i > $max_gnu_item_index){warning("Program bug with -lp.  seqno=$seqno should be $gnu_sequence_number and i=$i should be less than max=$max_gnu_item_index\n");report_definite_bug()}else {if ($arrow_count==0){$gnu_item_list[$i]->permanently_decrease_AVAILABLE_SPACES($available_spaces)}else {$gnu_item_list[$i]->tentatively_decrease_AVAILABLE_SPACES($available_spaces)}my$j;for ($j=$i + 1 ;$j <= $max_gnu_item_index ;$j++ ){$gnu_item_list[$j]->decrease_SPACES($available_spaces)}}}}--$max_gnu_stack_index;$lev=$gnu_stack[$max_gnu_stack_index]->get_LEVEL();$ci_lev=$gnu_stack[$max_gnu_stack_index]->get_CI_LEVEL();if ($lev <= $level && $ci_lev <= $ci_level){$space_count=$gnu_stack[$max_gnu_stack_index]->get_SPACES();$current_level=$lev;$current_ci_level=$ci_lev;last}}else {warning("program bug with -lp: stack_error. level=$level; lev=$lev; ci_level=$ci_level; ci_lev=$ci_lev; rerun with -nlp\n");report_definite_bug();last}}}if ($level > $current_level || $ci_level > $current_ci_level){my$standard_increment=($level - $current_level)* $rOpts_indent_columns + ($ci_level - $current_ci_level)* $rOpts_continuation_indentation;my$available_space=0;my$align_paren=0;my$excess=0;if ($max_gnu_stack_index==0){$space_count=$level * $rOpts_indent_columns}elsif ($last_nonblank_block_type){$space_count += $standard_increment}elsif ($last_nonblank_type ne '{'){$space_count += $standard_increment}else {$space_count=$gnu_position_predictor;my$min_gnu_indentation=$gnu_stack[$max_gnu_stack_index]->get_SPACES();$available_space=$space_count - $min_gnu_indentation;if ($available_space >= $standard_increment){$min_gnu_indentation += $standard_increment}elsif ($available_space > 1){$min_gnu_indentation += $available_space + 1}elsif ($last_nonblank_token =~ /^[\{\[\(]$/){if (($tightness{$last_nonblank_token}< 2)){$min_gnu_indentation += 2}else {$min_gnu_indentation += 1}}else {$min_gnu_indentation += $standard_increment}$available_space=$space_count - $min_gnu_indentation;if ($available_space < 0){$space_count=$min_gnu_indentation;$available_space=0}$align_paren=1}if ($types_to_go[$max_index_to_go]ne 'b'){$gnu_stack[$max_gnu_stack_index]->set_HAVE_CHILD(1);++$max_gnu_stack_index;$gnu_stack[$max_gnu_stack_index]=new_lp_indentation_item($space_count,$level,$ci_level,$available_space,$align_paren);if ($available_space > 0 && $space_count > $halfway){$gnu_stack[$max_gnu_stack_index]->tentatively_decrease_AVAILABLE_SPACES($available_space)}}}if ($type eq '=>'){$gnu_arrow_count{$total_depth}++;$last_gnu_equals{$total_depth}=$max_index_to_go}elsif ($type eq ','){$gnu_comma_count{$total_depth}++}elsif ($is_assignment{$type}){$last_gnu_equals{$total_depth}=$max_index_to_go}if ($type ne 'b'){if ($max_index_to_go==1 && $types_to_go[0]eq 'b' || $last_nonblank_type_to_go =~ /^([\:\?\,f])$/ || ($last_nonblank_type_to_go eq '{' && $type ne '}')|| ($last_nonblank_type_to_go eq '(' and $type ne ')')|| $type =~ /^([\.]|\|\||\&\&)$/ || ($last_nonblank_type_to_go eq '}' && $last_nonblank_token_to_go eq $last_nonblank_type_to_go)|| ($last_nonblank_type_to_go eq 'k' && ($last_nonblank_token_to_go eq 'return' && $type ne '{'))|| ($type eq 'k' && $is_if_unless_and_or_last_next_redo_return{$token})|| ($is_assignment{$last_nonblank_type_to_go}&& ($last_last_nonblank_type_to_go =~ /^[\}\)\]]$/ || $gnu_position_predictor > $halfway))){check_for_long_gnu_style_lines();$line_start_index_to_go=$max_index_to_go;if ($line_start_index_to_go > 0){if ($last_nonblank_type_to_go eq 'k'){if ($want_break_before{$last_nonblank_token_to_go}){$line_start_index_to_go--}}elsif ($want_break_before{$last_nonblank_type_to_go}){$line_start_index_to_go--}}}}if ($max_index_to_go > $line_start_index_to_go){$gnu_position_predictor=total_line_length($line_start_index_to_go,$max_index_to_go)}else {$gnu_position_predictor=$space_count + $token_lengths_to_go[$max_index_to_go]}$leading_spaces_to_go[$max_index_to_go]=$gnu_stack[$max_gnu_stack_index];$reduced_spaces_to_go[$max_index_to_go]=($max_gnu_stack_index > 0 && $ci_level)? $gnu_stack[$max_gnu_stack_index - 1 ]: $gnu_stack[$max_gnu_stack_index];return}sub check_for_long_gnu_style_lines {return unless ($rOpts_line_up_parentheses);return if ($max_gnu_item_index==UNDEFINED_INDEX);my$spaces_needed=$gnu_position_predictor - maximum_line_length($max_index_to_go)+ 2;return if ($spaces_needed <= 0);my@candidates=();my$i;for ($i=0 ;$i <= $max_gnu_item_index ;$i++ ){my$item=$gnu_item_list[$i];next if ($item->get_CLOSED()>= 0);my$available_spaces=$item->get_AVAILABLE_SPACES();if ($available_spaces > 0){push(@candidates,[$i,$available_spaces ])}}return unless (@candidates);@candidates=sort {$b->[1]<=> $a->[1]}@candidates;my$candidate;for$candidate (@candidates){my ($i,$available_spaces)=@{$candidate};my$deleted_spaces=($available_spaces > $spaces_needed)? $spaces_needed : $available_spaces;$gnu_item_list[$i]->decrease_AVAILABLE_SPACES($deleted_spaces);my$i_debug=$i;for (;$i <= $max_gnu_item_index ;$i++ ){my$old_spaces=$gnu_item_list[$i]->get_SPACES();if ($old_spaces >= $deleted_spaces){$gnu_item_list[$i]->decrease_SPACES($deleted_spaces)}else {my$level=$gnu_item_list[$i_debug]->get_LEVEL();my$ci_level=$gnu_item_list[$i_debug]->get_CI_LEVEL();my$old_level=$gnu_item_list[$i]->get_LEVEL();my$old_ci_level=$gnu_item_list[$i]->get_CI_LEVEL();warning("program bug with -lp: want to delete $deleted_spaces from item $i, but old=$old_spaces deleted: lev=$level ci=$ci_level  deleted: level=$old_level ci=$ci_level\n");report_definite_bug()}}$gnu_position_predictor -= $deleted_spaces;$spaces_needed -= $deleted_spaces;last unless ($spaces_needed > 0)}}sub finish_lp_batch {return unless ($rOpts_line_up_parentheses);return if ($max_gnu_item_index==UNDEFINED_INDEX);my$i;for ($i=0 ;$i <= $max_gnu_item_index ;$i++ ){my$item=$gnu_item_list[$i];next if ($item->get_CLOSED()>= 0);my$available_spaces=$item->get_AVAILABLE_SPACES();if ($available_spaces > 0){$gnu_item_list[$i]->tentatively_decrease_AVAILABLE_SPACES($available_spaces);for ($i + 1 .. $max_gnu_item_index){$gnu_item_list[$_]->decrease_SPACES($available_spaces)}}}return}sub reduce_lp_indentation {my ($i,$spaces_wanted)=@_;my$deleted_spaces=0;my$item=$leading_spaces_to_go[$i];my$available_spaces=$item->get_AVAILABLE_SPACES();if ($available_spaces > 0 && (($spaces_wanted <= $available_spaces)||!$item->get_HAVE_CHILD())){$deleted_spaces=$item->tentatively_decrease_AVAILABLE_SPACES($spaces_wanted)}return$deleted_spaces}sub token_sequence_length {my ($ibeg,$iend)=@_;return 0 if ($iend < 0 || $ibeg > $iend);return$summed_lengths_to_go[$iend + 1 ]if ($ibeg < 0);return$summed_lengths_to_go[$iend + 1 ]- $summed_lengths_to_go[$ibeg]}sub total_line_length {my ($ibeg,$iend)=@_;return leading_spaces_to_go($ibeg)+ token_sequence_length($ibeg,$iend)}sub maximum_line_length_for_level {my$maximum_line_length=$rOpts_maximum_line_length;if ($rOpts_variable_maximum_line_length){my$level=shift;if ($level < 0){$level=0}$maximum_line_length += $level * $rOpts_indent_columns}return$maximum_line_length}sub maximum_line_length {return maximum_line_length_for_level($levels_to_go[$_[0]])}sub excess_line_length {my ($ibeg,$iend)=@_;return total_line_length($ibeg,$iend)- maximum_line_length($ibeg)}sub finish_formatting {my$self=shift;flush();$file_writer_object->decrement_output_line_number();we_are_at_the_last_line();if ($added_semicolon_count > 0){my$first=($added_semicolon_count > 1)? "First" : "";my$what=($added_semicolon_count > 1)? "semicolons were" : "semicolon was";write_logfile_entry("$added_semicolon_count $what added:\n");write_logfile_entry("  $first at input line $first_added_semicolon_at\n");if ($added_semicolon_count > 1){write_logfile_entry("   Last at input line $last_added_semicolon_at\n")}write_logfile_entry("  (Use -nasc to prevent semicolon addition)\n");write_logfile_entry("\n")}if ($deleted_semicolon_count > 0){my$first=($deleted_semicolon_count > 1)? "First" : "";my$what=($deleted_semicolon_count > 1)? "semicolons were" : "semicolon was";write_logfile_entry("$deleted_semicolon_count unnecessary $what deleted:\n");write_logfile_entry("  $first at input line $first_deleted_semicolon_at\n");if ($deleted_semicolon_count > 1){write_logfile_entry("   Last at input line $last_deleted_semicolon_at\n")}write_logfile_entry("  (Use -ndsc to prevent semicolon deletion)\n");write_logfile_entry("\n")}if ($embedded_tab_count > 0){my$first=($embedded_tab_count > 1)? "First" : "";my$what=($embedded_tab_count > 1)? "quotes or patterns" : "quote or pattern";write_logfile_entry("$embedded_tab_count $what had embedded tabs:\n");write_logfile_entry("This means the display of this script could vary with device or software\n");write_logfile_entry("  $first at input line $first_embedded_tab_at\n");if ($embedded_tab_count > 1){write_logfile_entry("   Last at input line $last_embedded_tab_at\n")}write_logfile_entry("\n")}if ($first_tabbing_disagreement){write_logfile_entry("First indentation disagreement seen at input line $first_tabbing_disagreement\n")}if ($in_tabbing_disagreement){write_logfile_entry("Ending with indentation disagreement which started at input line $in_tabbing_disagreement\n")}else {if ($last_tabbing_disagreement){write_logfile_entry("Last indentation disagreement seen at input line $last_tabbing_disagreement\n")}else {write_logfile_entry("No indentation disagreement seen\n")}}if ($first_tabbing_disagreement){write_logfile_entry("Note: Indentation disagreement detection is not accurate for outdenting and -lp.\n")}write_logfile_entry("\n");$vertical_aligner_object->report_anything_unusual();$file_writer_object->report_line_length_errors()}sub check_options {($rOpts)=@_;make_static_block_comment_pattern();make_static_side_comment_pattern();make_closing_side_comment_prefix();make_closing_side_comment_list_pattern();$format_skipping_pattern_begin=make_format_skipping_pattern('format-skipping-begin','#<<<');$format_skipping_pattern_end=make_format_skipping_pattern('format-skipping-end','#>>>');if ($rOpts->{'closing-side-comments'}){if (!$rOpts->{'closing-side-comment-warnings'}){$rOpts->{'delete-closing-side-comments'}=1}}elsif ($rOpts->{'closing-side-comment-warnings'}){if ($rOpts->{'delete-closing-side-comments'}){$rOpts->{'delete-closing-side-comments'}=0;$rOpts->{'closing-side-comments'}=1;$rOpts->{'closing-side-comment-interval'}=100000000}}make_bli_pattern();make_block_brace_vertical_tightness_pattern();if ($rOpts->{'line-up-parentheses'}){if ($rOpts->{'indent-only'}||!$rOpts->{'add-newlines'}||!$rOpts->{'delete-old-newlines'}){Perl::Tidy::Warn <<EOM;$rOpts->{'line-up-parentheses'}=0}}if ($rOpts->{'line-up-parentheses'}&& $rOpts->{'tabs'}){Perl::Tidy::Warn <<EOM;$rOpts->{'tabs'}=0}if ($rOpts->{'outdent-keywords'}&& $rOpts->{'tabs'}){Perl::Tidy::Warn <<EOM;$rOpts->{'tabs'}=0}if ($rOpts->{'outdent-labels'}&& $rOpts->{'tabs'}){Perl::Tidy::Warn <<EOM;$rOpts->{'tabs'}=0}if (!$rOpts->{'space-for-semicolon'}){$want_left_space{'f'}=-1}if ($rOpts->{'space-terminal-semicolon'}){$want_left_space{';'}=1}%outdent_keyword=();unless (@_=split_words($rOpts->{'outdent-keyword-okl'})){@_=qw(next last redo goto return)}for (@_){if ($Perl::Tidy::Tokenizer::is_keyword{$_}){$outdent_keyword{$_}=1}else {Perl::Tidy::Warn "ignoring '$_' in -okwl list; not a perl keyword"}}if (@_=split_words($rOpts->{'want-left-space'})){@want_left_space{@_}=(1)x scalar(@_)}if (@_=split_words($rOpts->{'want-right-space'})){@want_right_space{@_}=(1)x scalar(@_)}if (@_=split_words($rOpts->{'nowant-left-space'})){@want_left_space{@_}=(-1)x scalar(@_)}if (@_=split_words($rOpts->{'nowant-right-space'})){@want_right_space{@_}=(-1)x scalar(@_)}if ($rOpts->{'dump-want-left-space'}){dump_want_left_space(*STDOUT);Perl::Tidy::Exit 0}if ($rOpts->{'dump-want-right-space'}){dump_want_right_space(*STDOUT);Perl::Tidy::Exit 0}@_=qw(my local our and or err eq ne if else elsif until unless while for foreach return switch case given when);@space_after_keyword{@_}=(1)x scalar(@_);if (@_=split_words($rOpts->{'nospace-after-keyword'})){if (@_==1 && $_[0]eq '*'){@_=keys(%space_after_keyword)}@space_after_keyword{@_}=(0)x scalar(@_)}if (@_=split_words($rOpts->{'space-after-keyword'})){@space_after_keyword{@_}=(1)x scalar(@_)}my@all_operators=qw(% + - * / x != == >= <= =~ !~ < > | & = **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= x= . : ? && || and or err xor);my$break_after=sub {for my$tok (@_){if ($tok eq '?'){$tok=':'}my$lbs=$left_bond_strength{$tok};my$rbs=$right_bond_strength{$tok};if (defined($lbs)&& defined($rbs)&& $lbs < $rbs){($right_bond_strength{$tok},$left_bond_strength{$tok})=($lbs,$rbs)}}};my$break_before=sub {for my$tok (@_){my$lbs=$left_bond_strength{$tok};my$rbs=$right_bond_strength{$tok};if (defined($lbs)&& defined($rbs)&& $rbs < $lbs){($right_bond_strength{$tok},$left_bond_strength{$tok})=($lbs,$rbs)}}};$break_after->(@all_operators)if ($rOpts->{'break-after-all-operators'});$break_before->(@all_operators)if ($rOpts->{'break-before-all-operators'});$break_after->(split_words($rOpts->{'want-break-after'}));$break_before->(split_words($rOpts->{'want-break-before'}));%want_break_before=();for my$tok (@all_operators,','){$want_break_before{$tok}=$left_bond_strength{$tok}< $right_bond_strength{$tok}}if (!$want_break_before{':'}){$want_break_before{'?'}=$want_break_before{':'};$right_bond_strength{'?'}=$right_bond_strength{':'}+ 0.01;$left_bond_strength{'?'}=NO_BREAK}@_=qw(until while unless if ; :);push @_,',';@is_do_follower{@_}=(1)x scalar(@_);if ($rOpts->{'cuddled-else'}){@_=qw(else elsif);@is_if_brace_follower{@_}=(1)x scalar(@_)}else {%is_if_brace_follower=()}%is_else_brace_follower=();@_=qw#; : => or and && || ~~ !~~ )#;push @_,',';@is_anon_sub_brace_follower{@_}=(1)x scalar(@_);@_=qw#; : => or and && || ) ] ~~ !~~#;push @_,',';@is_anon_sub_1_brace_follower{@_}=(1)x scalar(@_);@_=qw#; : => or and && || )#;push @_,',';if ($rOpts->{'cuddled-else'}){push @_,'continue'}@is_other_brace_follower{@_}=(1)x scalar(@_);$right_bond_strength{'{'}=WEAK;$left_bond_strength{'{'}=VERY_STRONG;if (!$rOpts->{'maximum-line-length'}){$rOpts->{'maximum-line-length'}=1000000}if (!$rOpts->{'long-block-line-count'}){$rOpts->{'long-block-line-count'}=1000000}my$enc=$rOpts->{'character-encoding'};if ($enc && $enc !~ /^(none|utf8)$/i){Perl::Tidy::Die <<EOM}my$ole=$rOpts->{'output-line-ending'};if ($ole){my%endings=(dos=>"\015\012",win=>"\015\012",mac=>"\015",unix=>"\012",);my%endings_inverted=("\015\012"=>'dos',"\015\012"=>'win',"\015"=>'mac',"\012"=>'unix',);if (defined($endings_inverted{$ole})){}else {$ole=lc$ole;unless ($rOpts->{'output-line-ending'}=$endings{$ole}){my$str=join " ",keys%endings;Perl::Tidy::Die <<EOM}if ($rOpts->{'preserve-line-endings'}){Perl::Tidy::Warn "Ignoring -ple; conflicts with -ole\n";$rOpts->{'preserve-line-endings'}=undef}}}%tightness=('{'=>$rOpts->{'brace-tightness'},'}'=>$rOpts->{'brace-tightness'},'('=>$rOpts->{'paren-tightness'},')'=>$rOpts->{'paren-tightness'},'['=>$rOpts->{'square-bracket-tightness'},']'=>$rOpts->{'square-bracket-tightness'},);%matching_token=('{'=>'}','('=>')','['=>']','?'=>':',);$rOpts_add_newlines=$rOpts->{'add-newlines'};$rOpts_add_whitespace=$rOpts->{'add-whitespace'};$rOpts_block_brace_tightness=$rOpts->{'block-brace-tightness'};$rOpts_block_brace_vertical_tightness=$rOpts->{'block-brace-vertical-tightness'};$rOpts_brace_left_and_indent=$rOpts->{'brace-left-and-indent'};$rOpts_comma_arrow_breakpoints=$rOpts->{'comma-arrow-breakpoints'};$rOpts_break_at_old_ternary_breakpoints=$rOpts->{'break-at-old-ternary-breakpoints'};$rOpts_break_at_old_attribute_breakpoints=$rOpts->{'break-at-old-attribute-breakpoints'};$rOpts_break_at_old_comma_breakpoints=$rOpts->{'break-at-old-comma-breakpoints'};$rOpts_break_at_old_keyword_breakpoints=$rOpts->{'break-at-old-keyword-breakpoints'};$rOpts_break_at_old_logical_breakpoints=$rOpts->{'break-at-old-logical-breakpoints'};$rOpts_closing_side_comment_else_flag=$rOpts->{'closing-side-comment-else-flag'};$rOpts_closing_side_comment_maximum_text=$rOpts->{'closing-side-comment-maximum-text'};$rOpts_continuation_indentation=$rOpts->{'continuation-indentation'};$rOpts_cuddled_else=$rOpts->{'cuddled-else'};$rOpts_delete_old_whitespace=$rOpts->{'delete-old-whitespace'};$rOpts_fuzzy_line_length=$rOpts->{'fuzzy-line-length'};$rOpts_indent_columns=$rOpts->{'indent-columns'};$rOpts_line_up_parentheses=$rOpts->{'line-up-parentheses'};$rOpts_maximum_fields_per_table=$rOpts->{'maximum-fields-per-table'};$rOpts_maximum_line_length=$rOpts->{'maximum-line-length'};$rOpts_whitespace_cycle=$rOpts->{'whitespace-cycle'};$rOpts_variable_maximum_line_length=$rOpts->{'variable-maximum-line-length'};$rOpts_short_concatenation_item_length=$rOpts->{'short-concatenation-item-length'};$rOpts_keep_old_blank_lines=$rOpts->{'keep-old-blank-lines'};$rOpts_ignore_old_breakpoints=$rOpts->{'ignore-old-breakpoints'};$rOpts_format_skipping=$rOpts->{'format-skipping'};$rOpts_space_function_paren=$rOpts->{'space-function-paren'};$rOpts_space_keyword_paren=$rOpts->{'space-keyword-paren'};$rOpts_keep_interior_semicolons=$rOpts->{'keep-interior-semicolons'};$rOpts_ignore_side_comment_lengths=$rOpts->{'ignore-side-comment-lengths'};%opening_vertical_tightness=('('=>$rOpts->{'paren-vertical-tightness'},'{'=>$rOpts->{'brace-vertical-tightness'},'['=>$rOpts->{'square-bracket-vertical-tightness'},')'=>$rOpts->{'paren-vertical-tightness'},'}'=>$rOpts->{'brace-vertical-tightness'},']'=>$rOpts->{'square-bracket-vertical-tightness'},);%closing_vertical_tightness=('('=>$rOpts->{'paren-vertical-tightness-closing'},'{'=>$rOpts->{'brace-vertical-tightness-closing'},'['=>$rOpts->{'square-bracket-vertical-tightness-closing'},')'=>$rOpts->{'paren-vertical-tightness-closing'},'}'=>$rOpts->{'brace-vertical-tightness-closing'},']'=>$rOpts->{'square-bracket-vertical-tightness-closing'},);$rOpts_tight_secret_operators=$rOpts->{'tight-secret-operators'};%closing_token_indentation=(')'=>$rOpts->{'closing-paren-indentation'},'}'=>$rOpts->{'closing-brace-indentation'},']'=>$rOpts->{'closing-square-bracket-indentation'},'>'=>$rOpts->{'closing-paren-indentation'},);$some_closing_token_indentation=$rOpts->{'closing-paren-indentation'}|| $rOpts->{'closing-brace-indentation'}|| $rOpts->{'closing-square-bracket-indentation'}|| $rOpts->{'indent-closing-brace'};%opening_token_right=('('=>$rOpts->{'opening-paren-right'},'{'=>$rOpts->{'opening-hash-brace-right'},'['=>$rOpts->{'opening-square-bracket-right'},);%stack_opening_token=('('=>$rOpts->{'stack-opening-paren'},'{'=>$rOpts->{'stack-opening-hash-brace'},'['=>$rOpts->{'stack-opening-square-bracket'},);%stack_closing_token=(')'=>$rOpts->{'stack-closing-paren'},'}'=>$rOpts->{'stack-closing-hash-brace'},']'=>$rOpts->{'stack-closing-square-bracket'},);$rOpts_stack_closing_block_brace=$rOpts->{'stack-closing-block-brace'}}sub make_static_block_comment_pattern {$static_block_comment_pattern='^\s*##';if ($rOpts->{'static-block-comment-prefix'}){my$prefix=$rOpts->{'static-block-comment-prefix'};$prefix =~ s/^\s*//;my$pattern=$prefix;if ($prefix !~ /^\^#/){if ($prefix !~ /^#/){Perl::Tidy::Die "ERROR: the -sbcp prefix is '$prefix' but must begin with '#' or '^#'\n"}$pattern='^\s*' .$prefix}eval "'##'=~/$pattern/";if ($@){Perl::Tidy::Die "ERROR: the -sbc prefix '$prefix' causes the invalid regex '$pattern'\n"}$static_block_comment_pattern=$pattern}}sub make_format_skipping_pattern {my ($opt_name,$default)=@_;my$param=$rOpts->{$opt_name};unless ($param){$param=$default}$param =~ s/^\s*//;if ($param !~ /^#/){Perl::Tidy::Die "ERROR: the $opt_name parameter '$param' must begin with '#'\n"}my$pattern='^' .$param .'\s';eval "'#'=~/$pattern/";if ($@){Perl::Tidy::Die "ERROR: the $opt_name parameter '$param' causes the invalid regex '$pattern'\n"}return$pattern}sub make_closing_side_comment_list_pattern {$closing_side_comment_list_pattern='^\w+';if (defined($rOpts->{'closing-side-comment-list'})&& $rOpts->{'closing-side-comment-list'}){$closing_side_comment_list_pattern=make_block_pattern('-cscl',$rOpts->{'closing-side-comment-list'})}}sub make_bli_pattern {if (defined($rOpts->{'brace-left-and-indent-list'})&& $rOpts->{'brace-left-and-indent-list'}){$bli_list_string=$rOpts->{'brace-left-and-indent-list'}}$bli_pattern=make_block_pattern('-blil',$bli_list_string)}sub make_block_brace_vertical_tightness_pattern {$block_brace_vertical_tightness_pattern='^((if|else|elsif|unless|while|for|foreach|do|\w+:)$|sub)';if (defined($rOpts->{'block-brace-vertical-tightness-list'})&& $rOpts->{'block-brace-vertical-tightness-list'}){$block_brace_vertical_tightness_pattern=make_block_pattern('-bbvtl',$rOpts->{'block-brace-vertical-tightness-list'})}}sub make_block_pattern {my ($abbrev,$string)=@_;my@list=split_words($string);my@words=();my%seen;for my$i (@list){if ($i eq '*'){my$pattern='^.*';return$pattern}next if$seen{$i};$seen{$i}=1;if ($i eq 'sub'){}elsif ($i eq ';'){push@words,';'}elsif ($i eq '{'){push@words,'\{'}elsif ($i eq ':'){push@words,'\w+:'}elsif ($i =~ /^\w/){push@words,$i}else {Perl::Tidy::Warn "unrecognized block type $i after $abbrev, ignoring\n"}}my$pattern='(' .join('|',@words).')$';if ($seen{'sub'}){$pattern='(' .$pattern .'|sub)'}$pattern='^' .$pattern;return$pattern}sub make_static_side_comment_pattern {$static_side_comment_pattern='^##';if ($rOpts->{'static-side-comment-prefix'}){my$prefix=$rOpts->{'static-side-comment-prefix'};$prefix =~ s/^\s*//;my$pattern='^' .$prefix;eval "'##'=~/$pattern/";if ($@){Perl::Tidy::Die "ERROR: the -sscp prefix '$prefix' causes the invalid regex '$pattern'\n"}$static_side_comment_pattern=$pattern}}sub make_closing_side_comment_prefix {my$csc_prefix=$rOpts->{'closing-side-comment-prefix'};my$csc_prefix_pattern;if (!defined($csc_prefix)){$csc_prefix='## end';$csc_prefix_pattern='^##\s+end'}else {my$test_csc_prefix=$csc_prefix;if ($test_csc_prefix !~ /^#/){$test_csc_prefix='#' .$test_csc_prefix}my$test_csc_prefix_pattern=$test_csc_prefix;$test_csc_prefix_pattern =~ s/([^#\s\w])/\\$1/g;$test_csc_prefix_pattern='^' .$test_csc_prefix_pattern;$test_csc_prefix_pattern =~ s/\s+/\\s\+/g;eval "'##'=~/$test_csc_prefix_pattern/";if ($@){report_definite_bug();Perl::Tidy::Warn "Program Error: the -cscp prefix '$csc_prefix' caused the invalid regex '$csc_prefix_pattern'\n";Perl::Tidy::Warn "Please consider using a simpler -cscp prefix\n";Perl::Tidy::Warn "Using default -cscp instead; please check output\n"}else {$csc_prefix=$test_csc_prefix;$csc_prefix_pattern=$test_csc_prefix_pattern}}$rOpts->{'closing-side-comment-prefix'}=$csc_prefix;$closing_side_comment_prefix_pattern=$csc_prefix_pattern}sub dump_want_left_space {my$fh=shift;local $"="\n";print$fh <<EOM;for (sort keys%want_left_space){print$fh "$_\t$want_left_space{$_}\n"}}sub dump_want_right_space {my$fh=shift;local $"="\n";print$fh <<EOM;for (sort keys%want_right_space){print$fh "$_\t$want_right_space{$_}\n"}}{my%is_sort_grep_map;my%is_for_foreach;BEGIN {@_=qw(sort grep map);@is_sort_grep_map{@_}=(1)x scalar(@_);@_=qw(for foreach);@is_for_foreach{@_}=(1)x scalar(@_)}sub is_essential_whitespace {my ($tokenll,$typell,$tokenl,$typel,$tokenr,$typer)=@_;my$result=(($tokenl =~ /([\'\w]|\:\:)$/ && $typel ne 'CORE::')&& ($tokenr =~ /^([\'\w]|\:\:)/))|| (($typel eq 'n')&& ($tokenr eq '.'))|| (($typer eq 'n')&& ($tokenl eq '.'))|| (($tokenl eq '-')&& ($tokenr =~ /^[_A-Za-z]$/))|| (($tokenl eq '-')&& ($typer =~ /^[wC]$/ && $tokenr =~ /^[_A-Za-z]/))|| (($typel eq 'Q')&& ($tokenr =~ /^[a-zA-Z_]/))|| (($typel eq 'i' && $tokenl =~ /\$$/)&& ($tokenr =~ /^[a-zA-Z_]/))|| ($tokenr =~ /^\<\</)|| ($is_digraph{$tokenl .$tokenr })|| ($is_trigraph{$tokenl .$tokenr })|| ($is_digraph{$tokenl .substr($tokenr,0,1)})|| (($tokenl =~ /^\$[\$\#]$/)&& ($tokenr =~ /^\w/))|| ($typel eq 'Z')|| ($typell eq 'Z' && $typel =~ /^[\/\?\+\-\*]$/)|| ($tokenr eq '(' && $typel eq 'w' && $typell eq 'k' && $tokenll eq 'use')|| ($typel eq 'Y' && $tokenr eq '(')|| ($typel eq 'h')|| (($typer =~ /^(pp|mm)$/)&& ($tokenl !~ /^[\;\{\(\[]/))|| (($typel =~ /^(\+\+|\-\-)$/)&& ($tokenr !~ /^[\;\}\)\]]/))|| ($tokenl eq 'my' && $is_for_foreach{$tokenll}&& $tokenr =~ /^\$/)|| ($tokenr eq '(' && $is_sort_grep_map{$tokenl})|| (($typel eq 'n')&& ($tokenr eq '('))|| (($typel eq '&')&& ($tokenr =~ /^[a-zA-Z_]/))|| ($typel eq 'J' && $typer eq 'J');return$result}}{my%secret_operators;my%is_leading_secret_token;BEGIN {%secret_operators=('Goatse'=>[qw#= ( ) =#],'Venus1'=>[qw#0 +#],'Venus2'=>[qw#+ 0#],'Enterprise'=>[qw#) x ! !#],'Kite1'=>[qw#~ ~ <>#],'Kite2'=>[qw#~~ <>#],'Winking Fat Comma'=>[(',','=>')],);for my$value (values(%secret_operators)){my$tok=$value->[0];push @{$is_leading_secret_token{$tok}},$value}}sub secret_operator_whitespace {my ($jmax,$rtokens,$rtoken_type,$rwhite_space_flag)=@_;my ($j,$token,$type);for ($j=0 ;$j <= $jmax ;$j++ ){$token=$$rtokens[$j];$type=$$rtoken_type[$j];next if ($type eq 'b');next unless ($is_leading_secret_token{$token});for my$rpattern (@{$is_leading_secret_token{$token}}){my$jend=$j - 1;for my$tok (@{$rpattern}){$jend++;$jend++ if ($jend <= $jmax && $$rtoken_type[$jend]eq 'b');if ($jend > $jmax || $tok ne $$rtokens[$jend]){$jend=undef;last}}if ($jend){for (my$jj=$j + 1 ;$jj <= $jend ;$jj++ ){$rwhite_space_flag->[$jj]=WS_NO}$j=$jend;last}}}}}sub set_white_space_flag {BEGIN {@_=qw"L { ( [";@is_opening_type{@_}=(1)x scalar(@_);@_=qw"R } ) ]";@is_closing_type{@_}=(1)x scalar(@_);my@spaces_both_sides=qw"+ - * / % ? = . : x < > | & ^ .. << >> ** && .. || // => += -= .= %= x= &= |= ^= *= <> <= >= == =~ !~ /= != ... <<= >>= ~~ !~~ &&= ||= //= <=> A k f w F n C Y U G v";my@spaces_left_side=qw"t ! ~ m p { \ h pp mm Z j";push(@spaces_left_side,'#');my@spaces_right_side=qw"; } ) ] R J ++ -- **=";push(@spaces_right_side,',');@want_left_space{@spaces_both_sides}=(1)x scalar(@spaces_both_sides);@want_right_space{@spaces_both_sides}=(1)x scalar(@spaces_both_sides);@want_left_space{@spaces_left_side}=(1)x scalar(@spaces_left_side);@want_right_space{@spaces_left_side}=(-1)x scalar(@spaces_left_side);@want_left_space{@spaces_right_side}=(-1)x scalar(@spaces_right_side);@want_right_space{@spaces_right_side}=(1)x scalar(@spaces_right_side);$want_left_space{'->'}=WS_NO;$want_right_space{'->'}=WS_NO;$want_left_space{'**'}=WS_NO;$want_right_space{'**'}=WS_NO;$want_right_space{'CORE::'}=WS_NO;$binary_ws_rules{'i'}{'L'}=WS_NO;$binary_ws_rules{'i'}{'{'}=WS_YES;$binary_ws_rules{'k'}{'{'}=WS_YES;$binary_ws_rules{'U'}{'{'}=WS_YES;$binary_ws_rules{'i'}{'['}=WS_NO;$binary_ws_rules{'R'}{'L'}=WS_NO;$binary_ws_rules{'R'}{'{'}=WS_NO;$binary_ws_rules{'t'}{'L'}=WS_NO;$binary_ws_rules{'t'}{'{'}=WS_NO;$binary_ws_rules{'}'}{'L'}=WS_NO;$binary_ws_rules{'}'}{'{'}=WS_NO;$binary_ws_rules{'$'}{'L'}=WS_NO;$binary_ws_rules{'$'}{'{'}=WS_NO;$binary_ws_rules{'@'}{'L'}=WS_NO;$binary_ws_rules{'@'}{'{'}=WS_NO;$binary_ws_rules{'='}{'L'}=WS_YES;$binary_ws_rules{'J'}{'J'}=WS_YES;$binary_ws_rules{']'}{'L'}=WS_NO;$binary_ws_rules{']'}{'{'}=WS_NO;$binary_ws_rules{')'}{'{'}=WS_YES;$binary_ws_rules{')'}{'['}=WS_NO;$binary_ws_rules{']'}{'['}=WS_NO;$binary_ws_rules{']'}{'{'}=WS_NO;$binary_ws_rules{'}'}{'['}=WS_NO;$binary_ws_rules{'R'}{'['}=WS_NO;$binary_ws_rules{']'}{'++'}=WS_NO;$binary_ws_rules{']'}{'--'}=WS_NO;$binary_ws_rules{')'}{'++'}=WS_NO;$binary_ws_rules{')'}{'--'}=WS_NO;$binary_ws_rules{'R'}{'++'}=WS_NO;$binary_ws_rules{'R'}{'--'}=WS_NO;$binary_ws_rules{'i'}{'Q'}=WS_YES;$binary_ws_rules{'n'}{'('}=WS_YES;$binary_ws_rules{'i'}{'('}=WS_NO;$binary_ws_rules{'w'}{'('}=WS_NO;$binary_ws_rules{'w'}{'{'}=WS_YES}my ($jmax,$rtokens,$rtoken_type,$rblock_type)=@_;my ($last_token,$last_type,$last_block_type,$token,$type,$block_type);my (@white_space_flag);my$j_tight_closing_paren=-1;if ($max_index_to_go >= 0){$token=$tokens_to_go[$max_index_to_go];$type=$types_to_go[$max_index_to_go];$block_type=$block_type_to_go[$max_index_to_go];if ($type =~ /^[wi]$/){my$im=$iprev_to_go[$max_index_to_go];my$tm=($im >= 0)? $types_to_go[$im]: "";if ($tm eq '->'){$token=$tm .$token}}}else {$token=' ';$type='b';$block_type=''}my ($j,$ws);for ($j=0 ;$j <= $jmax ;$j++ ){if ($$rtoken_type[$j]eq 'b'){$white_space_flag[$j]=WS_OPTIONAL;next}$ws=undef;$last_token=$token;$last_type=$type;$last_block_type=$block_type;$token=$$rtokens[$j];$type=$$rtoken_type[$j];$block_type=$$rblock_type[$j];if ($is_opening_type{$last_type}){$j_tight_closing_paren=-1;if ($token eq $matching_token{$last_token}){if ($block_type){$ws=WS_YES}else {$ws=WS_NO}}else {my$tightness;if ($last_type eq '{' && $last_token eq '{' && $last_block_type){$tightness=$rOpts_block_brace_tightness}else {$tightness=$tightness{$last_token}}if ($type eq 'w' && $token =~ /^\^/){$tightness=1}if ($tightness <= 0){$ws=WS_YES}elsif ($tightness > 1){$ws=WS_NO}else {my$j_here=$j;++$j_here if ($token eq '-' && $last_token eq '{' && $$rtoken_type[$j + 1 ]eq 'w');my$j_next=($$rtoken_type[$j_here + 1 ]eq 'b')? $j_here + 2 : $j_here + 1;my$tok_next=$$rtokens[$j_next];my$type_next=$$rtoken_type[$j_next];if ($tok_next eq $matching_token{$last_token}&& $last_token ne $token){$j_tight_closing_paren=$j_next;$ws=WS_NO}else {$ws=WS_YES}}}}my$ws_1=$ws if FORMATTER_DEBUG_FLAG_WHITE;if ($is_closing_type{$type}){if ($j==$j_tight_closing_paren){$j_tight_closing_paren=-1;$ws=WS_NO}else {if (!defined($ws)){my$tightness;if ($type eq '}' && $token eq '}' && $block_type){$tightness=$rOpts_block_brace_tightness}else {$tightness=$tightness{$token}}$ws=($tightness > 1)? WS_NO : WS_YES}}}my$ws_2=$ws if FORMATTER_DEBUG_FLAG_WHITE;if (!defined($ws)){$ws=$binary_ws_rules{$last_type}{$type}}my$ws_3=$ws if FORMATTER_DEBUG_FLAG_WHITE;if ($token eq '('){if ($last_type eq '}'){$ws=WS_YES}elsif ($last_type eq 'k'){$ws=WS_NO unless ($rOpts_space_keyword_paren || $space_after_keyword{$last_token})}elsif (($last_type =~ /^[wUG]$/)|| ($last_type =~ /^[wi]$/ && $last_token =~ /^(\&|->)/)){$ws=WS_NO unless ($rOpts_space_function_paren)}elsif ($last_type eq 'i' && $last_token =~ /^[\$\%\@]/){$ws=WS_YES}elsif ($last_type eq 'C' && $$rtokens[$j + 1 ]eq ')'){$ws=WS_NO}}elsif (($token eq '{' && $type ne 'L')&& $last_token eq ']'){$ws=WS_OPTIONAL}if ($type eq '{'){if ($last_token eq 'sub'){$ws=WS_YES}if ($last_token eq ')' && $token eq '{'){$ws=WS_YES}if ($last_type eq 'i' && $last_token =~ /^\@/){$ws=WS_NO}}elsif ($type eq 'i'){if ($token =~ /^\-\>/){$ws=WS_NO}}elsif ($type eq 'w' || $type eq 'C'){$ws=WS_OPTIONAL if$last_type eq '-';if ($token =~ /^\-\>/){$ws=WS_NO}}elsif ($type eq 'm' || $type eq '-'){$ws=WS_OPTIONAL if ($last_type eq 'w')}elsif ($type eq '#'){$ws=WS_YES if$j > 0}if ($type ne '#' && (($last_type eq 'Z' && $last_token ne '_')|| $last_type eq 'h')){$ws=WS_OPTIONAL}my$ws_4=$ws if FORMATTER_DEBUG_FLAG_WHITE;if (!defined($ws)){my$wl=$want_left_space{$type};my$wr=$want_right_space{$last_type};if (!defined($wl)){$wl=0}if (!defined($wr)){$wr=0}$ws=(($wl==$wr)|| ($wl==-1)||!$wr)? $wl : $wr}if (!defined($ws)){$ws=0;write_diagnostics("WS flag is undefined for tokens $last_token $token\n")}if ($ws==0 && $j==0){$ws=1}if (($ws==0)&& $j > 0 && $j < $jmax && ($last_type !~ /^[Zh]$/)){write_diagnostics("WS flag is zero for tokens $last_token $token\n")}$white_space_flag[$j]=$ws;FORMATTER_DEBUG_FLAG_WHITE && do {my$str=substr($last_token,0,15);$str .= ' ' x (16 - length($str));if (!defined($ws_1)){$ws_1="*"}if (!defined($ws_2)){$ws_2="*"}if (!defined($ws_3)){$ws_3="*"}if (!defined($ws_4)){$ws_4="*"}print STDOUT "WHITE:  i=$j $str $last_type $type $ws_1 : $ws_2 : $ws_3 : $ws_4 : $ws \n"}}if ($rOpts_tight_secret_operators){secret_operator_whitespace($jmax,$rtokens,$rtoken_type,\@white_space_flag)}return \@white_space_flag}{my$rtoken_type;my$rtokens;my$rlevels;my$rslevels;my$rblock_type;my$rcontainer_type;my$rcontainer_environment;my$rtype_sequence;my$input_line;my$rnesting_tokens;my$rci_levels;my$rnesting_blocks;my$in_quote;my$guessed_indentation_level;my$block_type;my$ci_level;my$container_environment;my$container_type;my$in_continued_quote;my$level;my$nesting_blocks;my$no_internal_newlines;my$slevel;my$token;my$type;my$type_sequence;sub extract_token {my$j=shift;$token=$$rtokens[$j];$type=$$rtoken_type[$j];$block_type=$$rblock_type[$j];$container_type=$$rcontainer_type[$j];$container_environment=$$rcontainer_environment[$j];$type_sequence=$$rtype_sequence[$j];$level=$$rlevels[$j];$slevel=$$rslevels[$j];$nesting_blocks=$$rnesting_blocks[$j];$ci_level=$$rci_levels[$j]}{my@saved_token;sub save_current_token {@saved_token=($block_type,$ci_level,$container_environment,$container_type,$in_continued_quote,$level,$nesting_blocks,$no_internal_newlines,$slevel,$token,$type,$type_sequence,)}sub restore_current_token {($block_type,$ci_level,$container_environment,$container_type,$in_continued_quote,$level,$nesting_blocks,$no_internal_newlines,$slevel,$token,$type,$type_sequence,)=@saved_token}}sub token_length {my ($token,$type,$not_first_token)=@_;my$token_length=length($token);$token_length=1 if ($rOpts_ignore_side_comment_lengths && $not_first_token && $type eq '#');return$token_length}sub rtoken_length {my ($i)=@_;return token_length($$rtokens[$i],$$rtoken_type[$i],$i)}sub store_token_to_go {my$flag=$no_internal_newlines;if ($_[0]){$flag=1}$tokens_to_go[++$max_index_to_go ]=$token;$types_to_go[$max_index_to_go]=$type;$nobreak_to_go[$max_index_to_go]=$flag;$old_breakpoint_to_go[$max_index_to_go]=0;$forced_breakpoint_to_go[$max_index_to_go]=0;$block_type_to_go[$max_index_to_go]=$block_type;$type_sequence_to_go[$max_index_to_go]=$type_sequence;$container_environment_to_go[$max_index_to_go]=$container_environment;$nesting_blocks_to_go[$max_index_to_go]=$nesting_blocks;$ci_levels_to_go[$max_index_to_go]=$ci_level;$mate_index_to_go[$max_index_to_go]=-1;$matching_token_to_go[$max_index_to_go]='';$bond_strength_to_go[$max_index_to_go]=0;$levels_to_go[$max_index_to_go]=$level;$nesting_depth_to_go[$max_index_to_go]=($slevel >= 0)? $slevel : 0;my$iprev=$max_index_to_go - 1;$iprev-- if ($iprev >= 0 && $types_to_go[$iprev]eq 'b');$iprev_to_go[$max_index_to_go]=$iprev;$inext_to_go[$iprev]=$max_index_to_go if ($iprev >= 0 && $type ne 'b');$inext_to_go[$max_index_to_go]=$max_index_to_go + 1;$token_lengths_to_go[$max_index_to_go]=token_length($token,$type,$max_index_to_go);$summed_lengths_to_go[$max_index_to_go + 1 ]=$summed_lengths_to_go[$max_index_to_go]+ $token_lengths_to_go[$max_index_to_go];set_leading_whitespace($level,$ci_level,$in_continued_quote);if ($type ne 'b'){$last_last_nonblank_index_to_go=$last_nonblank_index_to_go;$last_last_nonblank_type_to_go=$last_nonblank_type_to_go;$last_last_nonblank_token_to_go=$last_nonblank_token_to_go;$last_nonblank_index_to_go=$max_index_to_go;$last_nonblank_type_to_go=$type;$last_nonblank_token_to_go=$token;if ($type eq ','){$comma_count_in_batch++}}FORMATTER_DEBUG_FLAG_STORE && do {my ($a,$b,$c)=caller();print STDOUT "STORE: from $a $c: storing token $token type $type lev=$level slev=$slevel at $max_index_to_go\n"}}sub insert_new_token_to_go {save_current_token();($token,$type,$slevel,$no_internal_newlines)=@_;if ($max_index_to_go==UNDEFINED_INDEX){warning("code bug: bad call to insert_new_token_to_go\n")}$level=$levels_to_go[$max_index_to_go];$nesting_blocks=$nesting_blocks_to_go[$max_index_to_go];$ci_level=$ci_levels_to_go[$max_index_to_go];$container_environment=$container_environment_to_go[$max_index_to_go];$in_continued_quote=0;$block_type="";$type_sequence="";store_token_to_go();restore_current_token();return}sub print_line_of_tokens {my$line_of_tokens=shift;$input_line_number=$line_of_tokens->{_line_number};$rtoken_type=$line_of_tokens->{_rtoken_type};$rtokens=$line_of_tokens->{_rtokens};$rlevels=$line_of_tokens->{_rlevels};$rslevels=$line_of_tokens->{_rslevels};$rblock_type=$line_of_tokens->{_rblock_type};$rcontainer_type=$line_of_tokens->{_rcontainer_type};$rcontainer_environment=$line_of_tokens->{_rcontainer_environment};$rtype_sequence=$line_of_tokens->{_rtype_sequence};$input_line=$line_of_tokens->{_line_text};$rnesting_tokens=$line_of_tokens->{_rnesting_tokens};$rci_levels=$line_of_tokens->{_rci_levels};$rnesting_blocks=$line_of_tokens->{_rnesting_blocks};$in_continued_quote=$starting_in_quote=$line_of_tokens->{_starting_in_quote};$in_quote=$line_of_tokens->{_ending_in_quote};$ending_in_quote=$in_quote;$guessed_indentation_level=$line_of_tokens->{_guessed_indentation_level};my$j;my$j_next;my$jmax;my$next_nonblank_token;my$next_nonblank_token_type;my$rwhite_space_flag;$jmax=@$rtokens - 1;$block_type="";$container_type="";$container_environment="";$type_sequence="";$no_internal_newlines=1 - $rOpts_add_newlines;$is_static_block_comment=0;if ($in_continued_quote){if ($jmax <= 0){if (($input_line =~ "\t")){note_embedded_tab()}write_unindented_line("$input_line");$last_line_had_side_comment=0;return}}if ($in_format_skipping_section){write_unindented_line("$input_line");$last_line_had_side_comment=0;if ($jmax==0 && $$rtoken_type[0]eq '#' && ($$rtokens[0]." ")=~ /$format_skipping_pattern_end/o){$in_format_skipping_section=0;write_logfile_entry("Exiting formatting skip section\n");$file_writer_object->reset_consecutive_blank_lines()}return}if ($rOpts_format_skipping && $jmax==0 && $$rtoken_type[0]eq '#' && ($$rtokens[0]." ")=~ /$format_skipping_pattern_begin/o){flush();$in_format_skipping_section=1;write_logfile_entry("Entering formatting skip section\n");write_unindented_line("$input_line");$last_line_had_side_comment=0;return}if ($jmax > 0 && $$rtoken_type[$jmax]eq 'b'){$jmax--}if ($jmax < 0){if ($rOpts_keep_old_blank_lines){flush();$file_writer_object->write_blank_code_line($rOpts_keep_old_blank_lines==2);$last_line_leading_type='b'}$last_line_had_side_comment=0;return}my$is_static_block_comment_without_leading_space=0;if ($jmax==0 && $$rtoken_type[0]eq '#' && $rOpts->{'static-block-comments'}&& $input_line =~ /$static_block_comment_pattern/o){$is_static_block_comment=1;$is_static_block_comment_without_leading_space=substr($input_line,0,1)eq '#'}if ($jmax==0 && $$rtoken_type[0]eq '#' && $input_line =~ /^\#   \s*
  Error trying to discover Win_OS_Type: $id:$major:$minor Has no name of record!
  We won't be able to look for a system-wide config file.
  EOS
  Error reading file '$config_file' at line number $line_no.
  $msg
  Please fix this line or use -npro to avoid reading this file
  EOM
  Error reading file $config_file at line number $line_no.
  Did not see ending quote character <$quote_char> in this text:
  $instr
  Please fix this line or use -npro to avoid reading this file
  EOM
  Did not see ending quote character <$quote_char> in this text:
  $body
  EOM
  # Command line long names (passed to GetOptions)
  #---------------------------------------------------------------
  # here is a summary of the Getopt codes:
  # <none> does not take an argument
  # =s takes a mandatory string
  # :s takes an optional string
  # =i takes a mandatory integer
  # :i takes an optional integer
  # ! does not take an argument and may be negated
  #  i.e., -foo and -nofoo are allowed
  # a double dash signals the end of the options list
  #
  #---------------------------------------------------------------
  EOM
  This is perltidy, v$VERSION 
  
  Copyright 2000-2016, Steve Hancock
  
  Perltidy is free software and may be copied under the terms of the GNU
  General Public License, which is included in the distribution files.
  
  Complete documentation for perltidy can be found using 'man perltidy'
  or on the internet at http://perltidy.sourceforge.net.
  EOM
  This is perltidy version $VERSION, a perl script indenter.  Usage:
  
      perltidy [ options ] file1 file2 file3 ...
              (output goes to file1.tdy, file2.tdy, file3.tdy, ...)
      perltidy [ options ] file1 -o outfile
      perltidy [ options ] file1 -st >outfile
      perltidy [ options ] <infile >outfile
  
  Options have short and long forms. Short forms are shown; see
  man pages for long forms.  Note: '=s' indicates a required string,
  and '=n' indicates a required integer.
  
  I/O control
   -h      show this help
   -o=file name of the output file (only if single input file)
   -oext=s change output extension from 'tdy' to s
   -opath=path  change path to be 'path' for output files
   -b      backup original to .bak and modify file in-place
   -bext=s change default backup extension from 'bak' to s
   -q      deactivate error messages (for running under editor)
   -w      include non-critical warning messages in the .ERR error output
   -syn    run perl -c to check syntax (default under unix systems)
   -log    save .LOG file, which has useful diagnostics
   -f      force perltidy to read a binary file
   -g      like -log but writes more detailed .LOG file, for debugging scripts
   -opt    write the set of options actually used to a .LOG file
   -npro   ignore .perltidyrc configuration command file 
   -pro=file   read configuration commands from file instead of .perltidyrc 
   -st     send output to standard output, STDOUT
   -se     send all error output to standard error output, STDERR
   -v      display version number to standard output and quit
  
  Basic Options:
   -i=n    use n columns per indentation level (default n=4)
   -t      tabs: use one tab character per indentation level, not recommeded
   -nt     no tabs: use n spaces per indentation level (default)
   -et=n   entab leading whitespace n spaces per tab; not recommended
   -io     "indent only": just do indentation, no other formatting.
   -sil=n  set starting indentation level to n;  use if auto detection fails
   -ole=s  specify output line ending (s=dos or win, mac, unix)
   -ple    keep output line endings same as input (input must be filename)
  
  Whitespace Control
   -fws    freeze whitespace; this disables all whitespace changes
             and disables the following switches:
   -bt=n   sets brace tightness,  n= (0 = loose, 1=default, 2 = tight)
   -bbt    same as -bt but for code block braces; same as -bt if not given
   -bbvt   block braces vertically tight; use with -bl or -bli
   -bbvtl=s  make -bbvt to apply to selected list of block types
   -pt=n   paren tightness (n=0, 1 or 2)
   -sbt=n  square bracket tightness (n=0, 1, or 2)
   -bvt=n  brace vertical tightness, 
           n=(0=open, 1=close unless multiple steps on a line, 2=always close)
   -pvt=n  paren vertical tightness (see -bvt for n)
   -sbvt=n square bracket vertical tightness (see -bvt for n)
   -bvtc=n closing brace vertical tightness: 
           n=(0=open, 1=sometimes close, 2=always close)
   -pvtc=n closing paren vertical tightness, see -bvtc for n.
   -sbvtc=n closing square bracket vertical tightness, see -bvtc for n.
   -ci=n   sets continuation indentation=n,  default is n=2 spaces
   -lp     line up parentheses, brackets, and non-BLOCK braces
   -sfs    add space before semicolon in for( ; ; )
   -aws    allow perltidy to add whitespace (default)
   -dws    delete all old non-essential whitespace 
   -icb    indent closing brace of a code block
   -cti=n  closing indentation of paren, square bracket, or non-block brace: 
           n=0 none, =1 align with opening, =2 one full indentation level
   -icp    equivalent to -cti=2
   -wls=s  want space left of tokens in string; i.e. -nwls='+ - * /'
   -wrs=s  want space right of tokens in string;
   -sts    put space before terminal semicolon of a statement
   -sak=s  put space between keywords given in s and '(';
   -nsak=s no space between keywords in s and '('; i.e. -nsak='my our local'
  
  Line Break Control
   -fnl    freeze newlines; this disables all line break changes
              and disables the following switches:
   -anl    add newlines;  ok to introduce new line breaks
   -bbs    add blank line before subs and packages
   -bbc    add blank line before block comments
   -bbb    add blank line between major blocks
   -kbl=n  keep old blank lines? 0=no, 1=some, 2=all
   -mbl=n  maximum consecutive blank lines to output (default=1)
   -ce     cuddled else; use this style: '} else {'
   -dnl    delete old newlines (default)
   -l=n    maximum line length;  default n=80
   -bl     opening brace on new line 
   -sbl    opening sub brace on new line.  value of -bl is used if not given.
   -bli    opening brace on new line and indented
   -bar    opening brace always on right, even for long clauses
   -vt=n   vertical tightness (requires -lp); n controls break after opening
           token: 0=never  1=no break if next line balanced   2=no break
   -vtc=n  vertical tightness of closing container; n controls if closing
           token starts new line: 0=always  1=not unless list  1=never
   -wba=s  want break after tokens in string; i.e. wba=': .'
   -wbb=s  want break before tokens in string
  
  Following Old Breakpoints
   -kis    keep interior semicolons.  Allows multiple statements per line.
   -boc    break at old comma breaks: turns off all automatic list formatting
   -bol    break at old logical breakpoints: or, and, ||, && (default)
   -bok    break at old list keyword breakpoints such as map, sort (default)
   -bot    break at old conditional (ternary ?:) operator breakpoints (default)
   -boa    break at old attribute breakpoints 
   -cab=n  break at commas after a comma-arrow (=>):
           n=0 break at all commas after =>
           n=1 stable: break unless this breaks an existing one-line container
           n=2 break only if a one-line container cannot be formed
           n=3 do not treat commas after => specially at all
  
  Comment controls
   -ibc    indent block comments (default)
   -isbc   indent spaced block comments; may indent unless no leading space
   -msc=n  minimum desired spaces to side comment, default 4
   -fpsc=n fix position for side comments; default 0;
   -csc    add or update closing side comments after closing BLOCK brace
   -dcsc   delete closing side comments created by a -csc command
   -cscp=s change closing side comment prefix to be other than '## end'
   -cscl=s change closing side comment to apply to selected list of blocks
   -csci=n minimum number of lines needed to apply a -csc tag, default n=6
   -csct=n maximum number of columns of appended text, default n=20 
   -cscw   causes warning if old side comment is overwritten with -csc
  
   -sbc    use 'static block comments' identified by leading '##' (default)
   -sbcp=s change static block comment identifier to be other than '##'
   -osbc   outdent static block comments
  
   -ssc    use 'static side comments' identified by leading '##' (default)
   -sscp=s change static side comment identifier to be other than '##'
  
  Delete selected text
   -dac    delete all comments AND pod
   -dbc    delete block comments     
   -dsc    delete side comments  
   -dp     delete pod
  
  Send selected text to a '.TEE' file
   -tac    tee all comments AND pod
   -tbc    tee block comments       
   -tsc    tee side comments       
   -tp     tee pod           
  
  Outdenting
   -olq    outdent long quoted strings (default) 
   -olc    outdent a long block comment line
   -ola    outdent statement labels
   -okw    outdent control keywords (redo, next, last, goto, return)
   -okwl=s specify alternative keywords for -okw command
  
  Other controls
   -mft=n  maximum fields per table; default n=40
   -x      do not format lines before hash-bang line (i.e., for VMS)
   -asc    allows perltidy to add a ';' when missing (default)
   -dsm    allows perltidy to delete an unnecessary ';'  (default)
  
  Combinations of other parameters
   -gnu     attempt to follow GNU Coding Standards as applied to perl
   -mangle  remove as many newlines as possible (but keep comments and pods)
   -extrude  insert as many newlines as possible
  
  Dump and die, debugging
   -dop    dump options used in this run to standard output and quit
   -ddf    dump default options to standard output and quit
   -dsn    dump all option short names to standard output and quit
   -dln    dump option long names to standard output and quit
   -dpro   dump whatever configuration file is in effect to standard output
   -dtt    dump all token types to standard output and quit
  
  HTML
   -html write an html file (see 'man perl2web' for many options)
         Note: when -html is used, no indentation or formatting are done.
         Hint: try perltidy -html -css=mystyle.css filename.pl
         and edit mystyle.css to change the appearance of filename.html.
         -nnn gives line numbers
         -pre only writes out <pre>..</pre> code section
         -toc places a table of contents to subs at the top (default)
         -pod passes pod text through pod2html (default)
         -frm write html as a frame (3 files)
         -text=s extra extension for table of contents if -frm, default='toc'
         -sext=s extra extension for file content if -frm, default='src'
  
  A prefix of "n" negates short form toggle switches, and a prefix of "no"
  negates the long forms.  For example, -nasc means don't add missing
  semicolons.  
  
  If you are unable to see this entire text, try "perltidy -h | more"
  For more detailed information, and additional options, try "man perltidy",
  or go to the perltidy home page at http://perltidy.sourceforge.net
  EOF
  ------------------------------------------------------------------------
  expecting ref to SCALAR but got ref to ($ref); trace follows:
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  expecting mode = 'r' or 'w' but got mode ($mode); trace follows:
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  getline call requires mode = 'r' but mode = ($mode); trace follows:
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  print call requires mode = 'w' but mode = ($mode); trace follows:
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  expecting ref to ARRAY but got ref to ($ref); trace follows:
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  expecting mode = 'r' or 'w' but got mode ($mode); trace follows:
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  getline requires mode = 'r' but mode = ($mode); trace follows:
  ------------------------------------------------------------------------
  EOM
  ------------------------------------------------------------------------
  print requires mode = 'w' but mode = ($mode); trace follows:
  ------------------------------------------------------------------------
  EOM
  Note: --syntax check will be skipped because standard input is used
  EOM
  Note: --syntax check will be skipped because standard output is used
  EOM
  The nesting depths in the table below are at the start of the lines.
  The indicated output line numbers are not always exact.
  ci = levels of continuation indentation; bk = 1 if in BLOCK, 0 if not.
  
  in:out indent c b  nesting   code + messages; (messages begin with >>>)
  lines  levels i k            (code begins with one '.' per indent level)
  ------  ----- - - --------   -------------------------------------------
  EOM
  
  You may have encountered a code bug in perltidy.  If you think so, and
  the problem is not listed in the BUGS file at
  http://perltidy.sourceforge.net, please report it so that it can be
  corrected.  Include the smallest possible script which has the problem,
  along with the .LOG file. See the manual pages for contact information.
  Thank you!
  EOM
  
  You may have encountered a bug in perltidy.  However, since you are using the
  -extrude option, the problem may be with perl or one of its modules, which have
  occasional problems with this type of file.  If you believe that the
  problem is with perltidy, and the problem is not listed in the BUGS file at
  http://perltidy.sourceforge.net, please report it so that it can be corrected.
  Include the smallest possible script which has the problem, along with the .LOG
  file. See the manual pages for contact information.
  Thank you!
  EOM
  
  Oops, you seem to have encountered a bug in perltidy.  Please check the
  BUGS file at http://perltidy.sourceforge.net.  If the problem is not
  listed there, please report it so that it can be corrected.  Include the
  smallest possible script which produces this message, along with the
  .LOG file if appropriate.  See the manual pages for contact information.
  Your efforts are appreciated.  
  Thank you!
  EOM
  
  The log file shows that perltidy added $added_semicolon_count semicolons.
  Please rerun with -nasc to see if that is the cause of the syntax error.  Even
  if that is the problem, please report it so that it can be fixed.
  EOM
  <pre>
  PRE_END
  <li><a href=\"#$unique_name\">package $package</a>
  <ul>
  EOM
  <!-- BEGIN CODE INDEX --><a name="code-index"></a>
  <ul>
  TOC_END
  </ul>
  <!-- END CODE INDEX -->
  TOC_END
  /* default style sheet generated by perltidy */
  body {background: $bg_color; color: $text_color}
  pre { color: $text_color; 
        background: $pre_bg_color;
        font-family: courier;
      } 
  
  EOM
  <html>
  <head>
  <title>$title</title>
  </head>
  <body>
  <h1><a href=\"$src_basename#-top-" target="$src_frame_name">$title</a></h1>
  EOM
  </body>
  </html>
  EOM
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
  <?xml version="1.0" encoding="iso-8859-1" ?>
  <html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  <title>$title</title>
  </head>
  EOM
  <frameset cols="20%,80%">
  <frameset rows="30%,70%">
  <frame src = "$top_basename" />
  <frame src = "$toc_basename" />
  </frameset>
  EOM
  <frameset cols="20%,*">
  <frame src = "$toc_basename" />
  EOM
  <frame src = "$src_basename" name = "$src_frame_name" />
  <noframes>
  <body>
  <p>If you see this message, you are using a non-frame-capable web client.</p>
  <p>This document contains:</p>
  <ul>
  <li><a href="$toc_basename">A table of contents</a></li>
  <li><a href="$src_basename">The source code</a></li>
  </ul>
  </body>
  </noframes>
  </frameset>
  </html>
  EOM
  </pre>
  PRE_END
  <style type="text/css">
  <!--
  ENDCSS
  -->
  </style>
  ENDCSS
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <!-- Generated by perltidy on $date -->
  <html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  <title>$title</title>
  HTML_START
  </head>
  <body>
  ENDCSS
  </head>
  <body bgcolor=\"$rOpts->{'html-color-background'}\" text=\"$rOpts->{'html-color-punctuation'}\">
  HTML_START
  <h1>$title</h1>
  EOM
  <hr />
  <!-- contents of filename: $fname_comment -->
  <pre>
  END_PRE
  </pre>
  </body>
  </html>
  HTML_END
  
  $for_html
  <!-- pERLTIDY sECTION -->
  
  EOM
  -----------------------------------------------------------------------
  Conflict: -lp  conflicts with -io, -fnl, -nanl, or -ndnl; ignoring -lp
      
  The -lp indentation logic requires that perltidy be able to coordinate
  arbitrarily large numbers of line breakpoints.  This isn't possible
  with these flags. Sometimes an acceptable workaround is to use -wocb=3
  -----------------------------------------------------------------------
  EOM
  Conflict: -t (tabs) cannot be used with the -lp  option; ignoring -t; see -et.
  EOM
  Conflict: -t (tabs) cannot be used with the -okw options; ignoring -t; see -et.
  EOM
  Conflict: -t (tabs) cannot be used with the -ola  option; ignoring -t; see -et.
  EOM
  Unrecognized character-encoding '$enc'; expecting one of: (none, utf8)
  EOM
  Unrecognized line ending '$ole'; expecting one of: $str
  EOM
  These values are the main control of whitespace to the left of a token type;
  They may be altered with the -wls parameter.
  For a list of token types, use perltidy --dump-token-types (-dtt)
   1 means the token wants a space to its left
  -1 means the token does not want a space to its left
  ------------------------------------------------------------------------
  EOM
  These values are the main control of whitespace to the right of a token type;
  They may be altered with the -wrs parameter.
  For a list of token types, use perltidy --dump-token-types (-dtt)
   1 means the token wants a space to its right
  -1 means the token does not want a space to its right
  ------------------------------------------------------------------------
  EOM
                                 line \s+ (\d+)   \s*
                                 (?:\s("?)([^"]+)\2)? \s*
                                 $/x){$is_static_block_comment=1;$is_static_block_comment_without_leading_space=1}my$is_hanging_side_comment;if ($jmax==0 && $$rtoken_type[0]eq '#' && $last_line_had_side_comment && $input_line =~ /^\s/ &&!$is_static_block_comment && $rOpts->{'hanging-side-comments'}){$is_hanging_side_comment=1;unshift @$rtoken_type,'q';unshift @$rtokens,'';unshift @$rlevels,$$rlevels[0];unshift @$rslevels,$$rslevels[0];unshift @$rblock_type,'';unshift @$rcontainer_type,'';unshift @$rcontainer_environment,'';unshift @$rtype_sequence,'';unshift @$rnesting_tokens,$$rnesting_tokens[0];unshift @$rci_levels,$$rci_levels[0];unshift @$rnesting_blocks,$$rnesting_blocks[0];$jmax=1}$last_line_had_side_comment=($jmax > 0 && $$rtoken_type[$jmax]eq '#');if (($jmax==0)&& ($$rtoken_type[0]eq '#')){if ($rOpts->{'delete-block-comments'}){return}if ($rOpts->{'tee-block-comments'}){$file_writer_object->tee_on()}destroy_one_line_block();output_line_to_go();if ($last_line_leading_type !~ /^[#b]$/ && $rOpts->{'blanks-before-comments'}&& $$rtokens[0]ne '#' &&!$last_output_short_opening_token &&!$is_static_block_comment){flush();$file_writer_object->write_blank_code_line();$last_line_leading_type='b'}$$rtokens[0]=~ s/\s*$//;if ($rOpts->{'indent-block-comments'}&& (!$rOpts->{'indent-spaced-block-comments'}|| $input_line =~ /^\s+/)&&!$is_static_block_comment_without_leading_space){extract_token(0);store_token_to_go();output_line_to_go()}else {flush();$file_writer_object->write_code_line($$rtokens[0]."\n");$last_line_leading_type='#'}if ($rOpts->{'tee-block-comments'}){$file_writer_object->tee_off()}return}my$structural_indentation_level=$$rlevels[0];compare_indentation_levels($guessed_indentation_level,$structural_indentation_level)unless ($is_hanging_side_comment || $$rci_levels[0]> 0 || $guessed_indentation_level==0 && $$rtoken_type[0]eq 'Q');my$is_VERSION_statement=0;if (!$saw_VERSION_in_this_file && $jmax < 80 && $input_line =~ /^[^;]*;?[^;]*([\$*])(([\w\:\']*)\bVERSION)\b.*\=/){$saw_VERSION_in_this_file=1;$is_VERSION_statement=1;write_logfile_entry("passing VERSION line; -npvl deactivates\n");$no_internal_newlines=1}if ($rOpts->{'indent-only'}){flush();my$line=$input_line;if ($rOpts->{'delete-side-comments'}&& $rtoken_type->[$jmax]eq '#'){$line=join "",@{$rtokens}[0 .. $jmax - 1 ]}trim($line);extract_token(0);$token=$line;$type='q';$block_type="";$container_type="";$container_environment="";$type_sequence="";store_token_to_go();output_line_to_go();return}push(@$rtokens,' ',' ');push(@$rtoken_type,'b','b');($rwhite_space_flag)=set_white_space_flag($jmax,$rtokens,$rtoken_type,$rblock_type);if ($max_index_to_go >= 0){$old_line_count_in_batch++;if (is_essential_whitespace($last_last_nonblank_token,$last_last_nonblank_type,$tokens_to_go[$max_index_to_go],$types_to_go[$max_index_to_go],$$rtokens[0],$$rtoken_type[0])){my$slevel=$$rslevels[0];insert_new_token_to_go(' ','b',$slevel,$no_internal_newlines)}}if ($looking_for_else){unless ($$rtokens[0]=~ /^(elsif|else)$/){write_logfile_entry("(No else block)\n")}$looking_for_else=0}if ((($semicolons_before_block_self_destruct==0)&& ($max_index_to_go >= 0)&& ($types_to_go[$max_index_to_go]eq ';')&& ($$rtokens[0]ne '}'))|| ($rOpts_break_at_old_comma_breakpoints && $max_index_to_go >= 0 && $types_to_go[$max_index_to_go]eq ',')){$forced_breakpoint_to_go[$max_index_to_go]=1 if ($rOpts_break_at_old_comma_breakpoints);destroy_one_line_block();output_line_to_go()}$type='b';$token="";for$j (0 .. $jmax){extract_token($j);if ($type eq '#'){$token =~ s/\s*$//;if ($rOpts->{'delete-side-comments'}|| ($rOpts->{'delete-closing-side-comments'}&& $token =~ /$closing_side_comment_prefix_pattern/o && $last_nonblank_block_type =~ /$closing_side_comment_list_pattern/o)){if ($types_to_go[$max_index_to_go]eq 'b'){unstore_token_to_go()}last}}if ($rbrace_follower && $type ne 'b'){unless ($rbrace_follower->{$token}){output_line_to_go()}$rbrace_follower=undef}$j_next=($$rtoken_type[$j + 1 ]eq 'b')? $j + 2 : $j + 1;$next_nonblank_token=$$rtokens[$j_next];$next_nonblank_token_type=$$rtoken_type[$j_next];if ($type =~ /^[wit]$/){if ($token =~ /^([\$\&\%\*\@]|\-\>)\s/){$token =~ s/\s*//g}if ($token =~ /^\-\>(.*)$/ && $1){my$token_save=$1;my$type_save=$type;if ($max_index_to_go >= 0 && $types_to_go[$max_index_to_go]ne 'b' && $want_left_space{'->'}==WS_YES){insert_new_token_to_go(' ','b',$slevel,$no_internal_newlines)}$token='->';$type=$token;store_token_to_go();$$rwhite_space_flag[$j]=$want_right_space{'->'};$token=$token_save;$type=$type_save}if ($token =~ /^sub/){$token =~ s/\s+/ /g}if ($type eq 'i'){$token =~ s/\s+$//g}}elsif ($type eq 'J'){$token =~ s/\s+//g}elsif ($type eq 'n'){if ($token =~ /^x\d+/){$token =~ s/x/x /}}elsif ($type eq 'Q'){note_embedded_tab()if ($token =~ "\t");if ($token =~ /^(s|tr|y|m|\/)/ && $last_nonblank_token =~ /^(=|==|!=)$/ && $last_last_nonblank_type eq 'i' && $last_last_nonblank_token =~ /^\$/ && $next_nonblank_token =~ /^[; \)\}]$/ &&!($types_to_go[0]eq 'k' && $tokens_to_go[0]=~ /^(my|our|local)$/)){my$guess=substr($last_nonblank_token,0,1).'~';complain("Note: be sure you want '$last_nonblank_token' instead of '$guess' here\n")}}elsif ($type eq 'q'){$token =~ s/\s*$//;note_embedded_tab()if ($token =~ "\t")}if (($type ne 'b')&& ($max_index_to_go >= 0)&& ($types_to_go[$max_index_to_go]ne 'b')&& $rOpts_add_whitespace){my$ws=$$rwhite_space_flag[$j];if ($ws==1){insert_new_token_to_go(' ','b',$slevel,$no_internal_newlines)}}my$side_comment_follows=($next_nonblank_token_type eq '#');my$is_opening_BLOCK=($type eq '{' && $token eq '{' && $block_type && $block_type ne 't');my$is_closing_BLOCK=($type eq '}' && $token eq '}' && $block_type && $block_type ne 't');if ($side_comment_follows &&!$is_opening_BLOCK &&!$is_closing_BLOCK){$no_internal_newlines=1}if ($is_opening_BLOCK){store_token_to_go($side_comment_follows);my$too_long=starting_one_line_block($j,$jmax,$level,$slevel,$ci_level,$rtokens,$rtoken_type,$rblock_type);clear_breakpoint_undo_stack();my$keyword_on_same_line=1;if (($max_index_to_go >= 0)&& ($last_nonblank_type eq ')')){if ($block_type =~ /^(if|else|elsif)$/ && ($tokens_to_go[0]eq '}')&& $rOpts_cuddled_else){$keyword_on_same_line=1}elsif (($slevel < $nesting_depth_to_go[0])|| $too_long){$keyword_on_same_line=0}}my$want_break=$block_type !~ /^sub/ ? $rOpts->{'opening-brace-on-new-line'}: $block_type !~ /^sub\W*$/ ? $rOpts->{'opening-sub-brace-on-new-line'}: $rOpts->{'opening-anonymous-sub-brace-on-new-line'};if ($want_break && $index_start_one_line_block==UNDEFINED_INDEX || (!$keyword_on_same_line &&!$rOpts->{'opening-brace-always-on-right'})){unless ($no_internal_newlines){unstore_token_to_go();output_line_to_go();store_token_to_go($side_comment_follows)}}if ($side_comment_follows){$no_internal_newlines=1}unless ($no_internal_newlines){output_line_to_go()}}elsif ($is_closing_BLOCK){if ($index_start_one_line_block!=UNDEFINED_INDEX){if (excess_line_length($index_start_one_line_block,$max_index_to_go)>= 0 || ($semicolons_before_block_self_destruct==0 && $last_nonblank_type ne ';')){destroy_one_line_block()}}unless ($no_internal_newlines || $index_start_one_line_block!=UNDEFINED_INDEX){if (($max_index_to_go > 0)&& ($last_nonblank_type ne ';')&& $rOpts->{'add-semicolons'}&& ($ok_to_add_semicolon_for_block_type{$block_type}|| $block_type =~ /^(sub|package)/ || $block_type =~ /^\w+\:$/)){save_current_token();$token=';';$type=';';$level=$levels_to_go[$max_index_to_go];$slevel=$nesting_depth_to_go[$max_index_to_go];$nesting_blocks=$nesting_blocks_to_go[$max_index_to_go];$ci_level=$ci_levels_to_go[$max_index_to_go];$block_type="";$container_type="";$container_environment="";$type_sequence="";if ($types_to_go[$max_index_to_go]eq 'b'){unstore_token_to_go()}store_token_to_go();note_added_semicolon();restore_current_token()}output_line_to_go()}if ($side_comment_follows){$no_internal_newlines=1}store_token_to_go();my$is_one_line_block=0;my$keep_going=0;if ($index_start_one_line_block!=UNDEFINED_INDEX){$is_one_line_block=$types_to_go[$index_start_one_line_block];undo_forced_breakpoint_stack(0);set_nobreaks($index_start_one_line_block,$max_index_to_go - 1);destroy_one_line_block();if (($is_block_without_semicolon{$block_type}|| $is_one_line_block =~ /^[UG]$/ && $j==$jmax)&& $next_nonblank_token ne ';'){output_line_to_go()unless ($no_internal_newlines)}}if ($block_type eq 'do'){$rbrace_follower=\%is_do_follower}elsif ($block_type =~ /^(if|elsif|unless)$/){$rbrace_follower=\%is_if_brace_follower}elsif ($block_type eq 'else'){$rbrace_follower=\%is_else_brace_follower}elsif ($is_sort_map_grep_eval{$block_type}|| $is_one_line_block eq 'G'){$rbrace_follower=undef;$keep_going=1}elsif ($block_type =~ /^sub\W*$/){if ($is_one_line_block){$rbrace_follower=\%is_anon_sub_1_brace_follower}else {$rbrace_follower=\%is_anon_sub_brace_follower}}else {$rbrace_follower=\%is_other_brace_follower}if ($block_type eq 'elsif'){if ($next_nonblank_token_type eq 'b'){$looking_for_else=1}else {unless ($next_nonblank_token =~ /^(elsif|else)$/){write_logfile_entry("No else block :(\n")}}}if ($keep_going){}elsif (($next_nonblank_token_type eq 'b')&& $rOpts_add_newlines){unless ($rbrace_follower){output_line_to_go()unless ($no_internal_newlines)}}elsif ($rbrace_follower){unless ($rbrace_follower->{$next_nonblank_token}){output_line_to_go()unless ($no_internal_newlines)}$rbrace_follower=undef}else {output_line_to_go()unless ($no_internal_newlines)}}elsif ($type eq ';'){$semicolons_before_block_self_destruct--;if (($semicolons_before_block_self_destruct < 0)|| ($semicolons_before_block_self_destruct==0 && $next_nonblank_token_type !~ /^[b\}]$/)){destroy_one_line_block()}if (($last_nonblank_token eq '}' && ($is_block_without_semicolon{$last_nonblank_block_type}|| $last_nonblank_block_type =~ /^sub\s+\w/ || $last_nonblank_block_type =~ /^\w+:$/))|| $last_nonblank_type eq ';'){if ($rOpts->{'delete-semicolons'}&& ($next_nonblank_token_type ne '#')){note_deleted_semicolon();output_line_to_go()unless ($no_internal_newlines || $index_start_one_line_block!=UNDEFINED_INDEX);next}else {write_logfile_entry("Extra ';'\n")}}store_token_to_go();output_line_to_go()unless ($no_internal_newlines || ($rOpts_keep_interior_semicolons && $j < $jmax)|| ($next_nonblank_token eq '}'))}elsif ($type eq 'h'){$no_internal_newlines=1;destroy_one_line_block();store_token_to_go()}else {if ($type eq 'b'){$token=' ' if$rOpts_add_whitespace;my$ws=$$rwhite_space_flag[$j + 1 ];if ((defined($ws)&& $ws==-1)|| $rOpts_delete_old_whitespace){next unless is_essential_whitespace($last_last_nonblank_token,$last_last_nonblank_type,$tokens_to_go[$max_index_to_go],$types_to_go[$max_index_to_go],$$rtokens[$j + 1 ],$$rtoken_type[$j + 1 ])}}store_token_to_go()}if ($type ne '#' && $type ne 'b'){$last_last_nonblank_token=$last_nonblank_token;$last_last_nonblank_type=$last_nonblank_type;$last_nonblank_token=$token;$last_nonblank_type=$type;$last_nonblank_block_type=$block_type}$in_continued_quote=0}if ((($type eq '#')&&!$rOpts->{'delete-side-comments'})|| $in_quote || $is_VERSION_statement || $type eq 'J' ||!$rOpts->{'delete-old-newlines'}){destroy_one_line_block();output_line_to_go()}if ($max_index_to_go >= 0 &&!$rOpts_ignore_old_breakpoints){$old_breakpoint_to_go[$max_index_to_go]=1}}}sub output_line_to_go {FORMATTER_DEBUG_FLAG_OUTPUT && do {my ($a,$b,$c)=caller;write_diagnostics("OUTPUT: output_line_to_go called: $a $c $last_nonblank_type $last_nonblank_token, one_line=$index_start_one_line_block, tokens to write=$max_index_to_go\n");my$output_str=join "",@tokens_to_go[0 .. $max_index_to_go ];write_diagnostics("$output_str\n")};if ($index_start_one_line_block!=UNDEFINED_INDEX){set_forced_breakpoint($max_index_to_go);return}my$cscw_block_comment;$cscw_block_comment=add_closing_side_comment()if ($rOpts->{'closing-side-comments'}&& $max_index_to_go >= 0);my$comma_arrow_count_contained=match_opening_and_closing_tokens();finish_lp_batch();my$saw_good_break=0;if ($block_type_to_go[$max_index_to_go]&&!$is_block_without_semicolon{$block_type_to_go[$max_index_to_go]}){my$lev=$nesting_depth_to_go[$max_index_to_go];for (my$i=$max_index_to_go - 1 ;$i >= 0 ;$i-- ){last if ($levels_to_go[$i]< $lev);next if ($levels_to_go[$i]> $lev);if ($block_type_to_go[$i]){if ($tokens_to_go[$i]eq '}'){set_forced_breakpoint($i);$saw_good_break=1}}elsif ($types_to_go[$i]!~ /^[\(\)Gwib]$/){last}}}my$imin=0;my$imax=$max_index_to_go;if ($max_index_to_go >= 0){if ($types_to_go[$imin]eq 'b'){$imin++}if ($types_to_go[$imax]eq 'b'){$imax--}}if ($imin <= $imax){if ($last_line_leading_type !~ /^[#]/){my$want_blank=0;my$leading_token=$tokens_to_go[$imin];my$leading_type=$types_to_go[$imin];if ($leading_token =~ /^(sub\s)/ && $leading_type eq 'i'){$want_blank=$rOpts->{'blank-lines-before-subs'}if (terminal_type(\@types_to_go,\@block_type_to_go,$imin,$imax)!~ /^[\;\}]$/)}elsif ($leading_token =~ /^(package\s)/ && $leading_type eq 'i'){$want_blank=$rOpts->{'blank-lines-before-packages'}}if ($leading_token =~ /^(BEGIN|END)$/ && $leading_type eq 'k'){$want_blank=$rOpts->{'blank-lines-before-subs'}if (terminal_type(\@types_to_go,\@block_type_to_go,$imin,$imax)ne '}')}elsif ($leading_type eq 'k' && $last_line_leading_type ne 'b' && $leading_token =~ /^(unless|if|while|until|for|foreach)$/){my$lc=$nonblank_lines_at_depth[$last_line_leading_level];if (!defined($lc)){$lc=0}$want_blank=$rOpts->{'blanks-before-blocks'}&& $lc >= $rOpts->{'long-block-line-count'}&& $file_writer_object->get_consecutive_nonblank_lines()>= $rOpts->{'long-block-line-count'}&& (terminal_type(\@types_to_go,\@block_type_to_go,$imin,$imax)ne '}')}if ($want_blank){Perl::Tidy::VerticalAligner::flush();$file_writer_object->require_blank_code_lines($want_blank)}}$last_last_line_leading_level=$last_line_leading_level;$last_line_leading_level=$levels_to_go[$imin];if ($last_line_leading_level < 0){$last_line_leading_level=0}$last_line_leading_type=$types_to_go[$imin];if ($last_line_leading_level==$last_last_line_leading_level && $last_line_leading_type ne 'b' && $last_line_leading_type ne '#' && defined($nonblank_lines_at_depth[$last_line_leading_level])){$nonblank_lines_at_depth[$last_line_leading_level]++}else {$nonblank_lines_at_depth[$last_line_leading_level]=1}FORMATTER_DEBUG_FLAG_FLUSH && do {my ($package,$file,$line)=caller;print STDOUT "FLUSH: flushing from $package $file $line, types= $types_to_go[$imin] to $types_to_go[$imax]\n"};pad_array_to_go();my$is_long_line=excess_line_length($imin,$max_index_to_go)> 0;if ($is_long_line || $old_line_count_in_batch > 1 || is_unbalanced_batch()|| ($comma_count_in_batch && ($rOpts_maximum_fields_per_table > 0 || $rOpts_comma_arrow_breakpoints==0))|| ($comma_arrow_count_contained && $rOpts_comma_arrow_breakpoints!=3)){my$sgb=scan_list();$saw_good_break ||= $sgb}my ($ri_first,$ri_last);if (!$rOpts_add_newlines || (!$forced_breakpoint_count &&!$saw_good_break &&!$is_long_line)){@$ri_first=($imin);@$ri_last=($imax)}else {($ri_first,$ri_last,my$colon_count)=set_continuation_breaks($saw_good_break);break_all_chain_tokens($ri_first,$ri_last);break_equals($ri_first,$ri_last);if ($rOpts->{'recombine'}){($ri_first,$ri_last)=recombine_breakpoints($ri_first,$ri_last)}insert_final_breaks($ri_first,$ri_last)if$colon_count}my$do_not_pad=0;if ($rOpts_line_up_parentheses){$do_not_pad=correct_lp_indentation($ri_first,$ri_last)}send_lines_to_vertical_aligner($ri_first,$ri_last,$do_not_pad)}prepare_for_new_input_lines();if ($cscw_block_comment){flush();$file_writer_object->write_code_line($cscw_block_comment ."\n")}}sub note_added_semicolon {$last_added_semicolon_at=$input_line_number;if ($added_semicolon_count==0){$first_added_semicolon_at=$last_added_semicolon_at}$added_semicolon_count++;write_logfile_entry("Added ';' here\n")}sub note_deleted_semicolon {$last_deleted_semicolon_at=$input_line_number;if ($deleted_semicolon_count==0){$first_deleted_semicolon_at=$last_deleted_semicolon_at}$deleted_semicolon_count++;write_logfile_entry("Deleted unnecessary ';'\n")}sub note_embedded_tab {$embedded_tab_count++;$last_embedded_tab_at=$input_line_number;if (!$first_embedded_tab_at){$first_embedded_tab_at=$last_embedded_tab_at}if ($embedded_tab_count <= MAX_NAG_MESSAGES){write_logfile_entry("Embedded tabs in quote or pattern\n")}}sub starting_one_line_block {my ($j,$jmax,$level,$slevel,$ci_level,$rtokens,$rtoken_type,$rblock_type)=@_;destroy_one_line_block();my$i_start=0;if ($max_index_to_go < 0){warning("program bug: store_token_to_go called incorrectly\n");report_definite_bug()}else {if (($tokens_to_go[0]eq '}')&& $rOpts_cuddled_else){return 0}}my$block_type=$$rblock_type[$j];if ($block_type =~ /^[\{\}\;\:]$/ || $block_type =~ /^package/){$i_start=$max_index_to_go}elsif (($last_last_nonblank_token_to_go eq $block_type)|| ($block_type =~ /^sub/)|| $block_type =~ /\(\)/){$i_start=$last_last_nonblank_index_to_go;if ($tokens_to_go[$i_start]eq ')'){my$lev_want=$levels_to_go[$i_start];for ($i_start-- ;$i_start >= 0 ;$i_start-- ){if ($i_start <= 0){return 0}my$lev=$levels_to_go[$i_start];if ($lev <= $lev_want){if ($tokens_to_go[$i_start]ne '('){return 0}$i_start--;if ($i_start > 0 && $types_to_go[$i_start]eq 'b'){$i_start--}}}}}elsif ($last_last_nonblank_token_to_go eq ')'){$i_start=$index_max_forced_break + 1;if ($types_to_go[$i_start]eq 'b'){$i_start++}my$stripped_block_type=$block_type;$stripped_block_type =~ s/\(\)$//;unless ($tokens_to_go[$i_start]eq $stripped_block_type){return 0}}elsif ($block_type eq 'case' || $block_type eq 'when'){$i_start=$index_max_forced_break + 1;if ($types_to_go[$i_start]eq 'b'){$i_start++}unless ($tokens_to_go[$i_start]eq $block_type){return 0}}else {return 1}my$pos=total_line_length($i_start,$max_index_to_go)- 1;my$i;if ($pos > maximum_line_length($i_start)){return 1}for ($i=$j + 1 ;$i <= $jmax ;$i++ ){if ($$rtoken_type[$i]eq 'b'){$pos += 1}else {$pos += rtoken_length($i)}if ($pos > maximum_line_length($i_start)){return 0}elsif ($$rtokens[$i]eq '{' && $$rtoken_type[$i]eq '{' && $$rblock_type[$i]){return 0}elsif ($$rtokens[$i]eq '}' && $$rtoken_type[$i]eq '}' && $$rblock_type[$i]){my$i_nonblank=($$rtoken_type[$i + 1 ]eq 'b')? $i + 2 : $i + 1;if ($$rtoken_type[$i_nonblank]eq '#' &&!$is_sort_map_grep{$block_type}){$pos += rtoken_length($i_nonblank);if ($i_nonblank > $i + 1){if ($$rtoken_type[$i + 1 ]eq 'b'){$pos += 1}else {$pos += rtoken_length($i + 1)}}if ($pos >= maximum_line_length($i_start)){return 0}}create_one_line_block($i_start,20);return 0}else {}}if ($is_sort_map_grep_eval{$block_type}){create_one_line_block($i_start,1)}return 0}sub unstore_token_to_go {if ($max_index_to_go > 0){$max_index_to_go--}else {$max_index_to_go=UNDEFINED_INDEX}}sub want_blank_line {flush();$file_writer_object->want_blank_line()unless$in_format_skipping_section}sub write_unindented_line {flush();$file_writer_object->write_line($_[0])}sub undo_ci {my ($ri_first,$ri_last)=@_;my ($line_1,$line_2,$lev_last);my$this_line_is_semicolon_terminated;my$max_line=@$ri_first - 1;for my$line (0 .. $max_line){my$ibeg=$$ri_first[$line];my$lev=$levels_to_go[$ibeg];if ($line > 0){if ($line_1){if ($lev==$lev_last){if ($types_to_go[$ibeg]eq 'k' && $is_sort_map_grep{$tokens_to_go[$ibeg]}){if ($line==$max_line){my$iend=$$ri_last[$line];$this_line_is_semicolon_terminated=$types_to_go[$iend]eq ';' || ($types_to_go[$iend]eq '#' && $iend - $ibeg >= 2 && $types_to_go[$iend - 2 ]eq ';' && $types_to_go[$iend - 1 ]eq 'b')}$line_2=$line if ($this_line_is_semicolon_terminated)}else {$line_1=undef}}elsif ($lev < $lev_last){$line_2=$line - 1}elsif ($lev > $lev_last){$line_1=undef}if (defined($line_2)&& defined($line_1)){my$continuation_line_count=$line_2 - $line_1 + 1;@ci_levels_to_go[@$ri_first[$line_1 .. $line_2 ]]=(0)x ($continuation_line_count);@leading_spaces_to_go[@$ri_first[$line_1 .. $line_2 ]]=@reduced_spaces_to_go[@$ri_first[$line_1 .. $line_2 ]];$line_1=undef}}else {if ($lev > $lev_last){if ($types_to_go[$ibeg]eq 'k' && $is_sort_map_grep{$tokens_to_go[$ibeg]}){$line_1=$line}}}}$lev_last=$lev}}sub undo_lp_ci {my ($line_open,$i_start,$closing_index,$ri_first,$ri_last)=@_;my$max_line=@$ri_first - 1;return unless$max_line > $line_open;my$lev_start=$levels_to_go[$i_start];my$ci_start_plus=1 + $ci_levels_to_go[$i_start];my$n;my$line_1=1 + $line_open;for ($n=$line_1 ;$n <= $max_line ;++$n ){my$ibeg=$$ri_first[$n];my$iend=$$ri_last[$n];if ($ibeg eq $closing_index){$n--;last}return if ($lev_start!=$levels_to_go[$ibeg]);return if ($ci_start_plus!=$ci_levels_to_go[$ibeg]);last if ($closing_index <= $iend)}my$continuation_line_count=$n - $line_open;@ci_levels_to_go[@$ri_first[$line_1 .. $n ]]=(0)x ($continuation_line_count);@leading_spaces_to_go[@$ri_first[$line_1 .. $n ]]=@reduced_spaces_to_go[@$ri_first[$line_1 .. $n ]]}sub pad_token {my ($ipad,$pad_spaces)=@_;if ($pad_spaces > 0){$tokens_to_go[$ipad]=' ' x $pad_spaces .$tokens_to_go[$ipad]}elsif ($pad_spaces==-1 && $tokens_to_go[$ipad]eq ' '){$tokens_to_go[$ipad]=""}else {return}$token_lengths_to_go[$ipad]+= $pad_spaces;for (my$i=$ipad ;$i <= $max_index_to_go ;$i++ ){$summed_lengths_to_go[$i + 1 ]+= $pad_spaces}}{my%is_math_op;BEGIN {@_=qw(+ - * /);@is_math_op{@_}=(1)x scalar(@_)}sub set_logical_padding {my ($ri_first,$ri_last)=@_;my$max_line=@$ri_first - 1;my ($ibeg,$ibeg_next,$ibegm,$iend,$iendm,$ipad,$line,$pad_spaces,$tok_next,$type_next,$has_leading_op_next,$has_leading_op);for$line (0 .. $max_line - 1){$ibeg=$$ri_first[$line];$iend=$$ri_last[$line];$ibeg_next=$$ri_first[$line + 1 ];$tok_next=$tokens_to_go[$ibeg_next];$type_next=$types_to_go[$ibeg_next];$has_leading_op_next=($tok_next =~ /^\w/)? $is_chain_operator{$tok_next}: $is_chain_operator{$type_next};next unless ($has_leading_op_next);next if ($nesting_depth_to_go[$ibeg]> $nesting_depth_to_go[$ibeg_next]);$ipad=undef;if ($nesting_depth_to_go[$ibeg]==$nesting_depth_to_go[$ibeg_next]){if ($line > 0){next if$has_leading_op;next if ($levels_to_go[$ibeg]ne $levels_to_go[$ibeg_next]);my$ok_comma;if ($types_to_go[$iendm]eq ',' && $line==1 && $max_line > 2){my$ibeg_next_next=$$ri_first[$line + 2 ];my$tok_next_next=$tokens_to_go[$ibeg_next_next];$ok_comma=$tok_next_next eq $tok_next}next unless ($is_assignment{$types_to_go[$iendm]}|| $ok_comma || ($nesting_depth_to_go[$ibegm]< $nesting_depth_to_go[$ibeg])|| ($types_to_go[$iendm]eq 'k' && $tokens_to_go[$iendm]eq 'return'));$ipad=$ibeg}else {next if$starting_in_quote;if ($types_to_go[$ibeg]eq '}'){}else {next if ($nesting_depth_to_go[$ibeg]!=$nesting_depth_to_go[$ibeg_next]);if ($max_line > 1){my$leading_token=$tokens_to_go[$ibeg_next];my$tokens_differ;next if ($leading_token eq '.');my$count=1;for my$l (2 .. 3){last if ($line + $l > $max_line);my$ibeg_next_next=$$ri_first[$line + $l ];if ($tokens_to_go[$ibeg_next_next]ne $leading_token){$tokens_differ=1;last}$count++}next if ($tokens_differ);next if ($count < 3 && $leading_token ne ':');$ipad=$ibeg}else {next}}}}if (!defined($ipad)){for (my$i=$ibeg ;($i < $iend)&&!$ipad ;$i++ ){next unless ($type_sequence_to_go[$i]&& $mate_index_to_go[$i]> $iend);$ipad=$inext_to_go[$i];last if ($ipad > $iend)}last unless$ipad}next if ($ipad==0 && $levels_to_go[$ipad]==0);my$iend_next=$$ri_last[$line + 1 ];next if ($nesting_depth_to_go[$iend_next + 1 ]> $nesting_depth_to_go[$ipad]);my$inext_next=$inext_to_go[$ibeg_next];my$type=$types_to_go[$ipad];my$type_next=$types_to_go[$ipad + 1 ];my$logical_continuation_lines=1;if ($line + 2 <= $max_line){my$leading_token=$tokens_to_go[$ibeg_next];my$ibeg_next_next=$$ri_first[$line + 2 ];if ($tokens_to_go[$ibeg_next_next]eq $leading_token && $nesting_depth_to_go[$ibeg_next]eq $nesting_depth_to_go[$ibeg_next_next]){$logical_continuation_lines++}}my$types_match=$types_to_go[$inext_next]eq $type;my$matches_without_bang;if (!$types_match && $type eq '!'){$types_match=$matches_without_bang=$types_to_go[$inext_next]eq $types_to_go[$ipad + 1 ]}if (($logical_continuation_lines > 1 && $ipad > 0)|| ($types_match &&!($type eq 'k' && $tokens_to_go[$ipad]ne $tokens_to_go[$inext_next]))){my$ok_to_pad=1;my$ibg=$$ri_first[$line + 1 ];my$depth=$nesting_depth_to_go[$ibg + 1 ];my$lsp=$levels_to_go[$ibg]+ $ci_levels_to_go[$ibg];my$l=$line + 1;for$l ($line + 2 .. $max_line){my$ibg=$$ri_first[$l];last if ($nesting_depth_to_go[$ibg + 1 ]< $depth)|| ($nesting_depth_to_go[$ibg]< $depth);if ($levels_to_go[$ibg]+ $ci_levels_to_go[$ibg]< $lsp){$ok_to_pad=0;last}}if ($l==$max_line){my$i2=$$ri_last[$l];if ($types_to_go[$i2]eq '#'){my$i1=$$ri_first[$l];next if (terminal_type(\@types_to_go,\@block_type_to_go,$i1,$i2)eq ',')}}if ($types_to_go[$ibeg_next]eq 'm'){$ok_to_pad=0 if$types_to_go[$ibeg]eq 'Q'}next unless$ok_to_pad;my$length_1=total_line_length($ibeg,$ipad - 1);my$length_2=total_line_length($ibeg_next,$inext_next - 1);$pad_spaces=$length_2 - $length_1;if ($matches_without_bang){$pad_spaces--}my$indentation_1=$leading_spaces_to_go[$ibeg];if (ref($indentation_1)){if ($indentation_1->get_RECOVERABLE_SPACES()==0){my$indentation_2=$leading_spaces_to_go[$ibeg_next];unless ($indentation_2->get_RECOVERABLE_SPACES()==0){$pad_spaces=0}}}if ($pad_spaces < 0){if ($pad_spaces==-1){if ($ipad > $ibeg && $types_to_go[$ipad - 1 ]eq 'b'){pad_token($ipad - 1,$pad_spaces)}}$pad_spaces=0}if ($ipad >= 0 && $pad_spaces){my$length_t=total_line_length($ibeg,$iend);if ($pad_spaces + $length_t <= maximum_line_length($ibeg)){pad_token($ipad,$pad_spaces)}}}}continue {$iendm=$iend;$ibegm=$ibeg;$has_leading_op=$has_leading_op_next}return}}sub correct_lp_indentation {my ($ri_first,$ri_last)=@_;my$do_not_pad=0;my$max_line=@$ri_first - 1;my ($ibeg,$iend);my$line;for$line (0 .. $max_line){$ibeg=$$ri_first[$line];$iend=$$ri_last[$line];my$i;for$i ($ibeg .. $iend){my$indentation=$leading_spaces_to_go[$i];if (!$indentation->get_MARKED()){$indentation->set_MARKED(1);next unless ($indentation->get_ALIGN_PAREN());if ($i > $ibeg){my$im=max($ibeg,$iprev_to_go[$i]);if ($type_sequence_to_go[$im]&& $mate_index_to_go[$im]<= $iend){next}}if ($line==1 && $i==$ibeg){$do_not_pad=1}my$actual_pos;my$predicted_pos=$indentation->get_SPACES();if ($i > $ibeg){$actual_pos=total_line_length($ibeg,$i - 1);my$closing_index=$indentation->get_CLOSED();if ($closing_index > $iend){my$ibeg_next=$$ri_first[$line + 1 ];if ($ci_levels_to_go[$ibeg_next]> 0){undo_lp_ci($line,$i,$closing_index,$ri_first,$ri_last)}}}elsif ($line > 0){my$ibegm=$$ri_first[$line - 1 ];my$iendm=$$ri_last[$line - 1 ];$actual_pos=total_line_length($ibegm,$iendm);++$actual_pos if ($types_to_go[$iendm + 1 ]eq 'b')}else {$actual_pos=$predicted_pos}my$move_right=$actual_pos - $predicted_pos;if ($move_right==0){$indentation->set_RECOVERABLE_SPACES($move_right);next}my$closing_index=$indentation->get_CLOSED();if ($closing_index < 0){$indentation->set_RECOVERABLE_SPACES($move_right);next}my$right_margin=0;my$have_child=$indentation->get_HAVE_CHILD();my%saw_indentation;my$line_count=1;$saw_indentation{$indentation}=$indentation;if ($have_child || $move_right > 0){$have_child=0;my$max_length=0;if ($i==$ibeg){$max_length=total_line_length($ibeg,$iend)}my$line_t;for$line_t ($line + 1 .. $max_line){my$ibeg_t=$$ri_first[$line_t];my$iend_t=$$ri_last[$line_t];last if ($closing_index <= $ibeg_t);my$indentation_t=$leading_spaces_to_go[$ibeg_t];$saw_indentation{$indentation_t}=$indentation_t;$line_count++;my$length_t=total_line_length($ibeg_t,$iend_t);if ($length_t > $max_length){$max_length=$length_t}}$right_margin=maximum_line_length($ibeg)- $max_length;if ($right_margin < 0){$right_margin=0}}my$first_line_comma_count=grep {$_ eq ','}@types_to_go[$ibeg .. $iend ];my$comma_count=$indentation->get_COMMA_COUNT();my$arrow_count=$indentation->get_ARROW_COUNT();my$indentation_count=keys%saw_indentation;my$is_vertically_aligned=($i==$ibeg && $first_line_comma_count > 1 && $indentation_count==1 && ($arrow_count==0 || $arrow_count==$line_count));if ($move_right < 0 || ($comma_count==0)|| ($comma_count > 0 &&!$is_vertically_aligned)){my$move=($move_right <= $right_margin)? $move_right : $right_margin;for (keys%saw_indentation){$saw_indentation{$_}->permanently_decrease_AVAILABLE_SPACES(-$move)}}else {$indentation->set_RECOVERABLE_SPACES($move_right)}}}}return$do_not_pad}sub flush {destroy_one_line_block();output_line_to_go();Perl::Tidy::VerticalAligner::flush()}sub reset_block_text_accumulator {if ($accumulating_text_for_block){if ($accumulating_text_for_block =~ /^(if|elsif)$/){push @{$rleading_block_if_elsif_text},$leading_block_text}}$accumulating_text_for_block="";$leading_block_text="";$leading_block_text_level=0;$leading_block_text_length_exceeded=0;$leading_block_text_line_number=0;$leading_block_text_line_length=0}sub set_block_text_accumulator {my$i=shift;$accumulating_text_for_block=$tokens_to_go[$i];if ($accumulating_text_for_block !~ /^els/){$rleading_block_if_elsif_text=[]}$leading_block_text="";$leading_block_text_level=$levels_to_go[$i];$leading_block_text_line_number=$vertical_aligner_object->get_output_line_number();$leading_block_text_length_exceeded=0;$leading_block_text_line_length=length($csc_last_label)+ length($accumulating_text_for_block)+ length($rOpts->{'closing-side-comment-prefix'})+ $leading_block_text_level * $rOpts_indent_columns + 3}sub accumulate_block_text {my$i=shift;if ($accumulating_text_for_block &&!$leading_block_text_length_exceeded && $types_to_go[$i]ne '#'){my$added_length=$token_lengths_to_go[$i];$added_length += 1 if$i==0;my$new_line_length=$leading_block_text_line_length + $added_length;if (length($leading_block_text)< $rOpts_closing_side_comment_maximum_text && ($new_line_length < maximum_line_length_for_level($leading_block_text_level)|| length($leading_block_text)+ $added_length < $rOpts_closing_side_comment_maximum_text)|| ($tokens_to_go[$i]eq ')' && (($i + 1 <= $max_index_to_go && $block_type_to_go[$i + 1 ]eq $accumulating_text_for_block)|| ($i + 2 <= $max_index_to_go && $block_type_to_go[$i + 2 ]eq $accumulating_text_for_block)))){if ($i==0){$leading_block_text .= ' '}$leading_block_text .= $tokens_to_go[$i];$leading_block_text_line_length=$new_line_length}elsif ($types_to_go[$i]ne 'b'){$leading_block_text_length_exceeded=1;$leading_block_text .= '...'}}}{my%is_if_elsif_else_unless_while_until_for_foreach;BEGIN {@_=qw(if elsif else unless while until for foreach case when);@is_if_elsif_else_unless_while_until_for_foreach{@_}=(1)x scalar(@_)}sub accumulate_csc_text {my$block_leading_text="";my$rblock_leading_if_elsif_text;my$i_block_leading_text=-1;my$block_line_count=100;my$terminal_type='b';my$i_terminal=0;my$terminal_block_type="";$csc_last_label="" unless ($csc_last_label);if ($types_to_go[0]eq 'J'){$csc_last_label=$tokens_to_go[0]}my$block_label=$csc_last_label;for my$i (0 .. $max_index_to_go){my$type=$types_to_go[$i];my$block_type=$block_type_to_go[$i];my$token=$tokens_to_go[$i];if ($type ne '#' && $type ne 'b'){$terminal_type=$type;$terminal_block_type=$block_type;$i_terminal=$i}my$type_sequence=$type_sequence_to_go[$i];if ($block_type && $type_sequence){if ($token eq '}'){if (defined($block_leading_text{$type_sequence})){($block_leading_text,$rblock_leading_if_elsif_text)=@{$block_leading_text{$type_sequence}};$i_block_leading_text=$i;delete$block_leading_text{$type_sequence};$rleading_block_if_elsif_text=$rblock_leading_if_elsif_text}if (defined($csc_block_label{$type_sequence})){$block_label=$csc_block_label{$type_sequence};delete$csc_block_label{$type_sequence}}if ($accumulating_text_for_block && $levels_to_go[$i]<= $leading_block_text_level){my$lev=$levels_to_go[$i];reset_block_text_accumulator()}if (defined($block_opening_line_number{$type_sequence})){my$output_line_number=$vertical_aligner_object->get_output_line_number();$block_line_count=$output_line_number - $block_opening_line_number{$type_sequence}+ 1;delete$block_opening_line_number{$type_sequence}}else {}}elsif ($token eq '{'){my$line_number=$vertical_aligner_object->get_output_line_number();$block_opening_line_number{$type_sequence}=$line_number;if ($block_type =~ /:$/){$csc_last_label=""}$csc_block_label{$type_sequence}=$csc_last_label;$csc_last_label="";if ($accumulating_text_for_block && $levels_to_go[$i]==$leading_block_text_level){if ($accumulating_text_for_block eq $block_type){$block_leading_text{$type_sequence}=[$leading_block_text,$rleading_block_if_elsif_text ];$block_opening_line_number{$type_sequence}=$leading_block_text_line_number;reset_block_text_accumulator()}else {}}}}if ($type eq 'k' && $csc_new_statement_ok && $is_if_elsif_else_unless_while_until_for_foreach{$token}&& $token =~ /$closing_side_comment_list_pattern/o){set_block_text_accumulator($i)}else {if ($type ne 'b' && $type ne '#' && $type ne 'q'){$csc_new_statement_ok=($block_type || $type eq 'J' || $type eq ';')}if ($type eq ';' && $accumulating_text_for_block && $levels_to_go[$i]==$leading_block_text_level){reset_block_text_accumulator()}else {accumulate_block_text($i)}}}if ($terminal_block_type =~ /^els/ && $rblock_leading_if_elsif_text){$block_leading_text=make_else_csc_text($i_terminal,$terminal_block_type,$block_leading_text,$rblock_leading_if_elsif_text)}$csc_last_label="";if ($terminal_type eq 'J'){$csc_last_label=$tokens_to_go[$i_terminal]}return ($terminal_type,$i_terminal,$i_block_leading_text,$block_leading_text,$block_line_count,$block_label)}}sub make_else_csc_text {my ($i_terminal,$block_type,$block_leading_text,$rif_elsif_text)=@_;my$csc_text=$block_leading_text;if ($block_type eq 'elsif' && $rOpts_closing_side_comment_else_flag==0){return$csc_text}my$count=@{$rif_elsif_text};return$csc_text unless ($count);my$if_text='[ if' .$rif_elsif_text->[0];if ($block_type eq 'else'){$csc_text .= $if_text}if ($rOpts_closing_side_comment_else_flag==0){return$csc_text}my$last_elsif_text="";if ($count > 1){$last_elsif_text=' [elsif' .$rif_elsif_text->[$count - 1 ];if ($count > 2){$last_elsif_text=' [...' .$last_elsif_text}}my$saved_text=$csc_text;if ($block_type eq 'else'){$csc_text .= $last_elsif_text}else {$csc_text .= ' ' .$if_text}if ($rOpts_closing_side_comment_else_flag==2){return$csc_text}my$length=length($csc_text)+ length($block_type)+ length($rOpts->{'closing-side-comment-prefix'})+ $levels_to_go[$i_terminal]* $rOpts_indent_columns + 3;if ($length > maximum_line_length_for_level($leading_block_text_level)){$csc_text=$saved_text}return$csc_text}{my%matching_char;BEGIN {%matching_char=('{'=>'}','('=>')','['=>']','}'=>'{',')'=>'(',']'=>'[',)}sub balance_csc_text {my ($csc)=@_;for (my$pos=length($csc)- 1 ;$pos >= 0 ;$pos-- ){my$char=substr($csc,$pos,1);next unless ($matching_char{$char});my$top=chop($csc);$csc=$csc .$top .$matching_char{$char}unless$top eq $char}return$csc}}sub add_closing_side_comment {my$cscw_block_comment;my ($terminal_type,$i_terminal,$i_block_leading_text,$block_leading_text,$block_line_count,$block_label)=accumulate_csc_text();my$have_side_comment=$i_terminal!=$max_index_to_go;if ($terminal_type eq '}' && (($block_line_count >= $rOpts->{'closing-side-comment-interval'})|| ($have_side_comment && $rOpts->{'closing-side-comment-warnings'}))&& $block_type_to_go[$i_terminal]=~ /$closing_side_comment_list_pattern/o && $block_type_to_go[$i_terminal]ne 'sub' && $mate_index_to_go[$i_terminal]< 0 && (!$have_side_comment || $tokens_to_go[$max_index_to_go]=~ /$closing_side_comment_prefix_pattern/o)){if ($block_label){$block_label .= " "}my$token="$rOpts->{'closing-side-comment-prefix'} $block_label$block_type_to_go[$i_terminal]";if ($i_block_leading_text==$i_terminal){$token .= $block_leading_text}$token=balance_csc_text($token)if$rOpts->{'closing-side-comments-balanced'};$token =~ s/\s*$//;if ($have_side_comment){if ($rOpts->{'closing-side-comment-warnings'}){my$old_csc=$tokens_to_go[$max_index_to_go];my$new_csc=$token;$new_csc =~ s/\s+//g;$old_csc =~ s/\s+//g;$new_csc =~ s/[\]\)\}\s]*$//;$old_csc =~ s/[\]\)\}\s]*$//;$new_csc =~ s/(\.\.\.)$//;my$new_trailing_dots=$1;$old_csc =~ s/(\.\.\.)\s*$//;if ($block_type_to_go[$i_terminal]eq 'else'){if ($old_csc =~ /\[\s*elsif/){$old_csc=$new_csc}}elsif ($block_type_to_go[$i_terminal]eq 'elsif'){if ($old_csc =~ /\[\s*if/){$old_csc=$new_csc}}if (length($new_csc)> length($old_csc)){$new_csc=substr($new_csc,0,length($old_csc))}if (length($new_csc)< length($old_csc)&& $new_trailing_dots){$old_csc=substr($old_csc,0,length($new_csc))}if ($new_csc ne $old_csc){if ($block_line_count < $rOpts->{'closing-side-comment-interval'}){$token=undef}else {warning("perltidy -cscw replaced: $tokens_to_go[$max_index_to_go]\n");my ($day,$month,$year)=(localtime)[3,4,5 ];$year += 1900;$month += 1;$cscw_block_comment="## perltidy -cscw $year-$month-$day: $tokens_to_go[$max_index_to_go]"}}else {if ($block_line_count < $rOpts->{'closing-side-comment-interval'}){$token=undef;unstore_token_to_go()if ($types_to_go[$max_index_to_go]eq '#');unstore_token_to_go()if ($types_to_go[$max_index_to_go]eq 'b')}}}$tokens_to_go[$max_index_to_go]=$token if$token}else {my$type='#';my$block_type='';my$type_sequence='';my$container_environment=$container_environment_to_go[$max_index_to_go];my$level=$levels_to_go[$max_index_to_go];my$slevel=$nesting_depth_to_go[$max_index_to_go];my$no_internal_newlines=0;my$nesting_blocks=$nesting_blocks_to_go[$max_index_to_go];my$ci_level=$ci_levels_to_go[$max_index_to_go];my$in_continued_quote=0;insert_new_token_to_go(' ','b',$slevel,$no_internal_newlines);insert_new_token_to_go($token,$type,$slevel,$no_internal_newlines)}}return$cscw_block_comment}sub previous_nonblank_token {my ($i)=@_;my$name="";my$im=$i - 1;return "" if ($im < 0);if ($types_to_go[$im]eq 'b'){$im--}return "" if ($im < 0);$name=$tokens_to_go[$im];if ($name eq '->'){$im--;if ($im >= 0 && $types_to_go[$im]ne 'b'){$name=$tokens_to_go[$im].$name}}return$name}sub send_lines_to_vertical_aligner {my ($ri_first,$ri_last,$do_not_pad)=@_;my$rindentation_list=[0];set_vertical_alignment_markers($ri_first,$ri_last);my$must_flush=0;if (@$ri_first > 1){if ($types_to_go[0]eq 'k' && $tokens_to_go[0]=~ /^(if|unless)$/){$must_flush=1}}if ($must_flush){Perl::Tidy::VerticalAligner::flush()}undo_ci($ri_first,$ri_last);set_logical_padding($ri_first,$ri_last);my$n_last_line=@$ri_first - 1;my$in_comma_list;for my$n (0 .. $n_last_line){my$ibeg=$$ri_first[$n];my$iend=$$ri_last[$n];my ($rtokens,$rfields,$rpatterns)=make_alignment_patterns($ibeg,$iend);my$ljump=0;if ($n < $n_last_line){my$ibegp=$$ri_first[$n + 1 ];$ljump=$levels_to_go[$ibegp]- $levels_to_go[$iend]}my ($indentation,$lev,$level_end,$terminal_type,$is_semicolon_terminated,$is_outdented_line)=set_adjusted_indentation($ibeg,$iend,$rfields,$rpatterns,$ri_first,$ri_last,$rindentation_list,$ljump);my$outdent_long_lines=(($types_to_go[$ibeg]eq 'Q' && $rOpts->{'outdent-long-quotes'})|| ($types_to_go[$ibeg]eq '#' && $rOpts->{'outdent-long-comments'}&&!$is_static_block_comment));my$level_jump=$nesting_depth_to_go[$iend + 1 ]- $nesting_depth_to_go[$ibeg];my$rvertical_tightness_flags=set_vertical_tightness_flags($n,$n_last_line,$ibeg,$iend,$ri_first,$ri_last);Perl::Tidy::VerticalAligner::flush()if ($is_outdented_line);my$is_terminal_ternary=0;if ($tokens_to_go[$ibeg]eq ':' || $n > 0 && $tokens_to_go[$$ri_last[$n - 1 ]]eq ':'){my$last_leading_type=":";if ($n > 0){my$iprev=$$ri_first[$n - 1 ];$last_leading_type=$types_to_go[$iprev]}if ($terminal_type ne ';' && $n_last_line > $n && $level_end==$lev){my$inext=$$ri_first[$n + 1 ];$level_end=$levels_to_go[$inext];$terminal_type=$types_to_go[$inext]}$is_terminal_ternary=$last_leading_type eq ':' && (($terminal_type eq ';' && $level_end <= $lev)|| ($terminal_type ne ':' && $level_end < $lev))&&!grep /^[\?\:]$/,@types_to_go[$ibeg + 1 .. $iend ]}my$forced_breakpoint=$forced_breakpoint_to_go[$iend];Perl::Tidy::VerticalAligner::valign_input($lev,$level_end,$indentation,$rfields,$rtokens,$rpatterns,$forced_breakpoint_to_go[$iend]|| $in_comma_list,$outdent_long_lines,$is_terminal_ternary,$is_semicolon_terminated,$do_not_pad,$rvertical_tightness_flags,$level_jump,);$in_comma_list=$tokens_to_go[$iend]eq ',' && $forced_breakpoint_to_go[$iend];Perl::Tidy::VerticalAligner::flush()if ($is_outdented_line);$do_not_pad=0;$last_output_short_opening_token =$types_to_go[$iend]=~ /^[\{\(\[L]$/ && ($iend==$ibeg || ($iend - $ibeg <= 2 && $tokens_to_go[$ibeg]!~ /\s+/))&& token_sequence_length($ibeg,$iend)<= 10}save_opening_indentation($ri_first,$ri_last,$rindentation_list)}{my%block_type_map;my%keyword_map;BEGIN {%block_type_map=('unless'=>'if','else'=>'if','elsif'=>'if','when'=>'if','default'=>'if','case'=>'if','sort'=>'map','grep'=>'map',);%keyword_map=('unless'=>'if','else'=>'if','elsif'=>'if','when'=>'given','default'=>'given','case'=>'switch','undef'=>'Q',)}sub make_alignment_patterns {my ($ibeg,$iend)=@_;my@tokens=();my@fields=();my@patterns=();my$i_start=$ibeg;my$i;my$depth=0;my@container_name=("");my@multiple_comma_arrows=(undef);my$j=0;$patterns[0]="";for$i ($ibeg .. $iend){if ($tokens_to_go[$i]eq '('){my$i_mate=$mate_index_to_go[$i];if ($i_mate > $i && $i_mate <= $iend){$depth++;my$seqno=$type_sequence_to_go[$i];my$count=comma_arrow_count($seqno);$multiple_comma_arrows[$depth]=$count && $count > 1;my$name=previous_nonblank_token($i);$name =~ s/^->//;$container_name[$depth]="+" .$name;if ($matching_token_to_go[$i]eq ''){my$len=($i_start==$ibeg)? total_line_length($i_start,$i - 1): token_sequence_length($i_start,$i - 1);$container_name[$depth].= "-" .$len}}}elsif ($tokens_to_go[$i]eq ')'){$depth-- if$depth > 0}if ($i > $i_start && $matching_token_to_go[$i]ne ''){my$tok=my$raw_tok=$matching_token_to_go[$i];if ($raw_tok ne '#'){$tok .= "$nesting_depth_to_go[$i]"}if ($raw_tok eq ',' || $raw_tok eq '=>'){if ($container_name[$depth]){$tok .= $container_name[$depth]}}if ($raw_tok eq '('){my$ci=$ci_levels_to_go[$ibeg];if ($container_name[$depth]=~ /^\+(if|unless)/ && $ci){$tok .= $container_name[$depth]}}if ($raw_tok eq '{' && $block_type_to_go[$i]){my$block_type=$block_type_to_go[$i];$block_type=$block_type_map{$block_type}if (defined($block_type_map{$block_type}));if ($block_type =~ /^sub /){$block_type='sub'}if ($block_type =~ /^[A-Z]+$/){$block_type='BEGIN'}$tok .= $block_type}push(@fields,join('',@tokens_to_go[$i_start .. $i - 1 ]));push(@tokens,$tok);$i_start=$i;$j++;$patterns[$j]=""}if ($types_to_go[$i]ne 'k'){my$type=$types_to_go[$i];if (($i < $iend - 1)&& ($type =~ /^[wnC]$/)){my$next_type=$types_to_go[$i + 1 ];my$i_next_nonblank=(($next_type eq 'b')? $i + 2 : $i + 1);if ($types_to_go[$i_next_nonblank]eq '=>'){$type='Q';if ($patterns[$j]eq 'm'){$patterns[$j]=""}}}if ($type eq 'n'){$type='Q'}if ($type eq '!'){$type=''}$patterns[$j].= $type}else {my$tok=$tokens_to_go[$i];$tok=$keyword_map{$tok}if (defined($keyword_map{$tok}));$patterns[$j].= $tok}}push(@fields,join('',@tokens_to_go[$i_start .. $iend ]));return (\@tokens,\@fields,\@patterns)}}{my@unmatched_opening_indexes_in_this_batch;my@unmatched_closing_indexes_in_this_batch;my%comma_arrow_count;sub is_unbalanced_batch {@unmatched_opening_indexes_in_this_batch + @unmatched_closing_indexes_in_this_batch}sub comma_arrow_count {my$seqno=$_[0];return$comma_arrow_count{$seqno}}sub match_opening_and_closing_tokens {@unmatched_opening_indexes_in_this_batch=();@unmatched_closing_indexes_in_this_batch=();%comma_arrow_count=();my$comma_arrow_count_contained=0;my ($i,$i_mate,$token);for$i (0 .. $max_index_to_go){if ($type_sequence_to_go[$i]){$token=$tokens_to_go[$i];if ($token =~ /^[\(\[\{\?]$/){push@unmatched_opening_indexes_in_this_batch,$i}elsif ($token =~ /^[\)\]\}\:]$/){$i_mate=pop@unmatched_opening_indexes_in_this_batch;if (defined($i_mate)&& $i_mate >= 0){if ($type_sequence_to_go[$i_mate]==$type_sequence_to_go[$i]){$mate_index_to_go[$i]=$i_mate;$mate_index_to_go[$i_mate]=$i;my$seqno=$type_sequence_to_go[$i];if ($comma_arrow_count{$seqno}){$comma_arrow_count_contained += $comma_arrow_count{$seqno}}}else {push@unmatched_opening_indexes_in_this_batch,$i_mate;push@unmatched_closing_indexes_in_this_batch,$i}}else {push@unmatched_closing_indexes_in_this_batch,$i}}}elsif ($tokens_to_go[$i]eq '=>'){if (@unmatched_opening_indexes_in_this_batch){my$j=$unmatched_opening_indexes_in_this_batch[-1];my$seqno=$type_sequence_to_go[$j];$comma_arrow_count{$seqno}++}}}return$comma_arrow_count_contained}sub save_opening_indentation {my ($ri_first,$ri_last,$rindentation_list)=@_;for (@unmatched_closing_indexes_in_this_batch){my$seqno=$type_sequence_to_go[$_];delete$saved_opening_indentation{$seqno}}for (@unmatched_opening_indexes_in_this_batch){my$seqno=$type_sequence_to_go[$_];$saved_opening_indentation{$seqno}=[lookup_opening_indentation($_,$ri_first,$ri_last,$rindentation_list)]}}}sub get_opening_indentation {my ($i_closing,$ri_first,$ri_last,$rindentation_list)=@_;my$i_opening=$mate_index_to_go[$i_closing];my ($indent,$offset,$is_leading,$exists);$exists=1;if ($i_opening >= 0){($indent,$offset,$is_leading)=lookup_opening_indentation($i_opening,$ri_first,$ri_last,$rindentation_list)}else {my$seqno=$type_sequence_to_go[$i_closing];if ($seqno){if ($saved_opening_indentation{$seqno}){($indent,$offset,$is_leading)=@{$saved_opening_indentation{$seqno}}}else {$indent=0;$offset=0;$is_leading=0;$exists=0}}else {$indent=0;$offset=0;$is_leading=0;$exists=0}}return ($indent,$offset,$is_leading,$exists)}sub lookup_opening_indentation {my ($i_opening,$ri_start,$ri_last,$rindentation_list)=@_;my$nline=$rindentation_list->[0];$nline=0 if ($i_opening < $ri_start->[$nline]);unless ($i_opening > $ri_last->[-1]){while ($i_opening > $ri_last->[$nline]){$nline++}}else {warning("non-fatal program bug in lookup_opening_indentation - index out of range\n");report_definite_bug();$nline=$#{$ri_last}}$rindentation_list->[0]=$nline;my$ibeg=$ri_start->[$nline];my$offset=token_sequence_length($ibeg,$i_opening)- 1;my$is_leading=($ibeg==$i_opening);return ($rindentation_list->[$nline + 1 ],$offset,$is_leading)}{my%is_if_elsif_else_unless_while_until_for_foreach;BEGIN {@_=qw(if elsif else unless while until for foreach case when);@is_if_elsif_else_unless_while_until_for_foreach{@_}=(1)x scalar(@_)}sub set_adjusted_indentation {my ($ibeg,$iend,$rfields,$rpatterns,$ri_first,$ri_last,$rindentation_list,$level_jump)=@_;my ($terminal_type,$i_terminal)=terminal_type(\@types_to_go,\@block_type_to_go,$ibeg,$iend);my$is_outdented_line=0;my$is_semicolon_terminated=$terminal_type eq ';' && $nesting_depth_to_go[$iend]< $nesting_depth_to_go[$ibeg];my$adjust_indentation=0;my$default_adjust_indentation=$adjust_indentation;my ($opening_indentation,$opening_offset,$is_leading,$opening_exists);if ($types_to_go[$ibeg]=~ /^[\)\}\]R]$/){($opening_indentation,$opening_offset,$is_leading,$opening_exists)=get_opening_indentation($ibeg,$ri_first,$ri_last,$rindentation_list);if ($is_semicolon_terminated || ($terminal_type eq '(' && $types_to_go[$ibeg]eq ')' && ($nesting_depth_to_go[$iend]+ 1==$nesting_depth_to_go[$ibeg]))|| ($level_jump < 0 &&!$some_closing_token_indentation)){$adjust_indentation=1}if ($terminal_type eq ',' && $i_terminal==$ibeg + 1 && $container_environment_to_go[$i_terminal]eq 'LIST'){$adjust_indentation=1}if ($types_to_go[$i_terminal]=~ /^[\}\]\)R]$/ && $i_terminal==$ibeg){my$ci=$ci_levels_to_go[$ibeg];my$lev=$levels_to_go[$ibeg];my$next_type=$types_to_go[$ibeg + 1 ];my$i_next_nonblank=(($next_type eq 'b')? $ibeg + 2 : $ibeg + 1);if ($i_next_nonblank <= $max_index_to_go && $levels_to_go[$i_next_nonblank]< $lev){$adjust_indentation=1}if ($block_type_to_go[$ibeg]=~ /^sub\s*\(?/ && $container_environment_to_go[$i_terminal]eq 'LIST' &&!$rOpts->{'indent-closing-brace'}){($opening_indentation,$opening_offset,$is_leading,$opening_exists)=get_opening_indentation($ibeg,$ri_first,$ri_last,$rindentation_list);my$indentation=$leading_spaces_to_go[$ibeg];if (defined($opening_indentation)&& get_SPACES($indentation)> get_SPACES($opening_indentation)){$adjust_indentation=1}}}if ($block_type_to_go[$ibeg]eq 'eval' &&!$rOpts->{'line-up-parentheses'}&&!$rOpts->{'indent-closing-brace'}){($opening_indentation,$opening_offset,$is_leading,$opening_exists)=get_opening_indentation($ibeg,$ri_first,$ri_last,$rindentation_list);my$indentation=$leading_spaces_to_go[$ibeg];if (defined($opening_indentation)&& get_SPACES($indentation)> get_SPACES($opening_indentation)){$adjust_indentation=1}}$default_adjust_indentation=$adjust_indentation;if (!$block_type_to_go[$ibeg]){my$cti=$closing_token_indentation{$tokens_to_go[$ibeg]};if ($cti==1){if ($i_terminal <= $ibeg + 1 || $is_semicolon_terminated){$adjust_indentation=2}else {$adjust_indentation=0}}elsif ($cti==2){if ($is_semicolon_terminated){$adjust_indentation=3}else {$adjust_indentation=0}}elsif ($cti==3){$adjust_indentation=3}}else {if ($rOpts->{'indent-closing-brace'}&& ($i_terminal==$ibeg || $is_semicolon_terminated)){$adjust_indentation=3}}}elsif ($$rpatterns[0]=~ /^qb*;$/ && $$rfields[0]=~ /^([\)\}\]\>]);$/){if ($closing_token_indentation{$1}==0){$adjust_indentation=1}else {$adjust_indentation=3}}elsif ($types_to_go[$ibeg]eq ':'){($opening_indentation,$opening_offset,$is_leading,$opening_exists)=get_opening_indentation($ibeg,$ri_first,$ri_last,$rindentation_list);if ($is_leading){$adjust_indentation=2}}my$indentation;my$lev;my$level_end=$levels_to_go[$iend];if ($adjust_indentation==0){$indentation=$leading_spaces_to_go[$ibeg];$lev=$levels_to_go[$ibeg]}elsif ($adjust_indentation==1){$indentation=$reduced_spaces_to_go[$i_terminal];$lev=$levels_to_go[$i_terminal]}elsif ($adjust_indentation==2){$lev=$levels_to_go[$ibeg];my$space_count=get_SPACES($opening_indentation)+ $opening_offset;my$last_spaces=get_SPACES($last_indentation_written);if ($last_leading_token !~ /^[\}\]\)]$/){$last_spaces += get_RECOVERABLE_SPACES($last_indentation_written)}$lev=$levels_to_go[$ibeg];if ($space_count < $last_spaces){if ($rOpts_line_up_parentheses){my$lev=$levels_to_go[$ibeg];$indentation=new_lp_indentation_item($space_count,$lev,0,0,0)}else {$indentation=$space_count}}else {$space_count=leading_spaces_to_go($ibeg);if ($default_adjust_indentation==0){$indentation=$leading_spaces_to_go[$ibeg]}elsif ($default_adjust_indentation==1){$indentation=$reduced_spaces_to_go[$i_terminal];$lev=$levels_to_go[$i_terminal]}}}else {if ($block_type_to_go[$ibeg]&& $ci_levels_to_go[$i_terminal]==0){my$spaces=get_SPACES($leading_spaces_to_go[$i_terminal]);$indentation=$spaces + $rOpts_indent_columns}else {$indentation=$last_unadjusted_indentation;if (get_SPACES($last_indentation_written)< get_SPACES($indentation)){$indentation=$last_indentation_written}}$lev=$levels_to_go[$ibeg]}unless ($ibeg==0 && $starting_in_quote){$last_indentation_written=$indentation;$last_unadjusted_indentation=$leading_spaces_to_go[$ibeg];$last_leading_token=$tokens_to_go[$ibeg]}my$is_isolated_block_brace=$block_type_to_go[$ibeg]&& ($iend==$ibeg || $is_if_elsif_else_unless_while_until_for_foreach{$block_type_to_go[$ibeg]});my$is_unaligned_colon=$types_to_go[$ibeg]eq ':' &&!$is_leading;if (defined($opening_indentation)&&!$is_isolated_block_brace &&!$is_unaligned_colon){if (get_SPACES($opening_indentation)> get_SPACES($indentation)){$indentation=$opening_indentation}}push @{$rindentation_list},$indentation;if ($ibeg==0 && (($rOpts->{'outdent-keywords'}&& $types_to_go[$ibeg]eq 'k' && $outdent_keyword{$tokens_to_go[$ibeg]})|| ($rOpts->{'outdent-labels'}&& $types_to_go[$ibeg]eq 'J')|| ($types_to_go[$ibeg]eq '#' && $rOpts->{'outdent-static-block-comments'}&& $is_static_block_comment))){my$space_count=leading_spaces_to_go($ibeg);if ($space_count > 0){$space_count -= $rOpts_continuation_indentation;$is_outdented_line=1;if ($space_count < 0){$space_count=0}if ($types_to_go[$ibeg]eq '#' && $space_count==0){$space_count=1}if ($rOpts_line_up_parentheses){$indentation=new_lp_indentation_item($space_count,$lev,0,0,0)}else {$indentation=$space_count}}}return ($indentation,$lev,$level_end,$terminal_type,$is_semicolon_terminated,$is_outdented_line)}}sub set_vertical_tightness_flags {my ($n,$n_last_line,$ibeg,$iend,$ri_first,$ri_last)=@_;my$rvertical_tightness_flags=[0,0,0,0,0,0 ];if ($n < $n_last_line){my$ibeg_next=$$ri_first[$n + 1 ];my$token_end=$tokens_to_go[$iend];my$iend_next=$$ri_last[$n + 1 ];if ($type_sequence_to_go[$iend]&&!$block_type_to_go[$iend]&& $is_opening_token{$token_end}&& ($opening_vertical_tightness{$token_end}> 0 || ($rOpts_line_up_parentheses && $token_end eq '(' && $iend > $ibeg && $types_to_go[$iend - 1 ]ne 'b'))){my$ovt=$opening_vertical_tightness{$token_end};my$iend_next=$$ri_last[$n + 1 ];unless ($ovt < 2 && ($nesting_depth_to_go[$iend_next + 1 ]!=$nesting_depth_to_go[$ibeg_next])){my$valid_flag=$ovt;@{$rvertical_tightness_flags}=(1,$ovt,$type_sequence_to_go[$iend],$valid_flag)}}my$token_next=$tokens_to_go[$ibeg_next];if ($type_sequence_to_go[$ibeg_next]&&!$block_type_to_go[$ibeg_next]&& $is_closing_token{$token_next}&& $types_to_go[$iend]!~ '#'){my$ovt=$opening_vertical_tightness{$token_next};my$cvt=$closing_vertical_tightness{$token_next};if (($nesting_depth_to_go[$ibeg_next]==$nesting_depth_to_go[$iend_next + 1 ]+ 1)&& ($cvt==2 || ($container_environment_to_go[$ibeg_next]ne 'LIST' && ($cvt==1 || ($rOpts_line_up_parentheses && $token_next eq ')'))))){my$ok=0;if ($cvt==2 || $iend_next==$ibeg_next){$ok=1}else {my$str=join('',@types_to_go[$ibeg_next + 1 .. $ibeg_next + 2 ]);if ($str =~ /^b?[#;]/){$ok=1}}if ($ok){my$valid_flag=$cvt;@{$rvertical_tightness_flags}=(2,$tightness{$token_next}==2 ? 0 : 1,$type_sequence_to_go[$ibeg_next],$valid_flag,)}}}if ($opening_token_right{$tokens_to_go[$ibeg_next]}&&!$is_opening_token{$token_end}&&!$block_type_to_go[$ibeg_next]&& ($iend_next==$ibeg_next || $iend_next==$ibeg_next + 2 && $types_to_go[$iend_next]eq '#')&& $tokens_to_go[$ibeg]ne $tokens_to_go[$ibeg_next]){my$valid_flag=1;my$spaces=($types_to_go[$ibeg_next - 1 ]eq 'b')? 1 : 0;@{$rvertical_tightness_flags}=(2,$spaces,$type_sequence_to_go[$ibeg_next],$valid_flag,)}my$stackable;my$token_beg_next=$tokens_to_go[$ibeg_next];if ($types_to_go[$ibeg_next]eq 'q'){if ($token_beg_next =~ /^qw\s*([\[\(\{])$/){$token_beg_next=$1}}if ($is_closing_token{$token_end}&& $is_closing_token{$token_beg_next}){$stackable=$stack_closing_token{$token_beg_next}unless ($block_type_to_go[$ibeg_next])}elsif ($is_opening_token{$token_end}&& $is_opening_token{$token_beg_next}){$stackable=$stack_opening_token{$token_beg_next}unless ($block_type_to_go[$ibeg_next])}if ($stackable){my$is_semicolon_terminated;if ($n + 1==$n_last_line){my ($terminal_type,$i_terminal)=terminal_type(\@types_to_go,\@block_type_to_go,$ibeg_next,$iend_next);$is_semicolon_terminated=$terminal_type eq ';' && $nesting_depth_to_go[$iend_next]< $nesting_depth_to_go[$ibeg_next]}if ($is_semicolon_terminated || ($iend_next==$ibeg_next || $iend_next==$ibeg_next + 2 && $types_to_go[$iend_next]eq '#')){my$valid_flag=1;my$spaces=($types_to_go[$ibeg_next - 1 ]eq 'b')? 1 : 0;@{$rvertical_tightness_flags}=(2,$spaces,$type_sequence_to_go[$ibeg_next],$valid_flag,)}}}elsif ($rOpts_block_brace_vertical_tightness && $ibeg eq $iend && $types_to_go[$iend]eq '{' && $block_type_to_go[$iend]=~ /$block_brace_vertical_tightness_pattern/o){@{$rvertical_tightness_flags}=(3,$rOpts_block_brace_vertical_tightness,0,1)}elsif ($rOpts_stack_closing_block_brace && $ibeg eq $iend && $block_type_to_go[$iend]&& $types_to_go[$iend]eq '}'){my$spaces=$rOpts_block_brace_tightness==2 ? 0 : 1;@{$rvertical_tightness_flags}=(4,$spaces,$type_sequence_to_go[$iend],1)}$rvertical_tightness_flags->[4]=get_seqno($ibeg);$rvertical_tightness_flags->[5]=get_seqno($iend);return$rvertical_tightness_flags}sub get_seqno {my ($ii)=@_;my$seqno=$type_sequence_to_go[$ii];if ($types_to_go[$ii]eq 'q'){my$SEQ_QW=-1;if ($ii > 0){$seqno=$SEQ_QW if ($tokens_to_go[$ii]=~ /^qw\s*[\(\{\[]/)}else {if (!$ending_in_quote){$seqno=$SEQ_QW if ($tokens_to_go[$ii]=~ /[\)\}\]]$/)}}}return ($seqno)}{my%is_vertical_alignment_type;my%is_vertical_alignment_keyword;my%is_terminal_alignment_type;BEGIN {@_=qw#= **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= x= { ? : => && || // ~~ !~~#;@is_vertical_alignment_type{@_}=(1)x scalar(@_);@_=qw(&& ||);@is_terminal_alignment_type{@_}=(1)x scalar(@_);@_=qw(if unless and or err for foreach while until);@is_vertical_alignment_keyword{@_}=(1)x scalar(@_)}sub set_vertical_alignment_markers {if (!$rOpts_add_whitespace){for my$i (0 .. $max_index_to_go){$matching_token_to_go[$i]=''}return}my ($ri_first,$ri_last)=@_;my$i_terminal=$max_index_to_go;if ($types_to_go[$i_terminal]eq '#'){if ($i_terminal > 0 && $types_to_go[--$i_terminal ]eq 'b'){if ($i_terminal > 0){--$i_terminal}}}my$last_vertical_alignment_before_index;my$vert_last_nonblank_type;my$vert_last_nonblank_token;my$vert_last_nonblank_block_type;my$max_line=@$ri_first - 1;my ($i,$type,$token,$block_type,$alignment_type);my ($ibeg,$iend,$line);for$line (0 .. $max_line){$ibeg=$$ri_first[$line];$iend=$$ri_last[$line];$last_vertical_alignment_before_index=-1;$vert_last_nonblank_type='';$vert_last_nonblank_token='';$vert_last_nonblank_block_type='';for$i ($ibeg .. $iend){$alignment_type='';$type=$types_to_go[$i];$block_type=$block_type_to_go[$i];$token=$tokens_to_go[$i];if ($matching_token_to_go[$i]){$matching_token_to_go[$i]='';next}if ($i < $ibeg + 2){}elsif ($types_to_go[$i - 1 ]ne 'b'){}elsif ($type eq '#'){unless (($rOpts->{'static-side-comments'}&& $token =~ /$static_side_comment_pattern/o)|| ($vert_last_nonblank_block_type && $token =~ /$closing_side_comment_prefix_pattern/o)){$alignment_type=$type}}elsif ($last_vertical_alignment_before_index==$i - 2){}elsif ($type eq 'k'){if ($is_vertical_alignment_keyword{$token}){$alignment_type=$token}}elsif ($is_vertical_alignment_type{$type}){$alignment_type=$token;if ($i==$iend || $i >= $i_terminal){$alignment_type="" unless ($is_terminal_alignment_type{$type})}if ($i==$ibeg + 2 && $types_to_go[$ibeg]=~ /^[\.\:]$/ && $types_to_go[$i - 1 ]eq 'b'){$alignment_type=""}if ($token eq '(' && $vert_last_nonblank_type eq 'k'){$alignment_type="" unless$vert_last_nonblank_token =~ /^(if|unless|elsif)$/}}if ($alignment_type){$last_vertical_alignment_before_index=$i}if (!$alignment_type && ($i > $ibeg)&& $types_to_go[$i - 1 ]eq 'b' && ($vert_last_nonblank_type =~ /^[\,\;]$/)&& ($type !~ /^[b\#\)\]\}]$/)){$alignment_type=$vert_last_nonblank_type}$matching_token_to_go[$i]=$alignment_type;if ($type ne 'b'){$vert_last_nonblank_type=$type;$vert_last_nonblank_token=$token;$vert_last_nonblank_block_type=$block_type}}}}}sub terminal_type {my ($rtype,$rblock_type,$ibeg,$iend)=@_;if ($$rtype[$ibeg]eq '#'){return wantarray ? ($$rtype[$ibeg],$ibeg): $$rtype[$ibeg]}else {for (my$i=$iend ;$i >= $ibeg ;$i-- ){next if ($$rtype[$i]eq 'b');next if ($$rtype[$i]eq '#');my$terminal_type=$$rtype[$i];if ($terminal_type eq '}' && (!$$rblock_type[$i]|| ($is_sort_map_grep_eval_do{$$rblock_type[$i]}))){$terminal_type='b'}return wantarray ? ($terminal_type,$i): $terminal_type}return wantarray ? (' ',$ibeg): ' '}}{my%is_good_keyword_breakpoint;my%is_lt_gt_le_ge;my%binary_bond_strength;my%nobreak_lhs;my%nobreak_rhs;my@bias_tokens;my$delta_bias;sub bias_table_key {my ($type,$token)=@_;my$bias_table_key=$type;if ($type eq 'k'){$bias_table_key=$token;if ($token eq 'err'){$bias_table_key='or'}}return$bias_table_key}sub set_bond_strengths {BEGIN {@_=qw(if unless while until for foreach);@is_good_keyword_breakpoint{@_}=(1)x scalar(@_);@_=qw(lt gt le ge);@is_lt_gt_le_ge{@_}=(1)x scalar(@_);$left_bond_strength{'Z'}=NO_BREAK;$right_bond_strength{'Z'}=NO_BREAK;$left_bond_strength{'w'}=NO_BREAK;$right_bond_strength{'b'}=NO_BREAK;@_=qw"** .. ... <=>";@left_bond_strength{@_}=(STRONG)x scalar(@_);@right_bond_strength{@_}=(STRONG)x scalar(@_);$left_bond_strength{'=>'}=NO_BREAK;$right_bond_strength{'=>'}=NOMINAL;$left_bond_strength{'J'}=NO_BREAK;$right_bond_strength{'J'}=NOMINAL;$left_bond_strength{'j'}=STRONG;$right_bond_strength{'j'}=STRONG;$left_bond_strength{'A'}=STRONG;$right_bond_strength{'A'}=STRONG;$left_bond_strength{'->'}=STRONG;$right_bond_strength{'->'}=VERY_STRONG;$left_bond_strength{'CORE::'}=NOMINAL;$right_bond_strength{'CORE::'}=NO_BREAK;@_=qw"%";@left_bond_strength{@_}=(STRONG)x scalar(@_);@right_bond_strength{@_}=(0.1 * NOMINAL + 0.9 * STRONG)x scalar(@_);@_=qw"* / x";@left_bond_strength{@_}=(STRONG)x scalar(@_);@right_bond_strength{@_}=(NOMINAL)x scalar(@_);@_=qw"+ -";@left_bond_strength{@_}=(STRONG)x scalar(@_);@right_bond_strength{@_}=(0.91 * NOMINAL + 0.09 * WEAK)x scalar(@_);@_=qw">> <<";@right_bond_strength{@_}=(STRONG)x scalar(@_);@left_bond_strength{@_}=(NOMINAL)x scalar(@_);$right_bond_strength{'.'}=STRONG;$left_bond_strength{'.'}=0.9 * NOMINAL + 0.1 * WEAK;@_=qw"} ] ) R";@left_bond_strength{@_}=(STRONG)x scalar(@_);@right_bond_strength{@_}=(NOMINAL)x scalar(@_);@_=qw"!= == =~ !~ ~~ !~~";@left_bond_strength{@_}=(STRONG)x scalar(@_);@right_bond_strength{@_}=(0.9 * NOMINAL + 0.1 * WEAK)x scalar(@_);@_=qw"< > | & >= <=";@left_bond_strength{@_}=(VERY_STRONG)x scalar(@_);@right_bond_strength{@_}=(0.8 * NOMINAL + 0.2 * WEAK)x scalar(@_);$left_bond_strength{'Q'}=NOMINAL;$right_bond_strength{'Q'}=NOMINAL + 0.02;$left_bond_strength{'q'}=NOMINAL;$right_bond_strength{'q'}=NOMINAL;$left_bond_strength{'k'}=NOMINAL;$right_bond_strength{'k'}=STRONG;$left_bond_strength{'G'}=NOMINAL;$right_bond_strength{'G'}=STRONG;@_=qw(= **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= x=);@left_bond_strength{@_}=(STRONG)x scalar(@_);@right_bond_strength{@_}=(0.4 * WEAK + 0.6 * VERY_WEAK)x scalar(@_);$right_bond_strength{'||'}=NOMINAL;$left_bond_strength{'||'}=$right_bond_strength{'='};$right_bond_strength{'//'}=NOMINAL;$left_bond_strength{'//'}=$right_bond_strength{'='};$right_bond_strength{'&&'}=NOMINAL;$left_bond_strength{'&&'}=$left_bond_strength{'||'}+ 0.1;$left_bond_strength{';'}=VERY_STRONG;$right_bond_strength{';'}=VERY_WEAK;$left_bond_strength{'f'}=VERY_STRONG;$right_bond_strength{'f'}=VERY_WEAK - 0.03;$left_bond_strength{':'}=0.4 * WEAK + 0.6 * NOMINAL;$right_bond_strength{':'}=NO_BREAK;$left_bond_strength{'?'}=$left_bond_strength{':'}+ 0.01;$right_bond_strength{'?'}=NO_BREAK;$left_bond_strength{','}=VERY_STRONG;$right_bond_strength{','}=VERY_WEAK;@_=qw(:: <> ++ --);@left_bond_strength{@_}=(WEAK)x scalar(@_);@right_bond_strength{@_}=(STRONG)x scalar(@_);$left_bond_strength{'and'}=VERY_WEAK - 0.01;$left_bond_strength{'or'}=VERY_WEAK - 0.02;$left_bond_strength{'err'}=VERY_WEAK - 0.02;$left_bond_strength{'xor'}=NOMINAL;$right_bond_strength{'and'}=NOMINAL;$right_bond_strength{'or'}=NOMINAL;$right_bond_strength{'err'}=NOMINAL;$right_bond_strength{'xor'}=STRONG;$binary_bond_strength{'))'}{'{{'}=VERY_WEAK + 0.03;$binary_bond_strength{'(('}{'{{'}=NOMINAL;$binary_bond_strength{'R}'}{'(('}=0.8 * VERY_WEAK + 0.2 * WEAK;$binary_bond_strength{'}}'}{'(('}=0.8 * VERY_WEAK + 0.2 * WEAK;$binary_bond_strength{']]'}{'[['}=0.9 * STRONG + 0.1 * NOMINAL;$binary_bond_strength{']]'}{'L{'}=0.9 * STRONG + 0.1 * NOMINAL;$binary_bond_strength{'R}'}{'[['}=0.9 * STRONG + 0.1 * NOMINAL;$binary_bond_strength{'R}'}{'L{'}=0.9 * STRONG + 0.1 * NOMINAL;$binary_bond_strength{'i'}{'->'}=1.45 * STRONG;$binary_bond_strength{'))'}{'->'}=0.1 * STRONG + 0.9 * NOMINAL;$binary_bond_strength{']]'}{'->'}=0.1 * STRONG + 0.9 * NOMINAL;$binary_bond_strength{'})'}{'->'}=0.1 * STRONG + 0.9 * NOMINAL;$binary_bond_strength{'}]'}{'->'}=0.1 * STRONG + 0.9 * NOMINAL;$binary_bond_strength{'}}'}{'->'}=0.1 * STRONG + 0.9 * NOMINAL;$binary_bond_strength{'R}'}{'->'}=0.1 * STRONG + 0.9 * NOMINAL;$binary_bond_strength{'))'}{'[['}=0.2 * STRONG + 0.8 * NOMINAL;$binary_bond_strength{'})'}{'[['}=0.2 * STRONG + 0.8 * NOMINAL;$binary_bond_strength{'))'}{'{['}=0.2 * STRONG + 0.8 * NOMINAL;$binary_bond_strength{'})'}{'{['}=0.2 * STRONG + 0.8 * NOMINAL;$binary_bond_strength{'C'}{'=>'}=NO_BREAK;$binary_bond_strength{'U'}{'=>'}=NO_BREAK;$binary_bond_strength{'C'}{'(('}=NO_BREAK;$binary_bond_strength{'C'}{'{('}=NO_BREAK;$binary_bond_strength{'U'}{'(('}=NO_BREAK;$binary_bond_strength{'U'}{'{('}=NO_BREAK;$binary_bond_strength{'L{'}{'w'}=NO_BREAK;$binary_bond_strength{'w'}{'R}'}=NO_BREAK;$binary_bond_strength{'w'}{'=>'}=NO_BREAK;$binary_bond_strength{'t'}{'L{'}=NO_BREAK;$binary_bond_strength{'i'}{'L{'}=NO_BREAK;$binary_bond_strength{'(('}{'Y'}=NO_BREAK;$binary_bond_strength{'{('}{'Y'}=NO_BREAK;$binary_bond_strength{'w'}{'(('}=NO_BREAK;$binary_bond_strength{'w'}{'{('}=NO_BREAK;$binary_bond_strength{'}}'}{';'}=NO_BREAK;$nobreak_lhs{'++'}=NO_BREAK;$nobreak_lhs{'Z'}=NO_BREAK;$nobreak_rhs{'F'}=NO_BREAK;$nobreak_rhs{'CORE::'}=NO_BREAK;@bias_tokens=qw(: && || f and or .);$delta_bias=0.0001}$nobreak_to_go[$max_index_to_go]=0;my%bias;@bias{@bias_tokens}=(0)x scalar(@bias_tokens);my$code_bias=-.01;my$type='b';my$token=' ';my$last_type;my$last_nonblank_type=$type;my$last_nonblank_token=$token;my$list_str=$left_bond_strength{'?'};my ($block_type,$i_next,$i_next_nonblank,$next_nonblank_token,$next_nonblank_type,$next_token,$next_type,$total_nesting_depth,);for (my$i=0 ;$i <= $max_index_to_go ;$i++ ){$last_type=$type;if ($type ne 'b'){$last_nonblank_type=$type;$last_nonblank_token=$token}$type=$types_to_go[$i];if ($type eq 'b' && $last_type ne 'b'){$bond_strength_to_go[$i]=$bond_strength_to_go[$i - 1 ];next}$token=$tokens_to_go[$i];$block_type=$block_type_to_go[$i];$i_next=$i + 1;$next_type=$types_to_go[$i_next];$next_token=$tokens_to_go[$i_next];$total_nesting_depth=$nesting_depth_to_go[$i_next];$i_next_nonblank=(($next_type eq 'b')? $i + 2 : $i + 1);$next_nonblank_type=$types_to_go[$i_next_nonblank];$next_nonblank_token=$tokens_to_go[$i_next_nonblank];my$bsr=$right_bond_strength{$type};my$bsl=$left_bond_strength{$next_nonblank_type};if ($type eq 'k' && defined($right_bond_strength{$token})){$bsr=$right_bond_strength{$token}}elsif ($token eq 'ne' or $token eq 'eq'){$bsr=NOMINAL}if ($i_next_nonblank > $max_index_to_go){$bsl=NOMINAL}if ($next_nonblank_type eq 'k' && defined($left_bond_strength{$next_nonblank_token})){$bsl=$left_bond_strength{$next_nonblank_token}}elsif ($next_nonblank_token eq 'ne' or $next_nonblank_token eq 'eq'){$bsl=NOMINAL}elsif ($is_lt_gt_le_ge{$next_nonblank_token}){$bsl=0.9 * NOMINAL + 0.1 * STRONG}if (!defined($bsr)){$bsr=VERY_STRONG}if (!defined($bsl)){$bsl=VERY_STRONG}my$bond_str=($bsr < $bsl)? $bsr : $bsl;my$bond_str_1=$bond_str;if ($type eq '||' || $type eq 'k' && $token eq 'or'){if ($next_nonblank_token =~ /^(die|confess|croak|warn)$/){if ($want_break_before{$token}&& $i > 0){$bond_strength_to_go[$i - 1 ]-= $delta_bias}else {$bond_str -= $delta_bias}}}if ($type eq '}' && $block_type && $next_nonblank_type ne ';'){$bond_str=0.5 * WEAK + 0.5 * VERY_WEAK + $code_bias;$code_bias += $delta_bias}if ($type eq 'k'){if ($next_nonblank_type eq 'k' && $is_last_next_redo_return{$token}){$bond_str=0.45 * WEAK + 0.55 * VERY_WEAK}if ($token eq 'my'){$bond_str=NO_BREAK}}if ($is_if_brace_follower{$next_nonblank_token}){$bond_str=VERY_WEAK}if ($next_nonblank_type eq 'k' && $type ne 'CORE::'){if ($is_keyword_returning_list{$next_nonblank_token}){$bond_str=$list_str if ($bond_str > $list_str)}if ($is_good_keyword_breakpoint{$next_nonblank_token}){$bond_str=VERY_WEAK / 1.05}}elsif ($next_nonblank_type eq '=>'){if ($bond_str < STRONG){$bond_str=STRONG}}if ($token eq '(' && $next_nonblank_type eq 'i' && $last_nonblank_type eq 'k' && $is_sort_map_grep{$last_nonblank_token}){$bond_str=NO_BREAK}if ($last_nonblank_type eq 'F' && $next_nonblank_token eq '('){$bond_str=NO_BREAK}if ($type eq '{'){if ($token eq '(' && $next_nonblank_type eq 'w'){my$i_next_next_nonblank=$i_next_nonblank + 1;my$next_next_type=$types_to_go[$i_next_next_nonblank];if ($next_next_type eq 'b' && $i_next_nonblank < $max_index_to_go){$i_next_next_nonblank++;$next_next_type=$types_to_go[$i_next_next_nonblank]}if (!$old_breakpoint_to_go[$i]&& ($next_next_type eq ',' || $next_next_type eq '}')){$bond_str=NO_BREAK}}}elsif ($type eq 'Z'){if (($next_type ne 'b' && defined($want_left_space{$next_type})&& $want_left_space{$next_type}==WS_NO)|| $next_nonblank_type =~ /^[\/\?]$/){$bond_str=NO_BREAK}}if ($next_nonblank_type eq '?'){$bond_str=NO_BREAK if ($types_to_go[$i_next_nonblank + 1 ]eq 'Q')}elsif ($next_nonblank_type eq '.'){$bond_str=NO_BREAK if ($types_to_go[$i_next_nonblank + 1 ]eq 'n')}if ($rOpts_cuddled_else){if (($token eq 'else')&& ($next_nonblank_type eq '{')|| ($type eq '}')&& ($next_nonblank_token eq 'else')){$bond_str=NO_BREAK}}my$bond_str_2=$bond_str;my$tabulated_bond_str;my$ltype=$type;my$rtype=$next_nonblank_type;if ($token =~ /^[\(\[\{\)\]\}]/){$ltype=$type .$token}if ($next_nonblank_token =~ /^[\(\[\{\)\]\}]/){$rtype=$next_nonblank_type .$next_nonblank_token}if ($binary_bond_strength{$ltype}{$rtype}){$bond_str=$binary_bond_strength{$ltype}{$rtype};$tabulated_bond_str=$bond_str}if ($nobreak_rhs{$ltype}|| $nobreak_lhs{$rtype}){$bond_str=NO_BREAK;$tabulated_bond_str=$bond_str}my$bond_str_3=$bond_str;FORMATTER_DEBUG_FLAG_BOND_TABLES && $tabulated_bond_str && $bond_str_1 && $bond_str_1!=$bond_str_2 && $bond_str_2!=$tabulated_bond_str && do {print STDERR "BOND_TABLES: ltype=$ltype rtype=$rtype $bond_str_1->$bond_str_2->$bond_str_3\n"};my$left_key=bias_table_key($type,$token);my$right_key=bias_table_key($next_nonblank_type,$next_nonblank_token);if ($type eq ','){$bond_str += $bond_strength_to_go[$i]}elsif (defined($bias{$left_key})){if (!$want_break_before{$left_key}){$bias{$left_key}+= $delta_bias;$bond_str += $bias{$left_key}}}if (defined($bias{$right_key})){if ($want_break_before{$right_key}){if ($right_key eq '.'){unless ($last_nonblank_type eq '.' && (length($token)<= $rOpts_short_concatenation_item_length)&& ($token !~ /^[\)\]\}]$/)){$bias{$right_key}+= $delta_bias}}else {$bias{$right_key}+= $delta_bias}$bond_str += $bias{$right_key}}}my$bond_str_4=$bond_str;my$strength;if (defined($bond_str)&&!$nobreak_to_go[$i]){if ($total_nesting_depth > 0){$strength=$bond_str + $total_nesting_depth}else {$strength=$bond_str}}else {$strength=NO_BREAK}if ($type eq '#'){$strength=0}$bond_strength_to_go[$i]=$strength;FORMATTER_DEBUG_FLAG_BOND && do {my$str=substr($token,0,15);$str .= ' ' x (16 - length($str));print STDOUT "BOND:  i=$i $str $type $next_nonblank_type depth=$total_nesting_depth strength=$bond_str_1 -> $bond_str_2 -> $bond_str_3 -> $bond_str_4 $bond_str -> $strength \n"}}}}sub pad_array_to_go {$tokens_to_go[$max_index_to_go + 1 ]='';$tokens_to_go[$max_index_to_go + 2 ]='';$types_to_go[$max_index_to_go + 1 ]='b';$types_to_go[$max_index_to_go + 2 ]='b';$nesting_depth_to_go[$max_index_to_go + 1 ]=$nesting_depth_to_go[$max_index_to_go];if ($is_closing_type{$types_to_go[$max_index_to_go]}){if ($nesting_depth_to_go[$max_index_to_go]<= 0){unless (get_saw_brace_error()){warning("Program bug in scan_list: hit nesting error which should have been caught\n");report_definite_bug()}}else {$nesting_depth_to_go[$max_index_to_go + 1 ]-= 1}}elsif ($is_opening_type{$types_to_go[$max_index_to_go]}){$nesting_depth_to_go[$max_index_to_go + 1 ]+= 1}}{my ($block_type,$current_depth,$depth,$i,$i_last_nonblank_token,$last_colon_sequence_number,$last_nonblank_token,$last_nonblank_type,$last_nonblank_block_type,$last_old_breakpoint_count,$minimum_depth,$next_nonblank_block_type,$next_nonblank_token,$next_nonblank_type,$old_breakpoint_count,$starting_breakpoint_count,$starting_depth,$token,$type,$type_sequence,);my (@breakpoint_stack,@breakpoint_undo_stack,@comma_index,@container_type,@identifier_count_stack,@index_before_arrow,@interrupted_list,@item_count_stack,@last_comma_index,@last_dot_index,@last_nonblank_type,@old_breakpoint_count_stack,@opening_structure_index_stack,@rfor_semicolon_list,@has_old_logical_breakpoints,@rand_or_list,@i_equals,);sub check_for_new_minimum_depth {my$depth=shift;if ($depth < $minimum_depth){$minimum_depth=$depth;$breakpoint_stack[$depth]=$starting_breakpoint_count;$container_type[$depth]="";$identifier_count_stack[$depth]=0;$index_before_arrow[$depth]=-1;$interrupted_list[$depth]=1;$item_count_stack[$depth]=0;$last_nonblank_type[$depth]="";$opening_structure_index_stack[$depth]=-1;$breakpoint_undo_stack[$depth]=undef;$comma_index[$depth]=undef;$last_comma_index[$depth]=undef;$last_dot_index[$depth]=undef;$old_breakpoint_count_stack[$depth]=undef;$has_old_logical_breakpoints[$depth]=0;$rand_or_list[$depth]=[];$rfor_semicolon_list[$depth]=[];$i_equals[$depth]=-1;if (!defined($has_broken_sublist[$depth])){$dont_align[$depth]=0;$has_broken_sublist[$depth]=0;$want_comma_break[$depth]=0}}}sub set_comma_breakpoints {my$dd=shift;my$bp_count=0;my$do_not_break_apart=0;if ($item_count_stack[$dd]){if ($dont_align[$dd]){do_uncontained_comma_breaks($dd)}else {my$fbc=$forced_breakpoint_count;my$must_break_open=$last_nonblank_type[$dd]!~ /^[kwiU]$/;set_comma_breakpoints_do($dd,$opening_structure_index_stack[$dd],$i,$item_count_stack[$dd],$identifier_count_stack[$dd],$comma_index[$dd],$next_nonblank_type,$container_type[$dd],$interrupted_list[$dd],\$do_not_break_apart,$must_break_open,);$bp_count=$forced_breakpoint_count - $fbc;$do_not_break_apart=0 if$must_break_open}}return ($bp_count,$do_not_break_apart)}sub do_uncontained_comma_breaks {my$dd=shift;my$bias=-.01;my$old_comma_break_count=0;for my$ii (@{$comma_index[$dd]}){if ($old_breakpoint_to_go[$ii]){$old_comma_break_count++;$bond_strength_to_go[$ii]=$bias;$bias *= 0.99}}my$i_first_comma=$comma_index[$dd]->[0];if ($old_breakpoint_to_go[$i_first_comma]){my$level_comma=$levels_to_go[$i_first_comma];my$ibreak=-1;my$obp_count=0;for (my$ii=$i_first_comma - 1 ;$ii >= 0 ;$ii -= 1 ){if ($old_breakpoint_to_go[$ii]){$obp_count++;last if ($obp_count > 1);$ibreak=$ii if ($levels_to_go[$ii]==$level_comma)}}if ($ibreak >= 0 && $obp_count==1 && $old_comma_break_count > 0){my$ibreakm=$ibreak;$ibreakm-- if ($types_to_go[$ibreakm]eq 'b');if ($ibreakm >= 0 && $types_to_go[$ibreakm]!~ /^[\(\{\[L]$/){set_forced_breakpoint($ibreak)}}}}my%is_logical_container;BEGIN {@_=qw#if elsif unless while and or err not && | || ? : !#;@is_logical_container{@_}=(1)x scalar(@_)}sub set_for_semicolon_breakpoints {my$dd=shift;for (@{$rfor_semicolon_list[$dd]}){set_forced_breakpoint($_)}}sub set_logical_breakpoints {my$dd=shift;if ($item_count_stack[$dd]==0 && $is_logical_container{$container_type[$dd]}|| $has_old_logical_breakpoints[$dd]){for my$i (0 .. 3){if ($rand_or_list[$dd][$i]){for (@{$rand_or_list[$dd][$i]}){set_forced_breakpoint($_)}for (@{$rand_or_list[$dd][4]}){set_forced_breakpoint($_)}$rand_or_list[$dd]=[];last}}}}sub is_unbreakable_container {my$dd=shift;$is_sort_map_grep{$container_type[$dd]}}sub scan_list {$starting_depth=$nesting_depth_to_go[0];$block_type=' ';$current_depth=$starting_depth;$i=-1;$last_colon_sequence_number=-1;$last_nonblank_token=';';$last_nonblank_type=';';$last_nonblank_block_type=' ';$last_old_breakpoint_count=0;$minimum_depth=$current_depth + 1;$old_breakpoint_count=0;$starting_breakpoint_count=$forced_breakpoint_count;$token=';';$type=';';$type_sequence='';my$total_depth_variation=0;my$i_old_assignment_break;my$depth_last=$starting_depth;check_for_new_minimum_depth($current_depth);my$is_long_line=excess_line_length(0,$max_index_to_go)> 0;my$want_previous_breakpoint=-1;my$saw_good_breakpoint;my$i_line_end=-1;my$i_line_start=-1;while (++$i <= $max_index_to_go){if ($type ne 'b'){$i_last_nonblank_token=$i - 1;$last_nonblank_type=$type;$last_nonblank_token=$token;$last_nonblank_block_type=$block_type}$type=$types_to_go[$i];$block_type=$block_type_to_go[$i];$token=$tokens_to_go[$i];$type_sequence=$type_sequence_to_go[$i];my$next_type=$types_to_go[$i + 1 ];my$next_token=$tokens_to_go[$i + 1 ];my$i_next_nonblank=(($next_type eq 'b')? $i + 2 : $i + 1);$next_nonblank_type=$types_to_go[$i_next_nonblank];$next_nonblank_token=$tokens_to_go[$i_next_nonblank];$next_nonblank_block_type=$block_type_to_go[$i_next_nonblank];if ($want_previous_breakpoint >= 0){set_forced_breakpoint($want_previous_breakpoint);$want_previous_breakpoint=-1}$last_old_breakpoint_count=$old_breakpoint_count;if ($old_breakpoint_to_go[$i]){$i_line_end=$i;$i_line_start=$i_next_nonblank;$old_breakpoint_count++;if ($rOpts_break_at_old_keyword_breakpoints){if ($next_nonblank_type eq 'k' && $is_keyword_returning_list{$next_nonblank_token}&& ($type =~ /^[=\)\]\}Riw]$/ || $type eq 'k' && $is_keyword_returning_list{$token})){$want_previous_breakpoint=$i}}if ($rOpts_break_at_old_attribute_breakpoints){if ($next_nonblank_type eq 'A'){$want_previous_breakpoint=$i}}if ($is_assignment{$type}){$i_old_assignment_break=$i}elsif ($is_assignment{$next_nonblank_type}){$i_old_assignment_break=$i_next_nonblank}}next if ($type eq 'b');$depth=$nesting_depth_to_go[$i + 1 ];$total_depth_variation += abs($depth - $depth_last);$depth_last=$depth;if ($type eq '#'){if ($i!=$max_index_to_go){warning("Non-fatal program bug: backup logic needed to break after a comment\n");report_definite_bug();$nobreak_to_go[$i]=0;set_forced_breakpoint($i)}}if ($type eq 'k' && $i > 0 && $token =~ /^(if|unless|while|until|for)$/ && ($last_nonblank_type ne 'n' || $i > 2)&& $last_nonblank_block_type ne 'do' && ($is_long_line || ($next_nonblank_token eq '(' && $mate_index_to_go[$i_next_nonblank]< $i))){set_forced_breakpoint($i - 1)}if ($type eq '||'){push @{$rand_or_list[$depth][2]},$i;++$has_old_logical_breakpoints[$depth]if (($i==$i_line_start || $i==$i_line_end)&& $rOpts_break_at_old_logical_breakpoints)}elsif ($type eq '&&'){push @{$rand_or_list[$depth][3]},$i;++$has_old_logical_breakpoints[$depth]if (($i==$i_line_start || $i==$i_line_end)&& $rOpts_break_at_old_logical_breakpoints)}elsif ($type eq 'f'){push @{$rfor_semicolon_list[$depth]},$i}elsif ($type eq 'k'){if ($token eq 'and'){push @{$rand_or_list[$depth][1]},$i;++$has_old_logical_breakpoints[$depth]if (($i==$i_line_start || $i==$i_line_end)&& $rOpts_break_at_old_logical_breakpoints)}elsif ($token eq 'or'){push @{$rand_or_list[$depth][0]},$i;++$has_old_logical_breakpoints[$depth]if (($i==$i_line_start || $i==$i_line_end)&& $rOpts_break_at_old_logical_breakpoints);if ($is_logical_container{$container_type[$depth]}){}else {if ($is_long_line){set_forced_breakpoint($i)}elsif (($i==$i_line_start || $i==$i_line_end)&& $rOpts_break_at_old_logical_breakpoints){$saw_good_breakpoint=1}}}elsif ($token eq 'if' || $token eq 'unless'){push @{$rand_or_list[$depth][4]},$i;if (($i==$i_line_start || $i==$i_line_end)&& $rOpts_break_at_old_logical_breakpoints){set_forced_breakpoint($i)}}}elsif ($is_assignment{$type}){$i_equals[$depth]=$i}if ($type_sequence){if ($token =~ /^[\)\]\}\:]$/){if ($type eq ':'){$last_colon_sequence_number=$type_sequence;if (($i==$i_line_start || $i==$i_line_end)&& $rOpts_break_at_old_ternary_breakpoints){set_forced_breakpoint($i);if ($i_equals[$depth]> 0){set_forced_breakpoint($i_equals[$depth]);$i_equals[$depth]=-1}}}if (defined($postponed_breakpoint{$type_sequence})){my$inc=($type eq ':')? 0 : 1;set_forced_breakpoint($i - $inc);delete$postponed_breakpoint{$type_sequence}}}elsif ($token eq '?'){my$i_colon=$mate_index_to_go[$i];if ($i_colon <= 0 || $i==0 || $i==$max_index_to_go){set_forced_breakpoint($i)unless ($type_sequence==($last_colon_sequence_number + TYPE_SEQUENCE_INCREMENT)|| $tokens_to_go[$max_index_to_go]eq '#');set_closing_breakpoint($i)}}}if ($depth > $current_depth){$breakpoint_stack[$depth]=$forced_breakpoint_count;$breakpoint_undo_stack[$depth]=$forced_breakpoint_undo_count;$has_broken_sublist[$depth]=0;$identifier_count_stack[$depth]=0;$index_before_arrow[$depth]=-1;$interrupted_list[$depth]=0;$item_count_stack[$depth]=0;$last_comma_index[$depth]=undef;$last_dot_index[$depth]=undef;$last_nonblank_type[$depth]=$last_nonblank_type;$old_breakpoint_count_stack[$depth]=$old_breakpoint_count;$opening_structure_index_stack[$depth]=$i;$rand_or_list[$depth]=[];$rfor_semicolon_list[$depth]=[];$i_equals[$depth]=-1;$want_comma_break[$depth]=0;$container_type[$depth]=($last_nonblank_type =~ /^(k|=>|&&|\|\||\?|\:|\.)$/)? $last_nonblank_token : "";$has_old_logical_breakpoints[$depth]=0;if ($next_nonblank_type eq 'b' || $next_nonblank_type eq '#'){set_closing_breakpoint($i)}$dont_align[$depth]=($block_type ne "")|| ($type eq '(')&& (($last_nonblank_type eq 'k')|| ($next_nonblank_type eq '('));if ($block_type && ($last_nonblank_token eq ')')&& $mate_index_to_go[$i_last_nonblank_token]< 0 &&!$rOpts->{'opening-brace-always-on-right'}&& ($type eq '{')&& ($token eq '{')){set_forced_breakpoint($i - 1)}}elsif ($depth < $current_depth){check_for_new_minimum_depth($depth);$has_old_logical_breakpoints[$depth]||= $has_old_logical_breakpoints[$current_depth];if ($token eq ')' && $next_nonblank_block_type && $interrupted_list[$current_depth]&& $next_nonblank_type eq '{' &&!$rOpts->{'opening-brace-always-on-right'}){set_forced_breakpoint($i)}my ($bp_count,$do_not_break_apart)=set_comma_breakpoints($current_depth);my$i_opening=$opening_structure_index_stack[$current_depth];my$saw_opening_structure=($i_opening >= 0);my$is_long_term=$bp_count > 0;if (!$is_long_term && $tokens_to_go[$i_opening]=~ /^[\(\{\[]$/ && $index_before_arrow[$depth + 1 ]> 0 &&!$opening_vertical_tightness{$tokens_to_go[$i_opening]}){$is_long_term=$rOpts_comma_arrow_breakpoints==4 || ($rOpts_comma_arrow_breakpoints==0 && $last_nonblank_token eq ',')|| ($rOpts_comma_arrow_breakpoints==5 && $old_breakpoint_to_go[$i_opening])}if (!$is_long_term && $saw_opening_structure){my$i_opening_minus=find_token_starting_list($i_opening);$is_long_term=excess_line_length($i_opening_minus,$i)>= 0}if (($rOpts_comma_arrow_breakpoints!=0)&& ($rOpts_comma_arrow_breakpoints!=4)&& $saw_opening_structure && ($old_breakpoint_count_stack[$current_depth]==$last_old_breakpoint_count || $rOpts_comma_arrow_breakpoints==2)&& ($breakpoint_undo_stack[$current_depth]< $forced_breakpoint_undo_count)&&!$is_long_term){undo_forced_breakpoint_stack($breakpoint_undo_stack[$current_depth])}my$has_comma_breakpoints=($breakpoint_stack[$current_depth]!=$forced_breakpoint_count);$has_broken_sublist[$depth]=$has_broken_sublist[$depth]|| $has_broken_sublist[$current_depth]|| $is_long_term || $has_comma_breakpoints;my$is_simple_logical_expression=0;if ($item_count_stack[$current_depth]==0 && $saw_opening_structure && $tokens_to_go[$i_opening]eq '(' && $is_logical_container{$container_type[$current_depth]}){if (!$has_comma_breakpoints){$is_simple_logical_expression=1}else {set_logical_breakpoints($current_depth)}}if ($is_long_term && @{$rfor_semicolon_list[$current_depth]}){set_for_semicolon_breakpoints($current_depth);$has_comma_breakpoints=1 unless$rOpts_line_up_parentheses}if (!$block_type &&!$is_simple_logical_expression && ($has_comma_breakpoints ||!$saw_opening_structure || ($is_long_term && $container_environment_to_go[$i_opening]ne 'BLOCK'))){if ($rOpts_line_up_parentheses && $saw_opening_structure){my$item=$leading_spaces_to_go[$i_opening + 1 ];if ($i_opening + 1 < $max_index_to_go && $types_to_go[$i_opening + 1 ]eq 'b'){$item=$leading_spaces_to_go[$i_opening + 2 ]}if (defined($item)){my$i_start_2=$item->get_STARTING_INDEX();if (defined($i_start_2)&& $i_start_2 ne $i_opening){my$test1=$nesting_depth_to_go[$i_opening];my$test2=$nesting_depth_to_go[$i_start_2];if ($test2==$test1){set_forced_breakpoint($i_start_2 - 1)}}}}if ($minimum_depth <= $current_depth){set_forced_breakpoint($i_opening)unless ($do_not_break_apart || is_unbreakable_container($current_depth));if ($last_comma_index[$depth]){set_forced_breakpoint($last_comma_index[$depth])}if ($last_dot_index[$depth]){set_forced_breakpoint($last_dot_index[$depth])}if ($i_opening > 2){my$i_prev=($types_to_go[$i_opening - 1 ]eq 'b')? $i_opening - 2 : $i_opening - 1;if ($types_to_go[$i_prev]eq ',' && $types_to_go[$i_prev - 1 ]=~ /^[\)\}]$/){set_forced_breakpoint($i_prev)}elsif ($types_to_go[$i_prev]=~ /^([k\:\?]|&&|\|\|)$/){my$token_prev=$tokens_to_go[$i_prev];if ($want_break_before{$token_prev}){set_forced_breakpoint($i_prev)}}}}if ($next_type eq ','){set_forced_breakpoint($i + 1)}if ($is_assignment{$next_nonblank_type}&& ($breakpoint_stack[$current_depth]!=$forced_breakpoint_count)){set_forced_breakpoint($i)}my$icomma=$last_comma_index[$depth];if (defined($icomma)&& ($i_opening - $icomma)< 5){unless ($forced_breakpoint_to_go[$icomma]){set_forced_breakpoint($icomma)}}}elsif ($is_simple_logical_expression && $has_old_logical_breakpoints[$current_depth]){set_logical_breakpoints($current_depth)}elsif ($is_long_term){set_fake_breakpoint()}}$current_depth=$depth;if ($type eq '=>'){next if ($last_nonblank_type eq '=>');next if$rOpts_break_at_old_comma_breakpoints;next if$rOpts_comma_arrow_breakpoints==3;$want_comma_break[$depth]=1;$index_before_arrow[$depth]=$i_last_nonblank_token;next}elsif ($type eq '.'){$last_dot_index[$depth]=$i}elsif (($type =~ /^[\;\<\>\~]$/ || $is_assignment{$type})&& $container_environment_to_go[$i]ne 'LIST'){$dont_align[$depth]=1;$want_comma_break[$depth]=0;$index_before_arrow[$depth]=-1}next unless ($type eq ',');$last_dot_index[$depth]=undef;$last_comma_index[$depth]=$i;if ($want_comma_break[$depth]){if ($next_nonblank_type =~ /^[\)\}\]R]$/){if ($rOpts_comma_arrow_breakpoints){$want_comma_break[$depth]=0;next}}set_forced_breakpoint($i)unless ($next_nonblank_type eq '#');my$ibreak=$index_before_arrow[$depth]- 1;if ($ibreak > 0 && $tokens_to_go[$ibreak + 1 ]!~ /^[\)\}\]]$/){if ($tokens_to_go[$ibreak]eq '-'){$ibreak--}if ($types_to_go[$ibreak]eq 'b'){$ibreak--}if ($types_to_go[$ibreak]=~ /^[,wiZCUG\(\{\[]$/){if ($tokens_to_go[$ibreak + 1 ]ne '->' && $tokens_to_go[$ibreak + 1 ]ne ','){set_forced_breakpoint($ibreak)}}}$want_comma_break[$depth]=0;$index_before_arrow[$depth]=-1;$interrupted_list[$depth]=1;next}if ($depth < $starting_depth &&!$dont_align[$depth]){set_forced_breakpoint($i)unless ($next_nonblank_type eq '#');next}my$item_count=$item_count_stack[$depth];if ($item_count==0){if (($opening_structure_index_stack[$depth]< 0)&& $container_environment_to_go[$i]eq 'BLOCK'){$dont_align[$depth]=1}}$comma_index[$depth][$item_count]=$i;++$item_count_stack[$depth];if ($last_nonblank_type =~ /^[iR\]]$/){$identifier_count_stack[$depth]++}}for (my$dd=$current_depth ;$dd >= $minimum_depth ;$dd-- ){$interrupted_list[$dd]=1;$has_broken_sublist[$dd]=1 if ($dd < $current_depth);set_comma_breakpoints($dd);set_logical_breakpoints($dd)if ($has_old_logical_breakpoints[$dd]);set_for_semicolon_breakpoints($dd);my$i_opening=$opening_structure_index_stack[$dd];set_forced_breakpoint($i_opening)unless (is_unbreakable_container($dd)|| ($type eq 'Q' && $i_opening >= $max_index_to_go - 2 && $token =~ /^['"]$/))}if ($has_old_logical_breakpoints[$current_depth]){$saw_good_breakpoint=1}elsif ($i_old_assignment_break && $total_depth_variation > 4 && $old_breakpoint_count==1){$saw_good_breakpoint=1}return$saw_good_breakpoint}}sub find_token_starting_list {my$i_opening_paren=shift;my$i_opening_minus=$i_opening_paren;my$im1=$i_opening_paren - 1;my$im2=$i_opening_paren - 2;my$im3=$i_opening_paren - 3;my$typem1=$types_to_go[$im1];my$typem2=$im2 >= 0 ? $types_to_go[$im2]: 'b';if ($typem1 eq ',' || ($typem1 eq 'b' && $typem2 eq ',')){$i_opening_minus=$i_opening_paren}elsif ($tokens_to_go[$i_opening_paren]eq '('){$i_opening_minus=$im1 if$im1 >= 0;for (my$j=$im1 ;$j >= 0 ;$j-- ){last if ($types_to_go[$j]=~ /^[\(\[\{L\}\]\)Rb,]$/);$i_opening_minus=$j}if ($types_to_go[$i_opening_minus]eq 'b'){$i_opening_minus++}}elsif ($typem1 eq 'k'){$i_opening_minus=$im1}elsif ($typem1 eq 'b' && $im2 >= 0 && $types_to_go[$im2]eq 'k'){$i_opening_minus=$im2}return$i_opening_minus}{my%is_keyword_with_special_leading_term;BEGIN {@_=qw(formline grep kill map printf sprintf push chmod join pack unshift);@is_keyword_with_special_leading_term{@_}=(1)x scalar(@_)}sub set_comma_breakpoints_do {my ($depth,$i_opening_paren,$i_closing_paren,$item_count,$identifier_count,$rcomma_index,$next_nonblank_type,$list_type,$interrupted,$rdo_not_break_apart,$must_break_open,)=@_;return if ($item_count < 1);my$i_first_comma=$$rcomma_index[0];my$i_true_last_comma=$$rcomma_index[$item_count - 1 ];my$i_last_comma=$i_true_last_comma;if ($i_last_comma >= $max_index_to_go){$i_last_comma=$$rcomma_index[--$item_count - 1 ];return if ($item_count < 1)}my$comma_count=$item_count;my@item_lengths;my@i_term_begin;my@i_term_end;my@i_term_comma;my$i_prev_plus;my@max_length=(0,0);my$first_term_length;my$i=$i_opening_paren;my$is_odd=1;for (my$j=0 ;$j < $comma_count ;$j++ ){$is_odd=1 - $is_odd;$i_prev_plus=$i + 1;$i=$$rcomma_index[$j];my$i_term_end=($types_to_go[$i - 1 ]eq 'b')? $i - 2 : $i - 1;my$i_term_begin=($types_to_go[$i_prev_plus]eq 'b')? $i_prev_plus + 1 : $i_prev_plus;push@i_term_begin,$i_term_begin;push@i_term_end,$i_term_end;push@i_term_comma,$i;my$length=2 + token_sequence_length($i_term_begin,$i_term_end);push@item_lengths,$length;if ($j==0){$first_term_length=$length}else {if ($length > $max_length[$is_odd]){$max_length[$is_odd]=$length}}}my$i_b=($types_to_go[$i_last_comma + 1 ]eq 'b')? $i_last_comma + 1 : $i_last_comma;my$i_e=($types_to_go[$i_closing_paren - 1 ]eq 'b')? $i_closing_paren - 2 : $i_closing_paren - 1;my$i_effective_last_comma=$i_last_comma;my$last_item_length=token_sequence_length($i_b + 1,$i_e);if ($last_item_length > 0){$last_item_length += 2;push@item_lengths,$last_item_length;push@i_term_begin,$i_b + 1;push@i_term_end,$i_e;push@i_term_comma,undef;my$i_odd=$item_count % 2;if ($last_item_length > $max_length[$i_odd]){$max_length[$i_odd]=$last_item_length}$item_count++;$i_effective_last_comma=$i_e + 1;if ($types_to_go[$i_b + 1 ]=~ /^[iR\]]$/){$identifier_count++}}if ($has_broken_sublist[$depth]){my$small_length=10;my$skipped_count=0;my$columns=table_columns_available($i_first_comma);my$fields=int($columns / $small_length);if ($rOpts_maximum_fields_per_table && $fields > $rOpts_maximum_fields_per_table){$fields=$rOpts_maximum_fields_per_table}my$max_skipped_count=$fields - 1;my$is_simple_last_term=0;my$is_simple_next_term=0;for my$j (0 .. $item_count){$is_simple_last_term=$is_simple_next_term;$is_simple_next_term=0;if ($j < $item_count && $i_term_end[$j]==$i_term_begin[$j]&& $item_lengths[$j]<= $small_length){$is_simple_next_term=1}next if$j==0;if ($is_simple_last_term && $is_simple_next_term && $skipped_count < $max_skipped_count){$skipped_count++}else {$skipped_count=0;my$i=$i_term_comma[$j - 1 ];last unless defined$i;set_forced_breakpoint($i)}}if ($interrupted){set_forced_breakpoint($i_true_last_comma)}return}if ($rOpts_break_at_old_comma_breakpoints || $interrupted || $i_opening_paren < 0){copy_old_breakpoints($i_first_comma,$i_true_last_comma);return}my$opening_token=$tokens_to_go[$i_opening_paren];my$opening_environment=$container_environment_to_go[$i_opening_paren];my$i_opening_minus=find_token_starting_list($i_opening_paren);return unless excess_line_length($i_opening_minus,$i_closing_paren)> 0;set_fake_breakpoint();if ($i_effective_last_comma >= $max_index_to_go){$i_effective_last_comma=$max_index_to_go - 1}my$need_lp_break_open=$must_break_open;if ($rOpts_line_up_parentheses &&!$must_break_open){my$columns_if_unbroken=maximum_line_length($i_opening_minus)- total_line_length($i_opening_minus,$i_opening_paren);$need_lp_break_open=($max_length[0]> $columns_if_unbroken)|| ($max_length[1]> $columns_if_unbroken)|| ($first_term_length > $columns_if_unbroken)}my$odd_or_even=2;if ($identifier_count >= $item_count - 1 || $is_assignment{$next_nonblank_type}|| ($list_type && $list_type ne '=>' && $list_type !~ /^[\:\?]$/)){$odd_or_even=1}my$use_separate_first_term=($odd_or_even==1 && $item_count > 3 && $first_term_length > 2 * $max_length[0]- 2 && $first_term_length > 2 * $max_length[1]- 2);if (!$use_separate_first_term){if ($is_keyword_with_special_leading_term{$list_type}){$use_separate_first_term=1;if ($item_count < 3){if ($i_first_comma - $i_opening_paren < 4){$$rdo_not_break_apart=1}}elsif ($first_term_length < 20 && $i_first_comma - $i_opening_paren < 4){my$columns=table_columns_available($i_first_comma);if ($first_term_length < $columns){$$rdo_not_break_apart=1}}}}if ($use_separate_first_term){$use_separate_first_term=1;set_forced_breakpoint($i_first_comma);$i_opening_paren=$i_first_comma;$i_first_comma=$$rcomma_index[1];$item_count--;return if$comma_count==1;shift@item_lengths;shift@i_term_begin;shift@i_term_end;shift@i_term_comma}else {if ($first_term_length > $max_length[0]){$max_length[0]=$first_term_length}}my$pair_width=($max_length[0]+ $max_length[1]);my$max_width=($max_length[0]> $max_length[1])? $max_length[0]: $max_length[1];my$columns=table_columns_available($i_first_comma);my$number_of_fields_max=maximum_number_of_fields($columns,$odd_or_even,$max_width,$pair_width);my$number_of_fields=$number_of_fields_max;my ($number_of_fields_best,$ri_ragged_break_list,$new_identifier_count)=study_list_complexity(\@i_term_begin,\@i_term_end,\@item_lengths,$max_width);if ($number_of_fields_best!=0 && $number_of_fields_best < $number_of_fields_max){$number_of_fields=$number_of_fields_best}if ($rOpts_line_up_parentheses && ($number_of_fields==0 || ($number_of_fields==1 && $number_of_fields!=$number_of_fields_best))){my$available_spaces=get_AVAILABLE_SPACES_to_go($i_first_comma);if ($available_spaces > 0){my$spaces_wanted=$max_width - $columns;if ($number_of_fields_best==0){$number_of_fields_best=get_maximum_fields_wanted(\@item_lengths)}if ($number_of_fields_best!=1){my$spaces_wanted_2=1 + $pair_width - $columns;if ($available_spaces > $spaces_wanted_2){$spaces_wanted=$spaces_wanted_2}}if ($spaces_wanted > 0){my$deleted_spaces=reduce_lp_indentation($i_first_comma,$spaces_wanted);if ($deleted_spaces > 0){$columns=table_columns_available($i_first_comma);$number_of_fields_max=maximum_number_of_fields($columns,$odd_or_even,$max_width,$pair_width);$number_of_fields=$number_of_fields_max;if ($number_of_fields_best==1 && $number_of_fields >= 1){$number_of_fields=$number_of_fields_best}}}}}if ($number_of_fields <= 0){$number_of_fields=int($columns / $max_width)}if ($rOpts_maximum_fields_per_table && $number_of_fields > $rOpts_maximum_fields_per_table){$number_of_fields=$rOpts_maximum_fields_per_table}my$packed_columns=token_sequence_length($i_opening_paren + 1,$i_effective_last_comma + 1);if ($columns <= 0){$columns=1}my$packed_lines=1 + int($packed_columns / $columns);my$in_hierarchical_list=$next_nonblank_type =~ /^[\}\,]$/;if ($number_of_fields <= 0){my$i_last_comma=$$rcomma_index[$comma_count - 1 ];my$long_last_term=excess_line_length(0,$i_last_comma)<= 0;my$long_first_term=excess_line_length($i_first_comma + 1,$max_index_to_go)<= 0;if ($number_of_fields_best==1 || $in_hierarchical_list || ($comma_count > 1 &&!($long_last_term || $long_first_term))){for (0 .. $comma_count - 1){set_forced_breakpoint($$rcomma_index[$_])}}elsif ($long_last_term){set_forced_breakpoint($i_last_comma);$$rdo_not_break_apart=1 unless$must_break_open}elsif ($long_first_term){set_forced_breakpoint($i_first_comma)}else {}return}my$formatted_lines=$item_count / ($number_of_fields);if ($formatted_lines!=int$formatted_lines){$formatted_lines=1 + int$formatted_lines}$number_of_fields=compactify_table($item_count,$number_of_fields,$formatted_lines,$odd_or_even);my$columns_per_line=(int$number_of_fields / 2)* $pair_width + ($number_of_fields % 2)* $max_width;my$formatted_columns;if ($number_of_fields > 1){$formatted_columns=($pair_width * (int($item_count / 2))+ ($item_count % 2)* $max_width)}else {$formatted_columns=$max_width * $item_count}if ($formatted_columns < $packed_columns){$formatted_columns=$packed_columns}my$unused_columns=$formatted_columns - $packed_columns;my$sparsity=($unused_columns)/ ($formatted_columns);my$max_allowed_sparsity=($item_count < 3)? 0.1 : ($packed_lines==1)? 0.15 : ($packed_lines==2)? 0.4 : 0.7;if ($packed_lines <= 2 && $item_count < 9 && $opening_environment eq 'BLOCK' && $opening_token eq '('){if ($rOpts_line_up_parentheses && $item_count==2 &&!$must_break_open){my$i_break=$$rcomma_index[0];set_forced_breakpoint($i_break);$$rdo_not_break_apart=1;set_non_alignment_flags($comma_count,$rcomma_index);return}if (($number_of_fields==2 && $item_count==3)|| ($new_identifier_count > 0 && $sparsity > 0.15)){my$break_count=set_ragged_breakpoints(\@i_term_comma,$ri_ragged_break_list);++$break_count if ($use_separate_first_term);unless ($must_break_open){if ($break_count <= 1){$$rdo_not_break_apart=1}elsif ($rOpts_line_up_parentheses &&!$need_lp_break_open){$$rdo_not_break_apart=1}}set_non_alignment_flags($comma_count,$rcomma_index);return}}FORMATTER_DEBUG_FLAG_SPARSE && do {print STDOUT "SPARSE:cols=$columns commas=$comma_count items:$item_count ids=$identifier_count pairwidth=$pair_width fields=$number_of_fields lines packed: $packed_lines packed_cols=$packed_columns fmtd:$formatted_lines cols /line:$columns_per_line  unused:$unused_columns fmtd:$formatted_columns sparsity=$sparsity allow=$max_allowed_sparsity\n"};my$total_columns=table_columns_available($i_opening_paren);my$too_long=$packed_columns > $total_columns;if (!$too_long && $i_opening_paren > 0 && $opening_token eq '('){$too_long=excess_line_length($i_opening_minus,$i_effective_last_comma + 1)> 0}if (!$too_long && $i_opening_paren > 0 && $list_type eq '=>'){my$i_opening_minus=$i_opening_paren - 4;if ($i_opening_minus >= 0){$too_long=excess_line_length($i_opening_minus,$i_effective_last_comma + 1)> 0}}my$must_break_open_container=$must_break_open || ($too_long && ($in_hierarchical_list || $opening_token ne '('));if (($formatted_lines < 3 && $packed_lines < $formatted_lines)|| ($formatted_lines < 2)|| ($unused_columns > $max_allowed_sparsity * $formatted_columns)){if ($packed_lines > 2 && $item_count > 10){write_logfile_entry("List sparse: using old breakpoints\n");copy_old_breakpoints($i_first_comma,$i_last_comma)}else {my$break_count=set_ragged_breakpoints(\@i_term_comma,$ri_ragged_break_list);++$break_count if ($use_separate_first_term);unless ($must_break_open_container){if ($break_count <= 1){$$rdo_not_break_apart=1}elsif ($rOpts_line_up_parentheses &&!$need_lp_break_open){$$rdo_not_break_apart=1}}set_non_alignment_flags($comma_count,$rcomma_index)}return}write_logfile_entry("List: auto formatting with $number_of_fields fields/row\n");my$j_first_break=$use_separate_first_term ? $number_of_fields : $number_of_fields - 1;for (my$j=$j_first_break ;$j < $comma_count ;$j += $number_of_fields ){my$i=$$rcomma_index[$j];set_forced_breakpoint($i)}return}}sub set_non_alignment_flags {my ($comma_count,$rcomma_index)=@_;for (0 .. $comma_count - 1){$matching_token_to_go[$$rcomma_index[$_]]=1}}sub study_list_complexity {my ($ri_term_begin,$ri_term_end,$ritem_lengths,$max_width)=@_;my$item_count=@{$ri_term_begin};my$complex_item_count=0;my$number_of_fields_best=$rOpts_maximum_fields_per_table;my$i_max=@{$ritem_lengths}- 1;my$i_last_last_break=-3;my$i_last_break=-2;my@i_ragged_break_list;my$definitely_complex=30;my$definitely_simple=12;my$quote_count=0;for my$i (0 .. $i_max){my$ib=$ri_term_begin->[$i];my$ie=$ri_term_end->[$i];my$weighted_length=($ritem_lengths->[$i]- 2);my$is_quote=0;if ($types_to_go[$ib]=~ /^[qQ]$/){$is_quote=1;$quote_count++}elsif ($types_to_go[$ib]=~ /^[w\-]$/){$quote_count++}if ($ib eq $ie){if ($is_quote && $tokens_to_go[$ib]=~ /\s/){$complex_item_count++;$weighted_length *= 2}else {}}else {if (grep {$_ eq 'b'}@types_to_go[$ib .. $ie ]){$complex_item_count++;$weighted_length *= 2}if (grep {$_ eq '..'}@types_to_go[$ib .. $ie ]){$weighted_length += 4}}$weighted_length += 2 * ($ie - $ib);if ($weighted_length >= $definitely_complex){if ($i_last_break==$i - 1 && $i > 1 && $i_last_last_break!=$i - 2){pop@i_ragged_break_list;push@i_ragged_break_list,$i - 2;push@i_ragged_break_list,$i - 1}push@i_ragged_break_list,$i;$i_last_last_break=$i_last_break;$i_last_break=$i}elsif ($i==$i_max && $i_last_break==$i - 1 && $weighted_length <= $definitely_simple){pop@i_ragged_break_list}}my$identifier_count=$i_max + 1 - $quote_count;if ($max_width > 12 && $complex_item_count > $item_count / 2 && $number_of_fields_best!=2){$number_of_fields_best=1}return ($number_of_fields_best,\@i_ragged_break_list,$identifier_count)}sub get_maximum_fields_wanted {my ($ritem_lengths)=@_;my$number_of_fields_best=0;my$item_count=@{$ritem_lengths};if ($item_count <= 5){$number_of_fields_best=1}else {my$is_odd=1;my@max_length=(0,0);my@last_length_2=(undef,undef);my@first_length_2=(undef,undef);my$last_length=undef;my$total_variation_1=0;my$total_variation_2=0;my@total_variation_2=(0,0);for (my$j=0 ;$j < $item_count ;$j++ ){$is_odd=1 - $is_odd;my$length=$ritem_lengths->[$j];if ($length > $max_length[$is_odd]){$max_length[$is_odd]=$length}if (defined($last_length)){my$dl=abs($length - $last_length);$total_variation_1 += $dl}$last_length=$length;my$ll=$last_length_2[$is_odd];if (defined($ll)){my$dl=abs($length - $ll);$total_variation_2[$is_odd]+= $dl}else {$first_length_2[$is_odd]=$length}$last_length_2[$is_odd]=$length}$total_variation_2=$total_variation_2[0]+ $total_variation_2[1];my$factor=($item_count > 10)? 1 : ($item_count > 5)? 0.75 : 0;unless ($total_variation_2 < $factor * $total_variation_1){$number_of_fields_best=1}}return ($number_of_fields_best)}sub table_columns_available {my$i_first_comma=shift;my$columns=maximum_line_length($i_first_comma)- leading_spaces_to_go($i_first_comma);$columns -= 1;return$columns}sub maximum_number_of_fields {my ($columns,$odd_or_even,$max_width,$pair_width)=@_;my$max_pairs=int($columns / $pair_width);my$number_of_fields=$max_pairs * 2;if ($odd_or_even==1 && $max_pairs * $pair_width + $max_width <= $columns){$number_of_fields++}return$number_of_fields}sub compactify_table {my ($item_count,$number_of_fields,$formatted_lines,$odd_or_even)=@_;if ($number_of_fields >= $odd_or_even * 2 && $formatted_lines > 0){my$min_fields;for ($min_fields=$number_of_fields ;$min_fields >= $odd_or_even && $min_fields * $formatted_lines >= $item_count ;$min_fields -= $odd_or_even ){$number_of_fields=$min_fields}}return$number_of_fields}sub set_ragged_breakpoints {my ($ri_term_comma,$ri_ragged_break_list)=@_;my$break_count=0;for (@$ri_ragged_break_list){my$j=$ri_term_comma->[$_];if ($j){set_forced_breakpoint($j);$break_count++}}return$break_count}sub copy_old_breakpoints {my ($i_first_comma,$i_last_comma)=@_;for my$i ($i_first_comma .. $i_last_comma){if ($old_breakpoint_to_go[$i]){set_forced_breakpoint($i)}}}sub set_nobreaks {my ($i,$j)=@_;if ($i >= 0 && $i <= $j && $j <= $max_index_to_go){FORMATTER_DEBUG_FLAG_NOBREAK && do {my ($a,$b,$c)=caller();print STDOUT "NOBREAK: forced_breakpoint $forced_breakpoint_count from $a $c with i=$i max=$max_index_to_go type=$types_to_go[$i]\n"};@nobreak_to_go[$i .. $j ]=(1)x ($j - $i + 1)}else {FORMATTER_DEBUG_FLAG_NOBREAK && do {my ($a,$b,$c)=caller();print STDOUT "NOBREAK ERROR: from $a $c with i=$i j=$j max=$max_index_to_go\n"}}}sub set_fake_breakpoint {$forced_breakpoint_count++}sub set_forced_breakpoint {my$i=shift;return unless defined$i && $i >= 0;my$token=$tokens_to_go[$i];if ($token =~ /^([\=\.\,\:\?]|and|or|xor|&&|\|\|)$/){if ($want_break_before{$token}&& $i >= 0){$i--}}elsif ($is_if_unless{$token}){$i--}if ($i >= 0 && $i <= $max_index_to_go){my$i_nonblank=($types_to_go[$i]ne 'b')? $i : $i - 1;FORMATTER_DEBUG_FLAG_FORCE && do {my ($a,$b,$c)=caller();print STDOUT "FORCE $forced_breakpoint_count from $a $c with i=$i_nonblank max=$max_index_to_go tok=$tokens_to_go[$i_nonblank] type=$types_to_go[$i_nonblank] nobr=$nobreak_to_go[$i_nonblank]\n"};if ($i_nonblank >= 0 && $nobreak_to_go[$i_nonblank]==0){$forced_breakpoint_to_go[$i_nonblank]=1;if ($i_nonblank > $index_max_forced_break){$index_max_forced_break=$i_nonblank}$forced_breakpoint_count++;$forced_breakpoint_undo_stack[$forced_breakpoint_undo_count++ ]=$i_nonblank;if ($tokens_to_go[$i_nonblank]=~ /^[\{\[\(\?]$/){set_closing_breakpoint($i_nonblank)}}}}sub clear_breakpoint_undo_stack {$forced_breakpoint_undo_count=0}sub undo_forced_breakpoint_stack {my$i_start=shift;if ($i_start < 0){$i_start=0;my ($a,$b,$c)=caller();warning("Program Bug: undo_forced_breakpoint_stack from $a $c has i=$i_start ")}while ($forced_breakpoint_undo_count > $i_start){my$i=$forced_breakpoint_undo_stack[--$forced_breakpoint_undo_count ];if ($i >= 0 && $i <= $max_index_to_go){$forced_breakpoint_to_go[$i]=0;$forced_breakpoint_count--;FORMATTER_DEBUG_FLAG_UNDOBP && do {my ($a,$b,$c)=caller();print STDOUT "UNDOBP: undo forced_breakpoint i=$i $forced_breakpoint_undo_count from $a $c max=$max_index_to_go\n"}}else {FORMATTER_DEBUG_FLAG_UNDOBP && do {my ($a,$b,$c)=caller();print STDOUT "Program Bug: undo_forced_breakpoint from $a $c has i=$i but max=$max_index_to_go"}}}}{my%is_amp_amp;my%is_ternary;my%is_math_op;my%is_plus_minus;my%is_mult_div;BEGIN {@_=qw(&& ||);@is_amp_amp{@_}=(1)x scalar(@_);@_=qw(? :);@is_ternary{@_}=(1)x scalar(@_);@_=qw(+ - * /);@is_math_op{@_}=(1)x scalar(@_);@_=qw(+ -);@is_plus_minus{@_}=(1)x scalar(@_);@_=qw(* /);@is_mult_div{@_}=(1)x scalar(@_)}sub DUMP_BREAKPOINTS {my ($ri_beg,$ri_end,$msg)=@_;print STDERR "----Dumping breakpoints from: $msg----\n";for my$n (0 .. @{$ri_end}- 1){my$ibeg=$$ri_beg[$n];my$iend=$$ri_end[$n];my$text="";for my$i ($ibeg .. $iend){$text .= $tokens_to_go[$i]}print STDERR "$n ($ibeg:$iend) $text\n"}print STDERR "----\n"}sub recombine_breakpoints {my ($ri_beg,$ri_end)=@_;my@joint;my$nmax=@$ri_end - 1;for my$n (1 .. $nmax){my$ibeg_1=$$ri_beg[$n - 1 ];my$iend_1=$$ri_end[$n - 1 ];my$iend_2=$$ri_end[$n];my$ibeg_2=$$ri_beg[$n];my ($itok,$itokp,$itokm);for my$itest ($iend_1,$ibeg_2){my$type=$types_to_go[$itest];if ($is_math_op{$type}|| $is_amp_amp{$type}|| $is_assignment{$type}|| $type eq ':'){$itok=$itest}}$joint[$n]=[$itok]}my$more_to_do=1;my$nmax_last=@$ri_end;while ($more_to_do){my$n_best=0;my$bs_best;my$n;my$nmax=@$ri_end - 1;unless ($nmax < $nmax_last){Perl::Tidy::Die "Program bug-infinite loop in recombine breakpoints\n"}$nmax_last=$nmax;$more_to_do=0;my$previous_outdentable_closing_paren;my$leading_amp_count=0;my$this_line_is_semicolon_terminated;for$n (1 .. $nmax){my$ibeg_1=$$ri_beg[$n - 1 ];my$iend_1=$$ri_end[$n - 1 ];my$iend_2=$$ri_end[$n];my$ibeg_2=$$ri_beg[$n];my$ibeg_nmax=$$ri_beg[$nmax];my$type_iend_1=$types_to_go[$iend_1];my$type_iend_2=$types_to_go[$iend_2];my$type_ibeg_1=$types_to_go[$ibeg_1];my$type_ibeg_2=$types_to_go[$ibeg_2];my$ibeg_0=$n > 1 ? $$ri_beg[$n - 2 ]: -1;my$ibeg_3=$n < $nmax ? $$ri_beg[$n + 1 ]: -1;my$ibeg_4=$n + 2 <= $nmax ? $$ri_beg[$n + 2 ]: -1;my$bs_tweak=0;FORMATTER_DEBUG_FLAG_RECOMBINE && do {print STDERR "RECOMBINE: n=$n imid=$iend_1 if=$ibeg_1 type=$type_ibeg_1 =$tokens_to_go[$ibeg_1] next_type=$type_ibeg_2 next_tok=$tokens_to_go[$ibeg_2]\n"};if ($n==$nmax){next if$type_ibeg_2 eq '{';$this_line_is_semicolon_terminated=$type_iend_2 eq ';' || ($type_iend_2 eq '#' && $iend_2 - $ibeg_2 >= 2 && $types_to_go[$iend_2 - 2 ]eq ';' && $types_to_go[$iend_2 - 1 ]eq 'b')}my ($itok)=@{$joint[$n]};if ($itok){my$iend_1=$type_iend_1 eq 'b' ? $iend_1 - 1 : $iend_1;my$iend_2=$type_iend_2 eq 'b' ? $iend_2 - 1 : $iend_2;my$type=$types_to_go[$itok];if ($type eq ':'){if ($itok eq $iend_1){next unless$want_break_before{$type}}else {$leading_amp_count++;next if$want_break_before{$type}}}elsif ($is_math_op{$type}){my$good_combo;my$itokp=min($inext_to_go[$itok],$iend_2);my$itokpp=min($inext_to_go[$itokp],$iend_2);my$itokm=max($iprev_to_go[$itok],$ibeg_1);my$itokmm=max($iprev_to_go[$itokm],$ibeg_1);if ($types_to_go[$itokp]eq 'n'){if ($itokp==$iend_2){$good_combo=1}else {$good_combo=(($itokpp==$iend_2)&& $is_math_op{$types_to_go[$itokpp]})|| $types_to_go[$itokpp]=~ /^[#,;]$/}}if (!$good_combo && $types_to_go[$itokm]eq 'n'){if ($itokm==$ibeg_1){$good_combo=1}else {$good_combo=($itokmm==$ibeg_1)&& ($is_math_op{$types_to_go[$itokmm]}|| $types_to_go[$itokmm]=~ /^[,]$/ || $is_assignment{$types_to_go[$itokmm]})}}if (!$good_combo){my$two=($itok eq $iend_1)? 2 : 0;$good_combo=$types_to_go[$itokp]=~ /^[in]$/ && $types_to_go[$itokm]=~ /^[in]$/ && (($itokpp==$iend_2 && token_sequence_length($itokp,$iend_2)< $two + $rOpts_short_concatenation_item_length)|| ($itokmm==$ibeg_1 && token_sequence_length($ibeg_1,$itokm)< 2 - $two + $rOpts_short_concatenation_item_length))&&!($is_plus_minus{$type}&& ($is_mult_div{$types_to_go[$itokmm]}|| $is_mult_div{$types_to_go[$itokpp]}))&&!($is_mult_div{$type}&& ($is_plus_minus{$types_to_go[$itokmm]}|| $is_plus_minus{$types_to_go[$itokpp]}))}if (!$good_combo){my$iother=($itok==$iend_1)? $iend_2 : $ibeg_1;$good_combo=$n==2 && $n==$nmax && $types_to_go[$iother]ne $type}next unless ($good_combo)}elsif ($is_amp_amp{$type}){}elsif ($is_assignment{$type}){}}if ($type_iend_1 eq '}'){$previous_outdentable_closing_paren=$this_line_is_semicolon_terminated && $ibeg_1==$iend_1 && $tokens_to_go[$iend_1]eq ')' &&!$closing_token_indentation{')'}&& ($leading_amp_count==0 || $type_ibeg_2 !~ /^(:|\&\&|\|\|)$/)&& $type_ibeg_2 ne ':' && ($nesting_depth_to_go[$iend_1]==$nesting_depth_to_go[$iend_2]+ 1);if ($block_type_to_go[$iend_1]eq 'eval' &&!$rOpts->{'line-up-parentheses'}&&!$rOpts->{'indent-closing-brace'}&& $tokens_to_go[$iend_2]eq '{' && (($type_ibeg_2 =~ /^(|\&\&|\|\|)$/)|| ($type_ibeg_2 eq 'k' && $is_and_or{$tokens_to_go[$ibeg_2]})|| $is_if_unless{$tokens_to_go[$ibeg_2]})){$previous_outdentable_closing_paren ||= 1}next unless ($previous_outdentable_closing_paren || ($type_ibeg_2 =~ /^[\.\?]$/))}elsif ($type_iend_1 eq '{'){next if$forced_breakpoint_to_go[$iend_1]}elsif ($is_amp_amp{$type_iend_1}){next unless$want_break_before{$type_iend_1}}elsif ($type_iend_1 eq '?'){next if ($levels_to_go[$ibeg_1]ne $levels_to_go[$ibeg_2]);next unless$type_iend_2 eq ':'}elsif ($type_iend_1 eq ','){next if ($old_breakpoint_to_go[$iend_1]);if ($type_ibeg_1 eq '}' && $type_ibeg_2 eq 'i'){next unless (($ibeg_1==($iend_1 - 1))&& ($iend_2==($ibeg_2 + 1))&& $this_line_is_semicolon_terminated);$forced_breakpoint_to_go[$iend_1]=0}else {next unless ($n + 1 >= $nmax);next if ($levels_to_go[$iend_1]!=$levels_to_go[$iend_2]);my$saw_paren;for my$ii ($ibeg_2 .. $iend_2){if ($tokens_to_go[$ii]eq '('){$saw_paren=1;last}}next if$saw_paren}}elsif ($type_iend_1 eq '('){}elsif ($type_iend_1 eq ')'){}elsif ($type_iend_1 eq 'f'){next}elsif ($is_assignment{$type_iend_1}){next if$old_breakpoint_to_go[$iend_1]&& $iend_1!=$ibeg_1;my$is_short_quote=($type_ibeg_2 eq 'Q' && $ibeg_2==$iend_2 && token_sequence_length($ibeg_2,$ibeg_2)< $rOpts_short_concatenation_item_length);my$is_ternary=($type_ibeg_1 eq '?' && ($ibeg_3 >= 0 && $types_to_go[$ibeg_3]eq ':'));if ($ibeg_1!=$iend_1 &&!$is_short_quote &&!$is_ternary){next unless (($nmax < $n + 2 || ($nmax==$n + 2 && $types_to_go[$ibeg_nmax]eq ';')|| $type_iend_2 eq 'h' || (!$forced_breakpoint_to_go[$iend_1]&& $type_iend_2 eq '{'))&& ($ibeg_3 >= 0 && $type_ibeg_2 ne $types_to_go[$ibeg_3]));if ($nmax >= $n + 2 && (!$rOpts_line_up_parentheses || $type_iend_2 ne ',')){my$tv=0;my$depth=$nesting_depth_to_go[$ibeg_2];for (my$i=$ibeg_2 + 1 ;$i < $iend_2 ;$i++ ){if ($nesting_depth_to_go[$i]!=$depth){$tv++;last if ($tv > 1)}$depth=$nesting_depth_to_go[$i]}if ($tv > 0){next if ($tv > 1);my$istop=($n < $nmax)? $$ri_end[$n + 1 ]: $iend_2;for (my$i=$iend_2 ;$i <= $istop ;$i++ ){if ($nesting_depth_to_go[$i]!=$depth){$tv++;last if ($tv > 2)}$depth=$nesting_depth_to_go[$i]}next if ($tv > 2)}}}unless ($tokens_to_go[$ibeg_2]=~ /^[\{\(\[]$/){$forced_breakpoint_to_go[$iend_1]=0}}elsif ($type_iend_1 eq 'k'){next if ($is_last_next_redo_return{$tokens_to_go[$iend_1]}&& $n < $nmax);if ($is_and_or{$tokens_to_go[$iend_1]}){next unless$want_break_before{$tokens_to_go[$iend_1]}}}if ($previous_outdentable_closing_paren){$forced_breakpoint_to_go[$iend_1]=0}elsif ($is_amp_amp{$type_ibeg_2}){$leading_amp_count++;my$ok=($is_ternary{$type_ibeg_1}&& $tokens_to_go[$iend_2]eq '(')|| ($ibeg_3 >= 0 && $is_ternary{$types_to_go[$ibeg_3]}&& $nesting_depth_to_go[$ibeg_3]==$nesting_depth_to_go[$ibeg_2]);next if!$ok && $want_break_before{$type_ibeg_2};$forced_breakpoint_to_go[$iend_1]=0;$bs_tweak=0.25}elsif ($type_ibeg_2 eq '?'){my$lev=$levels_to_go[$ibeg_2];next if ($lev ne $levels_to_go[$ibeg_1]);my$follows_colon=$ibeg_1 >= 0 && $type_ibeg_1 eq ':';my$precedes_colon=$ibeg_3 >= 0 && $types_to_go[$ibeg_3]eq ':';next unless ($follows_colon || $precedes_colon);if (!$follows_colon){my$local_count=0;for my$ii ($ibeg_0,$ibeg_1,$ibeg_3,$ibeg_4){$local_count++ if$ii >= 0 && $types_to_go[$ii]eq ':' && $levels_to_go[$ii]==$lev}next unless ($local_count > 1)}$forced_breakpoint_to_go[$iend_1]=0}elsif ($type_ibeg_2 eq '.'){my$i_next_nonblank=min($inext_to_go[$ibeg_2],$iend_2);next unless (($n==2 && $n==$nmax && $type_ibeg_1 ne $type_ibeg_2)|| ($types_to_go[$i_next_nonblank]eq 'Q' && $i_next_nonblank >= $iend_2 - 1 && $token_lengths_to_go[$i_next_nonblank]< $rOpts_short_concatenation_item_length))}elsif ($type_ibeg_2 eq 'k'){if ($tokens_to_go[$ibeg_2]eq 'or'){next unless ($this_line_is_semicolon_terminated && ($type_ibeg_1 eq 'k' && $is_if_unless{$tokens_to_go[$ibeg_1]}&& ($iend_2 - $ibeg_2 <= 7)));$forced_breakpoint_to_go[$iend_1]=0 unless$old_breakpoint_to_go[$iend_1]}elsif ($tokens_to_go[$ibeg_2]eq 'and'){next unless ($this_line_is_semicolon_terminated && ($type_ibeg_1 eq 'k' && ($is_if_unless{$tokens_to_go[$ibeg_1]}|| $tokens_to_go[$ibeg_1]eq 'or')))}elsif ($is_if_unless{$tokens_to_go[$ibeg_2]}){next unless ($this_line_is_semicolon_terminated && $type_ibeg_1 eq 'k' && $is_and_or{$tokens_to_go[$ibeg_1]})}else {unless ($is_assignment{$type_iend_1}){next if (($type_iend_1 ne 'k')&& ($tokens_to_go[$ibeg_2]ne 'while'))}}}elsif ($is_amp_amp{$type_ibeg_2}){next unless ($this_line_is_semicolon_terminated && $type_ibeg_1 eq 'k' && $is_if_unless{$tokens_to_go[$ibeg_1]})}elsif ($is_assignment{$type_ibeg_2}){next unless ($n==1 || $n==$nmax);next if$old_breakpoint_to_go[$iend_1];next unless ($nmax==2 || ($nmax==3 && $types_to_go[$ibeg_nmax]eq ';')|| $type_iend_2 eq 'h' || ($n==$nmax && $this_line_is_semicolon_terminated));$forced_breakpoint_to_go[$iend_1]=0}next if ($forced_breakpoint_to_go[$iend_1]> 0);my$bs=$bond_strength_to_go[$iend_1]+ $bs_tweak;my$excess=excess_line_length($ibeg_1,$iend_2);next if ($excess > 0);next if ($old_breakpoint_to_go[$iend_1]&&!$this_line_is_semicolon_terminated && $n < $nmax && $excess + 4 > 0 && $type_iend_2 ne ',');if ($n < $nmax){my$if_next=$$ri_beg[$n + 1 ];next if ($levels_to_go[$ibeg_1]< $levels_to_go[$ibeg_2]&& $levels_to_go[$ibeg_2]< $levels_to_go[$if_next]&&!($n==1 && $iend_1 - $ibeg_1 <= 2 && $type_ibeg_1 eq 'k' && $tokens_to_go[$ibeg_1]eq 'if' && $tokens_to_go[$iend_1]ne '('))}next if ($bs >= NO_BREAK - 1);if (!$n_best){$n_best=$n;$bs_best=$bs}else {if ($bs > $bs_best){$n_best=$n;$bs_best=$bs}}}if ($n_best){splice @$ri_beg,$n_best,1;splice @$ri_end,$n_best - 1,1;splice@joint,$n_best,1;$more_to_do++}}return ($ri_beg,$ri_end)}}sub break_all_chain_tokens {my ($ri_left,$ri_right)=@_;my%saw_chain_type;my%left_chain_type;my%right_chain_type;my%interior_chain_type;my$nmax=@$ri_right - 1;my$count=0;for my$n (0 .. $nmax){my$il=$$ri_left[$n];my$ir=$$ri_right[$n];my$typel=$types_to_go[$il];my$typer=$types_to_go[$ir];$typel='+' if ($typel eq '-');$typer='+' if ($typer eq '-');$typel='*' if ($typel eq '/');$typer='*' if ($typer eq '/');my$tokenl=$tokens_to_go[$il];my$tokenr=$tokens_to_go[$ir];if ($is_chain_operator{$tokenl}&& $want_break_before{$typel}){next if ($typel eq '?');push @{$left_chain_type{$typel}},$il;$saw_chain_type{$typel}=1;$count++}if ($is_chain_operator{$tokenr}&&!$want_break_before{$typer}){next if ($typer eq '?');push @{$right_chain_type{$typer}},$ir;$saw_chain_type{$typer}=1;$count++}}return unless$count;$count=0;for my$n (0 .. $nmax){my$il=$$ri_left[$n];my$ir=$$ri_right[$n];for (my$i=$il + 1 ;$i < $ir ;$i++ ){my$type=$types_to_go[$i];$type='+' if ($type eq '-');$type='*' if ($type eq '/');if ($saw_chain_type{$type}){push @{$interior_chain_type{$type}},$i;$count++}}}return unless$count;my@insert_list;for my$type (keys%saw_chain_type){last if ($nmax==1 && $type =~ /^[\.\+]$/);for my$itest (@{$interior_chain_type{$type}}){if ($left_chain_type{$type}){next if$nobreak_to_go[$itest - 1 ];for my$i (@{$left_chain_type{$type}}){next unless in_same_container($i,$itest);push@insert_list,$itest - 1;if ($type eq ':' && $levels_to_go[$i]!=$levels_to_go[$itest]){my$i_question=$mate_index_to_go[$itest];if ($i_question > 0){push@insert_list,$i_question - 1}}last}}if ($right_chain_type{$type}){next if$nobreak_to_go[$itest];for my$i (@{$right_chain_type{$type}}){next unless in_same_container($i,$itest);push@insert_list,$itest;if ($type eq ':' && $levels_to_go[$i]!=$levels_to_go[$itest]){my$i_question=$mate_index_to_go[$itest];if ($i_question >= 0){push@insert_list,$i_question}}last}}}}if (@insert_list){insert_additional_breaks(\@insert_list,$ri_left,$ri_right)}}sub break_equals {my ($ri_left,$ri_right)=@_;my$nmax=@$ri_right - 1;return unless ($nmax >= 2);my$tokbeg="";my$depth_beg;for my$n (1 .. 2){my$il=$$ri_left[$n];my$typel=$types_to_go[$il];my$tokenl=$tokens_to_go[$il];my$has_leading_op=($tokenl =~ /^\w/)? $is_chain_operator{$tokenl}: $is_chain_operator{$typel};return unless ($has_leading_op);if ($n > 1){return unless ($tokenl eq $tokbeg && $nesting_depth_to_go[$il]eq $depth_beg)}$tokbeg=$tokenl;$depth_beg=$nesting_depth_to_go[$il]}my$il=$$ri_left[0];my$ir=$$ri_right[0];my@insert_list;for (my$i=$ir - 1 ;$i > $il ;$i-- ){my$type=$types_to_go[$i];if ($is_assignment{$type}&& $nesting_depth_to_go[$i]eq $depth_beg){if ($want_break_before{$type}){push@insert_list,$i - 1}else {push@insert_list,$i}}}my$i=0;if ($types_to_go[$i]eq 'k' && $tokens_to_go[$i]eq 'return' && $ir > $il && $nesting_depth_to_go[$i]eq $depth_beg){push@insert_list,$i}return unless (@insert_list);for my$n (1 .. 2){my$il=$$ri_left[$n];my$ir=$$ri_right[$n];for (my$i=$il + 1 ;$i <= $ir ;$i++ ){my$type=$types_to_go[$i];return if ($is_assignment{$type}&& $nesting_depth_to_go[$i]eq $depth_beg)}}if (@insert_list){insert_additional_breaks(\@insert_list,$ri_left,$ri_right)}}sub insert_final_breaks {my ($ri_left,$ri_right)=@_;my$nmax=@$ri_right - 1;my$count=0;my$i_first_colon=-1;for my$n (0 .. $nmax){my$il=$$ri_left[$n];my$ir=$$ri_right[$n];my$typel=$types_to_go[$il];my$typer=$types_to_go[$ir];return if ($typel eq '?');return if ($typer eq '?');if ($typel eq ':'){$i_first_colon=$il;last}elsif ($typer eq ':'){$i_first_colon=$ir;last}}if ($i_first_colon > 0){my$i_question=$mate_index_to_go[$i_first_colon];if ($i_question > 0){my@insert_list;for (my$ii=$i_question - 1 ;$ii >= 0 ;$ii -= 1 ){my$token=$tokens_to_go[$ii];my$type=$types_to_go[$ii];if (($type eq ',' || $type eq 'k' && $token eq 'return')&& in_same_container($ii,$i_question)){push@insert_list,$ii;last}}if (@insert_list){insert_additional_breaks(\@insert_list,$ri_left,$ri_right)}}}}sub in_same_container {my ($i1,$i2)=@_;my$type=$types_to_go[$i1];my$depth=$nesting_depth_to_go[$i1];return unless ($nesting_depth_to_go[$i2]==$depth);if ($i2 < $i1){($i1,$i2)=($i2,$i1)}return if ($i2 - $i1 > 200);for (my$i=$i1 + 1 ;$i < $i2 ;$i++ ){next if ($nesting_depth_to_go[$i]> $depth);return if ($nesting_depth_to_go[$i]< $depth);my$tok=$tokens_to_go[$i];$tok=',' if$tok eq '=>';if ($type ne ':'){return if ($tok =~ /^[\,\:\?]$/)|| $tok eq '||' || $tok eq 'or'}else {return if ($tok =~ /^[\,]$/)}}return 1}sub set_continuation_breaks {my$saw_good_break=shift;my@i_first=();my@i_last=();my@i_colon_breaks=();if ($types_to_go[0]eq ':'){push@i_colon_breaks,0}set_bond_strengths();my$imin=0;my$imax=$max_index_to_go;if ($types_to_go[$imin]eq 'b'){$imin++}if ($types_to_go[$imax]eq 'b'){$imax--}my$i_begin=$imin;my$leading_spaces=leading_spaces_to_go($imin);my$line_count=0;my$last_break_strength=NO_BREAK;my$i_last_break=-1;my$max_bias=0.001;my$tiny_bias=0.0001;my$leading_alignment_token="";my$leading_alignment_type="";my$colons_in_order=1;my$last_tok="";my@colon_list=grep /^[\?\:]$/,@types_to_go[0 .. $max_index_to_go ];my$colon_count=@colon_list;for (@colon_list){if ($_ eq $last_tok){$colons_in_order=0;last}$last_tok=$_}my$is_colon_chain=($colons_in_order && @colon_list > 2);while ($i_begin <= $imax){my$lowest_strength=NO_BREAK;my$starting_sum=$summed_lengths_to_go[$i_begin];my$i_lowest=-1;my$i_test=-1;my$lowest_next_token='';my$lowest_next_type='b';my$i_lowest_next_nonblank=-1;for ($i_test=$i_begin ;$i_test <= $imax ;$i_test++ ){my$type=$types_to_go[$i_test];my$token=$tokens_to_go[$i_test];my$next_type=$types_to_go[$i_test + 1 ];my$next_token=$tokens_to_go[$i_test + 1 ];my$i_next_nonblank=$inext_to_go[$i_test];my$next_nonblank_type=$types_to_go[$i_next_nonblank];my$next_nonblank_token=$tokens_to_go[$i_next_nonblank];my$next_nonblank_block_type=$block_type_to_go[$i_next_nonblank];my$strength=$bond_strength_to_go[$i_test];my$maximum_line_length=maximum_line_length($i_begin);if ($old_breakpoint_to_go[$i_test]&&!$want_break_before{$type}&& $i_next_nonblank <= $imax && ($want_break_before{$next_nonblank_type}|| $token_lengths_to_go[$i_next_nonblank]> 2 || $next_nonblank_type =~ /^[\,\(\[\{L]$/)){$strength -= $tiny_bias}else {my$len=$leading_spaces + $summed_lengths_to_go[$i_test + 1 ]- $starting_sum;if ($len >= $maximum_line_length){$strength += $tiny_bias}}my$must_break=0;if (($next_nonblank_type =~ /^(\.|\&\&|\|\|)$/ || ($next_nonblank_type eq 'k' && $next_nonblank_token =~ /^(and|or)$/))&& ($nesting_depth_to_go[$i_begin]> $nesting_depth_to_go[$i_next_nonblank])&& ($strength <= $lowest_strength)){set_forced_breakpoint($i_next_nonblank)}if ($forced_breakpoint_to_go[$i_test]|| ($line_count && ($token eq ')')&& ($next_nonblank_type eq '{')&& ($next_nonblank_block_type)&& ($next_nonblank_block_type ne $tokens_to_go[$i_begin])&&!($next_nonblank_block_type =~ /^sub/ && ($nesting_depth_to_go[$i_begin]==$nesting_depth_to_go[$i_next_nonblank]))&&!$rOpts->{'opening-brace-always-on-right'})|| (($type eq '{')&& ($i_test==$imax))){if ($strength < NO_BREAK - 1){$strength=$lowest_strength - $tiny_bias;$must_break=1}}if (!$must_break && ($next_nonblank_type =~ /^[\;\,]$/)&& (($leading_spaces + $summed_lengths_to_go[$i_next_nonblank + 1 ]- $starting_sum)> $maximum_line_length)){last if ($i_lowest >= 0)}if (!$must_break && ($i_test==$i_begin)&& ($i_test < $imax)&& ($token eq $type)&& (($leading_spaces + $summed_lengths_to_go[$i_test + 1 ]- $starting_sum)< $maximum_line_length)){$i_test=min($imax,$inext_to_go[$i_test]);redo}if (($strength <= $lowest_strength)&& ($strength < NO_BREAK)){last if ($leading_alignment_type);last if ($i_test==$imax &&!$forced_breakpoint_count && $saw_good_break && $type =~ /^[#;\{]$/ && $i_last_break < 0 && $i_lowest >= 0 && $i_lowest < $imax - 1 && $strength - $lowest_strength < 0.5 * WEAK);if ($line_count > 2 && $i_lowest < $i_test && $i_test > $imax - 2 && $nesting_depth_to_go[$i_begin]> $nesting_depth_to_go[$i_lowest]&& $lowest_strength < $last_break_strength - .5 * WEAK){my$ir=$inext_to_go[$i_lowest];my$il=$iprev_to_go[$ir];last if ($types_to_go[$il]=~ /^[\/\*\+\-\%]$/ || $types_to_go[$ir]=~ /^[\/\*\+\-\%]$/)}$lowest_strength=$strength;$i_lowest=$i_test;$lowest_next_token=$next_nonblank_token;$lowest_next_type=$next_nonblank_type;$i_lowest_next_nonblank=$i_next_nonblank;last if$must_break;if ($line_count > 0 && $i_test < $imax && ($lowest_strength - $last_break_strength <= $max_bias)){my$i_last_end=$iprev_to_go[$i_begin];my$tok_beg=$tokens_to_go[$i_begin];my$type_beg=$types_to_go[$i_begin];if (($tok_beg eq $next_nonblank_token && $is_chain_operator{$tok_beg}&& ($type_beg eq 'k' || $type_beg eq $tok_beg)&& $nesting_depth_to_go[$i_begin]>= $nesting_depth_to_go[$i_next_nonblank])|| ($tokens_to_go[$i_last_end]eq $token && $is_chain_operator{$token}&& ($type eq 'k' || $type eq $token)&& $nesting_depth_to_go[$i_last_end]>= $nesting_depth_to_go[$i_test])){$leading_alignment_token=$next_nonblank_token;$leading_alignment_type=$next_nonblank_type}}}my$too_long=($i_test >= $imax);if (!$too_long){my$next_length=$leading_spaces + $summed_lengths_to_go[$i_test + 2 ]- $starting_sum;$too_long=$next_length > $maximum_line_length;if (!$too_long && $i_test + 1 < $imax && $next_nonblank_type !~ /^[,\}\]\)R]$/){$too_long=$next_length >= $maximum_line_length}}FORMATTER_DEBUG_FLAG_BREAK && do {my$ltok=$token;my$rtok=$next_nonblank_token ? $next_nonblank_token : "";my$i_testp2=$i_test + 2;if ($i_testp2 > $max_index_to_go + 1){$i_testp2=$max_index_to_go + 1}if (length($ltok)> 6){$ltok=substr($ltok,0,8)}if (length($rtok)> 6){$rtok=substr($rtok,0,8)}print STDOUT "BREAK: i=$i_test imax=$imax $types_to_go[$i_test] $next_nonblank_type sp=($leading_spaces) lnext= $summed_lengths_to_go[$i_testp2] 2long=$too_long str=$strength    $ltok $rtok\n"};if ($rOpts_fuzzy_line_length && $too_long && $i_lowest==$i_test && $token_lengths_to_go[$i_test]> 1 && $next_nonblank_type =~ /^[\;\,]$/){$too_long=0}last if (($i_test==$imax)|| (($i_lowest >= 0)&& $too_long))}if ($i_lowest < 0){$i_lowest=$imax}my$i_next_nonblank=$inext_to_go[$i_lowest];my$next_nonblank_type=$types_to_go[$i_next_nonblank];my$next_nonblank_token=$tokens_to_go[$i_next_nonblank];my$i;for$i ($i_begin + 1 .. $i_lowest - 1){next unless ($tokens_to_go[$i]eq '?');next if ($is_colon_chain);next if ($tokens_to_go[$max_index_to_go]eq '#' && terminal_type(\@types_to_go,\@block_type_to_go,0,$max_index_to_go)!~ /^[\;\}]$/);next if ($mate_index_to_go[$i]>= 0 && $mate_index_to_go[$i]<= $i_next_nonblank);$i_lowest=$i;if ($want_break_before{'?'}){$i_lowest--}last}$i_next_nonblank=$inext_to_go[$i_lowest];$next_nonblank_type=$types_to_go[$i_next_nonblank];$next_nonblank_token=$tokens_to_go[$i_next_nonblank];FORMATTER_DEBUG_FLAG_BREAK && print STDOUT "BREAK: best is i = $i_lowest strength = $lowest_strength\n";if ($next_nonblank_type eq '?'){set_closing_breakpoint($i_next_nonblank)}elsif ($types_to_go[$i_lowest]eq '?'){set_closing_breakpoint($i_lowest)}if ($next_nonblank_type eq ':'){push@i_colon_breaks,$i_next_nonblank}elsif ($types_to_go[$i_lowest]eq ':'){push@i_colon_breaks,$i_lowest}$line_count++;push(@i_first,($types_to_go[$i_begin]eq 'b')? $i_begin + 1 : $i_begin);push(@i_last,($types_to_go[$i_lowest]eq 'b')? $i_lowest - 1 : $i_lowest);if ($tokens_to_go[$i_lowest]=~ /^[\{\[]$/ &&!$forced_breakpoint_to_go[$i_lowest]){set_closing_breakpoint($i_lowest)}$i_begin=$i_lowest + 1;$last_break_strength=$lowest_strength;$i_last_break=$i_lowest;$leading_alignment_token="";$leading_alignment_type="";$lowest_next_token='';$lowest_next_type='b';if (($i_begin <= $imax)&& ($types_to_go[$i_begin]eq 'b')){$i_begin++}if ($i_begin <= $imax){$leading_spaces=leading_spaces_to_go($i_begin)}}if (@i_colon_breaks){my$is_chain=($colons_in_order && @i_colon_breaks > 1);unless ($is_chain){my@insert_list=();for (@i_colon_breaks){my$i_question=$mate_index_to_go[$_];if ($i_question >= 0){if ($want_break_before{'?'}){$i_question=$iprev_to_go[$i_question]}if ($i_question >= 0){push@insert_list,$i_question}}insert_additional_breaks(\@insert_list,\@i_first,\@i_last)}}}return (\@i_first,\@i_last,$colon_count)}sub insert_additional_breaks {my ($ri_break_list,$ri_first,$ri_last)=@_;my$i_f;my$i_l;my$line_number=0;my$i_break_left;for$i_break_left (sort {$a <=> $b}@$ri_break_list){$i_f=$$ri_first[$line_number];$i_l=$$ri_last[$line_number];while ($i_break_left >= $i_l){$line_number++;if ($line_number >= @$ri_last){warning("Non-fatal program bug: couldn't set break at $i_break_left\n");report_definite_bug();return}$i_f=$$ri_first[$line_number];$i_l=$$ri_last[$line_number]}if ($types_to_go[$i_break_left]eq 'b'){$i_break_left--}my$i_break_right=$inext_to_go[$i_break_left];if ($i_break_left >= $i_f && $i_break_left < $i_l && $i_break_right > $i_f && $i_break_right <= $i_l){splice(@$ri_first,$line_number,1,($i_f,$i_break_right));splice(@$ri_last,$line_number,1,($i_break_left,$i_l))}}}sub set_closing_breakpoint {my$i_break=shift;if ($mate_index_to_go[$i_break]>= 0){if ($mate_index_to_go[$i_break]> $i_break + 2){my$inc=($tokens_to_go[$i_break]eq '?')? 0 : 1;set_forced_breakpoint($mate_index_to_go[$i_break]- $inc)}}else {my$type_sequence=$type_sequence_to_go[$i_break];if ($type_sequence){my$closing_token=$matching_token{$tokens_to_go[$i_break]};$postponed_breakpoint{$type_sequence}=1}}}sub compare_indentation_levels {my ($guessed_indentation_level,$structural_indentation_level)=@_;if ($guessed_indentation_level ne $structural_indentation_level){$last_tabbing_disagreement=$input_line_number;if ($in_tabbing_disagreement){}else {$tabbing_disagreement_count++;if ($tabbing_disagreement_count <= MAX_NAG_MESSAGES){write_logfile_entry("Start indentation disagreement: input=$guessed_indentation_level; output=$structural_indentation_level\n")}$in_tabbing_disagreement=$input_line_number;$first_tabbing_disagreement=$in_tabbing_disagreement unless ($first_tabbing_disagreement)}}else {if ($in_tabbing_disagreement){if ($tabbing_disagreement_count <= MAX_NAG_MESSAGES){write_logfile_entry("End indentation disagreement from input line $in_tabbing_disagreement\n");if ($tabbing_disagreement_count==MAX_NAG_MESSAGES){write_logfile_entry("No further tabbing disagreements will be noted\n")}}$in_tabbing_disagreement=0}}}package Perl::Tidy::IndentationItem;use constant SPACES=>0;use constant LEVEL=>1;use constant CI_LEVEL=>2;use constant AVAILABLE_SPACES=>3;use constant CLOSED=>4;use constant COMMA_COUNT=>5;use constant SEQUENCE_NUMBER=>6;use constant INDEX=>7;use constant HAVE_CHILD=>8;use constant RECOVERABLE_SPACES=>9;use constant ALIGN_PAREN=>10;use constant MARKED=>11;use constant STACK_DEPTH=>12;use constant STARTING_INDEX=>13;use constant ARROW_COUNT=>14;sub new {my ($class,$spaces,$level,$ci_level,$available_spaces,$index,$gnu_sequence_number,$align_paren,$stack_depth,$starting_index,)=@_;my$closed=-1;my$arrow_count=0;my$comma_count=0;my$have_child=0;my$want_right_spaces=0;my$marked=0;bless [$spaces,$level,$ci_level,$available_spaces,$closed,$comma_count,$gnu_sequence_number,$index,$have_child,$want_right_spaces,$align_paren,$marked,$stack_depth,$starting_index,$arrow_count,],$class}sub permanently_decrease_AVAILABLE_SPACES {my ($item,$spaces_needed)=@_;my$available_spaces=$item->get_AVAILABLE_SPACES();my$deleted_spaces=($available_spaces > $spaces_needed)? $spaces_needed : $available_spaces;$item->decrease_AVAILABLE_SPACES($deleted_spaces);$item->decrease_SPACES($deleted_spaces);$item->set_RECOVERABLE_SPACES(0);return$deleted_spaces}sub tentatively_decrease_AVAILABLE_SPACES {my ($item,$spaces_needed)=@_;my$available_spaces=$item->get_AVAILABLE_SPACES();my$deleted_spaces=($available_spaces > $spaces_needed)? $spaces_needed : $available_spaces;$item->decrease_AVAILABLE_SPACES($deleted_spaces);$item->decrease_SPACES($deleted_spaces);$item->increase_RECOVERABLE_SPACES($deleted_spaces);return$deleted_spaces}sub get_STACK_DEPTH {my$self=shift;return$self->[STACK_DEPTH]}sub get_SPACES {my$self=shift;return$self->[SPACES]}sub get_MARKED {my$self=shift;return$self->[MARKED]}sub set_MARKED {my ($self,$value)=@_;if (defined($value)){$self->[MARKED]=$value}return$self->[MARKED]}sub get_AVAILABLE_SPACES {my$self=shift;return$self->[AVAILABLE_SPACES]}sub decrease_SPACES {my ($self,$value)=@_;if (defined($value)){$self->[SPACES]-= $value}return$self->[SPACES]}sub decrease_AVAILABLE_SPACES {my ($self,$value)=@_;if (defined($value)){$self->[AVAILABLE_SPACES]-= $value}return$self->[AVAILABLE_SPACES]}sub get_ALIGN_PAREN {my$self=shift;return$self->[ALIGN_PAREN]}sub get_RECOVERABLE_SPACES {my$self=shift;return$self->[RECOVERABLE_SPACES]}sub set_RECOVERABLE_SPACES {my ($self,$value)=@_;if (defined($value)){$self->[RECOVERABLE_SPACES]=$value}return$self->[RECOVERABLE_SPACES]}sub increase_RECOVERABLE_SPACES {my ($self,$value)=@_;if (defined($value)){$self->[RECOVERABLE_SPACES]+= $value}return$self->[RECOVERABLE_SPACES]}sub get_CI_LEVEL {my$self=shift;return$self->[CI_LEVEL]}sub get_LEVEL {my$self=shift;return$self->[LEVEL]}sub get_SEQUENCE_NUMBER {my$self=shift;return$self->[SEQUENCE_NUMBER]}sub get_INDEX {my$self=shift;return$self->[INDEX]}sub get_STARTING_INDEX {my$self=shift;return$self->[STARTING_INDEX]}sub set_HAVE_CHILD {my ($self,$value)=@_;if (defined($value)){$self->[HAVE_CHILD]=$value}return$self->[HAVE_CHILD]}sub get_HAVE_CHILD {my$self=shift;return$self->[HAVE_CHILD]}sub set_ARROW_COUNT {my ($self,$value)=@_;if (defined($value)){$self->[ARROW_COUNT]=$value}return$self->[ARROW_COUNT]}sub get_ARROW_COUNT {my$self=shift;return$self->[ARROW_COUNT]}sub set_COMMA_COUNT {my ($self,$value)=@_;if (defined($value)){$self->[COMMA_COUNT]=$value}return$self->[COMMA_COUNT]}sub get_COMMA_COUNT {my$self=shift;return$self->[COMMA_COUNT]}sub set_CLOSED {my ($self,$value)=@_;if (defined($value)){$self->[CLOSED]=$value}return$self->[CLOSED]}sub get_CLOSED {my$self=shift;return$self->[CLOSED]}package Perl::Tidy::VerticalAligner::Line;{use strict;use Carp;use constant JMAX=>0;use constant JMAX_ORIGINAL_LINE=>1;use constant RTOKENS=>2;use constant RFIELDS=>3;use constant RPATTERNS=>4;use constant INDENTATION=>5;use constant LEADING_SPACE_COUNT=>6;use constant OUTDENT_LONG_LINES=>7;use constant LIST_TYPE=>8;use constant IS_HANGING_SIDE_COMMENT=>9;use constant RALIGNMENTS=>10;use constant MAXIMUM_LINE_LENGTH=>11;use constant RVERTICAL_TIGHTNESS_FLAGS=>12;my%_index_map;$_index_map{jmax}=JMAX;$_index_map{jmax_original_line}=JMAX_ORIGINAL_LINE;$_index_map{rtokens}=RTOKENS;$_index_map{rfields}=RFIELDS;$_index_map{rpatterns}=RPATTERNS;$_index_map{indentation}=INDENTATION;$_index_map{leading_space_count}=LEADING_SPACE_COUNT;$_index_map{outdent_long_lines}=OUTDENT_LONG_LINES;$_index_map{list_type}=LIST_TYPE;$_index_map{is_hanging_side_comment}=IS_HANGING_SIDE_COMMENT;$_index_map{ralignments}=RALIGNMENTS;$_index_map{maximum_line_length}=MAXIMUM_LINE_LENGTH;$_index_map{rvertical_tightness_flags}=RVERTICAL_TIGHTNESS_FLAGS;my@_default_data=();$_default_data[JMAX]=undef;$_default_data[JMAX_ORIGINAL_LINE]=undef;$_default_data[RTOKENS]=undef;$_default_data[RFIELDS]=undef;$_default_data[RPATTERNS]=undef;$_default_data[INDENTATION]=undef;$_default_data[LEADING_SPACE_COUNT]=undef;$_default_data[OUTDENT_LONG_LINES]=undef;$_default_data[LIST_TYPE]=undef;$_default_data[IS_HANGING_SIDE_COMMENT]=undef;$_default_data[RALIGNMENTS]=[];$_default_data[MAXIMUM_LINE_LENGTH]=undef;$_default_data[RVERTICAL_TIGHTNESS_FLAGS]=undef;{my$_count=0;sub get_count {$_count}sub _increment_count {++$_count}sub _decrement_count {--$_count}}sub new {my ($caller,%arg)=@_;my$caller_is_obj=ref($caller);my$class=$caller_is_obj || $caller;no strict "refs";my$self=bless [],$class;$self->[RALIGNMENTS]=[];my$index;for (keys%_index_map){$index=$_index_map{$_};if (exists$arg{$_}){$self->[$index]=$arg{$_}}elsif ($caller_is_obj){$self->[$index]=$caller->[$index]}else {$self->[$index]=$_default_data[$index]}}$self->_increment_count();return$self}sub DESTROY {$_[0]->_decrement_count()}sub get_jmax {$_[0]->[JMAX]}sub get_jmax_original_line {$_[0]->[JMAX_ORIGINAL_LINE]}sub get_rtokens {$_[0]->[RTOKENS]}sub get_rfields {$_[0]->[RFIELDS]}sub get_rpatterns {$_[0]->[RPATTERNS]}sub get_indentation {$_[0]->[INDENTATION]}sub get_leading_space_count {$_[0]->[LEADING_SPACE_COUNT]}sub get_outdent_long_lines {$_[0]->[OUTDENT_LONG_LINES]}sub get_list_type {$_[0]->[LIST_TYPE]}sub get_is_hanging_side_comment {$_[0]->[IS_HANGING_SIDE_COMMENT]}sub get_rvertical_tightness_flags {$_[0]->[RVERTICAL_TIGHTNESS_FLAGS]}sub set_column {$_[0]->[RALIGNMENTS]->[$_[1]]->set_column($_[2])}sub get_alignment {$_[0]->[RALIGNMENTS]->[$_[1]]}sub get_alignments {@{$_[0]->[RALIGNMENTS]}}sub get_column {$_[0]->[RALIGNMENTS]->[$_[1]]->get_column()}sub get_starting_column {$_[0]->[RALIGNMENTS]->[$_[1]]->get_starting_column()}sub increment_column {$_[0]->[RALIGNMENTS]->[$_[1]]->increment_column($_[2])}sub set_alignments {my$self=shift;@{$self->[RALIGNMENTS]}=@_}sub current_field_width {my$self=shift;my ($j)=@_;if ($j==0){return$self->get_column($j)}else {return$self->get_column($j)- $self->get_column($j - 1)}}sub field_width_growth {my$self=shift;my$j=shift;return$self->get_column($j)- $self->get_starting_column($j)}sub starting_field_width {my$self=shift;my$j=shift;if ($j==0){return$self->get_starting_column($j)}else {return$self->get_starting_column($j)- $self->get_starting_column($j - 1)}}sub increase_field_width {my$self=shift;my ($j,$pad)=@_;my$jmax=$self->get_jmax();for my$k ($j .. $jmax){$self->increment_column($k,$pad)}}sub get_available_space_on_right {my$self=shift;my$jmax=$self->get_jmax();return$self->[MAXIMUM_LINE_LENGTH]- $self->get_column($jmax)}sub set_jmax {$_[0]->[JMAX]=$_[1]}sub set_jmax_original_line {$_[0]->[JMAX_ORIGINAL_LINE]=$_[1]}sub set_rtokens {$_[0]->[RTOKENS]=$_[1]}sub set_rfields {$_[0]->[RFIELDS]=$_[1]}sub set_rpatterns {$_[0]->[RPATTERNS]=$_[1]}sub set_indentation {$_[0]->[INDENTATION]=$_[1]}sub set_leading_space_count {$_[0]->[LEADING_SPACE_COUNT]=$_[1]}sub set_outdent_long_lines {$_[0]->[OUTDENT_LONG_LINES]=$_[1]}sub set_list_type {$_[0]->[LIST_TYPE]=$_[1]}sub set_is_hanging_side_comment {$_[0]->[IS_HANGING_SIDE_COMMENT]=$_[1]}sub set_alignment {$_[0]->[RALIGNMENTS]->[$_[1]]=$_[2]}}package Perl::Tidy::VerticalAligner::Alignment;{use strict;use constant COLUMN=>0;use constant STARTING_COLUMN=>1;use constant MATCHING_TOKEN=>2;use constant STARTING_LINE=>3;use constant ENDING_LINE=>4;use constant SAVED_COLUMN=>5;use constant SERIAL_NUMBER=>6;my%_index_map;$_index_map{column}=COLUMN;$_index_map{starting_column}=STARTING_COLUMN;$_index_map{matching_token}=MATCHING_TOKEN;$_index_map{starting_line}=STARTING_LINE;$_index_map{ending_line}=ENDING_LINE;$_index_map{saved_column}=SAVED_COLUMN;$_index_map{serial_number}=SERIAL_NUMBER;my@_default_data=();$_default_data[COLUMN]=undef;$_default_data[STARTING_COLUMN]=undef;$_default_data[MATCHING_TOKEN]=undef;$_default_data[STARTING_LINE]=undef;$_default_data[ENDING_LINE]=undef;$_default_data[SAVED_COLUMN]=undef;$_default_data[SERIAL_NUMBER]=undef;{my$_count=0;sub get_count {$_count}sub _increment_count {++$_count}sub _decrement_count {--$_count}}sub new {my ($caller,%arg)=@_;my$caller_is_obj=ref($caller);my$class=$caller_is_obj || $caller;no strict "refs";my$self=bless [],$class;for (keys%_index_map){my$index=$_index_map{$_};if (exists$arg{$_}){$self->[$index]=$arg{$_}}elsif ($caller_is_obj){$self->[$index]=$caller->[$index]}else {$self->[$index]=$_default_data[$index]}}$self->_increment_count();return$self}sub DESTROY {$_[0]->_decrement_count()}sub get_column {return $_[0]->[COLUMN]}sub get_starting_column {return $_[0]->[STARTING_COLUMN]}sub get_matching_token {return $_[0]->[MATCHING_TOKEN]}sub get_starting_line {return $_[0]->[STARTING_LINE]}sub get_ending_line {return $_[0]->[ENDING_LINE]}sub get_serial_number {return $_[0]->[SERIAL_NUMBER]}sub set_column {$_[0]->[COLUMN]=$_[1]}sub set_starting_column {$_[0]->[STARTING_COLUMN]=$_[1]}sub set_matching_token {$_[0]->[MATCHING_TOKEN]=$_[1]}sub set_starting_line {$_[0]->[STARTING_LINE]=$_[1]}sub set_ending_line {$_[0]->[ENDING_LINE]=$_[1]}sub increment_column {$_[0]->[COLUMN]+= $_[1]}sub save_column {$_[0]->[SAVED_COLUMN]=$_[0]->[COLUMN]}sub restore_column {$_[0]->[COLUMN]=$_[0]->[SAVED_COLUMN]}}package Perl::Tidy::VerticalAligner;BEGIN {use constant VALIGN_DEBUG_FLAG_APPEND=>0;use constant VALIGN_DEBUG_FLAG_APPEND0=>0;use constant VALIGN_DEBUG_FLAG_TERNARY=>0;use constant VALIGN_DEBUG_FLAG_TABS=>0;my$debug_warning=sub {print STDOUT "VALIGN_DEBUGGING with key $_[0]\n"};VALIGN_DEBUG_FLAG_APPEND && $debug_warning->('APPEND');VALIGN_DEBUG_FLAG_APPEND0 && $debug_warning->('APPEND0');VALIGN_DEBUG_FLAG_TERNARY && $debug_warning->('TERNARY');VALIGN_DEBUG_FLAG_TABS && $debug_warning->('TABS')}use vars qw($vertical_aligner_self $current_line $maximum_alignment_index $ralignment_list $maximum_jmax_seen $minimum_jmax_seen $previous_minimum_jmax_seen $previous_maximum_jmax_seen $maximum_line_index $group_level $group_type $group_maximum_gap $marginal_match $last_level_written $last_leading_space_count $extra_indent_ok $zero_count @group_lines $last_comment_column $last_side_comment_line_number $last_side_comment_length $last_side_comment_level $outdented_line_count $first_outdented_line_at $last_outdented_line_at $diagnostics_object $logger_object $file_writer_object @side_comment_history $comment_leading_space_count $is_matching_terminal_line $consecutive_block_comments $cached_line_text $cached_line_type $cached_line_flag $cached_seqno $cached_line_valid $cached_line_leading_space_count $cached_seqno_string $valign_buffer_filling @valign_buffer $seqno_string $last_nonblank_seqno_string $rOpts $rOpts_maximum_line_length $rOpts_variable_maximum_line_length $rOpts_continuation_indentation $rOpts_indent_columns $rOpts_tabs $rOpts_entab_leading_whitespace $rOpts_valign $rOpts_fixed_position_side_comment $rOpts_minimum_space_to_comment);sub initialize {my$class;($class,$rOpts,$file_writer_object,$logger_object,$diagnostics_object)=@_;$ralignment_list=[];$group_level=0;$last_level_written=-1;$extra_indent_ok=0;$last_side_comment_length=0;$maximum_jmax_seen=0;$minimum_jmax_seen=0;$previous_minimum_jmax_seen=0;$previous_maximum_jmax_seen=0;@group_lines=();$outdented_line_count=0;$first_outdented_line_at=0;$last_outdented_line_at=0;$last_side_comment_line_number=0;$last_side_comment_level=-1;$is_matching_terminal_line=0;$side_comment_history[0]=[-300,0 ];$side_comment_history[1]=[-200,0 ];$side_comment_history[2]=[-100,0 ];$cached_line_text="";$cached_line_type=0;$cached_line_flag=0;$cached_seqno=0;$cached_line_valid=0;$cached_line_leading_space_count=0;$cached_seqno_string="";$seqno_string="";$last_nonblank_seqno_string="";$rOpts_indent_columns=$rOpts->{'indent-columns'};$rOpts_tabs=$rOpts->{'tabs'};$rOpts_entab_leading_whitespace=$rOpts->{'entab-leading-whitespace'};$rOpts_fixed_position_side_comment=$rOpts->{'fixed-position-side-comment'};$rOpts_minimum_space_to_comment=$rOpts->{'minimum-space-to-comment'};$rOpts_maximum_line_length=$rOpts->{'maximum-line-length'};$rOpts_variable_maximum_line_length=$rOpts->{'variable-maximum-line-length'};$rOpts_valign=$rOpts->{'valign'};$consecutive_block_comments=0;forget_side_comment();initialize_for_new_group();$vertical_aligner_self={};bless$vertical_aligner_self,$class;return$vertical_aligner_self}sub initialize_for_new_group {$maximum_line_index=-1;$maximum_alignment_index=-1;$zero_count=0;$current_line=undef;$group_maximum_gap=0;$group_type="";$marginal_match=0;$comment_leading_space_count=0;$last_leading_space_count=0}sub write_diagnostics {if ($diagnostics_object){$diagnostics_object->write_diagnostics(@_)}}sub warning {if ($logger_object){$logger_object->warning(@_)}}sub write_logfile_entry {if ($logger_object){$logger_object->write_logfile_entry(@_)}}sub report_definite_bug {if ($logger_object){$logger_object->report_definite_bug()}}sub get_SPACES {my$indentation=shift;return ref($indentation)? $indentation->get_SPACES(): $indentation}sub get_RECOVERABLE_SPACES {my$indentation=shift;return ref($indentation)? $indentation->get_RECOVERABLE_SPACES(): 0}sub get_STACK_DEPTH {my$indentation=shift;return ref($indentation)? $indentation->get_STACK_DEPTH(): 0}sub make_alignment {my ($col,$token)=@_;++$maximum_alignment_index;my$alignment=new Perl::Tidy::VerticalAligner::Alignment(column=>$col,starting_column=>$col,matching_token=>$token,starting_line=>$maximum_line_index,ending_line=>$maximum_line_index,serial_number=>$maximum_alignment_index,);$ralignment_list->[$maximum_alignment_index]=$alignment;return$alignment}sub dump_alignments {print STDOUT "Current Alignments:\ni\ttoken\tstarting_column\tcolumn\tstarting_line\tending_line\n";for my$i (0 .. $maximum_alignment_index){my$column=$ralignment_list->[$i]->get_column();my$starting_column=$ralignment_list->[$i]->get_starting_column();my$matching_token=$ralignment_list->[$i]->get_matching_token();my$starting_line=$ralignment_list->[$i]->get_starting_line();my$ending_line=$ralignment_list->[$i]->get_ending_line();print STDOUT "$i\t$matching_token\t$starting_column\t$column\t$starting_line\t$ending_line\n"}}sub save_alignment_columns {for my$i (0 .. $maximum_alignment_index){$ralignment_list->[$i]->save_column()}}sub restore_alignment_columns {for my$i (0 .. $maximum_alignment_index){$ralignment_list->[$i]->restore_column()}}sub forget_side_comment {$last_comment_column=0}sub maximum_line_length_for_level {my$maximum_line_length=$rOpts_maximum_line_length;if ($rOpts_variable_maximum_line_length){my$level=shift;if ($level < 0){$level=0}$maximum_line_length += $level * $rOpts_indent_columns}return$maximum_line_length}sub valign_input {my ($level,$level_end,$indentation,$rfields,$rtokens,$rpatterns,$is_forced_break,$outdent_long_lines,$is_terminal_ternary,$is_terminal_statement,$do_not_pad,$rvertical_tightness_flags,$level_jump,)=@_;my$jmax=$#{$rfields};my$leading_space_count=get_SPACES($indentation);my$is_outdented=$last_leading_space_count > $leading_space_count;$last_leading_space_count=$leading_space_count;my$is_hanging_side_comment=($jmax==1 && $rtokens->[0]eq '#' && $rfields->[0]=~ /^\s*$/);$is_outdented=0 if$is_hanging_side_comment;my$is_block_comment=($jmax==0 && $rfields->[0]=~ /^#/);if ($is_block_comment){$consecutive_block_comments++}else {if ($consecutive_block_comments > 1){forget_side_comment()}$consecutive_block_comments=0}VALIGN_DEBUG_FLAG_APPEND0 && do {print STDOUT "APPEND0: entering lines=$maximum_line_index new #fields= $jmax, leading_count=$leading_space_count last_cmt=$last_comment_column force=$is_forced_break\n"};if ($rvertical_tightness_flags){if ($maximum_line_index <= 0 && $cached_line_type && $cached_seqno && $rvertical_tightness_flags->[2]&& $rvertical_tightness_flags->[2]==$cached_seqno){$rvertical_tightness_flags->[3]||= 1;$cached_line_valid ||= 1}}if ($cached_line_type==3 && $maximum_line_index < 0 && $cached_line_flag < 2 && $level_jump!=0){$cached_line_valid=0}if ($do_not_pad){my_flush()}if ($level < 0){$level=0}if ($level!=$group_level || $is_outdented ||!$rOpts_valign){$extra_indent_ok=($level < $group_level && $last_level_written < $group_level);my_flush();$extra_indent_ok=($is_terminal_statement && $level > $group_level);$group_level=$level;$leading_space_count=get_SPACES($indentation)}my$is_blank_line="";if ($group_type eq 'COMMENT'){if (($is_block_comment && $outdent_long_lines && $leading_space_count==$comment_leading_space_count)|| $is_blank_line){$group_lines[++$maximum_line_index ]=$rfields->[0];return}else {my_flush()}}my$j_terminal_match;if ($is_terminal_ternary && $current_line){$j_terminal_match=fix_terminal_ternary($rfields,$rtokens,$rpatterns);$jmax=@{$rfields}- 1}if ($rfields->[0]=~ /^else\s*$/ && $current_line && $level_jump==0){$j_terminal_match=fix_terminal_else($rfields,$rtokens,$rpatterns);$jmax=@{$rfields}- 1}if ($jmax <= 0){$zero_count++;if ($maximum_line_index >= 0 &&!get_RECOVERABLE_SPACES($group_lines[0]->get_indentation())){if ($group_lines[0]->get_jmax()> 1){my_flush()}elsif (($zero_count > 3)|| (($leading_space_count + length($$rfields[0]))> $group_lines[0]->get_column(0))){my_flush()}}if ($is_block_comment && $outdent_long_lines && $maximum_line_index < 0){$group_type='COMMENT';$comment_leading_space_count=$leading_space_count;$group_lines[++$maximum_line_index ]=$rfields->[0];return}if ($maximum_line_index < 0 &&!get_RECOVERABLE_SPACES($indentation)){valign_output_step_B($leading_space_count,$$rfields[0],0,$outdent_long_lines,$rvertical_tightness_flags,$level);return}}else {$zero_count=0}if ($jmax > 0 && ($#{$rtokens}!=($jmax - 1))){warning("Program bug in Perl::Tidy::VerticalAligner - number of tokens = $#{$rtokens} should be one less than number of fields: $#{$rfields})\n");report_definite_bug()}my$new_line=new Perl::Tidy::VerticalAligner::Line(jmax=>$jmax,jmax_original_line=>$jmax,rtokens=>$rtokens,rfields=>$rfields,rpatterns=>$rpatterns,indentation=>$indentation,leading_space_count=>$leading_space_count,outdent_long_lines=>$outdent_long_lines,list_type=>"",is_hanging_side_comment=>$is_hanging_side_comment,maximum_line_length=>maximum_line_length_for_level($level),rvertical_tightness_flags=>$rvertical_tightness_flags,);my$col_matching_terminal=0;if (defined($j_terminal_match)){$col_matching_terminal=$current_line->get_column($j_terminal_match);$is_matching_terminal_line=1}make_side_comment($new_line,$level_end);if ($is_forced_break){decide_if_list($new_line)}if ($current_line){join_hanging_comment($new_line,$current_line)if$is_hanging_side_comment;eliminate_old_fields($new_line,$current_line);eliminate_new_fields($new_line,$current_line);check_match($new_line,$current_line);if ($current_line){check_fit($new_line,$current_line)}}add_to_group($new_line);$current_line=$new_line if ($maximum_line_index==0);if (defined($j_terminal_match)){if ($maximum_line_index==0){my$col_now=$current_line->get_column($j_terminal_match);my$pad=$col_matching_terminal - $col_now;my$padding_available=$current_line->get_available_space_on_right();if ($pad > 0 && $pad <= $padding_available){$current_line->increase_field_width($j_terminal_match,$pad)}}my_flush();$is_matching_terminal_line=0}VALIGN_DEBUG_FLAG_APPEND && do {print STDOUT "APPEND fields:";dump_array(@$rfields);print STDOUT "APPEND tokens:";dump_array(@$rtokens);print STDOUT "APPEND patterns:";dump_array(@$rpatterns);dump_alignments()};return}sub join_hanging_comment {my$line=shift;my$jmax=$line->get_jmax();return 0 unless$jmax==1;my$rtokens=$line->get_rtokens();return 0 unless $$rtokens[0]eq '#';my$rfields=$line->get_rfields();return 0 unless $$rfields[0]=~ /^\s*$/;my$old_line=shift;my$maximum_field_index=$old_line->get_jmax();return 0 unless$maximum_field_index > $jmax;my$rpatterns=$line->get_rpatterns();$line->set_is_hanging_side_comment(1);$jmax=$maximum_field_index;$line->set_jmax($jmax);$$rfields[$jmax]=$$rfields[1];$$rtokens[$jmax - 1 ]=$$rtokens[0];$$rpatterns[$jmax - 1 ]=$$rpatterns[0];for (my$j=1 ;$j < $jmax ;$j++ ){$$rfields[$j]=" ";$$rtokens[$j - 1 ]="";$$rpatterns[$j - 1 ]=""}return 1}sub eliminate_old_fields {my$new_line=shift;my$jmax=$new_line->get_jmax();if ($jmax > $maximum_jmax_seen){$maximum_jmax_seen=$jmax}if ($jmax < $minimum_jmax_seen){$minimum_jmax_seen=$jmax}return unless ($maximum_line_index==0);my$old_line=shift;my$maximum_field_index=$old_line->get_jmax();return unless$maximum_field_index > $jmax;my$case=1;my$old_rtokens=$old_line->get_rtokens();my$rtokens=$new_line->get_rtokens();my$rpatterns=$new_line->get_rpatterns();my$old_rpatterns=$old_line->get_rpatterns();if ($rtokens->[0]=~ /^=\d*$/ && $old_rtokens->[0]eq $rtokens->[0]&& $old_rpatterns->[0]eq $rpatterns->[0]){$case=2}return unless ($case!=1 || $maximum_field_index - 2 <= $jmax);my$old_rfields=$old_line->get_rfields();return if ($case==1 && length($$old_rfields[$maximum_field_index])==0);my$rfields=$new_line->get_rfields();my$hid_equals=0;my@new_alignments=();my@new_fields=();my@new_matching_patterns=();my@new_matching_tokens=();my$j=0;my$k;my$current_field='';my$current_pattern='';my$in_match=0;for ($k=0 ;$k < $maximum_field_index ;$k++ ){$current_field .= $$old_rfields[$k];$current_pattern .= $$old_rpatterns[$k];last if ($j > $jmax - 1);if ($$old_rtokens[$k]eq $$rtokens[$j]){$in_match=1;$new_fields[$j]=$current_field;$new_matching_patterns[$j]=$current_pattern;$current_field='';$current_pattern='';$new_matching_tokens[$j]=$$old_rtokens[$k];$new_alignments[$j]=$old_line->get_alignment($k);$j++}else {if ($$old_rtokens[$k]=~ /^\=\d*$/){last if ($case==2);$hid_equals=1}last if ($in_match && $case==1)}}if (($j==$jmax)&& ($current_field eq '')&& ($case!=1 || $hid_equals)){$k=$maximum_field_index;$current_field .= $$old_rfields[$k];$current_pattern .= $$old_rpatterns[$k];$new_fields[$j]=$current_field;$new_matching_patterns[$j]=$current_pattern;$new_alignments[$j]=$old_line->get_alignment($k);$maximum_field_index=$j;$old_line->set_alignments(@new_alignments);$old_line->set_jmax($jmax);$old_line->set_rtokens(\@new_matching_tokens);$old_line->set_rfields(\@new_fields);$old_line->set_rpatterns(\@$rpatterns)}}sub make_side_comment {my$new_line=shift;my$level_end=shift;my$jmax=$new_line->get_jmax();my$rtokens=$new_line->get_rtokens();if (($jmax==0)|| ($$rtokens[$jmax - 1 ]ne '#')){my$rfields=$new_line->get_rfields();my$rpatterns=$new_line->get_rpatterns();$$rtokens[$jmax]='#';$$rfields[++$jmax ]='';$$rpatterns[$jmax]='#';$new_line->set_jmax($jmax);$new_line->set_jmax_original_line($jmax)}else {my$line_number=$vertical_aligner_self->get_output_line_number();my$rfields=$new_line->get_rfields();if ($line_number - $last_side_comment_line_number > 12 || ($level_end < $last_side_comment_level && $$rfields[0]=~ /^}/)){forget_side_comment()}$last_side_comment_line_number=$line_number;$last_side_comment_level=$level_end}}sub decide_if_list {my$line=shift;my$rtokens=$line->get_rtokens();my$test_token=$$rtokens[0];if ($test_token =~ /^(\,|=>)/){my$list_type=$test_token;my$jmax=$line->get_jmax();for (1 .. $jmax - 2){if ($$rtokens[$_]!~ /^(\,|=>|\{)/){$list_type="";last}}$line->set_list_type($list_type)}}sub eliminate_new_fields {return unless ($maximum_line_index >= 0);my ($new_line,$old_line)=@_;my$jmax=$new_line->get_jmax();my$old_rtokens=$old_line->get_rtokens();my$rtokens=$new_line->get_rtokens();my$is_assignment=($rtokens->[0]=~ /^=\d*$/ && ($old_rtokens->[0]eq $rtokens->[0]));return unless ($is_assignment || $previous_maximum_jmax_seen <= $jmax);my$maximum_field_index=$old_line->get_jmax();return unless ($maximum_field_index < $jmax);unless ($is_assignment){return unless ($old_line->get_jmax_original_line()==$minimum_jmax_seen);return unless ($maximum_field_index > 1)&& ($new_line->get_list_type()!~ /^,/)}my$rfields=$new_line->get_rfields();my$rpatterns=$new_line->get_rpatterns();my$old_rpatterns=$old_line->get_rpatterns();my$match=1;my$k;for ($k=0 ;$k < $maximum_field_index - 1 ;$k++ ){if (($$old_rtokens[$k]ne $$rtokens[$k])|| ($$old_rpatterns[$k]ne $$rpatterns[$k])){$match=0;last}}if ($match){for$k ($maximum_field_index .. $jmax - 1){$$rfields[$maximum_field_index - 1 ].= $$rfields[$k];$$rfields[$k]="";$$rpatterns[$maximum_field_index - 1 ].= $$rpatterns[$k];$$rpatterns[$k]=""}$$rtokens[$maximum_field_index - 1 ]='#';$$rfields[$maximum_field_index]=$$rfields[$jmax];$$rpatterns[$maximum_field_index]=$$rpatterns[$jmax];$jmax=$maximum_field_index}$new_line->set_jmax($jmax)}sub fix_terminal_ternary {my ($rfields,$rtokens,$rpatterns)=@_;my$jmax=@{$rfields}- 1;my$old_line=$group_lines[$maximum_line_index];my$rfields_old=$old_line->get_rfields();my$rpatterns_old=$old_line->get_rpatterns();my$rtokens_old=$old_line->get_rtokens();my$maximum_field_index=$old_line->get_jmax();my ($jquestion);my$depth_question;my$pad="";for (my$j=0 ;$j < $maximum_field_index ;$j++ ){my$tok=$rtokens_old->[$j];if ($tok =~ /^\?(\d+)$/){$depth_question=$1;next unless ($depth_question eq $group_level);$jquestion=$j;if ($rfields_old->[$j + 1 ]=~ /^(\?\s*)/){$pad=" " x length($1)}else {return}last}}return unless (defined($jquestion));my$jadd=$jquestion;my@fields=@{$rfields};my@patterns=@{$rpatterns};my@tokens=@{$rtokens};VALIGN_DEBUG_FLAG_TERNARY && do {local $"='><';print STDOUT "CURRENT FIELDS=<@{$rfields_old}>\n";print STDOUT "CURRENT TOKENS=<@{$rtokens_old}>\n";print STDOUT "CURRENT PATTERNS=<@{$rpatterns_old}>\n";print STDOUT "UNMODIFIED FIELDS=<@{$rfields}>\n";print STDOUT "UNMODIFIED TOKENS=<@{$rtokens}>\n";print STDOUT "UNMODIFIED PATTERNS=<@{$rpatterns}>\n"};if ($fields[0]=~ /^(:\s*)(.*)$/){my ($colon,$therest)=($1,$2);if ($therest){my$field1=shift@fields;unshift@fields,($colon,$pad .$therest);return unless ($patterns[0]=~ s/^\:/?/);unshift(@tokens,@{$rtokens_old}[0 .. $jquestion ]);unshift(@patterns,@{$rpatterns_old}[0 .. $jquestion ]);splice(@fields,1,0,('')x $jadd)if$jadd}else {return unless ($jmax > 0 && $tokens[0]ne '#');$patterns[1]="?b" .$patterns[1];$fields[1]=$pad .$fields[1];splice(@tokens,0,1,@{$rtokens_old}[0 .. $jquestion ]);splice(@patterns,1,0,@{$rpatterns_old}[1 .. $jquestion ]);splice(@fields,1,0,('')x $jadd)if$jadd}}else {$patterns[0]='?' .'b' .$patterns[0];unshift(@tokens,@{$rtokens_old}[0 .. $jquestion ]);unshift(@patterns,@{$rpatterns_old}[0 .. $jquestion ]);$jadd=$jquestion + 1;$fields[0]=$pad .$fields[0];splice(@fields,0,0,('')x $jadd)if$jadd}VALIGN_DEBUG_FLAG_TERNARY && do {local $"='><';print STDOUT "MODIFIED TOKENS=<@tokens>\n";print STDOUT "MODIFIED PATTERNS=<@patterns>\n";print STDOUT "MODIFIED FIELDS=<@fields>\n"};@{$rfields}=@fields;@{$rtokens}=@tokens;@{$rpatterns}=@patterns;return$jquestion}sub fix_terminal_else {my ($rfields,$rtokens,$rpatterns)=@_;my$jmax=@{$rfields}- 1;return unless ($jmax > 0);my$rfields_old=$current_line->get_rfields();return unless ($rfields_old->[0]=~ /^(if|elsif|unless)\s*$/);my$tok_brace=$rtokens->[0];my$depth_brace;if ($tok_brace =~ /^\{(\d+)/){$depth_brace=$1}else {return}my$rpatterns_old=$current_line->get_rpatterns();my$rtokens_old=$current_line->get_rtokens();my$maximum_field_index=$current_line->get_jmax();my$jparen=0;my$tok_paren='(' .$depth_brace;my$tok_test=$rtokens_old->[$jparen];return unless ($tok_test eq $tok_paren);my ($jbrace);for (my$j=1 ;$j < $maximum_field_index ;$j++ ){my$tok=$rtokens_old->[$j];if ($tok eq $tok_brace){$jbrace=$j;last}}return unless (defined($jbrace));my$jadd=$jbrace - $jparen;splice(@{$rtokens},0,0,@{$rtokens_old}[$jparen .. $jbrace - 1 ]);splice(@{$rpatterns},1,0,@{$rpatterns_old}[$jparen + 1 .. $jbrace ]);splice(@{$rfields},1,0,('')x $jadd);return$jbrace unless ($rfields_old->[0]=~ /^case\s*$/)}{my%is_good_alignment;BEGIN {@_=qw({ ? => =);push @_,(',');@is_good_alignment{@_}=(1)x scalar(@_)}sub check_match {my$new_line=shift;my$old_line=shift;my$jmax=$new_line->get_jmax();my$maximum_field_index=$old_line->get_jmax();if ($jmax > $maximum_field_index){goto NO_MATCH}if (($maximum_field_index > $jmax)&& (($previous_minimum_jmax_seen < $jmax)|| ($old_line->get_jmax_original_line()!=$maximum_jmax_seen))){goto NO_MATCH}my$jmax_original_line=$new_line->get_jmax_original_line();my$is_hanging_side_comment=$new_line->get_is_hanging_side_comment();my$rtokens=$new_line->get_rtokens();my$rfields=$new_line->get_rfields();my$rpatterns=$new_line->get_rpatterns();my$list_type=$new_line->get_list_type();my$group_list_type=$old_line->get_list_type();my$old_rpatterns=$old_line->get_rpatterns();my$old_rtokens=$old_line->get_rtokens();my$jlimit=$jmax - 1;if ($maximum_field_index > $jmax){$jlimit=$jmax_original_line;--$jlimit unless (length($new_line->get_rfields()->[$jmax]))}if ($group_list_type && ($list_type eq $group_list_type)){for my$j (0 .. $jlimit){my$old_tok=$$old_rtokens[$j];next unless$old_tok;my$new_tok=$$rtokens[$j];next unless$new_tok;goto NO_MATCH if ($old_tok =~ /^=>/ && $new_tok =~ /^,/ || $new_tok =~ /^=>/ && $old_tok =~ /^,/)}}elsif (!$is_hanging_side_comment){my$leading_space_count=$new_line->get_leading_space_count();my$max_pad=0;my$min_pad=0;my$saw_good_alignment;for my$j (0 .. $jlimit){my$old_tok=$$old_rtokens[$j];my$new_tok=$$rtokens[$j];my$alignment_token=$new_tok;if ($alignment_token =~ /^([^\d]+)/){$alignment_token=$1}my$tokens_match=$new_tok eq $old_tok || ($new_tok =~ /^,\d*\+\:/ && $old_tok =~ /^,\d*\+\?/);if (!$tokens_match){if ($j==$jlimit && ($j > 0 || $old_tok =~ /^,/)){$marginal_match=1 if ($marginal_match==0 && $maximum_line_index==0);last}goto NO_MATCH}my$pad=length($$rfields[$j])- $old_line->current_field_width($j);if ($j==0){$pad += $leading_space_count}if ($alignment_token ne '#'){if ($pad > $max_pad){$max_pad=$pad}if ($pad < $min_pad){$min_pad=$pad}}if ($is_good_alignment{$alignment_token}){$saw_good_alignment=1}if ($$old_rpatterns[$j]ne $$rpatterns[$j]){$marginal_match=1 if ($marginal_match==0 && $maximum_line_index==0);if ($alignment_token eq ','){goto NO_MATCH unless ($new_tok =~ /[A-Za-z]/)}elsif ($alignment_token eq '('){if ($pad!=0){goto NO_MATCH}}elsif ($alignment_token eq '='){if (substr($$old_rpatterns[$j],0,1)ne substr($$rpatterns[$j],0,1)){goto NO_MATCH}elsif ($maximum_line_index==0){$marginal_match=2}}}if ($maximum_field_index > $jmax){if ($pad > 0){goto NO_MATCH}}}if ($marginal_match==1 && $jmax==$maximum_field_index && ($saw_good_alignment || ($max_pad < 3 && $min_pad > -3))){$marginal_match=0}}if ($maximum_field_index > $jmax){my$comment=$$rfields[$jmax];for$jmax ($jlimit .. $maximum_field_index){$$rtokens[$jmax]=$$old_rtokens[$jmax];$$rfields[++$jmax ]='';$$rpatterns[$jmax]=$$old_rpatterns[$jmax]}$$rfields[$jmax]=$comment;$new_line->set_jmax($jmax)}return;NO_MATCH: my_flush();return}}sub check_fit {return unless ($maximum_line_index >= 0);my$new_line=shift;my$old_line=shift;my$jmax=$new_line->get_jmax();my$leading_space_count=$new_line->get_leading_space_count();my$is_hanging_side_comment=$new_line->get_is_hanging_side_comment();my$rtokens=$new_line->get_rtokens();my$rfields=$new_line->get_rfields();my$rpatterns=$new_line->get_rpatterns();my$group_list_type=$group_lines[0]->get_list_type();my$padding_so_far=0;my$padding_available=$old_line->get_available_space_on_right();save_alignment_columns();my ($j,$pad,$eight);my$maximum_field_index=$old_line->get_jmax();for$j (0 .. $jmax){$pad=length($$rfields[$j])- $old_line->current_field_width($j);if ($j==0){$pad += $leading_space_count}if ($pad < 0 && $group_maximum_gap < -$pad && $j > 0 && $j < $jmax - 1){$group_maximum_gap=-$pad}next if$pad < 0;if (($pad > $padding_available)){restore_alignment_columns();my_flush();last}next if ($jmax < $maximum_field_index && $j==$jmax - 1);$old_line->increase_field_width($j,$pad);$padding_available -= $pad;if ($pad > $group_maximum_gap && $j > 0 && $j < $jmax - 1){$group_maximum_gap=$pad}}}sub add_to_group {my$new_line=shift;$group_lines[++$maximum_line_index ]=$new_line;if ($maximum_line_index==0){my$jmax=$new_line->get_jmax();my$rfields=$new_line->get_rfields();my$rtokens=$new_line->get_rtokens();my$j;my$col=$new_line->get_leading_space_count();for$j (0 .. $jmax){$col += length($$rfields[$j]);my$token="";if ($j < $jmax){$token=$$rtokens[$j]}my$alignment=make_alignment($col,$token);$new_line->set_alignment($j,$alignment)}$maximum_jmax_seen=$jmax;$minimum_jmax_seen=$jmax}else {my@new_alignments=$group_lines[$maximum_line_index - 1 ]->get_alignments();$new_line->set_alignments(@new_alignments)}$previous_minimum_jmax_seen=$minimum_jmax_seen;$previous_maximum_jmax_seen=$maximum_jmax_seen}sub dump_array {local $"=')(';print STDOUT "(@_)\n"}sub flush {dump_valign_buffer();if ($maximum_line_index < 0){if ($cached_line_type){$seqno_string=$cached_seqno_string;valign_output_step_C($cached_line_text,$cached_line_leading_space_count,$last_level_written);$cached_line_type=0;$cached_line_text="";$cached_seqno_string=""}}else {my_flush()}}sub reduce_valign_buffer_indentation {my ($diff)=@_;if ($valign_buffer_filling && $diff){my$max_valign_buffer=@valign_buffer;for (my$i=0 ;$i < $max_valign_buffer ;$i++ ){my ($line,$leading_space_count,$level)=@{$valign_buffer[$i]};my$ws=substr($line,0,$diff);if ((length($ws)==$diff)&& $ws =~ /^\s+$/){$line=substr($line,$diff)}if ($leading_space_count >= $diff){$leading_space_count -= $diff;$level=level_change($leading_space_count,$diff,$level)}$valign_buffer[$i]=[$line,$leading_space_count,$level ]}}}sub level_change {my ($leading_space_count,$diff,$level)=@_;if ($rOpts_indent_columns){my$olev=int(($leading_space_count + $diff)/ $rOpts_indent_columns);my$nlev=int($leading_space_count / $rOpts_indent_columns);$level -= ($olev - $nlev);if ($level < 0){$level=0}}return$level}sub dump_valign_buffer {if (@valign_buffer){for (@valign_buffer){valign_output_step_D(@{$_})}@valign_buffer=()}$valign_buffer_filling=""}sub my_flush {return if ($maximum_line_index < 0);if ($group_type eq 'COMMENT'){VALIGN_DEBUG_FLAG_APPEND0 && do {my ($a,$b,$c)=caller();print STDOUT "APPEND0: Flush called from $a $b $c for COMMENT group: lines=$maximum_line_index \n"};my$leading_space_count=$comment_leading_space_count;my$leading_string=get_leading_string($leading_space_count);my$max_excess=0;for my$i (0 .. $maximum_line_index){my$str=$group_lines[$i];my$excess=length($str)+ $leading_space_count - maximum_line_length_for_level($group_level);if ($excess > $max_excess){$max_excess=$excess}}if ($max_excess > 0){$leading_space_count -= $max_excess;if ($leading_space_count < 0){$leading_space_count=0}$last_outdented_line_at=$file_writer_object->get_output_line_number();unless ($outdented_line_count){$first_outdented_line_at=$last_outdented_line_at}$outdented_line_count += ($maximum_line_index + 1)}my$outdent_long_lines=0;for my$i (0 .. $maximum_line_index){valign_output_step_B($leading_space_count,$group_lines[$i],0,$outdent_long_lines,"",$group_level)}}else {VALIGN_DEBUG_FLAG_APPEND0 && do {my$group_list_type=$group_lines[0]->get_list_type();my ($a,$b,$c)=caller();my$maximum_field_index=$group_lines[0]->get_jmax();print STDOUT "APPEND0: Flush called from $a $b $c fields=$maximum_field_index list=$group_list_type lines=$maximum_line_index extra=$extra_indent_ok\n"};my$do_not_align=decide_if_aligned();$do_not_align=adjust_side_comment($do_not_align);my$extra_leading_spaces=get_extra_leading_spaces();my$group_leader_length=$group_lines[0]->get_leading_space_count();my$min_ci_gap=improve_continuation_indentation($do_not_align,$group_leader_length);for my$i (0 .. $maximum_line_index){my$line=$group_lines[$i];valign_output_step_A($line,$min_ci_gap,$do_not_align,$group_leader_length,$extra_leading_spaces)}}initialize_for_new_group()}sub decide_if_aligned {return unless$maximum_line_index==1;return if ($is_matching_terminal_line);my$group_list_type=$group_lines[0]->get_list_type();my$do_not_align=(!$group_list_type && ($marginal_match || $group_maximum_gap > 12 || $previous_maximum_jmax_seen!=$previous_minimum_jmax_seen));my$rfields=$group_lines[0]->get_rfields();my$maximum_field_index=$group_lines[0]->get_jmax();if ($do_not_align && ($maximum_line_index > 0)&& (length($$rfields[$maximum_field_index])> 0)){combine_fields();$do_not_align=0}return$do_not_align}sub adjust_side_comment {my$do_not_align=shift;my$have_side_comment=0;my$first_side_comment_line=-1;my$maximum_field_index=$group_lines[0]->get_jmax();for my$i (0 .. $maximum_line_index){my$line=$group_lines[$i];if (length($line->get_rfields()->[$maximum_field_index])){$have_side_comment=1;$first_side_comment_line=$i;last}}my$kmax=$maximum_field_index + 1;if ($have_side_comment){my$line=$group_lines[0];my$avail=$line->get_available_space_on_right();my$side_comment_column=$line->get_column($kmax - 2);my$move=$last_comment_column - $side_comment_column;if ($kmax > 0 &&!$do_not_align){if ($move > $avail){$move=$rOpts_minimum_space_to_comment - 1}my$min_move=$rOpts_minimum_space_to_comment - 1;if ($move >= 0 && $last_side_comment_length > 0 && ($first_side_comment_line==0)&& $group_level==$last_level_written){$min_move=0}if ($move < $min_move){$move=$min_move}if ($move > $avail){$move=$avail}if ($move > 0){$line->increase_field_width($maximum_field_index - 1,$move)}$last_comment_column=$line->get_column($kmax - 2)}else {if ($kmax > 0 && $move > 0 && $move < $avail){$line->increase_field_width($maximum_field_index - 1,$move);$do_not_align=0}else {forget_side_comment()}}}return$do_not_align}sub improve_continuation_indentation {my ($do_not_align,$group_leader_length)=@_;return 0;my$maximum_field_index=$group_lines[0]->get_jmax();my$min_ci_gap=maximum_line_length_for_level($group_level);if ($maximum_field_index > 1 &&!$do_not_align){for my$i (0 .. $maximum_line_index){my$line=$group_lines[$i];my$leading_space_count=$line->get_leading_space_count();my$rfields=$line->get_rfields();my$gap=$line->get_column(0)- $leading_space_count - length($$rfields[0]);if ($leading_space_count > $group_leader_length){if ($gap < $min_ci_gap){$min_ci_gap=$gap}}}if ($min_ci_gap >= maximum_line_length_for_level($group_level)){$min_ci_gap=0}}else {$min_ci_gap=0}return$min_ci_gap}sub valign_output_step_A {my ($line,$min_ci_gap,$do_not_align,$group_leader_length,$extra_leading_spaces)=@_;my$rfields=$line->get_rfields();my$leading_space_count=$line->get_leading_space_count();my$outdent_long_lines=$line->get_outdent_long_lines();my$maximum_field_index=$line->get_jmax();my$rvertical_tightness_flags=$line->get_rvertical_tightness_flags();if ($leading_space_count > $group_leader_length){$leading_space_count += $min_ci_gap}my$str=$$rfields[0];my$total_pad_count=0;my ($j,$pad);for$j (1 .. $maximum_field_index){last if (($j==$maximum_field_index)&& (!defined($$rfields[$j])|| (length($$rfields[$j])==0)));my$col=$line->get_column($j - 1);$pad=$col - (length($str)+ $leading_space_count);if ($do_not_align){$pad=($j < $maximum_field_index)? 0 : $rOpts_minimum_space_to_comment - 1}if ($rOpts_fixed_position_side_comment && $j==$maximum_field_index){my$newpad=$pad + $rOpts_fixed_position_side_comment - $col - 1;if ($newpad >= 0){$pad=$newpad}}if ($pad > 0){$total_pad_count += $pad}if (!defined $$rfields[$j]){write_diagnostics("UNDEFined field at j=$j\n")}if (length($$rfields[$j])> 0){$str .= ' ' x $total_pad_count;$total_pad_count=0;$str .= $$rfields[$j]}else {$total_pad_count=0}if ($j==$maximum_field_index){my$lineno=$file_writer_object->get_output_line_number();shift@side_comment_history;push@side_comment_history,[$lineno,$col ]}}my$side_comment_length=(length($$rfields[$maximum_field_index]));valign_output_step_B($leading_space_count + $extra_leading_spaces,$str,$side_comment_length,$outdent_long_lines,$rvertical_tightness_flags,$group_level)}sub get_extra_leading_spaces {my$extra_leading_spaces=0;if ($extra_indent_ok){my$object=$group_lines[0]->get_indentation();if (ref($object)){my$extra_indentation_spaces_wanted=get_RECOVERABLE_SPACES($object);my$i;for$i (1 .. $maximum_line_index){if ($object!=$group_lines[$i]->get_indentation()){$extra_indentation_spaces_wanted=0;last}}if ($extra_indentation_spaces_wanted){my$avail=$group_lines[0]->get_available_space_on_right();$extra_leading_spaces=($avail > $extra_indentation_spaces_wanted)? $extra_indentation_spaces_wanted : $avail;$object->permanently_decrease_AVAILABLE_SPACES(-$extra_leading_spaces)}}}return$extra_leading_spaces}sub combine_fields {my ($j,$k);my$maximum_field_index=$group_lines[0]->get_jmax();for ($j=0 ;$j <= $maximum_line_index ;$j++ ){my$line=$group_lines[$j];my$rfields=$line->get_rfields();for (1 .. $maximum_field_index - 1){$$rfields[0].= $$rfields[$_]}$$rfields[1]=$$rfields[$maximum_field_index];$line->set_jmax(1);$line->set_column(0,0);$line->set_column(1,0)}$maximum_field_index=1;for$j (0 .. $maximum_line_index){my$line=$group_lines[$j];my$rfields=$line->get_rfields();for$k (0 .. $maximum_field_index){my$pad=length($$rfields[$k])- $line->current_field_width($k);if ($k==0){$pad += $group_lines[$j]->get_leading_space_count()}if ($pad > 0){$line->increase_field_width($k,$pad)}}}}sub get_output_line_number {my$self=shift;1 + $maximum_line_index + $file_writer_object->get_output_line_number()}sub valign_output_step_B {my ($leading_space_count,$str,$side_comment_length,$outdent_long_lines,$rvertical_tightness_flags,$level)=@_;if ($outdent_long_lines){my$excess=length($str)- $side_comment_length + $leading_space_count - maximum_line_length_for_level($level);if ($excess > 0){$leading_space_count=0;$last_outdented_line_at=$file_writer_object->get_output_line_number();unless ($outdented_line_count){$first_outdented_line_at=$last_outdented_line_at}$outdented_line_count++}}my$leading_string=$leading_space_count > 0 ? (' ' x $leading_space_count): "";my ($open_or_close,$tightness_flag,$seqno,$valid,$seqno_beg,$seqno_end);if ($rvertical_tightness_flags){($open_or_close,$tightness_flag,$seqno,$valid,$seqno_beg,$seqno_end)=@{$rvertical_tightness_flags}}$seqno_string=$seqno_end;if (length($cached_line_text)){if (!$cached_line_valid){valign_output_step_C($cached_line_text,$cached_line_leading_space_count,$last_level_written)}elsif ($cached_line_type==1 || $cached_line_type==3){my$gap=$leading_space_count - length($cached_line_text);if ($cached_line_flag==1){if (defined($open_or_close)&& $open_or_close==1){$gap=-1}}if ($gap >= 0 && defined($seqno_beg)){$leading_string=$cached_line_text .' ' x $gap;$leading_space_count=$cached_line_leading_space_count;$seqno_string=$cached_seqno_string .':' .$seqno_beg;$level=$last_level_written}else {valign_output_step_C($cached_line_text,$cached_line_leading_space_count,$last_level_written)}}else {my$test_line=$cached_line_text .' ' x $cached_line_flag .$str;if ($seqno_beg && (($open_or_close==$cached_line_type)|| ($cached_line_type==2 && $open_or_close==4)|| (!$open_or_close && $cached_line_type==2))&& (length($test_line)<= maximum_line_length_for_level($last_level_written))){$seqno_string=$cached_seqno_string .':' .$seqno_beg;if ($str =~ /^\);/ && $cached_line_text =~ /^[\)\}\]\s]*$/){$seqno_string =~ s/^:+//;$last_nonblank_seqno_string =~ s/^:+//;$seqno_string =~ s/:+/:/g;$last_nonblank_seqno_string =~ s/:+/:/g;my$diff=$cached_line_leading_space_count - $leading_space_count;if ($diff > 0 && length($seqno_string)&& length($last_nonblank_seqno_string)==length($seqno_string)){my@seqno_last=(split ':',$last_nonblank_seqno_string);my@seqno_now=(split ':',$seqno_string);if ($seqno_now[-1]==$seqno_last[0]&& $seqno_now[0]==$seqno_last[-1]){my$ws=substr($test_line,0,$diff);if ((length($ws)==$diff)&& $ws =~ /^\s+$/){$test_line=substr($test_line,$diff);$cached_line_leading_space_count -= $diff;$last_level_written=level_change($cached_line_leading_space_count,$diff,$last_level_written);reduce_valign_buffer_indentation($diff)}}}}$str=$test_line;$leading_string="";$leading_space_count=$cached_line_leading_space_count;$level=$last_level_written}else {valign_output_step_C($cached_line_text,$cached_line_leading_space_count,$last_level_written)}}}$cached_line_type=0;$cached_line_text="";my$line=$leading_string .$str;if (!$open_or_close || $side_comment_length > 0){valign_output_step_C($line,$leading_space_count,$level)}else {$cached_line_text=$line;$cached_line_type=$open_or_close;$cached_line_flag=$tightness_flag;$cached_seqno=$seqno;$cached_line_valid=$valid;$cached_line_leading_space_count=$leading_space_count;$cached_seqno_string=$seqno_string}$last_level_written=$level;$last_side_comment_length=$side_comment_length;$extra_indent_ok=0}sub valign_output_step_C {my@args=@_;dump_valign_buffer()if ($seqno_string && $valign_buffer_filling);if ($valign_buffer_filling){push@valign_buffer,[@args]}else {valign_output_step_D(@args)}if ($seqno_string){$last_nonblank_seqno_string=$seqno_string;if ($seqno_string =~ /^\d+(\:+\d+)+$/ && $args[0]!~ /^[\}\)\]\:\?]/){$valign_buffer_filling=$seqno_string}}}sub valign_output_step_D {my ($line,$leading_space_count,$level)=@_;if ($leading_space_count > 0){if (!($rOpts_tabs || $rOpts_entab_leading_whitespace)|| $rOpts_indent_columns <= 0){}elsif ($rOpts_entab_leading_whitespace){my$space_count=$leading_space_count % $rOpts_entab_leading_whitespace;my$tab_count=int($leading_space_count / $rOpts_entab_leading_whitespace);my$leading_string="\t" x $tab_count .' ' x $space_count;if ($line =~ /^\s{$leading_space_count,$leading_space_count}/){substr($line,0,$leading_space_count)=$leading_string}else {VALIGN_DEBUG_FLAG_TABS && warning("Error entabbing in valign_output_step_D: expected count=$leading_space_count\n")}}else {my$leading_string=("\t" x $level);my$space_count=$leading_space_count - $level * $rOpts_indent_columns;if ($space_count < 0){if ($line !~ /^\s*#/){VALIGN_DEBUG_FLAG_TABS && warning("Error entabbing in valign_output_step_D: for level=$group_level count=$leading_space_count\n")}$leading_string=(' ' x $leading_space_count)}else {$leading_string .= (' ' x $space_count)}if ($line =~ /^\s{$leading_space_count,$leading_space_count}/){substr($line,0,$leading_space_count)=$leading_string}else {VALIGN_DEBUG_FLAG_TABS && warning("Error entabbing in valign_output_step_D: expected count=$leading_space_count\n")}}}$file_writer_object->write_code_line($line ."\n")}{my@leading_string_cache;sub get_leading_string {my$leading_whitespace_count=shift;if ($leading_whitespace_count <= 0){return ""}elsif ($leading_string_cache[$leading_whitespace_count]){return$leading_string_cache[$leading_whitespace_count]}my$leading_string;if (!($rOpts_tabs || $rOpts_entab_leading_whitespace)|| $rOpts_indent_columns <= 0){$leading_string=(' ' x $leading_whitespace_count)}elsif ($rOpts_entab_leading_whitespace){my$space_count=$leading_whitespace_count % $rOpts_entab_leading_whitespace;my$tab_count=int($leading_whitespace_count / $rOpts_entab_leading_whitespace);$leading_string="\t" x $tab_count .' ' x $space_count}else {$leading_string=("\t" x $group_level);my$space_count=$leading_whitespace_count - $group_level * $rOpts_indent_columns;if ($space_count < 0){VALIGN_DEBUG_FLAG_TABS && warning("Error in get_leading_string: for level=$group_level count=$leading_whitespace_count\n");$leading_string=(' ' x $leading_whitespace_count)}else {$leading_string .= (' ' x $space_count)}}$leading_string_cache[$leading_whitespace_count]=$leading_string;return$leading_string}}sub report_anything_unusual {my$self=shift;if ($outdented_line_count > 0){write_logfile_entry("$outdented_line_count long lines were outdented:\n");write_logfile_entry("  First at output line $first_outdented_line_at\n");if ($outdented_line_count > 1){write_logfile_entry("   Last at output line $last_outdented_line_at\n")}write_logfile_entry("  use -noll to prevent outdenting, -l=n to increase line length\n");write_logfile_entry("\n")}}package Perl::Tidy::FileWriter;use constant MAX_NAG_MESSAGES=>6;sub write_logfile_entry {my$self=shift;my$logger_object=$self->{_logger_object};if ($logger_object){$logger_object->write_logfile_entry(@_)}}sub new {my$class=shift;my ($line_sink_object,$rOpts,$logger_object)=@_;bless {_line_sink_object=>$line_sink_object,_logger_object=>$logger_object,_rOpts=>$rOpts,_output_line_number=>1,_consecutive_blank_lines=>0,_consecutive_nonblank_lines=>0,_first_line_length_error=>0,_max_line_length_error=>0,_last_line_length_error=>0,_first_line_length_error_at=>0,_max_line_length_error_at=>0,_last_line_length_error_at=>0,_line_length_error_count=>0,_max_output_line_length=>0,_max_output_line_length_at=>0,},$class}sub tee_on {my$self=shift;$self->{_line_sink_object}->tee_on()}sub tee_off {my$self=shift;$self->{_line_sink_object}->tee_off()}sub get_output_line_number {my$self=shift;return$self->{_output_line_number}}sub decrement_output_line_number {my$self=shift;$self->{_output_line_number}--}sub get_consecutive_nonblank_lines {my$self=shift;return$self->{_consecutive_nonblank_lines}}sub reset_consecutive_blank_lines {my$self=shift;$self->{_consecutive_blank_lines}=0}sub want_blank_line {my$self=shift;unless ($self->{_consecutive_blank_lines}){$self->write_blank_code_line()}}sub require_blank_code_lines {my$self=shift;my$count=shift;my$need=$count - $self->{_consecutive_blank_lines};my$rOpts=$self->{_rOpts};my$forced=$rOpts->{'maximum-consecutive-blank-lines'}> 0;for (my$i=0 ;$i < $need ;$i++ ){$self->write_blank_code_line($forced)}}sub write_blank_code_line {my$self=shift;my$forced=shift;my$rOpts=$self->{_rOpts};return if (!$forced && $self->{_consecutive_blank_lines}>= $rOpts->{'maximum-consecutive-blank-lines'});$self->{_consecutive_blank_lines}++;$self->{_consecutive_nonblank_lines}=0;$self->write_line("\n")}sub write_code_line {my$self=shift;my$a=shift;if ($a =~ /^\s*$/){my$rOpts=$self->{_rOpts};return if ($self->{_consecutive_blank_lines}>= $rOpts->{'maximum-consecutive-blank-lines'});$self->{_consecutive_blank_lines}++;$self->{_consecutive_nonblank_lines}=0}else {$self->{_consecutive_blank_lines}=0;$self->{_consecutive_nonblank_lines}++}$self->write_line($a)}sub write_line {my$self=shift;my$a=shift;if ($a =~ /\n$/){$self->{_output_line_number}++}$self->{_line_sink_object}->write_line($a);my$rOpts=$self->{_rOpts};my$exceed=length($a)- $rOpts->{'maximum-line-length'}- 1;if ($a =~ /^\t+/g){$exceed += pos($a)* ($rOpts->{'indent-columns'}- 1)}if (length($a)> 1 + $self->{_max_output_line_length}){$self->{_max_output_line_length}=length($a)- 1;$self->{_max_output_line_length_at}=$self->{_output_line_number}- 1}if ($exceed > 0){my$output_line_number=$self->{_output_line_number};$self->{_last_line_length_error}=$exceed;$self->{_last_line_length_error_at}=$output_line_number - 1;if ($self->{_line_length_error_count}==0){$self->{_first_line_length_error}=$exceed;$self->{_first_line_length_error_at}=$output_line_number - 1}if ($self->{_last_line_length_error}> $self->{_max_line_length_error}){$self->{_max_line_length_error}=$exceed;$self->{_max_line_length_error_at}=$output_line_number - 1}if ($self->{_line_length_error_count}< MAX_NAG_MESSAGES){$self->write_logfile_entry("Line length exceeded by $exceed characters\n")}$self->{_line_length_error_count}++}}sub report_line_length_errors {my$self=shift;my$rOpts=$self->{_rOpts};my$line_length_error_count=$self->{_line_length_error_count};if ($line_length_error_count==0){$self->write_logfile_entry("No lines exceeded $rOpts->{'maximum-line-length'} characters\n");my$max_output_line_length=$self->{_max_output_line_length};my$max_output_line_length_at=$self->{_max_output_line_length_at};$self->write_logfile_entry("  Maximum output line length was $max_output_line_length at line $max_output_line_length_at\n")}else {my$word=($line_length_error_count > 1)? "s" : "";$self->write_logfile_entry("$line_length_error_count output line$word exceeded $rOpts->{'maximum-line-length'} characters:\n");$word=($line_length_error_count > 1)? "First" : "";my$first_line_length_error=$self->{_first_line_length_error};my$first_line_length_error_at=$self->{_first_line_length_error_at};$self->write_logfile_entry(" $word at line $first_line_length_error_at by $first_line_length_error characters\n");if ($line_length_error_count > 1){my$max_line_length_error=$self->{_max_line_length_error};my$max_line_length_error_at=$self->{_max_line_length_error_at};my$last_line_length_error=$self->{_last_line_length_error};my$last_line_length_error_at=$self->{_last_line_length_error_at};$self->write_logfile_entry(" Maximum at line $max_line_length_error_at by $max_line_length_error characters\n");$self->write_logfile_entry(" Last at line $last_line_length_error_at by $last_line_length_error characters\n")}}}package Perl::Tidy::Debugger;sub new {my ($class,$filename)=@_;bless {_debug_file=>$filename,_debug_file_opened=>0,_fh=>undef,},$class}sub really_open_debug_file {my$self=shift;my$debug_file=$self->{_debug_file};my$fh;unless ($fh=IO::File->new("> $debug_file")){Perl::Tidy::Warn("can't open $debug_file: $!\n")}$self->{_debug_file_opened}=1;$self->{_fh}=$fh;print$fh "Use -dump-token-types (-dtt) to get a list of token type codes\n"}sub close_debug_file {my$self=shift;my$fh=$self->{_fh};if ($self->{_debug_file_opened}){eval {$self->{_fh}->close()}}}sub write_debug_entry {my$self=shift;my$line_of_tokens=shift;my$input_line=$line_of_tokens->{_line_text};my$rtoken_type=$line_of_tokens->{_rtoken_type};my$rtokens=$line_of_tokens->{_rtokens};my$rlevels=$line_of_tokens->{_rlevels};my$rslevels=$line_of_tokens->{_rslevels};my$rblock_type=$line_of_tokens->{_rblock_type};my$input_line_number=$line_of_tokens->{_line_number};my$line_type=$line_of_tokens->{_line_type};my ($j,$num);my$token_str="$input_line_number: ";my$reconstructed_original="$input_line_number: ";my$block_str="$input_line_number: ";my$pattern="";my@next_char=('"','"');my$i_next=0;unless ($self->{_debug_file_opened}){$self->really_open_debug_file()}my$fh=$self->{_fh};for ($j=0 ;$j < @$rtoken_type ;$j++ ){if ($$rtoken_type[$j]eq 'k'){$pattern .= $$rtokens[$j]}else {$pattern .= $$rtoken_type[$j]}$reconstructed_original .= $$rtokens[$j];$block_str .= "($$rblock_type[$j])";$num=length($$rtokens[$j]);my$type_str=$$rtoken_type[$j];if ($type_str eq ' '){print$fh "BLANK TOKEN on the next line\n";$type_str=$next_char[$i_next];$i_next=1 - $i_next}if (length($type_str)==1){$type_str=$type_str x $num}$token_str .= $type_str}print$fh "$reconstructed_original\n";print$fh "$token_str\n"}package Perl::Tidy::LineBuffer;sub new {my$class=shift;my$line_source_object=shift;return bless {_line_source_object=>$line_source_object,_rlookahead_buffer=>[],},$class}sub peek_ahead {my$self=shift;my$buffer_index=shift;my$line=undef;my$line_source_object=$self->{_line_source_object};my$rlookahead_buffer=$self->{_rlookahead_buffer};if ($buffer_index < scalar(@$rlookahead_buffer)){$line=$$rlookahead_buffer[$buffer_index]}else {$line=$line_source_object->get_line();push(@$rlookahead_buffer,$line)}return$line}sub get_line {my$self=shift;my$line=undef;my$line_source_object=$self->{_line_source_object};my$rlookahead_buffer=$self->{_rlookahead_buffer};if (scalar(@$rlookahead_buffer)){$line=shift @$rlookahead_buffer}else {$line=$line_source_object->get_line()}return$line}package Perl::Tidy::Tokenizer;BEGIN {use constant TOKENIZER_DEBUG_FLAG_EXPECT=>0;use constant TOKENIZER_DEBUG_FLAG_NSCAN=>0;use constant TOKENIZER_DEBUG_FLAG_QUOTE=>0;use constant TOKENIZER_DEBUG_FLAG_SCAN_ID=>0;use constant TOKENIZER_DEBUG_FLAG_TOKENIZE=>0;my$debug_warning=sub {print STDOUT "TOKENIZER_DEBUGGING with key $_[0]\n"};TOKENIZER_DEBUG_FLAG_EXPECT && $debug_warning->('EXPECT');TOKENIZER_DEBUG_FLAG_NSCAN && $debug_warning->('NSCAN');TOKENIZER_DEBUG_FLAG_QUOTE && $debug_warning->('QUOTE');TOKENIZER_DEBUG_FLAG_SCAN_ID && $debug_warning->('SCAN_ID');TOKENIZER_DEBUG_FLAG_TOKENIZE && $debug_warning->('TOKENIZE')}use Carp;use vars qw{$tokenizer_self $last_nonblank_token $last_nonblank_type $last_nonblank_block_type $statement_type $in_attribute_list $current_package $context %is_constant %is_user_function %user_function_prototype %is_block_function %is_block_list_function %saw_function_definition $brace_depth $paren_depth $square_bracket_depth @current_depth @total_depth $total_depth @nesting_sequence_number @current_sequence_number @paren_type @paren_semicolon_count @paren_structural_type @brace_type @brace_structural_type @brace_context @brace_package @square_bracket_type @square_bracket_structural_type @depth_array @nested_ternary_flag @nested_statement_type @starting_line_of_current_depth};use vars qw{%is_indirect_object_taker %is_block_operator %expecting_operator_token %expecting_operator_types %expecting_term_types %expecting_term_token %is_digraph %is_file_test_operator %is_trigraph %is_valid_token_type %is_keyword %is_code_block_token %really_want_term @opening_brace_names @closing_brace_names %is_keyword_taking_list %is_q_qq_qw_qx_qr_s_y_tr_m};use constant TERM=>-1;use constant UNKNOWN=>0;use constant OPERATOR=>1;use constant SCALAR_CONTEXT=>-1;use constant UNKNOWN_CONTEXT=>0;use constant LIST_CONTEXT=>1;use constant MAX_NAG_MESSAGES=>6;{my$_count=0;sub get_count {$_count}sub _increment_count {++$_count}sub _decrement_count {--$_count}}sub DESTROY {$_[0]->_decrement_count()}sub new {my$class=shift;my%defaults=(source_object=>undef,debugger_object=>undef,diagnostics_object=>undef,logger_object=>undef,starting_level=>undef,indent_columns=>4,tabsize=>8,look_for_hash_bang=>0,trim_qw=>1,look_for_autoloader=>1,look_for_selfloader=>1,starting_line_number=>1,extended_syntax=>0,);my%args=(%defaults,@_);my$source_object=$args{source_object};my$line_buffer_object=Perl::Tidy::LineBuffer->new($source_object);$tokenizer_self={_rhere_target_list=>[],_in_here_doc=>0,_here_doc_target=>"",_here_quote_character=>"",_in_data=>0,_in_end=>0,_in_format=>0,_in_error=>0,_in_pod=>0,_in_attribute_list=>0,_in_quote=>0,_quote_target=>"",_line_start_quote=>-1,_starting_level=>$args{starting_level},_know_starting_level=>defined($args{starting_level}),_tabsize=>$args{tabsize},_indent_columns=>$args{indent_columns},_look_for_hash_bang=>$args{look_for_hash_bang},_trim_qw=>$args{trim_qw},_continuation_indentation=>$args{continuation_indentation},_outdent_labels=>$args{outdent_labels},_last_line_number=>$args{starting_line_number}- 1,_saw_perl_dash_P=>0,_saw_perl_dash_w=>0,_saw_use_strict=>0,_saw_v_string=>0,_look_for_autoloader=>$args{look_for_autoloader},_look_for_selfloader=>$args{look_for_selfloader},_saw_autoloader=>0,_saw_selfloader=>0,_saw_hash_bang=>0,_saw_end=>0,_saw_data=>0,_saw_negative_indentation=>0,_started_tokenizing=>0,_line_buffer_object=>$line_buffer_object,_debugger_object=>$args{debugger_object},_diagnostics_object=>$args{diagnostics_object},_logger_object=>$args{logger_object},_unexpected_error_count=>0,_started_looking_for_here_target_at=>0,_nearly_matched_here_target_at=>undef,_line_text=>"",_rlower_case_labels_at=>undef,_extended_syntax=>$args{extended_syntax},};prepare_for_a_new_file();find_starting_indentation_level();bless$tokenizer_self,$class;if (_increment_count()> 1){confess "Attempt to create more than 1 object in $class, which is not a true class yet\n"}return$tokenizer_self}sub warning {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->warning(@_)}}sub complain {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->complain(@_)}}sub write_logfile_entry {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->write_logfile_entry(@_)}}sub interrupt_logfile {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->interrupt_logfile()}}sub resume_logfile {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->resume_logfile()}}sub increment_brace_error {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->increment_brace_error()}}sub report_definite_bug {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->report_definite_bug()}}sub brace_warning {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->brace_warning(@_)}}sub get_saw_brace_error {my$logger_object=$tokenizer_self->{_logger_object};if ($logger_object){$logger_object->get_saw_brace_error()}else {0}}sub write_diagnostics {if ($tokenizer_self->{_diagnostics_object}){$tokenizer_self->{_diagnostics_object}->write_diagnostics(@_)}}sub report_tokenization_errors {my$self=shift;my$level=get_indentation_level();if ($level!=$tokenizer_self->{_starting_level}){warning("final indentation level: $level\n")}check_final_nesting_depths();if ($tokenizer_self->{_look_for_hash_bang}&&!$tokenizer_self->{_saw_hash_bang}){warning("hit EOF without seeing hash-bang line; maybe don't need -x?\n")}if ($tokenizer_self->{_in_format}){warning("hit EOF while in format description\n")}if ($tokenizer_self->{_in_pod}){if ($tokenizer_self->{_saw_data}|| $tokenizer_self->{_saw_end}){write_logfile_entry("hit eof while in pod documentation (no =cut seen)\n\tthis can cause trouble with some pod utilities\n")}else {complain("hit eof while in pod documentation (no =cut seen)\n\tthis can cause trouble with some pod utilities\n")}}if ($tokenizer_self->{_in_here_doc}){my$here_doc_target=$tokenizer_self->{_here_doc_target};my$started_looking_for_here_target_at=$tokenizer_self->{_started_looking_for_here_target_at};if ($here_doc_target){warning("hit EOF in here document starting at line $started_looking_for_here_target_at with target: $here_doc_target\n")}else {warning("hit EOF in here document starting at line $started_looking_for_here_target_at with empty target string\n")}my$nearly_matched_here_target_at=$tokenizer_self->{_nearly_matched_here_target_at};if ($nearly_matched_here_target_at){warning("NOTE: almost matched at input line $nearly_matched_here_target_at except for whitespace\n")}}if ($tokenizer_self->{_in_quote}){my$line_start_quote=$tokenizer_self->{_line_start_quote};my$quote_target=$tokenizer_self->{_quote_target};my$what=($tokenizer_self->{_in_attribute_list})? "attribute list" : "quote/pattern";warning("hit EOF seeking end of $what starting at line $line_start_quote ending in $quote_target\n")}unless ($tokenizer_self->{_saw_perl_dash_w}){if ($] < 5.006){write_logfile_entry("Suggest including '-w parameter'\n")}else {write_logfile_entry("Suggest including 'use warnings;'\n")}}if ($tokenizer_self->{_saw_perl_dash_P}){write_logfile_entry("Use of -P parameter for defines is discouraged\n")}unless ($tokenizer_self->{_saw_use_strict}){write_logfile_entry("Suggest including 'use strict;'\n")}if ($tokenizer_self->{_rlower_case_labels_at}){my@lower_case_labels_at=@{$tokenizer_self->{_rlower_case_labels_at}};write_logfile_entry("Suggest using upper case characters in label(s)\n");local $"=')(';write_logfile_entry("  defined at line(s): (@lower_case_labels_at)\n")}}sub report_v_string {my$tok=shift;unless ($tokenizer_self->{_saw_v_string}){$tokenizer_self->{_saw_v_string}=$tokenizer_self->{_last_line_number}}if ($] < 5.006){warning("Found v-string '$tok' but v-strings are not implemented in your version of perl; see Camel 3 book ch 2\n")}}sub get_input_line_number {return$tokenizer_self->{_last_line_number}}sub get_line {my$self=shift;my$input_line=$tokenizer_self->{_line_buffer_object}->get_line();$tokenizer_self->{_line_text}=$input_line;return undef unless ($input_line);my$input_line_number=++$tokenizer_self->{_last_line_number};my$input_line_separator="";if (chomp($input_line)){$input_line_separator=$/}if ($input_line =~ s/((\r|\035|\032)+)$//){$input_line_separator=$2 .$input_line_separator}$input_line .= "\n";$tokenizer_self->{_line_text}=$input_line;my$line_of_tokens={_line_type=>'EOF',_line_text=>$input_line,_line_number=>$input_line_number,_rtoken_type=>undef,_rtokens=>undef,_rlevels=>undef,_rslevels=>undef,_rblock_type=>undef,_rcontainer_type=>undef,_rcontainer_environment=>undef,_rtype_sequence=>undef,_rnesting_tokens=>undef,_rci_levels=>undef,_rnesting_blocks=>undef,_guessed_indentation_level=>0,_starting_in_quote=>0,_ending_in_quote=>0,_curly_brace_depth=>$brace_depth,_square_bracket_depth=>$square_bracket_depth,_paren_depth=>$paren_depth,_quote_character=>'',};if ($tokenizer_self->{_in_here_doc}){$line_of_tokens->{_line_type}='HERE';my$here_doc_target=$tokenizer_self->{_here_doc_target};my$here_quote_character=$tokenizer_self->{_here_quote_character};my$candidate_target=$input_line;chomp$candidate_target;if ($candidate_target eq $here_doc_target){$tokenizer_self->{_nearly_matched_here_target_at}=undef;$line_of_tokens->{_line_type}='HERE_END';write_logfile_entry("Exiting HERE document $here_doc_target\n");my$rhere_target_list=$tokenizer_self->{_rhere_target_list};if (@$rhere_target_list){($here_doc_target,$here_quote_character)=@{shift @$rhere_target_list};$tokenizer_self->{_here_doc_target}=$here_doc_target;$tokenizer_self->{_here_quote_character}=$here_quote_character;write_logfile_entry("Entering HERE document $here_doc_target\n");$tokenizer_self->{_nearly_matched_here_target_at}=undef;$tokenizer_self->{_started_looking_for_here_target_at}=$input_line_number}else {$tokenizer_self->{_in_here_doc}=0;$tokenizer_self->{_here_doc_target}="";$tokenizer_self->{_here_quote_character}=""}}else {$candidate_target =~ s/\s*$//;$candidate_target =~ s/^\s*//;if ($candidate_target eq $here_doc_target){$tokenizer_self->{_nearly_matched_here_target_at}=$input_line_number}}return$line_of_tokens}elsif ($tokenizer_self->{_in_format}){if ($input_line =~ /^\.[\s#]*$/){write_logfile_entry("Exiting format section\n");$tokenizer_self->{_in_format}=0;$line_of_tokens->{_line_type}='FORMAT_END'}else {$line_of_tokens->{_line_type}='FORMAT'}return$line_of_tokens}elsif ($tokenizer_self->{_in_pod}){$line_of_tokens->{_line_type}='POD';if ($input_line =~ /^=cut/){$line_of_tokens->{_line_type}='POD_END';write_logfile_entry("Exiting POD section\n");$tokenizer_self->{_in_pod}=0}if ($input_line =~ /^\#\!.*perl\b/){warning("Hash-bang in pod can cause older versions of perl to fail! \n")}return$line_of_tokens}elsif ($tokenizer_self->{_in_error}){$line_of_tokens->{_line_type}='ERROR';return$line_of_tokens}elsif ($tokenizer_self->{_in_data}){if ($input_line =~ /^=(?!cut)/){$line_of_tokens->{_line_type}='POD_START';write_logfile_entry("Entering POD section\n");$tokenizer_self->{_in_pod}=1;return$line_of_tokens}else {$line_of_tokens->{_line_type}='DATA';return$line_of_tokens}}elsif ($tokenizer_self->{_in_end}){if ($input_line =~ /^=(?!cut)/){$line_of_tokens->{_line_type}='POD_START';write_logfile_entry("Entering POD section\n");$tokenizer_self->{_in_pod}=1;return$line_of_tokens}else {$line_of_tokens->{_line_type}='END';return$line_of_tokens}}if (!$tokenizer_self->{_saw_hash_bang}){if ($input_line =~ /^\#\!.*perl\b/){$tokenizer_self->{_saw_hash_bang}=$input_line_number;if ($input_line =~ /^\#\!.*perl\s.*-.*P/){$tokenizer_self->{_saw_perl_dash_P}=1}if ($input_line =~ /^\#\!.*perl\s.*-.*w/){$tokenizer_self->{_saw_perl_dash_w}=1}if (($input_line_number > 1)&& (!$tokenizer_self->{_look_for_hash_bang})){if ($tokenizer_self->{_started_tokenizing}){warning("There seems to be a hash-bang after line 1; do you need to run with -x ?\n")}else {complain("Useless hash-bang after line 1\n")}}else {$line_of_tokens->{_line_type}='SYSTEM';return$line_of_tokens}}}if ($tokenizer_self->{_look_for_hash_bang}&&!$tokenizer_self->{_saw_hash_bang}){$line_of_tokens->{_line_type}='SYSTEM';return$line_of_tokens}if ($input_line_number==1 && $input_line =~ /^\s*\:\s*\#/){$line_of_tokens->{_line_type}='SYSTEM';return$line_of_tokens}my$ending_in_quote_last=$tokenizer_self->{_in_quote};tokenize_this_line($line_of_tokens);$line_of_tokens->{_ending_in_quote}=$tokenizer_self->{_in_quote};if ($tokenizer_self->{_in_error}){$tokenizer_self->{_in_quote}=0;warning("Giving up after error\n");$line_of_tokens->{_line_type}='ERROR';reset_indentation_level(0);return$line_of_tokens}if ($tokenizer_self->{_in_pod}){if ($input_line =~ /^=cut\b/){if ($tokenizer_self->{_saw_data}|| $tokenizer_self->{_saw_end}){complain("=cut while not in pod ignored\n");$tokenizer_self->{_in_pod}=0;$line_of_tokens->{_line_type}='POD_END'}else {$line_of_tokens->{_line_type}='POD_START';complain("=cut starts a pod section .. this can fool pod utilities.\n");write_logfile_entry("Entering POD section\n")}}else {$line_of_tokens->{_line_type}='POD_START';write_logfile_entry("Entering POD section\n")}return$line_of_tokens}if ($input_line !~ /^\s*$/){my$rlevels=$line_of_tokens->{_rlevels};$line_of_tokens->{_guessed_indentation_level}=guess_old_indentation_level($input_line)}my$rhere_target_list=$tokenizer_self->{_rhere_target_list};if (@$rhere_target_list){my ($here_doc_target,$here_quote_character)=@{shift @$rhere_target_list};$tokenizer_self->{_in_here_doc}=1;$tokenizer_self->{_here_doc_target}=$here_doc_target;$tokenizer_self->{_here_quote_character}=$here_quote_character;write_logfile_entry("Entering HERE document $here_doc_target\n");$tokenizer_self->{_started_looking_for_here_target_at}=$input_line_number}if ($tokenizer_self->{_in_data}){$line_of_tokens->{_line_type}='DATA_START';write_logfile_entry("Starting __DATA__ section\n");$tokenizer_self->{_saw_data}=1;if ($tokenizer_self->{_saw_selfloader}){$tokenizer_self->{_in_data}=0;write_logfile_entry("SelfLoader seen, continuing; -nlsl deactivates\n")}return$line_of_tokens}elsif ($tokenizer_self->{_in_end}){$line_of_tokens->{_line_type}='END_START';write_logfile_entry("Starting __END__ section\n");$tokenizer_self->{_saw_end}=1;if ($tokenizer_self->{_saw_autoloader}){$tokenizer_self->{_in_end}=0;write_logfile_entry("AutoLoader seen, continuing; -nlal deactivates\n")}return$line_of_tokens}$line_of_tokens->{_line_type}='CODE';if (!$tokenizer_self->{_started_tokenizing}&& $input_line !~ /^\s*$/ && $input_line !~ /^\s*#/){$tokenizer_self->{_started_tokenizing}=1}if ($tokenizer_self->{_debugger_object}){$tokenizer_self->{_debugger_object}->write_debug_entry($line_of_tokens)}if ($tokenizer_self->{_in_format}){write_logfile_entry("Entering format section\n")}if ($tokenizer_self->{_in_quote}and ($tokenizer_self->{_line_start_quote}< 0)){if ((my$quote_target=$tokenizer_self->{_quote_target})!~ /^\s*$/){$tokenizer_self->{_line_start_quote}=$input_line_number;write_logfile_entry("Start multi-line quote or pattern ending in $quote_target\n")}}elsif (($tokenizer_self->{_line_start_quote}>= 0)and!$tokenizer_self->{_in_quote}){$tokenizer_self->{_line_start_quote}=-1;write_logfile_entry("End of multi-line quote or pattern\n")}return$line_of_tokens}sub find_starting_indentation_level {my$starting_level=0;if ($tokenizer_self->{_know_starting_level}){$starting_level=$tokenizer_self->{_starting_level}}elsif ($tokenizer_self->{_look_for_hash_bang}){$tokenizer_self->{_know_starting_level}=1}else {my$line;my$i=0;my$msg="";while ($line=$tokenizer_self->{_line_buffer_object}->peek_ahead($i++)){if ($i==1 && $line =~ /^\#\!/){$starting_level=0;last}next if ($line =~ /^\s*#/);next if ($line =~ /^\s*$/);$starting_level=guess_old_indentation_level($line);last}$msg="Line $i implies starting-indentation-level = $starting_level\n";write_logfile_entry("$msg")}$tokenizer_self->{_starting_level}=$starting_level;reset_indentation_level($starting_level)}sub guess_old_indentation_level {my ($line)=@_;my$level=0;my$spaces=0;if ($line =~ /^(\t+)?(\s+)?(\w+:[^:])?/){if ($1){$spaces += length($1)* $tokenizer_self->{_tabsize}}if ($2){$spaces += length($2)}if ($3 && $tokenizer_self->{'_outdent_labels'}){$spaces += $tokenizer_self->{_continuation_indentation}}}my$indent_columns=$tokenizer_self->{_indent_columns};$indent_columns=4 if (!$indent_columns);$level=int($spaces / $indent_columns);return ($level)}sub dump_functions {my$fh=*STDOUT;my ($pkg,$sub);for$pkg (keys%is_user_function){print$fh "\nnon-constant subs in package $pkg\n";for$sub (keys %{$is_user_function{$pkg}}){my$msg="";if ($is_block_list_function{$pkg}{$sub}){$msg='block_list'}if ($is_block_function{$pkg}{$sub}){$msg='block'}print$fh "$sub $msg\n"}}for$pkg (keys%is_constant){print$fh "\nconstants and constant subs in package $pkg\n";for$sub (keys %{$is_constant{$pkg}}){print$fh "$sub\n"}}}sub ones_count {return (my$cis=$_[0])=~ tr/1/0/}sub prepare_for_a_new_file {$last_nonblank_token=';';$last_nonblank_type=';';$last_nonblank_block_type='';$statement_type='';$in_attribute_list=0;$current_package="main";$context=UNKNOWN_CONTEXT;%is_constant=();%is_user_function=();%user_function_prototype=();%is_block_function=();%is_block_list_function=();%saw_function_definition=();$paren_depth=0;$brace_depth=0;$square_bracket_depth=0;@current_depth[0 .. $#closing_brace_names ]=(0)x scalar@closing_brace_names;$total_depth=0;@total_depth=();@nesting_sequence_number[0 .. $#closing_brace_names ]=(0 .. $#closing_brace_names);@current_sequence_number=();$paren_type[$paren_depth]='';$paren_semicolon_count[$paren_depth]=0;$paren_structural_type[$brace_depth]='';$brace_type[$brace_depth]=';';$brace_structural_type[$brace_depth]='';$brace_context[$brace_depth]=UNKNOWN_CONTEXT;$brace_package[$paren_depth]=$current_package;$square_bracket_type[$square_bracket_depth]='';$square_bracket_structural_type[$square_bracket_depth]='';initialize_tokenizer_state()}{use constant BRACE=>0;use constant SQUARE_BRACKET=>1;use constant PAREN=>2;use constant QUESTION_COLON=>3;my ($block_type,$container_type,$expecting,$i,$i_tok,$input_line,$input_line_number,$last_nonblank_i,$max_token_index,$next_tok,$next_type,$peeked_ahead,$prototype,$rhere_target_list,$rtoken_map,$rtoken_type,$rtokens,$tok,$type,$type_sequence,$indent_flag,);my$routput_token_list=[];my$routput_token_type=[];my$routput_block_type=[];my$routput_container_type=[];my$routput_type_sequence=[];my$routput_indent_flag=[];my ($in_quote,$quote_type,$quote_character,$quote_pos,$quote_depth,$quoted_string_1,$quoted_string_2,$allowed_quote_modifiers,);my ($id_scan_state,$identifier,$want_paren,$indented_if_level);my ($nesting_token_string,$nesting_type_string,$nesting_block_string,$nesting_block_flag,$nesting_list_string,$nesting_list_flag,$ci_string_in_tokenizer,$continuation_string_in_tokenizer,$in_statement_continuation,$level_in_tokenizer,$slevel_in_tokenizer,$rslevel_stack,);my ($last_nonblank_container_type,$last_nonblank_type_sequence,$last_last_nonblank_token,$last_last_nonblank_type,$last_last_nonblank_block_type,$last_last_nonblank_container_type,$last_last_nonblank_type_sequence,$last_nonblank_prototype,);sub initialize_tokenizer_state {$in_quote=0;$quote_type='Q';$quote_character="";$quote_pos=0;$quote_depth=0;$quoted_string_1="";$quoted_string_2="";$allowed_quote_modifiers="";$id_scan_state='';$identifier='';$want_paren="";$indented_if_level=0;$nesting_token_string="";$nesting_type_string="";$nesting_block_string='1';$nesting_block_flag=1;$nesting_list_string='0';$nesting_list_flag=0;$ci_string_in_tokenizer="";$continuation_string_in_tokenizer="0";$in_statement_continuation=0;$level_in_tokenizer=0;$slevel_in_tokenizer=0;$rslevel_stack=[];$last_nonblank_container_type='';$last_nonblank_type_sequence='';$last_last_nonblank_token=';';$last_last_nonblank_type=';';$last_last_nonblank_block_type='';$last_last_nonblank_container_type='';$last_last_nonblank_type_sequence='';$last_nonblank_prototype=""}sub save_tokenizer_state {my$rTV1=[$block_type,$container_type,$expecting,$i,$i_tok,$input_line,$input_line_number,$last_nonblank_i,$max_token_index,$next_tok,$next_type,$peeked_ahead,$prototype,$rhere_target_list,$rtoken_map,$rtoken_type,$rtokens,$tok,$type,$type_sequence,$indent_flag,];my$rTV2=[$routput_token_list,$routput_token_type,$routput_block_type,$routput_container_type,$routput_type_sequence,$routput_indent_flag,];my$rTV3=[$in_quote,$quote_type,$quote_character,$quote_pos,$quote_depth,$quoted_string_1,$quoted_string_2,$allowed_quote_modifiers,];my$rTV4=[$id_scan_state,$identifier,$want_paren,$indented_if_level ];my$rTV5=[$nesting_token_string,$nesting_type_string,$nesting_block_string,$nesting_block_flag,$nesting_list_string,$nesting_list_flag,$ci_string_in_tokenizer,$continuation_string_in_tokenizer,$in_statement_continuation,$level_in_tokenizer,$slevel_in_tokenizer,$rslevel_stack,];my$rTV6=[$last_nonblank_container_type,$last_nonblank_type_sequence,$last_last_nonblank_token,$last_last_nonblank_type,$last_last_nonblank_block_type,$last_last_nonblank_container_type,$last_last_nonblank_type_sequence,$last_nonblank_prototype,];return [$rTV1,$rTV2,$rTV3,$rTV4,$rTV5,$rTV6 ]}sub restore_tokenizer_state {my ($rstate)=@_;my ($rTV1,$rTV2,$rTV3,$rTV4,$rTV5,$rTV6)=@{$rstate};($block_type,$container_type,$expecting,$i,$i_tok,$input_line,$input_line_number,$last_nonblank_i,$max_token_index,$next_tok,$next_type,$peeked_ahead,$prototype,$rhere_target_list,$rtoken_map,$rtoken_type,$rtokens,$tok,$type,$type_sequence,$indent_flag,)=@{$rTV1};($routput_token_list,$routput_token_type,$routput_block_type,$routput_container_type,$routput_type_sequence,$routput_type_sequence,)=@{$rTV2};($in_quote,$quote_type,$quote_character,$quote_pos,$quote_depth,$quoted_string_1,$quoted_string_2,$allowed_quote_modifiers,)=@{$rTV3};($id_scan_state,$identifier,$want_paren,$indented_if_level)=@{$rTV4};($nesting_token_string,$nesting_type_string,$nesting_block_string,$nesting_block_flag,$nesting_list_string,$nesting_list_flag,$ci_string_in_tokenizer,$continuation_string_in_tokenizer,$in_statement_continuation,$level_in_tokenizer,$slevel_in_tokenizer,$rslevel_stack,)=@{$rTV5};($last_nonblank_container_type,$last_nonblank_type_sequence,$last_last_nonblank_token,$last_last_nonblank_type,$last_last_nonblank_block_type,$last_last_nonblank_container_type,$last_last_nonblank_type_sequence,$last_nonblank_prototype,)=@{$rTV6}}sub get_indentation_level {if ($indented_if_level){return$level_in_tokenizer - 1}return$level_in_tokenizer}sub reset_indentation_level {$level_in_tokenizer=$_[0];$slevel_in_tokenizer=$_[0];push @{$rslevel_stack},$slevel_in_tokenizer}sub peeked_ahead {$peeked_ahead=defined($_[0])? $_[0]: $peeked_ahead}sub scan_replacement_text {my ($replacement_text)=@_;return undef unless ($replacement_text =~ /<</);write_logfile_entry("scanning replacement text for here-doc targets\n");my$logger_object=$tokenizer_self->{_logger_object};local ($tokenizer_self,$last_nonblank_token,$last_nonblank_type,$last_nonblank_block_type,$statement_type,$in_attribute_list,$current_package,$context,%is_constant,%is_user_function,%user_function_prototype,%is_block_function,%is_block_list_function,%saw_function_definition,$brace_depth,$paren_depth,$square_bracket_depth,@current_depth,@total_depth,$total_depth,@nesting_sequence_number,@current_sequence_number,@paren_type,@paren_semicolon_count,@paren_structural_type,@brace_type,@brace_structural_type,@brace_context,@brace_package,@square_bracket_type,@square_bracket_structural_type,@depth_array,@starting_line_of_current_depth,@nested_ternary_flag,@nested_statement_type,);my$rstate=save_tokenizer_state();_decrement_count();my$rOpts={};my$rpending_logfile_message;my$source_object=Perl::Tidy::LineSource->new(\$replacement_text,$rOpts,$rpending_logfile_message);my$tokenizer=Perl::Tidy::Tokenizer->new(source_object=>$source_object,logger_object=>$logger_object,starting_line_number=>$input_line_number,);1 while ($tokenizer->get_line());my$rht=undef;if ($tokenizer_self->{_in_here_doc}){$rht=[];push @{$rht},[$tokenizer_self->{_here_doc_target},$tokenizer_self->{_here_quote_character}];if ($tokenizer_self->{_rhere_target_list}){push @{$rht},@{$tokenizer_self->{_rhere_target_list}};$tokenizer_self->{_rhere_target_list}=undef}$tokenizer_self->{_in_here_doc}=undef}$tokenizer->report_tokenization_errors();restore_tokenizer_state($rstate);return$rht}sub scan_bare_identifier {($i,$tok,$type,$prototype)=scan_bare_identifier_do($input_line,$i,$tok,$type,$prototype,$rtoken_map,$max_token_index)}sub scan_identifier {($i,$tok,$type,$id_scan_state,$identifier)=scan_identifier_do($i,$id_scan_state,$identifier,$rtokens,$max_token_index,$expecting,$paren_type[$paren_depth])}sub scan_id {($i,$tok,$type,$id_scan_state)=scan_id_do($input_line,$i,$tok,$rtokens,$rtoken_map,$id_scan_state,$max_token_index)}sub scan_number {my$number;($i,$type,$number)=scan_number_do($input_line,$i,$rtoken_map,$type,$max_token_index);return$number}sub error_if_expecting_TERM {if ($expecting==TERM){if ($really_want_term{$last_nonblank_type}){unexpected($tok,"term",$i_tok,$last_nonblank_i,$rtoken_map,$rtoken_type,$input_line);1}}}sub error_if_expecting_OPERATOR {if ($expecting==OPERATOR){my$thing=defined $_[0]? $_[0]: $tok;unexpected($thing,"operator",$i_tok,$last_nonblank_i,$rtoken_map,$rtoken_type,$input_line);if ($i_tok==0){interrupt_logfile();warning("Missing ';' above?\n");resume_logfile()}1}}my%is_for_foreach;@_=qw(for foreach);@is_for_foreach{@_}=(1)x scalar(@_);my%is_my_our;@_=qw(my our);@is_my_our{@_}=(1)x scalar(@_);my%is_blocktype_with_paren;@_=qw(if elsif unless while until for foreach switch case given when catch);@is_blocktype_with_paren{@_}=(1)x scalar(@_);my$tokenization_code={'>'=>sub {error_if_expecting_TERM()if ($expecting==TERM)},'|'=>sub {error_if_expecting_TERM()if ($expecting==TERM)},'$'=>sub {error_if_expecting_OPERATOR("Scalar")if ($expecting==OPERATOR);scan_identifier();if ($identifier eq '$^W'){$tokenizer_self->{_saw_perl_dash_w}=1}if ($is_indirect_object_taker{$last_nonblank_token}|| (($last_nonblank_token eq '(')&& $is_indirect_object_taker{$paren_type[$paren_depth]})|| ($last_nonblank_type =~ /^[Uw]$/)){$type='Z'}},'('=>sub {++$paren_depth;$paren_semicolon_count[$paren_depth]=0;if ($want_paren){$container_type=$want_paren;$want_paren=""}elsif ($statement_type =~ /^sub/){$container_type=$statement_type}else {$container_type=$last_nonblank_token;if ($expecting==OPERATOR && $last_nonblank_token !~ /^([\]\}\&]|\-\>)/){if ($last_last_nonblank_token eq 'do'){complain("do SUBROUTINE is deprecated; consider & or -> notation\n")}else {my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);if ($next_nonblank_token ne ')'){my$hint;error_if_expecting_OPERATOR('(');if ($last_nonblank_type eq 'C'){$hint="$last_nonblank_token has a void prototype\n"}elsif ($last_nonblank_type eq 'i'){if ($i_tok > 0 && $last_nonblank_token =~ /^\$/){$hint="Do you mean '$last_nonblank_token->(' ?\n"}}if ($hint){interrupt_logfile();warning($hint);resume_logfile()}}}}}$paren_type[$paren_depth]=$container_type;($type_sequence,$indent_flag)=increase_nesting_depth(PAREN,$$rtoken_map[$i_tok]);if ($last_nonblank_token eq '('){$type=$last_nonblank_type}else {$type='{'}if ($last_nonblank_type eq ')'){warning("Syntax error? found token '$last_nonblank_type' then '('\n")}$paren_structural_type[$paren_depth]=$type},')'=>sub {($type_sequence,$indent_flag)=decrease_nesting_depth(PAREN,$$rtoken_map[$i_tok]);if ($paren_structural_type[$paren_depth]eq '{'){$type='}'}$container_type=$paren_type[$paren_depth];if ($is_for_foreach{$paren_type[$paren_depth]}){my$num_sc=$paren_semicolon_count[$paren_depth];if ($num_sc > 0 && $num_sc!=2){warning("Expected 2 ';' in 'for(;;)' but saw $num_sc\n")}}if ($paren_depth > 0){$paren_depth--}},','=>sub {if ($last_nonblank_type eq ','){complain("Repeated ','s \n")}if ($statement_type eq 'use'){$statement_type='_use'}},';'=>sub {$context=UNKNOWN_CONTEXT;$statement_type='';$want_paren="";if ($is_for_foreach{$paren_type[$paren_depth]}){if ($brace_depth==$depth_array[PAREN][BRACE][$paren_depth]&& $square_bracket_depth==$depth_array[PAREN][SQUARE_BRACKET][$paren_depth]){$type='f';$paren_semicolon_count[$paren_depth]++}}},'"'=>sub {error_if_expecting_OPERATOR("String")if ($expecting==OPERATOR);$in_quote=1;$type='Q';$allowed_quote_modifiers=""},"'"=>sub {error_if_expecting_OPERATOR("String")if ($expecting==OPERATOR);$in_quote=1;$type='Q';$allowed_quote_modifiers=""},'`'=>sub {error_if_expecting_OPERATOR("String")if ($expecting==OPERATOR);$in_quote=1;$type='Q';$allowed_quote_modifiers=""},'/'=>sub {my$is_pattern;if ($expecting==UNKNOWN){my$msg;($is_pattern,$msg)=guess_if_pattern_or_division($i,$rtokens,$rtoken_map,$max_token_index);if ($msg){write_diagnostics("DIVIDE:$msg\n");write_logfile_entry($msg)}}else {$is_pattern=($expecting==TERM)}if ($is_pattern){$in_quote=1;$type='Q';$allowed_quote_modifiers='[msixpodualngc]'}else {if ($$rtokens[$i + 1 ]eq '='){$i++;$tok='/=';$type=$tok}}},'{'=>sub {$container_type="";if ($statement_type =~ /^sub/){$last_nonblank_token=$statement_type;$last_nonblank_type='i';$statement_type=""}elsif (($statement_type eq 'case' || $statement_type eq 'when')&& $statement_type eq $last_nonblank_token){$last_nonblank_token=";"}elsif ($last_nonblank_token eq ')'){$last_nonblank_token=$paren_type[$paren_depth + 1 ];if (!defined($last_nonblank_token)){$last_nonblank_token='if'}unless ($is_blocktype_with_paren{$last_nonblank_token}){if ($tokenizer_self->{'_extended_syntax'}){$last_nonblank_token .= '()'}else {my$list=join(' ',sort keys%is_blocktype_with_paren);warning("syntax error at ') {', didn't see one of: <<$list>>; If this code is okay try using the -xs flag\n")}}}elsif ($last_nonblank_token eq 'qw' && $is_for_foreach{$want_paren}){$last_nonblank_token=$want_paren;if ($last_last_nonblank_token eq $want_paren){warning("syntax error at '$want_paren .. {' -- missing \$ loop variable\n")}$want_paren=""}if (is_non_structural_brace()){$type='L';if ($statement_type eq 'when' && $last_nonblank_type eq 'i' && $last_last_nonblank_type eq 'k' && ($i_tok==0 || $rtoken_type->[$i_tok - 1 ]eq 'b')){$type='{';$block_type=$statement_type}}else {$block_type=code_block_type($i_tok,$rtokens,$rtoken_type,$max_token_index);if ($block_type && $last_nonblank_type eq 'w' && $last_nonblank_i >= 0){if ($routput_token_type->[$last_nonblank_i]eq 'w'){$routput_token_type->[$last_nonblank_i]='G'}}if ($statement_type eq 'case' || $statement_type eq 'when'){if (!$block_type || $block_type eq '}'){$block_type=$statement_type}}}$brace_type[++$brace_depth ]=$block_type;$brace_package[$brace_depth]=$current_package;$brace_structural_type[$brace_depth]=$type;$brace_context[$brace_depth]=$context;($type_sequence,$indent_flag)=increase_nesting_depth(BRACE,$$rtoken_map[$i_tok])},'}'=>sub {$block_type=$brace_type[$brace_depth];if ($block_type){$statement_type=''}if (defined($brace_package[$brace_depth])){$current_package=$brace_package[$brace_depth]}else {}($type_sequence,$indent_flag)=decrease_nesting_depth(BRACE,$$rtoken_map[$i_tok]);if ($brace_structural_type[$brace_depth]eq 'L'){$type='R'}if ($is_block_operator{$block_type}){$tok=$block_type}$context=$brace_context[$brace_depth];if ($brace_depth > 0){$brace_depth--}},'&'=>sub {if ($expecting!=OPERATOR){if ($expecting==TERM || $next_type ne 'b'){scan_identifier()}}else {}},'<'=>sub {if ($expecting!=OPERATOR){($i,$type)=find_angle_operator_termination($input_line,$i,$rtoken_map,$expecting,$max_token_index);if ($type eq '<' && $expecting==TERM){error_if_expecting_TERM();interrupt_logfile();warning("Unterminated <> operator?\n");resume_logfile()}}else {}},'?'=>sub {my$is_pattern;if ($expecting==UNKNOWN){my$msg;($is_pattern,$msg)=guess_if_pattern_or_conditional($i,$rtokens,$rtoken_map,$max_token_index);if ($msg){write_logfile_entry($msg)}}else {$is_pattern=($expecting==TERM)}if ($is_pattern){$in_quote=1;$type='Q';$allowed_quote_modifiers='[msixpodualngc]'}else {($type_sequence,$indent_flag)=increase_nesting_depth(QUESTION_COLON,$$rtoken_map[$i_tok])}},'*'=>sub {if ($expecting==TERM){scan_identifier()}else {if ($$rtokens[$i + 1 ]eq '='){$tok='*=';$type=$tok;$i++}elsif ($$rtokens[$i + 1 ]eq '*'){$tok='**';$type=$tok;$i++;if ($$rtokens[$i + 1 ]eq '='){$tok='**=';$type=$tok;$i++}}}},'.'=>sub {if ($expecting!=OPERATOR){scan_number();if ($type eq '.'){error_if_expecting_TERM()if ($expecting==TERM)}}else {}},':'=>sub {if ($input_line_number==1 && $last_nonblank_i==-1){$type='J'}elsif ($statement_type =~ /^sub/){$type='A';$in_attribute_list=1}elsif ($is_my_our{$statement_type}&& $current_depth[QUESTION_COLON]==0){$type='A';$in_attribute_list=1}else {($type_sequence,$indent_flag)=decrease_nesting_depth(QUESTION_COLON,$$rtoken_map[$i_tok]);if ($last_nonblank_token eq '?'){warning("Syntax error near ? :\n")}}},'+'=>sub {if ($expecting==TERM){my$number=scan_number();if (!defined($number)){$type='p'}}elsif ($expecting==OPERATOR){}else {if ($next_type eq 'w'){$type='p'}}},'@'=>sub {error_if_expecting_OPERATOR("Array")if ($expecting==OPERATOR);scan_identifier()},'%'=>sub {if ($expecting==UNKNOWN){if ($next_type ne 'b'){$expecting=TERM}}if ($expecting==TERM){scan_identifier()}},'['=>sub {$square_bracket_type[++$square_bracket_depth ]=$last_nonblank_token;($type_sequence,$indent_flag)=increase_nesting_depth(SQUARE_BRACKET,$$rtoken_map[$i_tok]);if (!is_non_structural_brace()){$type='{'}$square_bracket_structural_type[$square_bracket_depth]=$type},']'=>sub {($type_sequence,$indent_flag)=decrease_nesting_depth(SQUARE_BRACKET,$$rtoken_map[$i_tok]);if ($square_bracket_structural_type[$square_bracket_depth]eq '{'){$type='}'}if ($square_bracket_type[$square_bracket_depth]eq '~~'){$tok=$square_bracket_type[$square_bracket_depth]}if ($square_bracket_depth > 0){$square_bracket_depth--}},'-'=>sub {if (($expecting!=OPERATOR)&& $is_file_test_operator{$next_tok}){my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i + 1,$rtokens,$max_token_index);if ($next_nonblank_token eq '='){$type='m'}else {$i++;$tok .= $next_tok;$type='F'}}elsif ($expecting==TERM){my$number=scan_number();if (!defined($number)){$type='m'}}elsif ($expecting==OPERATOR){}else {if ($next_type eq 'w'){$type='m'}}},'^'=>sub {if ($expecting==TERM){if ($last_nonblank_token eq '{' && ($next_tok =~ /^[A-Za-z_]/)){if ($next_tok eq 'W'){$tokenizer_self->{_saw_perl_dash_w}=1}$tok=$tok .$next_tok;$i=$i + 1;$type='w'}else {unless (error_if_expecting_TERM()){complain("The '^' seems unusual here\n")}}}},'::'=>sub {scan_bare_identifier()},'<<'=>sub {return unless ($i < $max_token_index);if ($expecting!=OPERATOR){my ($found_target,$here_doc_target,$here_quote_character,$saw_error);($found_target,$here_doc_target,$here_quote_character,$i,$saw_error)=find_here_doc($expecting,$i,$rtokens,$rtoken_map,$max_token_index);if ($found_target){push @{$rhere_target_list},[$here_doc_target,$here_quote_character ];$type='h';if (length($here_doc_target)> 80){my$truncated=substr($here_doc_target,0,80);complain("Long here-target: '$truncated' ...\n")}elsif ($here_doc_target !~ /^[A-Z_]\w+$/){complain("Unconventional here-target: '$here_doc_target'\n")}}elsif ($expecting==TERM){unless ($saw_error){warning("Program bug; didn't find here doc target\n");report_definite_bug()}}}else {}},'->'=>sub {scan_identifier()},'++'=>sub {if ($expecting==TERM){$type='pp'}elsif ($expecting==UNKNOWN){my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);if ($next_nonblank_token eq '$'){$type='pp'}}},'=>'=>sub {if ($last_nonblank_type eq $tok){complain("Repeated '=>'s \n")}if ($statement_type eq 'use'){$statement_type='_use'}},'--'=>sub {if ($expecting==TERM){$type='mm'}elsif ($expecting==UNKNOWN){my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);if ($next_nonblank_token eq '$'){$type='mm'}}},'&&'=>sub {error_if_expecting_TERM()if ($expecting==TERM)},'||'=>sub {error_if_expecting_TERM()if ($expecting==TERM)},'//'=>sub {error_if_expecting_TERM()if ($expecting==TERM)},};my%matching_start_token=('}'=>'{',']'=>'[',')'=>'(');my%is_zero_continuation_block_type;@_=qw(} { BEGIN END CHECK INIT AUTOLOAD DESTROY UNITCHECK continue ; if elsif else unless while until for foreach switch case given when);@is_zero_continuation_block_type{@_}=(1)x scalar(@_);my%is_not_zero_continuation_block_type;@_=qw(sort grep map do eval);@is_not_zero_continuation_block_type{@_}=(1)x scalar(@_);my%is_logical_container;@_=qw(if elsif unless while and or err not && ! || for foreach);@is_logical_container{@_}=(1)x scalar(@_);my%is_binary_type;@_=qw(|| &&);@is_binary_type{@_}=(1)x scalar(@_);my%is_binary_keyword;@_=qw(and or err eq ne cmp);@is_binary_keyword{@_}=(1)x scalar(@_);my%is_opening_type;@_=qw"L { ( [";@is_opening_type{@_}=(1)x scalar(@_);my%is_closing_type;@_=qw"R } ) ]";@is_closing_type{@_}=(1)x scalar(@_);my%is_redo_last_next_goto;@_=qw(redo last next goto);@is_redo_last_next_goto{@_}=(1)x scalar(@_);my%is_use_require;@_=qw(use require);@is_use_require{@_}=(1)x scalar(@_);my%is_sub_package;@_=qw(sub package);@is_sub_package{@_}=(1)x scalar(@_);my%is_format_END_DATA=('format'=>'_in_format','__END__'=>'_in_end','__DATA__'=>'_in_data',);my%quote_modifiers=('s'=>'[msixpodualngcer]','y'=>'[cdsr]','tr'=>'[cdsr]','m'=>'[msixpodualngc]','qr'=>'[msixpodualn]','q'=>"",'qq'=>"",'qw'=>"",'qx'=>"",);my%quote_items=('s'=>2,'y'=>2,'tr'=>2,'m'=>1,'qr'=>1,'q'=>1,'qq'=>1,'qw'=>1,'qx'=>1,);sub tokenize_this_line {my$line_of_tokens=shift;my ($untrimmed_input_line)=$line_of_tokens->{_line_text};$input_line_number=$line_of_tokens->{_line_number};$line_of_tokens->{_starting_in_quote}=$in_quote && $quote_type eq 'Q';if (($untrimmed_input_line =~ /^=[A-Za-z_]/)){if (!$in_quote and (operator_expected('b','=','b')==TERM)){$tokenizer_self->{_in_pod}=1;return}}$input_line=$untrimmed_input_line;chomp$input_line;unless ($in_quote && ($quote_type eq 'Q')){$input_line =~ s/^\s*//}$tokenizer_self->{_line_text}=$input_line;$routput_token_list=[];$routput_token_type=[];$routput_block_type=[];$routput_container_type=[];$routput_type_sequence=[];$rhere_target_list=[];$tok=$last_nonblank_token;$type=$last_nonblank_type;$prototype=$last_nonblank_prototype;$last_nonblank_i=-1;$block_type=$last_nonblank_block_type;$container_type=$last_nonblank_container_type;$type_sequence=$last_nonblank_type_sequence;$indent_flag=0;$peeked_ahead=0;my$max_tokens_wanted=0;if (!$in_quote && ($input_line =~ /^#/)){$max_tokens_wanted=1}($rtokens,$rtoken_map,$rtoken_type)=pre_tokenize($input_line,$max_tokens_wanted);$max_token_index=scalar(@$rtokens)- 1;push(@$rtokens,' ',' ',' ');push(@$rtoken_map,0,0,0);push(@$rtoken_type,'b','b','b');for$i (0 .. $max_token_index + 3){$routput_token_type->[$i]="";$routput_block_type->[$i]="";$routput_container_type->[$i]="";$routput_type_sequence->[$i]="";$routput_indent_flag->[$i]=0}$i=-1;$i_tok=-1;while (++$i <= $max_token_index){if ($in_quote){$type=$quote_type;unless (@{$routput_token_list}){push(@{$routput_token_list},$i);$routput_token_type->[$i]=$type}$tok=$quote_character unless ($quote_character =~ /^\s*$/);($i,$in_quote,$quote_character,$quote_pos,$quote_depth,$quoted_string_1,$quoted_string_2)=do_quote($i,$in_quote,$quote_character,$quote_pos,$quote_depth,$quoted_string_1,$quoted_string_2,$rtokens,$rtoken_map,$max_token_index);last if ($in_quote);my$qs1=$quoted_string_1;my$qs2=$quoted_string_2;$quote_character='';$quote_pos=0;$quote_type='Q';$quoted_string_1="";$quoted_string_2="";last if (++$i > $max_token_index);if ($allowed_quote_modifiers){if ($$rtokens[$i]=~ /^[A-Za-z_]/){my$str=$$rtokens[$i];my$saw_modifier_e;while ($str =~ /\G$allowed_quote_modifiers/gc){my$pos=pos($str);my$char=substr($str,$pos - 1,1);$saw_modifier_e ||= ($char eq 'e')}if ($saw_modifier_e){my$rht=scan_replacement_text($qs1);if ($rht){push @{$rhere_target_list},@{$rht};$type='h';if ($i_tok < 0){my$ilast=$routput_token_list->[-1];$routput_token_type->[$ilast]=$type}}}if (defined(pos($str))){if (pos($str)==length($str)){last if (++$i > $max_token_index)}else {warning(<<EOM);last if (++$i > $max_token_index)}}else {write_logfile_entry("Note: found word $str at quote modifier location\n")}}$allowed_quote_modifiers=""}}unless ($tok =~ /^\s*$/ || $tok eq 'CORE::'){if (($type eq 'n')&& ($tok ne '0')){if ($last_nonblank_token eq 'eq'){complain("Should 'eq' be '==' here ?\n")}elsif ($last_nonblank_token eq 'ne'){complain("Should 'ne' be '!=' here ?\n")}}$last_last_nonblank_token=$last_nonblank_token;$last_last_nonblank_type=$last_nonblank_type;$last_last_nonblank_block_type=$last_nonblank_block_type;$last_last_nonblank_container_type=$last_nonblank_container_type;$last_last_nonblank_type_sequence=$last_nonblank_type_sequence;$last_nonblank_token=$tok;$last_nonblank_type=$type;$last_nonblank_prototype=$prototype;$last_nonblank_block_type=$block_type;$last_nonblank_container_type=$container_type;$last_nonblank_type_sequence=$type_sequence;$last_nonblank_i=$i_tok}if ($i_tok >= 0){$routput_token_type->[$i_tok]=$type;$routput_block_type->[$i_tok]=$block_type;$routput_container_type->[$i_tok]=$container_type;$routput_type_sequence->[$i_tok]=$type_sequence;$routput_indent_flag->[$i_tok]=$indent_flag}my$pre_tok=$$rtokens[$i];my$pre_type=$$rtoken_type[$i];$tok=$pre_tok;$type=$pre_type;$block_type="";$container_type="";$type_sequence="";$indent_flag=0;$prototype="";$i_tok=$i;push(@{$routput_token_list},$i_tok);if ($id_scan_state && $pre_type !~ /[b#]/){if ($id_scan_state =~ /^(sub|package)/){scan_id()}else {scan_identifier()}last if ($id_scan_state);next if (($i > 0)|| $type);$type=$pre_type;$tok=$pre_tok}next if ($type eq 'b');my$prev_tok=$i > 0 ? $$rtokens[$i - 1 ]: ' ';my$prev_type=$i > 0 ? $$rtoken_type[$i - 1 ]: 'b';my$test_tok=$tok .$$rtokens[$i + 1 ];my$combine_ok=$is_digraph{$test_tok};if ($combine_ok){if ($test_tok eq '//' && $last_nonblank_type ne 'Z'){my$next_type=$$rtokens[$i + 1 ];my$expecting=operator_expected($prev_type,$tok,$next_type);$combine_ok=0 if ($expecting==TERM)}}if ($combine_ok && ($test_tok ne '/=')&& ($test_tok ne 'x=')&& ($test_tok ne '**')&& ($test_tok ne '*=')){$tok=$test_tok;$i++;$test_tok=$tok .$$rtokens[$i + 1 ];if ($is_trigraph{$test_tok}){$tok=$test_tok;$i++}}$type=$tok;$next_tok=$$rtokens[$i + 1 ];$next_type=$$rtoken_type[$i + 1 ];TOKENIZER_DEBUG_FLAG_TOKENIZE && do {local $"=')(';my@debug_list=($last_nonblank_token,$tok,$next_tok,$brace_depth,$brace_type[$brace_depth],$paren_depth,$paren_type[$paren_depth]);print STDOUT "TOKENIZE:(@debug_list)\n"};if ($pre_type ne 'w'){$in_attribute_list=0}if ($pre_type eq 'w'){$expecting=operator_expected($prev_type,$tok,$next_type);my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);if ($in_attribute_list){if ($next_nonblank_token eq '('){$in_quote=$quote_items{'q'};$allowed_quote_modifiers=$quote_modifiers{'q'};$type='q';$quote_type='q';next}else {$type='w';next}}if ($next_nonblank_token eq '='){if ($$rtokens[$i_next + 1 ]eq '>'){if ($is_constant{$current_package}{$tok}){$type='C'}elsif ($is_user_function{$current_package}{$tok}){$type='U';$prototype=$user_function_prototype{$current_package}{$tok}}elsif ($tok =~ /^v\d+$/){$type='v';report_v_string($tok)}else {$type='w'}next}}if ($next_nonblank_token eq '}' && ($last_nonblank_type eq 'L' || ($last_nonblank_type eq 'm' && $last_last_nonblank_type eq 'L'))){$type='w';next}my$tok_kw=$tok;if ($$rtokens[$i + 1 ]eq ':' && $$rtokens[$i + 2 ]eq ':'){$tok_kw .= '::'}if (($tok =~ /^x\d*$/)&& ($expecting==OPERATOR)){if ($tok eq 'x'){if ($$rtokens[$i + 1 ]eq '='){$tok='x=';$type=$tok;$i++}else {$type='x'}}else {$type='n'}}elsif ($tok_kw eq 'CORE::'){$type=$tok=$tok_kw;$i += 2}elsif (($tok eq 'strict')and ($last_nonblank_token eq 'use')){$tokenizer_self->{_saw_use_strict}=1;scan_bare_identifier()}elsif (($tok eq 'warnings')and ($last_nonblank_token eq 'use')){$tokenizer_self->{_saw_perl_dash_w}=1;scan_bare_identifier()}elsif ($tok eq 'AutoLoader' && $tokenizer_self->{_look_for_autoloader}&& ($last_nonblank_token eq 'use' || $input_line =~ /^\s*(use|require)\s+AutoLoader\b/ || $input_line =~ /\bISA\s*=.*\bAutoLoader\b/)){write_logfile_entry("AutoLoader seen, -nlal deactivates\n");$tokenizer_self->{_saw_autoloader}=1;$tokenizer_self->{_look_for_autoloader}=0;scan_bare_identifier()}elsif ($tok eq 'SelfLoader' && $tokenizer_self->{_look_for_selfloader}&& ($last_nonblank_token eq 'use' || $input_line =~ /^\s*(use|require)\s+SelfLoader\b/ || $input_line =~ /\bISA\s*=.*\bSelfLoader\b/)){write_logfile_entry("SelfLoader seen, -nlsl deactivates\n");$tokenizer_self->{_saw_selfloader}=1;$tokenizer_self->{_look_for_selfloader}=0;scan_bare_identifier()}elsif (($tok eq 'constant')and ($last_nonblank_token eq 'use')){scan_bare_identifier();my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);if ($next_nonblank_token){if ($is_keyword{$next_nonblank_token}){if (0 && $next_nonblank_token ne 'qw'){warning("Attempting to define constant '$next_nonblank_token' which is a perl keyword\n")}}else {$is_constant{$current_package}{$next_nonblank_token}=1}}}elsif ($is_q_qq_qw_qx_qr_s_y_tr_m{$tok}){if ($expecting==OPERATOR){unless ($tok eq 'qw' && ($last_nonblank_token =~ /^([\]\}\&]|\-\>)/ || $is_for_foreach{$want_paren})){error_if_expecting_OPERATOR()}}$in_quote=$quote_items{$tok};$allowed_quote_modifiers=$quote_modifiers{$tok};$type=($tok eq 'qw' && $tokenizer_self->{_trim_qw})? 'q' : 'Q';$quote_type=$type}elsif (($next_nonblank_token eq ':')&& ($$rtokens[$i_next + 1 ]ne ':')&& ($i_next <= $max_token_index)&& label_ok()){if ($tok !~ /[A-Z]/){push @{$tokenizer_self->{_rlower_case_labels_at}},$input_line_number}$type='J';$tok .= ':';$i=$i_next;next}elsif ($is_sub_package{$tok_kw}){error_if_expecting_OPERATOR()if ($expecting==OPERATOR);scan_id()}elsif ($is_format_END_DATA{$tok_kw}){$type=';';$tokenizer_self->{$is_format_END_DATA{$tok_kw}}=1;last}elsif ($is_keyword{$tok_kw}){$type='k';if ($is_for_foreach{$tok}){if (new_statement_ok()){$want_paren=$tok}}elsif ($is_use_require{$tok}){$statement_type=$tok;error_if_expecting_OPERATOR()if ($expecting==OPERATOR)}elsif ($is_my_our{$tok}){$statement_type=$tok}elsif ($tok eq 'elsif'){if ($last_nonblank_token ne ';' && $last_nonblank_block_type !~ /^(if|elsif|unless)$/){warning("expecting '$tok' to follow one of 'if|elsif|unless'\n")}}elsif ($tok eq 'else'){if ($last_nonblank_token ne ';' && $last_nonblank_block_type !~ /^(if|elsif|unless|case|when)$/ && $statement_type !~ /^(if|elsif|unless|case|when)$/){warning("expecting '$tok' to follow one of 'if|elsif|unless|case|when'\n")}}elsif ($tok eq 'continue'){if ($last_nonblank_token ne ';' && $last_nonblank_block_type !~ /(^(\{|\}|;|while|until|for|foreach)|:$)/){}}elsif ($tok eq 'when' || $tok eq 'case'){$statement_type=$tok}}elsif (($last_nonblank_type eq 'k')&& ($is_redo_last_next_goto{$last_nonblank_token})){$type='j';next}else {scan_bare_identifier();if ($type eq 'w'){if ($expecting==OPERATOR){if ($last_nonblank_type eq 'C'){if ($tok !~ /::$/){complain(<<EOM)}}else {error_if_expecting_OPERATOR("bareword")}}$next_tok=$$rtokens[$i + 1 ];if ($next_tok eq '('){$type='U'}if ($tok eq '_' && $last_nonblank_type eq 'F'){$type='Z'}if (($tok eq 'case' && $brace_type[$brace_depth]eq 'switch')|| ($tok eq 'when' && $brace_type[$brace_depth]eq 'given')){$statement_type=$tok;$type='k'}if ($next_nonblank_token eq '(' && ($tok eq 'switch' || $tok eq 'given')){$type='k'}}}}elsif ($pre_type eq 'd'){$expecting=operator_expected($prev_type,$tok,$next_type);error_if_expecting_OPERATOR("Number")if ($expecting==OPERATOR);my$number=scan_number();if (!defined($number)){warning("non-number beginning with digit--program bug\n");report_definite_bug()}}else {last if ($tok eq '#');my$code=$tokenization_code->{$tok};if ($code){$expecting=operator_expected($prev_type,$tok,$next_type);$code->();redo if$in_quote}}}if ($i_tok >= 0){$routput_token_type->[$i_tok]=$type;$routput_block_type->[$i_tok]=$block_type;$routput_container_type->[$i_tok]=$container_type;$routput_type_sequence->[$i_tok]=$type_sequence;$routput_indent_flag->[$i_tok]=$indent_flag}unless (($type eq 'b')|| ($type eq '#')){$last_last_nonblank_token=$last_nonblank_token;$last_last_nonblank_type=$last_nonblank_type;$last_last_nonblank_block_type=$last_nonblank_block_type;$last_last_nonblank_container_type=$last_nonblank_container_type;$last_last_nonblank_type_sequence=$last_nonblank_type_sequence;$last_nonblank_token=$tok;$last_nonblank_type=$type;$last_nonblank_block_type=$block_type;$last_nonblank_container_type=$container_type;$last_nonblank_type_sequence=$type_sequence;$last_nonblank_prototype=$prototype}if ($level_in_tokenizer < 0){if ($input_line =~ /^\s*(sub|package)\s+(\w+)/){reset_indentation_level(0);brace_warning("resetting level to 0 at $1 $2\n")}}my@token_type=();my@block_type=();my@container_type=();my@type_sequence=();my@tokens=();my@levels=();my@slevels=();my@nesting_tokens=();my@nesting_types=();my@nesting_blocks=();my@nesting_lists=();my@ci_string=();my@container_environment=();my$container_environment='';my$im=-1;my$num;my$ci_string_sum=ones_count($ci_string_in_tokenizer);my ($ci_string_i,$level_i,$nesting_block_string_i,$nesting_list_string_i,$nesting_token_string_i,$nesting_type_string_i,);for$i (@{$routput_token_list}){my$type=$routput_token_type->[$i];my$forced_indentation_flag=$routput_indent_flag->[$i];if ($forced_indentation_flag && $type eq 'k'){my$ixlast=-1;my$ilast=$routput_token_list->[$ixlast];my$toklast=$routput_token_type->[$ilast];if ($toklast eq '#'){$ixlast--;$ilast=$routput_token_list->[$ixlast];$toklast=$routput_token_type->[$ilast]}if ($toklast eq 'b'){$ixlast--;$ilast=$routput_token_list->[$ixlast];$toklast=$routput_token_type->[$ilast]}if ($toklast =~ /^[\{,]$/){$forced_indentation_flag=0}else {($toklast,my$i_next)=find_next_nonblank_token($max_token_index,$rtokens,$max_token_index);if ($toklast =~ /^[\{,]$/){$forced_indentation_flag=0}}}if ($indented_if_level){if ($type eq 'k'){$forced_indentation_flag=0}elsif ($type eq ';'){if ($level_in_tokenizer==$indented_if_level){$forced_indentation_flag=-1;$indented_if_level=0}}elsif ($type eq '}'){if ($level_in_tokenizer==$indented_if_level){$indented_if_level=0;$level_in_tokenizer--;if (@{$rslevel_stack}> 1){pop(@{$rslevel_stack})}if (length($nesting_block_string)> 1){chop$nesting_block_string;chop$nesting_list_string}}}}my$tok=$$rtokens[$i];$level_i=$level_in_tokenizer;if (!$is_valid_token_type{$type}){my$val=ord($type);warning("unexpected character decimal $val ($type) in script\n");$tokenizer_self->{_in_error}=1}my$fix_type=$type;if ($type eq ';' && $tok =~ /\w/){$fix_type='k'}if ($type eq 't' && $tok eq 'sub'){$fix_type='k'}$nesting_token_string_i=$nesting_token_string;$nesting_type_string_i=$nesting_type_string;$nesting_block_string_i=$nesting_block_string;$nesting_list_string_i=$nesting_list_string;if ($type eq '{' || $type eq 'L' || $forced_indentation_flag > 0){$container_environment=$nesting_block_flag ? 'BLOCK' : $nesting_list_flag ? 'LIST' : "";my$intervening_secondary_structure=0;if (@{$rslevel_stack}){$intervening_secondary_structure=$slevel_in_tokenizer - $rslevel_stack->[-1]}push(@{$rslevel_stack},1 + $slevel_in_tokenizer);$level_in_tokenizer++;if ($forced_indentation_flag){if ($type eq '?'){$level_i=$level_in_tokenizer}if ($type eq 'k'){$indented_if_level=$level_in_tokenizer}$nesting_block_string .= "$nesting_block_flag"}else {if ($routput_block_type->[$i]){$nesting_block_flag=1;$nesting_block_string .= '1'}else {$nesting_block_flag=0;$nesting_block_string .= '0'}}my$bit=0;if (!$routput_block_type->[$i]){if ($routput_container_type->[$i]eq '('){$bit=1 if$nesting_list_flag}else {$bit=1 unless $is_logical_container{$routput_container_type->[$i]}}}$nesting_list_string .= $bit;$nesting_list_flag=$bit;$ci_string_in_tokenizer .= ($intervening_secondary_structure!=0)? '1' : '0';$ci_string_sum=ones_count($ci_string_in_tokenizer);$continuation_string_in_tokenizer .= ($in_statement_continuation > 0)? '1' : '0';my$total_ci=$ci_string_sum;if (!$routput_block_type->[$i]&& ($in_statement_continuation)&&!($forced_indentation_flag && $type eq ':')){$total_ci += $in_statement_continuation unless ($ci_string_in_tokenizer =~ /1$/)}$ci_string_i=$total_ci;$in_statement_continuation=0}elsif ($type eq '}' || $type eq 'R' || $forced_indentation_flag < 0){if (@{$rslevel_stack}> 1){pop(@{$rslevel_stack})}$level_i=--$level_in_tokenizer;if (length($nesting_block_string)> 1){chop$nesting_block_string;$nesting_block_flag=($nesting_block_string =~ /1$/);chop$nesting_list_string;$nesting_list_flag=($nesting_list_string =~ /1$/);chop$ci_string_in_tokenizer;$ci_string_sum=ones_count($ci_string_in_tokenizer);$in_statement_continuation=chop$continuation_string_in_tokenizer;if ($routput_block_type->[$i]){if ($routput_block_type->[$i]=~ m/^sub\s*/gc){if ($routput_block_type->[$i]=~ /\G('|::|\w)/gc){$in_statement_continuation=0}}elsif ($is_zero_continuation_block_type{$routput_block_type->[$i]}){$in_statement_continuation=0}elsif ($is_not_zero_continuation_block_type{$routput_block_type->[$i]}){}elsif ($routput_block_type->[$i]=~ /:$/){$in_statement_continuation=0}else {$in_statement_continuation=0}}elsif ($tok eq ')'){$in_statement_continuation=1 if$routput_container_type->[$i]=~ /^[;,\{\}]$/}elsif ($tok eq ';'){$in_statement_continuation=0}}$container_environment=$nesting_block_flag ? 'BLOCK' : $nesting_list_flag ? 'LIST' : "";$ci_string_i=$ci_string_sum + $in_statement_continuation;$nesting_block_string_i=$nesting_block_string;$nesting_list_string_i=$nesting_list_string}else {$container_environment=$nesting_block_flag ? 'BLOCK' : $nesting_list_flag ? 'LIST' : "";if ($nesting_list_flag){if ($type =~ /^[,\?\:]$/){$in_statement_continuation=0}}if ($container_environment && ($type eq 'k' && $is_binary_keyword{$tok}|| $is_binary_type{$type})){$in_statement_continuation=1}$ci_string_i=$ci_string_sum + $in_statement_continuation;if ($type ne 'b' && $type ne '#'){if ($nesting_block_flag){if ($type eq ';' || $type eq 'J'){$in_statement_continuation=0}else {$in_statement_continuation=1}}else {if (!$nesting_list_flag){$in_statement_continuation=0}elsif ($type eq ',' || $type eq ';'){$in_statement_continuation=0}else {$in_statement_continuation=1}}}}if ($level_in_tokenizer < 0){unless ($tokenizer_self->{_saw_negative_indentation}){$tokenizer_self->{_saw_negative_indentation}=1;warning("Starting negative indentation\n")}}my$slevel_i=$slevel_in_tokenizer;if ($is_opening_type{$type}){$slevel_in_tokenizer++;$nesting_token_string .= $tok;$nesting_type_string .= $type}elsif ($is_closing_type{$type}){$slevel_in_tokenizer--;my$char=chop$nesting_token_string;if ($char ne $matching_start_token{$tok}){$nesting_token_string .= $char .$tok;$nesting_type_string .= $type}else {chop$nesting_type_string}}push(@block_type,$routput_block_type->[$i]);push(@ci_string,$ci_string_i);push(@container_environment,$container_environment);push(@container_type,$routput_container_type->[$i]);push(@levels,$level_i);push(@nesting_tokens,$nesting_token_string_i);push(@nesting_types,$nesting_type_string_i);push(@slevels,$slevel_i);push(@token_type,$fix_type);push(@type_sequence,$routput_type_sequence->[$i]);push(@nesting_blocks,$nesting_block_string);push(@nesting_lists,$nesting_list_string);if ($im >= 0){$num=$$rtoken_map[$i]- $$rtoken_map[$im];if ($num > 0){push(@tokens,substr($input_line,$$rtoken_map[$im],$num))}}$im=$i}$num=length($input_line)- $$rtoken_map[$im];if ($num > 0){push(@tokens,substr($input_line,$$rtoken_map[$im],$num))}$tokenizer_self->{_in_attribute_list}=$in_attribute_list;$tokenizer_self->{_in_quote}=$in_quote;$tokenizer_self->{_quote_target}=$in_quote ? matching_end_token($quote_character): "";$tokenizer_self->{_rhere_target_list}=$rhere_target_list;$line_of_tokens->{_rtoken_type}=\@token_type;$line_of_tokens->{_rtokens}=\@tokens;$line_of_tokens->{_rblock_type}=\@block_type;$line_of_tokens->{_rcontainer_type}=\@container_type;$line_of_tokens->{_rcontainer_environment}=\@container_environment;$line_of_tokens->{_rtype_sequence}=\@type_sequence;$line_of_tokens->{_rlevels}=\@levels;$line_of_tokens->{_rslevels}=\@slevels;$line_of_tokens->{_rnesting_tokens}=\@nesting_tokens;$line_of_tokens->{_rci_levels}=\@ci_string;$line_of_tokens->{_rnesting_blocks}=\@nesting_blocks;return}}sub operator_expected {my ($prev_type,$tok,$next_type)=@_;my$op_expected=UNKNOWN;if ($last_nonblank_type eq 'Z'){if ($last_nonblank_token =~ /^[A-Za-z_]/){$op_expected=UNKNOWN}elsif (($prev_type eq 'b')&& ($next_type ne 'b')){$op_expected=TERM}else {if ($tok =~ /^([x\/\+\-\*\%\&\.\?\<]|\>\>)$/){complain("operator in print statement not recommended\n");$op_expected=OPERATOR}}}elsif ($last_nonblank_type eq '}' && $last_nonblank_token eq '~~'){$op_expected=OPERATOR}elsif ($is_block_operator{$last_nonblank_token}){if ($last_nonblank_type eq 'k'){$op_expected=TERM}else {$op_expected=OPERATOR}}elsif ($last_nonblank_type eq 'w'){$op_expected=UNKNOWN}elsif (($last_nonblank_type =~ /^[\]RnviQh]$/)|| ($last_nonblank_token =~ /^(\)|\$|\-\>)/)){$op_expected=OPERATOR;if (($statement_type eq 'use')&& ($last_nonblank_type =~ /^[nv]$/)){$op_expected=UNKNOWN}elsif ($statement_type =~ /^package\b/ && $last_nonblank_token =~ /^package\b/){$op_expected=TERM}}elsif ($expecting_term_token{$last_nonblank_token}){if ($tok eq '/' && $next_type eq '/' && $last_nonblank_type eq 'k' && $last_nonblank_token =~ /^eof|undef|shift|pop$/){$op_expected=OPERATOR}else {$op_expected=TERM}}elsif ($expecting_term_types{$last_nonblank_type}){$op_expected=TERM}elsif ($expecting_operator_token{$last_nonblank_token}){$op_expected=OPERATOR}elsif ($expecting_operator_types{$last_nonblank_type}){$op_expected=OPERATOR}elsif ($last_nonblank_token =~ /^sub\s/){$op_expected=TERM}elsif ($last_nonblank_type eq '}'){if ($tok eq '/' && $next_type eq '/' && $last_nonblank_token eq ']'){$op_expected=OPERATOR}else {$op_expected=TERM}}else {$op_expected=UNKNOWN;write_diagnostics("OP: unknown after type=$last_nonblank_type  token=$last_nonblank_token\n")}TOKENIZER_DEBUG_FLAG_EXPECT && do {print STDOUT "EXPECT: returns $op_expected for last type $last_nonblank_type token $last_nonblank_token\n"};return$op_expected}sub new_statement_ok {return label_ok()|| $last_nonblank_type eq 'J'}sub label_ok {if (($last_nonblank_token eq '{' || $last_nonblank_token eq '}')&& $last_nonblank_type eq $last_nonblank_token){return$brace_type[$brace_depth]}else {return ($last_nonblank_type eq ';' || $last_nonblank_type eq 'J')}}sub code_block_type {my ($i,$rtokens,$rtoken_type,$max_token_index)=@_;if ($last_nonblank_token eq '{' && $last_nonblank_type eq $last_nonblank_token){if ($brace_type[$brace_depth]){return decide_if_code_block($i,$rtokens,$rtoken_type,$max_token_index)}else {return ""}}elsif ($last_nonblank_token eq ';'){return decide_if_code_block($i,$rtokens,$rtoken_type,$max_token_index)}elsif ($last_nonblank_token eq '}' && $last_nonblank_type eq $last_nonblank_token){if ($last_nonblank_block_type){return decide_if_code_block($i,$rtokens,$rtoken_type,$max_token_index)}else {return$last_nonblank_token}}elsif ($last_nonblank_type eq 'J'){return$last_nonblank_token}elsif ($is_code_block_token{$last_nonblank_token}){if ($last_nonblank_token =~ /^(if|unless)$/ && $last_nonblank_type eq 'k'){return ""}else {return$last_nonblank_token}}elsif (($last_nonblank_type eq 'i' || $last_nonblank_type eq 't')&& $last_nonblank_token =~ /^(sub|package)\b/){return$last_nonblank_token}elsif ($statement_type =~ /^(sub|package)\b/){return$statement_type}elsif ($last_nonblank_type eq 'G'){return$last_nonblank_token}elsif ($last_nonblank_type eq 'w'){return decide_if_code_block($i,$rtokens,$rtoken_type,$max_token_index)}elsif ($last_nonblank_token eq '('){my$paren_type=$paren_type[$paren_depth];if ($paren_type && $paren_type =~ /^(map|grep|sort)$/){return 't'}else {return ""}}elsif ($last_nonblank_token =~ /\(\)$/){return$last_nonblank_token}else {return ""}}sub decide_if_code_block {my ($i,$rtokens,$rtoken_type,$max_token_index)=@_;my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);my$code_block_type=$last_nonblank_token;if ($next_nonblank_token eq '}'){$code_block_type=""}else {my@pre_types;my@pre_tokens;if ($next_nonblank_token ne '#'){@pre_types=@$rtoken_type[$i + 1 .. $max_token_index ];@pre_tokens=@$rtokens[$i + 1 .. $max_token_index ]}my ($rpre_tokens,$rpre_types)=peek_ahead_for_n_nonblank_pre_tokens(20);if (defined($rpre_types)&& @$rpre_types){push@pre_types,@$rpre_types;push@pre_tokens,@$rpre_tokens}push@pre_types,'}';push@pre_types,'}';my$jbeg=0;$jbeg=1 if$pre_types[0]eq 'b';my$j=$jbeg;if ($pre_types[$j]=~ /^[\'\"]/){my$quote_mark=$pre_types[$j];for (my$k=$j + 1 ;$k < $#pre_types ;$k++ ){if ($pre_types[$k]eq $quote_mark){$j=$k + 1;my$next=$pre_types[$j];last}}}elsif ($pre_types[$j]eq 'd'){$j++}elsif ($pre_types[$j]eq 'w'){$j++}elsif ($pre_types[$j]eq '-' && $pre_types[++$j ]eq 'w'){$j++}if ($j > $jbeg){$j++ if$pre_types[$j]eq 'b';if (($pre_types[$j]eq ',' && $pre_tokens[$jbeg]!~ /^(s|m|y|tr|qr|q|qq|qx)$/)|| ($pre_types[$j]eq '=' && $pre_types[++$j ]eq '>')){$code_block_type=""}}}return$code_block_type}sub unexpected {my ($found,$expecting,$i_tok,$last_nonblank_i,$rpretoken_map,$rpretoken_type,$input_line)=@_;if (++$tokenizer_self->{_unexpected_error_count}<= MAX_NAG_MESSAGES){my$msg="found $found where $expecting expected";my$pos=$$rpretoken_map[$i_tok];interrupt_logfile();my$input_line_number=$tokenizer_self->{_last_line_number};my ($offset,$numbered_line,$underline)=make_numbered_line($input_line_number,$input_line,$pos);$underline=write_on_underline($underline,$pos - $offset,'^');my$trailer="";if (($i_tok > 0)&& ($last_nonblank_i >= 0)){my$pos_prev=$$rpretoken_map[$last_nonblank_i];my$num;if ($$rpretoken_type[$i_tok - 1 ]eq 'b'){$num=$$rpretoken_map[$i_tok - 1 ]- $pos_prev}else {$num=$pos - $pos_prev}if ($num > 40){$num=40;$pos_prev=$pos - 40}$underline=write_on_underline($underline,$pos_prev - $offset,'-' x $num);$trailer=" (previous token underlined)"}warning($numbered_line ."\n");warning($underline ."\n");warning($msg .$trailer ."\n");resume_logfile()}}sub is_non_structural_brace {($last_nonblank_token =~ /^([\$\@\*\&\%\)]|->|::)/ || $last_nonblank_type =~ /^([R\]])$/)}sub increase_nesting_depth {my ($aa,$pos)=@_;my$bb;$current_depth[$aa]++;$total_depth++;$total_depth[$aa][$current_depth[$aa]]=$total_depth;my$input_line_number=$tokenizer_self->{_last_line_number};my$input_line=$tokenizer_self->{_line_text};$nesting_sequence_number[$aa]+= scalar(@closing_brace_names);my$seqno=$nesting_sequence_number[$aa];$current_sequence_number[$aa][$current_depth[$aa]]=$seqno;$starting_line_of_current_depth[$aa][$current_depth[$aa]]=[$input_line_number,$input_line,$pos ];for$bb (0 .. $#closing_brace_names){next if ($bb==$aa);$depth_array[$aa][$bb][$current_depth[$aa]]=$current_depth[$bb]}my$indent=0;if ($aa==QUESTION_COLON){$nested_ternary_flag[$current_depth[$aa]]=0;if ($current_depth[$aa]> 1){if ($nested_ternary_flag[$current_depth[$aa]- 1 ]==0){my$pdepth=$total_depth[$aa][$current_depth[$aa]- 1 ];if ($pdepth==$total_depth - 1){$indent=1;$nested_ternary_flag[$current_depth[$aa]- 1 ]=-1}}}}$nested_statement_type[$aa][$current_depth[$aa]]=$statement_type;$statement_type="";return ($seqno,$indent)}sub decrease_nesting_depth {my ($aa,$pos)=@_;my$bb;my$seqno=0;my$input_line_number=$tokenizer_self->{_last_line_number};my$input_line=$tokenizer_self->{_line_text};my$outdent=0;$total_depth--;if ($current_depth[$aa]> 0){$seqno=$current_sequence_number[$aa][$current_depth[$aa]];if ($aa==QUESTION_COLON){$outdent=$nested_ternary_flag[$current_depth[$aa]]}$statement_type=$nested_statement_type[$aa][$current_depth[$aa]];for$bb (0 .. $#closing_brace_names){next if ($bb==$aa);unless ($depth_array[$aa][$bb][$current_depth[$aa]]==$current_depth[$bb]){my$diff=$current_depth[$bb]- $depth_array[$aa][$bb][$current_depth[$aa]];my$saw_brace_error=get_saw_brace_error();if ($saw_brace_error <= MAX_NAG_MESSAGES && (($diff > 0)|| ($saw_brace_error <= 0))){interrupt_logfile();my$rsl=$starting_line_of_current_depth[$aa][$current_depth[$aa]];my$sl=$$rsl[0];my$rel=[$input_line_number,$input_line,$pos ];my$el=$$rel[0];my ($ess);if ($diff==1 || $diff==-1){$ess=''}else {$ess='s'}my$bname=($diff > 0)? $opening_brace_names[$bb]: $closing_brace_names[$bb];write_error_indicator_pair(@$rsl,'^');my$msg=<<"EOM";if ($diff > 0){my$rml=$starting_line_of_current_depth[$bb][$current_depth[$bb]];my$ml=$$rml[0];$msg .= "    The most recent un-matched $bname is on line $ml\n";write_error_indicator_pair(@$rml,'^')}write_error_indicator_pair(@$rel,'^');warning($msg);resume_logfile()}increment_brace_error()}}$current_depth[$aa]--}else {my$saw_brace_error=get_saw_brace_error();if ($saw_brace_error <= MAX_NAG_MESSAGES){my$msg=<<"EOM";indicate_error($msg,$input_line_number,$input_line,$pos,'^')}increment_brace_error()}return ($seqno,$outdent)}sub check_final_nesting_depths {my ($aa);for$aa (0 .. $#closing_brace_names){if ($current_depth[$aa]){my$rsl=$starting_line_of_current_depth[$aa][$current_depth[$aa]];my$sl=$$rsl[0];my$msg=<<"EOM";indicate_error($msg,@$rsl,'^');increment_brace_error()}}}sub peek_ahead_for_n_nonblank_pre_tokens {my$max_pretokens=shift;my$line;my$i=0;my ($rpre_tokens,$rmap,$rpre_types);while ($line=$tokenizer_self->{_line_buffer_object}->peek_ahead($i++)){$line =~ s/^\s*//;next if (length($line)<= 0);next if ($line =~ /^#/);($rpre_tokens,$rmap,$rpre_types)=pre_tokenize($line,$max_pretokens);last}return ($rpre_tokens,$rpre_types)}sub peek_ahead_for_nonblank_token {my ($rtokens,$max_token_index)=@_;my$line;my$i=0;while ($line=$tokenizer_self->{_line_buffer_object}->peek_ahead($i++)){$line =~ s/^\s*//;next if (length($line)<= 0);next if ($line =~ /^#/);my ($rtok,$rmap,$rtype)=pre_tokenize($line,2);my$j=$max_token_index + 1;my$tok;for$tok (@$rtok){last if ($tok =~ "\n");$$rtokens[++$j ]=$tok}last}return$rtokens}sub guess_if_pattern_or_conditional {my ($i,$rtokens,$rtoken_map,$max_token_index)=@_;my$is_pattern=0;my$msg="guessing that ? after $last_nonblank_token starts a ";if ($i >= $max_token_index){$msg .= "conditional (no end to pattern found on the line)\n"}else {my$ibeg=$i;$i=$ibeg + 1;my$next_token=$$rtokens[$i];my$in_quote=1;my$quote_depth=0;my$quote_character='';my$quote_pos=0;my$quoted_string;($i,$in_quote,$quote_character,$quote_pos,$quote_depth,$quoted_string)=follow_quoted_string($ibeg,$in_quote,$rtokens,$quote_character,$quote_pos,$quote_depth,$max_token_index);if ($in_quote){$is_pattern=0;$msg .= "conditional (no ending ? on this line)\n"}else {if (pattern_expected($i,$rtokens,$max_token_index)>= 0){$is_pattern=1;$msg .= "pattern (found ending ? and pattern expected)\n"}else {$msg .= "pattern (uncertain, but found ending ?)\n"}}}return ($is_pattern,$msg)}sub guess_if_pattern_or_division {my ($i,$rtokens,$rtoken_map,$max_token_index)=@_;my$is_pattern=0;my$msg="guessing that / after $last_nonblank_token starts a ";if ($i >= $max_token_index){$msg .= "division (no end to pattern found on the line)\n"}else {my$ibeg=$i;my$divide_expected=numerator_expected($i,$rtokens,$max_token_index);$i=$ibeg + 1;my$next_token=$$rtokens[$i];my$in_quote=1;my$quote_depth=0;my$quote_character='';my$quote_pos=0;my$quoted_string;($i,$in_quote,$quote_character,$quote_pos,$quote_depth,$quoted_string)=follow_quoted_string($ibeg,$in_quote,$rtokens,$quote_character,$quote_pos,$quote_depth,$max_token_index);if ($in_quote){if ($divide_expected >= 0){$is_pattern=0;$msg .= "division (no ending / on this line)\n"}else {$msg="multi-line pattern (division not possible)\n";$is_pattern=1}}else {if (pattern_expected($i,$rtokens,$max_token_index)>= 0){if ($divide_expected >= 0){if ($i - $ibeg > 60){$msg .= "division (matching / too distant)\n";$is_pattern=0}else {$msg .= "pattern (but division possible too)\n";$is_pattern=1}}else {$is_pattern=1;$msg .= "pattern (division not possible)\n"}}else {if ($divide_expected >= 0){$is_pattern=0;$msg .= "division (pattern not possible)\n"}else {$is_pattern=1;$msg .= "pattern (uncertain, but division would not work here)\n"}}}}return ($is_pattern,$msg)}sub guess_if_here_doc {use constant HERE_DOC_WINDOW=>40;my$next_token=shift;my$here_doc_expected=0;my$line;my$k=0;my$msg="checking <<";while ($line=$tokenizer_self->{_line_buffer_object}->peek_ahead($k++)){chomp$line;if ($line =~ /^$next_token$/){$msg .= " -- found target $next_token ahead $k lines\n";$here_doc_expected=1;last}last if ($k >= HERE_DOC_WINDOW)}unless ($here_doc_expected){if (!defined($line)){$here_doc_expected=-1;$msg .= " -- must be shift; target $next_token not in file\n"}else {if (!$is_constant{$current_package}{$next_token}){$here_doc_expected=1;$msg .= " -- guessing it's a here-doc ($next_token not a constant)\n"}else {$msg .= " -- guessing it's a shift ($next_token is a constant)\n"}}}write_logfile_entry($msg);return$here_doc_expected}sub scan_bare_identifier_do {my ($input_line,$i,$tok,$type,$prototype,$rtoken_map,$max_token_index)=@_;my$i_begin=$i;my$package=undef;my$i_beg=$i;if ($tok eq '::'){$i_beg--}if ($tok eq '->'){$i_beg--}my$pos_beg=$$rtoken_map[$i_beg];pos($input_line)=$pos_beg;if ($input_line =~ m/\G\s*((?:\w*(?:'|::)))*(?:(?:->)?(\w+))?/gc){my$pos=pos($input_line);my$numc=$pos - $pos_beg;$tok=substr($input_line,$pos_beg,$numc);$type='w';my$sub_name="";if (defined($2)){$sub_name=$2}if (defined($1)){$package=$1;if (!($sub_name)&& substr($package,-1,1)eq '\''){$pos--}$package =~ s/\'/::/g;if ($package =~ /^\:/){$package='main' .$package}$package =~ s/::$//}else {$package=$current_package;if ($is_keyword{$tok}){$type='k'}}if ($type eq 'w'){if ($tok =~ /^v\d[_\d]*$/){if ($input_line =~ m/\G(\.\d[_\d]*)+/gc){$pos=pos($input_line);$numc=$pos - $pos_beg;$tok=substr($input_line,$pos_beg,$numc)}$type='v';report_v_string($tok)}elsif ($is_constant{$package}{$sub_name}){$type='C'}elsif ($last_nonblank_token eq 'sort' && $last_nonblank_type eq 'k'){$type='Z'}elsif ($is_block_function{$package}{$sub_name}){$type='G'}elsif ($is_block_list_function{$package}{$sub_name}){$type='G'}elsif ($is_user_function{$package}{$sub_name}){$type='U';$prototype=$user_function_prototype{$package}{$sub_name}}elsif (($input_line !~ m/\G\(/gc)&& ($is_indirect_object_taker{$last_nonblank_token}|| (($last_nonblank_token eq '(')&& $is_indirect_object_taker{$paren_type[$paren_depth]}))){if ($input_line =~ m/\G\s+/gc){$type='Y';if ($sub_name =~ /[a-z]/){if ($input_line =~ m/\G\s*\(/gc){complain("Caution: unknown word '$tok' in indirect object slot\n")}}}else {$type='Z'}}}my$error;($i,$error)=inverse_pretoken_map($i,$pos,$rtoken_map,$max_token_index);if ($error){warning("scan_bare_identifier: Possibly invalid tokenization\n")}}else {$type='w';warning("didn't find identifier after leading ::\n")}return ($i,$tok,$type,$prototype)}sub scan_id_do {my ($input_line,$i,$tok,$rtokens,$rtoken_map,$id_scan_state,$max_token_index)=@_;my$type='';my ($i_beg,$pos_beg);if ($id_scan_state){$i_beg=$i;$type=''}else {$i_beg=$i + 1;$id_scan_state=$tok;$type='t'}my$blank_line=0;my$next_nonblank_token=$$rtokens[$i_beg];if ($i_beg > $max_token_index){$blank_line=1}else {if ($next_nonblank_token eq '#'){unless ($tok eq '$'){$blank_line=1}}if ($next_nonblank_token =~ /^\s/){($next_nonblank_token,$i_beg)=find_next_nonblank_token_on_this_line($i_beg,$rtokens,$max_token_index);if ($next_nonblank_token =~ /(^#|^\s*$)/){$blank_line=1}}}unless ($blank_line){if ($id_scan_state eq 'sub'){($i,$tok,$type,$id_scan_state)=do_scan_sub($input_line,$i,$i_beg,$tok,$type,$rtokens,$rtoken_map,$id_scan_state,$max_token_index)}elsif ($id_scan_state eq 'package'){($i,$tok,$type)=do_scan_package($input_line,$i,$i_beg,$tok,$type,$rtokens,$rtoken_map,$max_token_index);$id_scan_state=''}else {warning("invalid token in scan_id: $tok\n");$id_scan_state=''}}if ($id_scan_state && (!defined($type)||!$type)){warning("Program bug in scan_id: undefined type but scan_state=$id_scan_state\n");report_definite_bug()}TOKENIZER_DEBUG_FLAG_NSCAN && do {print STDOUT "NSCAN: returns i=$i, tok=$tok, type=$type, state=$id_scan_state\n"};return ($i,$tok,$type,$id_scan_state)}sub check_prototype {my ($proto,$package,$subname)=@_;return unless (defined($package)&& defined($subname));if (defined($proto)){$proto =~ s/^\s*\(\s*//;$proto =~ s/\s*\)$//;if ($proto){$is_user_function{$package}{$subname}=1;$user_function_prototype{$package}{$subname}="($proto)";if ($proto =~ /\&/){if ($proto =~ /\&$/){$is_block_function{$package}{$subname}=1}elsif ($proto !~ /\&$/){$is_block_list_function{$package}{$subname}=1}}}else {$is_constant{$package}{$subname}=1}}else {$is_user_function{$package}{$subname}=1}}sub do_scan_package {my ($input_line,$i,$i_beg,$tok,$type,$rtokens,$rtoken_map,$max_token_index)=@_;my$package=undef;my$pos_beg=$$rtoken_map[$i_beg];pos($input_line)=$pos_beg;if ($input_line =~ m/\G\s*((?:\w*(?:'|::))*\w+)/gc){$package=$1;$package=(defined($1)&& $1)? $1 : 'main';$package =~ s/\'/::/g;if ($package =~ /^\:/){$package='main' .$package}$package =~ s/::$//;my$pos=pos($input_line);my$numc=$pos - $pos_beg;$tok='package ' .substr($input_line,$pos_beg,$numc);$type='i';my$error;($i,$error)=inverse_pretoken_map($i,$pos,$rtoken_map,$max_token_index);if ($error){warning("Possibly invalid package\n")}$current_package=$package;my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);if ($next_nonblank_token =~ /^([v\.\d;\{\}])|v\d|\d+$/){$statement_type=$tok}else {warning("Unexpected '$next_nonblank_token' after package name '$tok'\n")}}else {$type='k'}return ($i,$tok,$type)}sub scan_identifier_do {my ($i,$id_scan_state,$identifier,$rtokens,$max_token_index,$expecting,$container_type)=@_;my$i_begin=$i;my$type='';my$tok_begin=$$rtokens[$i_begin];if ($tok_begin eq ':'){$tok_begin='::'}my$id_scan_state_begin=$id_scan_state;my$identifier_begin=$identifier;my$tok=$tok_begin;my$message="";my$in_prototype_or_signature=$container_type =~ /^sub/;my$saw_alpha=($tok =~ /^[A-Za-z_]/);my$saw_type;my$allow_tick=($last_nonblank_token ne 'use');unless ($id_scan_state){$context=UNKNOWN_CONTEXT;if ($tok eq '>'){$tok='->';$tok_begin=$tok}$identifier=$tok;if ($tok eq '$' || $tok eq '*'){$id_scan_state='$';$context=SCALAR_CONTEXT}elsif ($tok eq '%' || $tok eq '@'){$id_scan_state='$';$context=LIST_CONTEXT}elsif ($tok eq '&'){$id_scan_state='&'}elsif ($tok eq 'sub' or $tok eq 'package'){$saw_alpha=0;$id_scan_state='$';$identifier .= ' '}elsif ($tok eq '::'){$id_scan_state='A'}elsif ($tok =~ /^[A-Za-z_]/){$id_scan_state=':'}elsif ($tok eq '->'){$id_scan_state='$'}else {my ($a,$b,$c)=caller;warning("Program Bug: scan_identifier given bad token = $tok \n");warning("   called from sub $a  line: $c\n");report_definite_bug()}$saw_type=!$saw_alpha}else {$i--;$saw_type=($tok =~ /([\$\%\@\*\&])/)}my$i_save=$i;while ($i < $max_token_index){$i_save=$i unless ($tok =~ /^\s*$/);$tok=$$rtokens[++$i ];if (($tok eq ':')&& ($$rtokens[$i + 1 ]eq ':')){$tok='::';$i++}if ($id_scan_state eq '$'){if ($tok eq '$'){$identifier .= $tok;if ($i==$max_token_index){$type='i';$id_scan_state='';last}}elsif (($tok =~ /^[\@\%\&\*]$/)&& $identifier =~ /\-\>$/){$identifier .= $tok}elsif ($tok =~ /^[A-Za-z_]/){$saw_alpha=1;$id_scan_state=':';$identifier .= $tok}elsif ($tok eq "'" && $allow_tick){$saw_alpha=1;$id_scan_state=':';$identifier .= $tok}elsif ($tok =~ /^[0-9]/){$saw_alpha=1;$id_scan_state=':';$identifier .= $tok}elsif ($tok eq '::'){$id_scan_state='A';$identifier .= $tok}elsif (($tok eq '#')&& ($identifier =~ /\$$/)){$identifier .= $tok}elsif ($tok eq '{'){if (($identifier eq '$' || $identifier eq '@' || $identifier eq '$#')&& $i + 2 <= $max_token_index && $$rtokens[$i + 2 ]eq '}' && $$rtokens[$i + 1 ]!~ /[\s\w]/){my$next2=$$rtokens[$i + 2 ];my$next1=$$rtokens[$i + 1 ];$identifier .= $tok .$next1 .$next2;$i += 2;$id_scan_state='';last}$id_scan_state='';if ($identifier eq '$' || $i==0){$identifier=''}$i=$i_save;last}elsif ($tok =~ /^\s*$/){if ($identifier =~ /^[\$\%\*\&\@]/){if (length($identifier)> 1){$id_scan_state='';$i=$i_save;$type='i';last}else {if ($identifier !~ /^[\@\$]$/){$message="Space in identifier, following $identifier\n"}}}}elsif ($tok eq '^'){if ($identifier =~ /^[\$\*\@\%]$/){$identifier .= $tok;$id_scan_state='A';my$next1=$$rtokens[$i + 1 ];if ($next1 eq ']'){$i++;$identifier .= $next1;$id_scan_state="";last}}else {$id_scan_state=''}}else {if ($in_prototype_or_signature && $tok =~ /^[\),=]/){$id_scan_state='';$i=$i_save;$type='i';last}if ($identifier =~ /^[\$\*\@\%]$/){$identifier .= $tok}elsif ($tok eq '*' && $identifier =~ /([\@\%\$\*\&]|\$\#)$/){$identifier .= $tok}elsif ($identifier eq '$#'){if ($tok eq '{'){$type='i';$i=$i_save}elsif ($tok =~ /^[\:\-\+]$/){$type='i';$identifier .= $tok}else {$i=$i_save;write_logfile_entry('Use of $# is deprecated' ."\n")}}elsif ($identifier eq '$$'){$i=$i_save;if ($tok eq '{'){$type='t'}else {$type='i'}}elsif ($identifier eq '->'){$i=$i_save}else {$i=$i_save;if (length($identifier)==1){$identifier=''}}$id_scan_state='';last}}elsif ($id_scan_state eq '&'){if ($tok =~ /^[\$A-Za-z_]/){$id_scan_state=':';$saw_alpha=1;$identifier .= $tok}elsif ($tok eq "'" && $allow_tick){$id_scan_state=':';$saw_alpha=1;$identifier .= $tok}elsif ($tok =~ /^[0-9]/){$id_scan_state=':';$saw_alpha=1;$identifier .= $tok}elsif ($tok =~ /^\s*$/){}elsif ($tok eq '::'){$id_scan_state='A';$identifier .= $tok}elsif ($tok eq '{'){if ($identifier eq '&' || $i==0){$identifier=''}$i=$i_save;$id_scan_state='';last}else {if ($identifier eq '&' && $expecting){$identifier .= $tok}else {$identifier='';$i=$i_save;$type='&'}$id_scan_state='';last}}elsif ($id_scan_state eq 'A'){if ($tok =~ /^[A-Za-z_]/){$identifier .= $tok;$id_scan_state=':';$saw_alpha=1}elsif ($tok eq "'" && $allow_tick){$identifier .= $tok;$id_scan_state=':';$saw_alpha=1}elsif ($tok =~ /^[0-9]/){$identifier .= $tok;$id_scan_state=':';$saw_alpha=1}elsif (($identifier =~ /^sub /)&& ($tok =~ /^\s*$/)){$id_scan_state='(';$identifier .= $tok}elsif (($identifier =~ /^sub /)&& ($tok eq '(')){$id_scan_state=')';$identifier .= $tok}else {$id_scan_state='';$i=$i_save;last}}elsif ($id_scan_state eq ':'){if ($tok eq '::'){$identifier .= $tok;$id_scan_state='A'}elsif ($tok =~ /^[A-Za-z_]/){$identifier .= $tok;$id_scan_state=':';$saw_alpha=1}elsif ($tok =~ /^[0-9]/){$identifier .= $tok;$id_scan_state=':';$saw_alpha=1}elsif ($tok eq "'" && $allow_tick){if ($is_keyword{$identifier}){$id_scan_state='';$i=$i_save}else {$identifier .= $tok}}elsif (($identifier =~ /^sub /)&& ($tok =~ /^\s*$/)){$id_scan_state='(';$identifier .= $tok}elsif (($identifier =~ /^sub /)&& ($tok eq '(')){$id_scan_state=')';$identifier .= $tok}else {$id_scan_state='';$i=$i_save;last}}elsif ($id_scan_state eq '('){if ($tok eq '('){$identifier .= $tok;$id_scan_state=')'}elsif ($tok =~ /^\s*$/){$identifier .= $tok}else {$id_scan_state='';$i=$i_save;last}}elsif ($id_scan_state eq ')'){if ($tok eq ')'){$identifier .= $tok;$id_scan_state='';last}elsif ($tok =~ /^[\s\$\%\\\*\@\&\;]/){$identifier .= $tok}else {warning("Unexpected '$tok' while seeking end of prototype\n");$identifier .= $tok}}else {$id_scan_state='';$i=$i_save;last}}if ($id_scan_state eq ')'){warning("Hit end of line while seeking ) to end prototype\n")}if ($id_scan_state =~ /^[A\:\(\)]/){$id_scan_state=''}if ($i < 0){$i=0}unless ($type){if ($saw_type){if ($saw_alpha){if ($identifier =~ /^->/ && $last_nonblank_type eq 'w'){$type='w'}else {$type='i'}}elsif ($identifier eq '->'){$type='->'}elsif ((length($identifier)> 1)&&!($identifier =~ /\$$/ && $tok eq '{')&& ($identifier !~ /^(sub |package )$/)){$type='i'}else {$type='t'}}elsif ($saw_alpha){$type='w'}else {$type=''}}if ($identifier){$tok=$identifier;if ($message){write_logfile_entry($message)}}else {$tok=$tok_begin;$i=$i_begin}TOKENIZER_DEBUG_FLAG_SCAN_ID && do {my ($a,$b,$c)=caller;print STDOUT "SCANID: called from $a $b $c with tok, i, state, identifier =$tok_begin, $i_begin, $id_scan_state_begin, $identifier_begin\n";print STDOUT "SCANID: returned with tok, i, state, identifier =$tok, $i, $id_scan_state, $identifier\n"};return ($i,$tok,$type,$id_scan_state,$identifier)}{my ($package_saved,$subname_saved);sub do_scan_sub {my ($input_line,$i,$i_beg,$tok,$type,$rtokens,$rtoken_map,$id_scan_state,$max_token_index)=@_;$id_scan_state="";my$subname=undef;my$package=undef;my$proto=undef;my$attrs=undef;my$match;my$pos_beg=$$rtoken_map[$i_beg];pos($input_line)=$pos_beg;if ($input_line =~ m/\G\s*
  
  Partial match to quote modifier $allowed_quote_modifiers at word: '$str'
  Please put a space between quote modifiers and trailing keywords.
  EOM
  Expecting operator after '$last_nonblank_token' but found bare word '$tok'
         Maybe indirectet object notation?
  EOM
  Found $diff extra $bname$ess between $opening_brace_names[$aa] on line $sl and $closing_brace_names[$aa] on line $el
  EOM
  There is no previous $opening_brace_names[$aa] to match a $closing_brace_names[$aa] on line $input_line_number
  EOM
  Final nesting depth of $opening_brace_names[$aa]s is $current_depth[$aa]
  The most recent un-matched $opening_brace_names[$aa] is on line $sl
  EOM
          ((?:\w*(?:'|::))*)  # package - something that ends in :: or '
          (\w+)               # NAME    - required
          /gcx){$match=1;$subname=$2;$package=(defined($1)&& $1)? $1 : $current_package;$package =~ s/\'/::/g;if ($package =~ /^\:/){$package='main' .$package}$package =~ s/::$//;my$pos=pos($input_line);my$numc=$pos - $pos_beg;$tok='sub ' .substr($input_line,$pos_beg,$numc);$type='i'}my$saw_opening_paren=$input_line =~ /\G\s*\(/;if ($input_line =~ m/\G(\s*\([^\)\(\}\{\,]*\))?  # PROTO
              (\s*:)?                              # ATTRS leading ':'
              /gcx && ($1 || $2)){$proto=$1;$attrs=$2;if ($match && $proto){$tok .= $proto}$match ||= 1;if ($subname_saved){$package=$package_saved;$subname=$subname_saved;$tok=$last_nonblank_token}$type='i'}if ($match){my$pos=pos($input_line);if ($attrs){$pos -= length($attrs)}my$next_nonblank_token=$tok;if ($pos==$pos_beg && $tok eq ':'){$type='A';$in_attribute_list=1}else {my$error;($i,$error)=inverse_pretoken_map($i,$pos,$rtoken_map,$max_token_index);if ($error){warning("Possibly invalid sub\n")}($next_nonblank_token,my$i_next)=find_next_nonblank_token_on_this_line($i,$rtokens,$max_token_index)}if ($next_nonblank_token =~ /^(\s*|#)$/){my ($rpre_tokens,$rpre_types)=peek_ahead_for_n_nonblank_pre_tokens(1);if (defined($rpre_tokens)&& @$rpre_tokens){$next_nonblank_token=$rpre_tokens->[0]}else {$next_nonblank_token='}'}}$package_saved="";$subname_saved="";if ($next_nonblank_token eq '{'){if ($subname){if ($saw_function_definition{$package}{$subname}&& $subname !~ /^[A-Z]+$/){my$lno=$saw_function_definition{$package}{$subname};warning("already saw definition of 'sub $subname' in package '$package' at line $lno\n")}$saw_function_definition{$package}{$subname}=$tokenizer_self->{_last_line_number}}}elsif ($next_nonblank_token eq ';'){}elsif ($next_nonblank_token eq '}'){}elsif ($next_nonblank_token eq ':'){$statement_type=$tok}elsif ($next_nonblank_token eq '('){if (!$saw_opening_paren){$id_scan_state='sub';$package_saved=$package;$subname_saved=$subname}$statement_type=$tok}elsif ($next_nonblank_token){warning("expecting ':' or ';' or '{' after definition or declaration of sub '$subname' but saw '$next_nonblank_token'\n")}check_prototype($proto,$package,$subname)}else {}return ($i,$tok,$type,$id_scan_state)}}sub find_next_nonblank_token {my ($i,$rtokens,$max_token_index)=@_;if ($i >= $max_token_index){if (!peeked_ahead()){peeked_ahead(1);$rtokens=peek_ahead_for_nonblank_token($rtokens,$max_token_index)}}my$next_nonblank_token=$$rtokens[++$i ];if ($next_nonblank_token =~ /^\s*$/){$next_nonblank_token=$$rtokens[++$i ]}return ($next_nonblank_token,$i)}sub numerator_expected {my ($i,$rtokens,$max_token_index)=@_;my$next_token=$$rtokens[$i + 1 ];if ($next_token eq '='){$i++}my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);if ($next_nonblank_token =~ /(\(|\$|\w|\.|\@)/){1}else {if ($next_nonblank_token =~ /^\s*$/){0}else {-1}}}sub pattern_expected {my ($i,$rtokens,$max_token_index)=@_;my$next_token=$$rtokens[$i + 1 ];if ($next_token =~ /^[msixpodualgc]/){$i++}my ($next_nonblank_token,$i_next)=find_next_nonblank_token($i,$rtokens,$max_token_index);if ($next_nonblank_token =~ /(\)|\}|\;|\&\&|\|\||and|or|while|if|unless)/){1}else {if ($next_nonblank_token =~ /^\s*$/){0}else {-1}}}sub find_next_nonblank_token_on_this_line {my ($i,$rtokens,$max_token_index)=@_;my$next_nonblank_token;if ($i < $max_token_index){$next_nonblank_token=$$rtokens[++$i ];if ($next_nonblank_token =~ /^\s*$/){if ($i < $max_token_index){$next_nonblank_token=$$rtokens[++$i ]}}}else {$next_nonblank_token=""}return ($next_nonblank_token,$i)}sub find_angle_operator_termination {my ($input_line,$i_beg,$rtoken_map,$expecting,$max_token_index)=@_;my$i=$i_beg;my$type='<';pos($input_line)=1 + $$rtoken_map[$i];my$filter;if ($expecting==TERM){$filter='[\>]'}elsif ($expecting==UNKNOWN){$filter='[\>\;\=\#\|\<]'}else {warning("Program Bug in find_angle_operator_termination\n")}if ($input_line =~ /($filter)/g){if ($1 eq '>'){my$pos=pos($input_line);my$pos_beg=$$rtoken_map[$i];my$str=substr($input_line,$pos_beg,($pos - $pos_beg));if ($expecting eq UNKNOWN){my$check=substr($input_line,$pos - 2,1);if ($check eq '-'){return ($i,$type)}}$type='Q';my$error;($i,$error)=inverse_pretoken_map($i,$pos,$rtoken_map,$max_token_index);if ($error){warning("Possible tokinization error..please check this line\n");report_possible_bug()}if ($expecting==TERM){}elsif ($i <= $i_beg + 3){write_diagnostics("ANGLE(1 or 2 tokens): $str\n")}else {my$br=0;while ($str =~ /\{/g){$br++}while ($str =~ /\}/g){$br--}my$sb=0;while ($str =~ /\[/g){$sb++}while ($str =~ /\]/g){$sb--}my$pr=0;while ($str =~ /\(/g){$pr++}while ($str =~ /\)/g){$pr--}if ($br || $sb || $pr){$i=$i_beg;$type='<';write_diagnostics("NOT ANGLE (BRACE={$br ($pr [$sb ):$str\n")}else {write_diagnostics("ANGLE-Guessing yes: $str expecting=$expecting\n");write_logfile_entry("Guessing angle operator here: $str\n")}}}else {if ($expecting==TERM){warning("No ending > for angle operator\n")}}}return ($i,$type)}sub scan_number_do {my ($input_line,$i,$rtoken_map,$input_type,$max_token_index)=@_;my$pos_beg=$$rtoken_map[$i];my$pos;my$i_begin=$i;my$number=undef;my$type=$input_type;my$first_char=substr($input_line,$pos_beg,1);if ($first_char !~ /[\d\.\+\-Ee]/){warning("Program bug - scan_number given character $first_char\n");report_definite_bug();return ($i,$type,$number)}pos($input_line)=$pos_beg;if ($input_line =~ /\G((\d+)?\.\d+(\.\d+)+)/g){$pos=pos($input_line);my$numc=$pos - $pos_beg;$number=substr($input_line,$pos_beg,$numc);$type='v';report_v_string($number)}if (!defined($number)){pos($input_line)=$pos_beg;if ($input_line =~ /\G[+-]?0(([xX][0-9a-fA-F_]+)|([0-7_]+)|([bB][01_]+))/g){$pos=pos($input_line);my$numc=$pos - $pos_beg;$number=substr($input_line,$pos_beg,$numc);$type='n'}}if (!defined($number)){pos($input_line)=$pos_beg;if ($input_line =~ /\G([+-]?[\d_]*(\.[\d_]*)?([Ee][+-]?(\d+))?)/g){$pos=pos($input_line);if ((substr($input_line,$pos - 1,1)eq '.')&& (substr($input_line,$pos,1)eq '.')){$pos--}my$numc=$pos - $pos_beg;$number=substr($input_line,$pos_beg,$numc);$type='n'}}if ($number !~ /\d/ || ($number =~ /^(.*)[eE]/ && $1 !~ /\d/)){$number=undef;$type=$input_type;return ($i,$type,$number)}my$error;($i,$error)=inverse_pretoken_map($i,$pos,$rtoken_map,$max_token_index);if ($error){warning("Possibly invalid number\n")}return ($i,$type,$number)}sub inverse_pretoken_map {my ($i,$pos,$rtoken_map,$max_token_index)=@_;my$error=0;while (++$i <= $max_token_index){if ($pos <= $$rtoken_map[$i]){if ($pos < $$rtoken_map[$i]){$error=1}$i--;last}}return ($i,$error)}sub find_here_doc {my ($expecting,$i,$rtokens,$rtoken_map,$max_token_index)=@_;my$ibeg=$i;my$found_target=0;my$here_doc_target='';my$here_quote_character='';my$saw_error=0;my ($next_nonblank_token,$i_next_nonblank,$next_token);$next_token=$$rtokens[$i + 1 ];my$backslash=0;if ($next_token eq '\\'){$backslash=1;$next_token=$$rtokens[$i + 2 ]}($next_nonblank_token,$i_next_nonblank)=find_next_nonblank_token_on_this_line($i,$rtokens,$max_token_index);if ($next_nonblank_token =~ /[\'\"\`]/){my$in_quote=1;my$quote_depth=0;my$quote_pos=0;my$quoted_string;($i,$in_quote,$here_quote_character,$quote_pos,$quote_depth,$quoted_string)=follow_quoted_string($i_next_nonblank,$in_quote,$rtokens,$here_quote_character,$quote_pos,$quote_depth,$max_token_index);if ($in_quote){$i=$ibeg;if ($expecting==TERM){warning("Did not find here-doc string terminator ($here_quote_character) before end of line \n");$saw_error=1}}else {my$j;$found_target=1;my$tokj;for ($j=$i_next_nonblank + 1 ;$j < $i ;$j++ ){$tokj=$$rtokens[$j];next if ($tokj eq "\\" && $j < $i - 1 && $$rtokens[$j + 1 ]eq $here_quote_character);$here_doc_target .= $tokj}}}elsif (($next_token =~ /^\s*$/)and ($expecting==TERM)){$found_target=1;write_logfile_entry("found blank here-target after <<; suggest using \"\"\n");$i=$ibeg}elsif ($next_token =~ /^\w/){my$here_doc_expected;if ($expecting==UNKNOWN){$here_doc_expected=guess_if_here_doc($next_token)}else {$here_doc_expected=1}if ($here_doc_expected){$found_target=1;$here_doc_target=$next_token;$i=$ibeg + 1}}else {if ($expecting==TERM){$found_target=1;write_logfile_entry("Note: bare here-doc operator <<\n")}else {$i=$ibeg}}if ($found_target && $backslash){$i++}return ($found_target,$here_doc_target,$here_quote_character,$i,$saw_error)}sub do_quote {my ($i,$in_quote,$quote_character,$quote_pos,$quote_depth,$quoted_string_1,$quoted_string_2,$rtokens,$rtoken_map,$max_token_index)=@_;my$in_quote_starting=$in_quote;my$quoted_string;if ($in_quote==2){my$ibeg=$i;($i,$in_quote,$quote_character,$quote_pos,$quote_depth,$quoted_string)=follow_quoted_string($i,$in_quote,$rtokens,$quote_character,$quote_pos,$quote_depth,$max_token_index);$quoted_string_2 .= $quoted_string;if ($in_quote==1){if ($quote_character =~ /[\{\[\<\(]/){$i++}$quote_character=''}else {$quoted_string_2 .= "\n"}}if ($in_quote==1){my$ibeg=$i;($i,$in_quote,$quote_character,$quote_pos,$quote_depth,$quoted_string)=follow_quoted_string($ibeg,$in_quote,$rtokens,$quote_character,$quote_pos,$quote_depth,$max_token_index);$quoted_string_1 .= $quoted_string;if ($in_quote==1){$quoted_string_1 .= "\n"}}return ($i,$in_quote,$quote_character,$quote_pos,$quote_depth,$quoted_string_1,$quoted_string_2)}sub follow_quoted_string {my ($i_beg,$in_quote,$rtokens,$beginning_tok,$quote_pos,$quote_depth,$max_token_index)=@_;my ($tok,$end_tok);my$i=$i_beg - 1;my$quoted_string="";TOKENIZER_DEBUG_FLAG_QUOTE && do {print STDOUT "QUOTE entering with quote_pos = $quote_pos i=$i beginning_tok =$beginning_tok\n"};if ($beginning_tok !~ /^\s*$/){$end_tok=matching_end_token($beginning_tok)}else {my$allow_quote_comments=($i < 0)? 1 : 0;while ($i < $max_token_index){$tok=$$rtokens[++$i ];if ($tok !~ /^\s*$/){if (($tok eq '#')&& ($allow_quote_comments)){$i=$max_token_index}else {if (length($tok)> 1){if ($quote_pos <= 0){$quote_pos=1}$beginning_tok=substr($tok,$quote_pos - 1,1)}else {$beginning_tok=$tok;$quote_pos=0}$end_tok=matching_end_token($beginning_tok);$quote_depth=1;last}}else {$allow_quote_comments=1}}}if ($beginning_tok =~ /\w/){if ($in_quote==1){write_logfile_entry("Note: alphanumeric quote delimiter ($beginning_tok) \n")}while ($i < $max_token_index){if ($quote_pos==0 || ($i < 0)){$tok=$$rtokens[++$i ];if ($tok eq '\\'){$quoted_string .= $tok unless $$rtokens[$i + 1 ]eq $end_tok;$quote_pos++;last if ($i >= $max_token_index);$tok=$$rtokens[++$i ]}}my$old_pos=$quote_pos;unless (defined($tok)&& defined($end_tok)&& defined($quote_pos)){}$quote_pos=1 + index($tok,$end_tok,$quote_pos);if ($quote_pos > 0){$quoted_string .= substr($tok,$old_pos,$quote_pos - $old_pos - 1);$quote_depth--;if ($quote_depth==0){$in_quote--;last}}else {$quoted_string .= substr($tok,$old_pos)}}}else {while ($i < $max_token_index){$tok=$$rtokens[++$i ];if ($tok eq $end_tok){$quote_depth--;if ($quote_depth==0){$in_quote--;last}}elsif ($tok eq $beginning_tok){$quote_depth++}elsif ($tok eq '\\'){$tok=$$rtokens[++$i ];$quoted_string .= '\\' unless ($tok eq $end_tok || $tok eq $beginning_tok)}$quoted_string .= $tok}}if ($i > $max_token_index){$i=$max_token_index}return ($i,$in_quote,$beginning_tok,$quote_pos,$quote_depth,$quoted_string)}sub indicate_error {my ($msg,$line_number,$input_line,$pos,$carrat)=@_;interrupt_logfile();warning($msg);write_error_indicator_pair($line_number,$input_line,$pos,$carrat);resume_logfile()}sub write_error_indicator_pair {my ($line_number,$input_line,$pos,$carrat)=@_;my ($offset,$numbered_line,$underline)=make_numbered_line($line_number,$input_line,$pos);$underline=write_on_underline($underline,$pos - $offset,$carrat);warning($numbered_line ."\n");$underline =~ s/\s*$//;warning($underline ."\n")}sub make_numbered_line {my ($lineno,$str,$pos)=@_;my$offset=($pos < 60)? 0 : $pos - 40;my$excess=length($str)- $offset - 68;my$numc=($excess > 0)? 68 : undef;if (defined($numc)){if ($offset==0){$str=substr($str,$offset,$numc - 4)." ..."}else {$str="... " .substr($str,$offset + 4,$numc - 4)." ..."}}else {if ($offset==0){}else {$str="... " .substr($str,$offset + 4)}}my$numbered_line=sprintf("%d: ",$lineno);$offset -= length($numbered_line);$numbered_line .= $str;my$underline=" " x length($numbered_line);return ($offset,$numbered_line,$underline)}sub write_on_underline {my ($underline,$pos,$pos_chr)=@_;unless (($pos >= 0)&& ($pos <= length($underline))){return$underline}my$excess=length($pos_chr)+ $pos - length($underline);if ($excess > 0){$pos_chr=substr($pos_chr,0,length($pos_chr)- $excess)}substr($underline,$pos,length($pos_chr))=$pos_chr;return ($underline)}sub pre_tokenize {my ($str,$max_tokens_wanted)=@_;my@tokens=();my@token_map=(0);my@type=();do {if ($str =~ /\G(\s+)/gc){push@type,'b'}elsif ($str =~ /\G(\d+)/gc){push@type,'d'}elsif ($str =~ /\G(\w+)/gc){push@type,'w'}elsif ($str =~ /\G(\W)/gc){push@type,$1}else {return (\@tokens,\@token_map,\@type)}push@tokens,$1;push@token_map,pos($str)}while (--$max_tokens_wanted!=0);return (\@tokens,\@token_map,\@type)}sub show_tokens {my ($rtokens,$rtoken_map)=@_;my$num=scalar(@$rtokens);my$i;for ($i=0 ;$i < $num ;$i++ ){my$len=length($$rtokens[$i]);print STDOUT "$i:$len:$$rtoken_map[$i]:$$rtokens[$i]:\n"}}sub matching_end_token {my$beginning_token=shift;if ($beginning_token eq '{'){'}'}elsif ($beginning_token eq '['){']'}elsif ($beginning_token eq '<'){'>'}elsif ($beginning_token eq '('){')'}else {$beginning_token}}sub dump_token_types {my$class=shift;my$fh=shift;print$fh <<'END_OF_LIST'}BEGIN {@opening_brace_names=qw#'{' '[' '(' '?'#;@closing_brace_names=qw#'}' ']' ')' ':'#;my@digraphs=qw(.. :: << >> ** && .. || // -> => += -= .= %= &= |= ^= *= <> <= >= == =~ !~ != ++ -- /= x= ~~ ~. |. &. ^.);@is_digraph{@digraphs}=(1)x scalar(@digraphs);my@trigraphs=qw(... **= <<= >>= &&= ||= //= <=> !~~ &.= |.= ^.=);@is_trigraph{@trigraphs}=(1)x scalar(@trigraphs);my@valid_token_types=qw#A b C G L R f h Q k t w i q n p m F pp mm U j J Y Z v { } ( ) [ ] ; + - / * | % ! x ~ = \ ? : . < > ^ &#;push(@valid_token_types,@digraphs);push(@valid_token_types,@trigraphs);push(@valid_token_types,('#',',','CORE::'));@is_valid_token_type{@valid_token_types}=(1)x scalar(@valid_token_types);my@file_test_operators=qw(A B C M O R S T W X b c d e f g k l o p r s t u w x z);@is_file_test_operator{@file_test_operators}=(1)x scalar(@file_test_operators);@_=qw(do eval);@is_block_operator{@_}=(1)x scalar(@_);@_=qw(print printf sort exec system say);@is_indirect_object_taker{@_}=(1)x scalar(@_);@_=qw(BEGIN END CHECK INIT AUTOLOAD DESTROY UNITCHECK continue if elsif else unless do while until eval for foreach map grep sort switch case given when catch);@is_code_block_token{@_}=(1)x scalar(@_);my@Keywords=();my@value_requestor=qw(AUTOLOAD BEGIN CHECK DESTROY END EQ GE GT INIT LE LT NE UNITCHECK abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir cmp connect continue cos crypt dbmclose dbmopen defined delete die dump each else elsif eof eq exec exists exit exp fcntl fileno flock for foreach formline ge getc getgrgid getgrnam gethostbyaddr gethostbyname getnetbyaddr getnetbyname getpeername getpgrp getpriority getprotobyname getprotobynumber getpwnam getpwuid getservbyname getservbyport getsockname getsockopt glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst le length link listen local localtime lock log lstat lt map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack pipe pop pos print printf prototype push quotemeta rand read readdir readlink readline readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir scalar seek seekdir select semctl semget semop send sethostent setnetent setpgrp setpriority setprotoent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat study substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec waitpid warn while write xor switch case given when err say);push(@Keywords,@value_requestor);my@extra_vr=qw(constant vars);push(@value_requestor,@extra_vr);@expecting_term_token{@value_requestor}=(1)x scalar(@value_requestor);my@operator_requestor=qw(endgrent endhostent endnetent endprotoent endpwent endservent fork getgrent gethostent getlogin getnetent getppid getprotoent getpwent getservent setgrent setpwent time times wait wantarray);push(@Keywords,@operator_requestor);my@extra_or=qw(STDERR STDIN STDOUT);push(@operator_requestor,@extra_or);@expecting_operator_token{@operator_requestor}=(1)x scalar(@operator_requestor);my@operator_requestor_types=qw(++ -- C <> q);@expecting_operator_types{@operator_requestor_types}=(1)x scalar(@operator_requestor_types);my@value_requestor_type=qw#L { ( [ ~ !~ =~ ; . .. ... A : && ! || // = + - x **= += -= .= /= *= %= x= &= |= ^= <<= >>= &&= ||= //= <= >= == != => \ > < % * / ? & | ** <=> ~~ !~~ f F pp mm Y p m U J G j >> << ^ t ~. ^. |. &. ^.= |.= &.=#;push(@value_requestor_type,',');@expecting_term_types{@value_requestor_type}=(1)x scalar(@value_requestor_type);%really_want_term=%expecting_term_types;delete$really_want_term{'U'};delete$really_want_term{'F'};delete$really_want_term{'Y'};@_=qw(q qq qw qx qr s y tr m);@is_q_qq_qw_qx_qr_s_y_tr_m{@_}=(1)x scalar(@_);my@special_keywords=qw(do eval format m package q qq qr qw qx s sub tr y);push(@Keywords,@special_keywords);my@keyword_taking_list=qw(and chmod chomp chop chown dbmopen die elsif exec fcntl for foreach formline getsockopt if index ioctl join kill local msgctl msgrcv msgsnd my open or our pack print printf push read readpipe recv return reverse rindex seek select semctl semget send setpriority setsockopt shmctl shmget shmread shmwrite socket socketpair sort splice split sprintf substr syscall sysopen sysread sysseek system syswrite tie unless unlink unpack unshift until vec warn while given when);@is_keyword_taking_list{@keyword_taking_list}=(1)x scalar(@keyword_taking_list);@is_keyword{@Keywords}=(1)x scalar(@Keywords)}1;
  
  Here is a list of the token types currently used for lines of type 'CODE'.  
  For the following tokens, the "type" of a token is just the token itself.  
  
  .. :: << >> ** && .. || // -> => += -= .= %= &= |= ^= *= <>
  ( ) <= >= == =~ !~ != ++ -- /= x=
  ... **= <<= >>= &&= ||= //= <=> 
  , + - / * | % ! x ~ = \ ? : . < > ^ &
  
  The following additional token types are defined:
  
   type    meaning
      b    blank (white space) 
      {    indent: opening structural curly brace or square bracket or paren
           (code block, anonymous hash reference, or anonymous array reference)
      }    outdent: right structural curly brace or square bracket or paren
      [    left non-structural square bracket (enclosing an array index)
      ]    right non-structural square bracket
      (    left non-structural paren (all but a list right of an =)
      )    right non-structural paren
      L    left non-structural curly brace (enclosing a key)
      R    right non-structural curly brace 
      ;    terminal semicolon
      f    indicates a semicolon in a "for" statement
      h    here_doc operator <<
      #    a comment
      Q    indicates a quote or pattern
      q    indicates a qw quote block
      k    a perl keyword
      C    user-defined constant or constant function (with void prototype = ())
      U    user-defined function taking parameters
      G    user-defined function taking block parameter (like grep/map/eval)
      M    (unused, but reserved for subroutine definition name)
      P    (unused, but -html uses it to label pod text)
      t    type indicater such as %,$,@,*,&,sub
      w    bare word (perhaps a subroutine call)
      i    identifier of some type (with leading %, $, @, *, &, sub, -> )
      n    a number
      v    a v-string
      F    a file test operator (like -e)
      Y    File handle
      Z    identifier in indirect object slot: may be file handle, object
      J    LABEL:  code block label
      j    LABEL after next, last, redo, goto
      p    unary +
      m    unary -
      pp   pre-increment operator ++
      mm   pre-decrement operator -- 
      A    : used as attribute separator
      
      Here are the '_line_type' codes used internally:
      SYSTEM         - system-specific code before hash-bang line
      CODE           - line of perl code (including comments)
      POD_START      - line starting pod, such as '=head'
      POD            - pod documentation text
      POD_END        - last line of pod section, '=cut'
      HERE           - text of here-document
      HERE_END       - last line of here-doc (target word)
      FORMAT         - format section
      FORMAT_END     - last line of format section, '.'
      DATA_START     - __DATA__ line
      DATA           - unidentified text following __DATA__
      END_START      - __END__ line
      END            - unidentified text following __END__
      ERROR          - we are in big trouble, probably not a perl script
  END_OF_LIST
PERL_TIDY

$fatpacked{"Pod/Spell.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SPELL';
  package Pod::Spell;use 5.008;use strict;use warnings;our$VERSION='0.01';sub new {my ($class,%args)=@_;my$no_wide_chars=delete$args{no_wide_chars};my$debug=delete($args{debug})|| $ENV{PERL_POD_SPELL_DEBUG};my$stopwords=$args{stopwords}|| do {require Pod::Wordlist;Pod::Wordlist->new(_is_debug=>$debug,no_wide_chars=>$no_wide_chars)};my%self=(processor=>Pod::Spell::_Processor->new($debug,$stopwords),stopwords=>$stopwords,debug=>$debug,);bless \%self,$class}sub _is_debug {(shift)->{debug}? 1 : 0}sub stopwords {(shift)->{stopwords}}sub parse_from_file {shift->{processor}->parse_from_file(@_)}sub parse_from_filehandle {shift->{processor}->parse_from_filehandle(@_)}package Pod::Spell::_Processor;use parent 'Pod::Parser';use Pod::Escapes ('e2char');use Text::Wrap ('wrap');use locale;use Carp;sub new {my ($class,$debug,$stopwords)=@_;my$self=$class->SUPER::new;@{$self}{qw<debug stopwords>}=($debug,$stopwords);$self}sub _is_debug {(shift)->{debug}? 1 : 0}sub stopwords {(shift)->{stopwords}}sub parse_from_file {my$self=shift;$self->{region}=[];$self->SUPER::parse_from_file(@_);delete$self->{region}}sub parse_from_filehandle {my$self=shift;$self->{region}=[];$self->SUPER::parse_from_filehandle(@_);delete$self->{region}}sub verbatim {''}sub textblock {my ($self,$paragraph)=@_;if (@{$self->{'region'}}){my$last_region =$self->{'region'}[-1];if ($last_region eq 'stopwords'){$self->stopwords->learn_stopwords($paragraph);return}elsif ($last_region eq ':stopwords'){$self->stopwords->learn_stopwords($self->interpolate($paragraph));return}elsif ($last_region !~ m/^:/s){printf "Ignoring a textblock because inside a %s region.\n",$self->{'region'}[-1]if$self->_is_debug;return}}$self->_treat_words($self->interpolate($paragraph));return}sub command {my ($self,$command,$text)=(shift,shift,@_);return if$command eq 'pod';if ($command eq 'begin'){my$region_name;if ($text =~ m/^\s*(\S+)/s){$region_name=$1}else {$region_name='WHATNAME'}print "~~~~ Beginning region \"$region_name\" ~~~~\n" if$self->_is_debug;push @{$self->{'region'}},$region_name}elsif ($command eq 'end'){pop @{$self->{'region'}}}elsif ($command eq 'for'){if ($text =~ s/^\s*(\:?)stopwords\s*(.*)//s){my$para=$2;$para=$self->interpolate($para)if $1;print "Stopword para: <$2>\n" if$self->_is_debug;$self->stopwords->learn_stopwords($para)}}elsif (@{$self->{'region'}}){}elsif ($command eq 'head1' or $command eq 'head2' or $command eq 'head2' or $command eq 'head3' or $command eq 'item'){my$out_fh=$self->output_handle();print$out_fh "\n";$self->_treat_words($self->interpolate(shift))}return}sub interior_sequence {my ($self,$command,$seq_arg)=@_;return '' if$command eq 'X' or $command eq 'Z';if ($command eq 'E'){my$it=e2char($seq_arg);if (defined$it){return$it}else {carp "Unknown escape: E<$seq_arg>";return "E<$seq_arg>"}}return if$seq_arg eq '';if ($command eq 'B' or $command eq 'I' or $command eq 'S'){$seq_arg}elsif ($command eq 'C' or $command eq 'F'){my$out='';$out .= ' ' if s/^\s+//s;my$append;$append=1 if s/\s+$//s;$out .= '_' if length$seq_arg;$out .= ' ' if$append;$out}elsif ($command eq 'L'){return $1 if m/^([^|]+)\|/s;''}else {carp "Unknown sequence $command<$seq_arg>"}}sub _treat_words {my ($self,$text)=@_;my$out=$self->stopwords->strip_stopwords($text);if (length$out){my$out_fh=$self->output_handle();local$Text::Wrap::huge='overflow';print$out_fh wrap('','',$out),"\n\n"}return}1;
POD_SPELL

$fatpacked{"Pod/Wordlist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_WORDLIST';
  package Pod::Wordlist;use strict;use warnings;use Lingua::EN::Inflect 'PL';use Class::Tiny {wordlist=>\&_copy_wordlist,_is_debug=>0,no_wide_chars=>0,};use Path::Tiny qw(path);use constant {MAXWORDLENGTH=>50,_DIST_DIR=>do {my$dir;if (-e __FILE__){my$local_dir=path(__FILE__)->parent->parent->parent->child('share/dist/Pod-Spell');$dir=$local_dir->absolute if -e $local_dir}if (not defined$dir){require File::ShareDir;$dir=File::ShareDir::dist_dir('Pod-Spell')}"$dir"},};our$VERSION='0.01';our%Wordlist;sub _copy_wordlist {return {%Wordlist }}for (path(_DIST_DIR,'wordlist')->lines_utf8({chomp=>1 })){$Wordlist{$_}=1;$Wordlist{PL($_)}=1}sub learn_stopwords {my ($self,$text)=@_;my$stopwords=$self->wordlist;while ($text =~ m<(\S+)>g){my$word=$1;if ($word =~ m/^!(.+)/s){my$negation=$1;delete$stopwords->{$negation};delete$stopwords->{PL($negation)};print "Unlearning stopword <$negation>\n" if$self->_is_debug}else {$word =~ s{'s$}{};$stopwords->{$word}=1;$stopwords->{PL($word)}=1;print "Learning stopword   <$word>\n" if$self->_is_debug}}return}sub is_stopword {my ($self,$word)=@_;my$stopwords=$self->wordlist;if (exists$stopwords->{$word}or exists$stopwords->{lc$word }){print "  Rejecting   <$word>\n" if$self->_is_debug;return 1}return}sub strip_stopwords {my ($self,$text)=@_;print "Content: <",$text,">\n" if$self->_is_debug;my@words=grep {length($_)< MAXWORDLENGTH}split " ",$text;for (@words){print "Parsing word: <$_>\n" if$self->_is_debug;$_='' if$self->no_wide_chars && /[^\x00-\xFF]/;s/^[\(\[\{\'\"\:\;\,\?\!\.]+//;s/^([^\)\]\}\"\;\,\?\!]+).*$/$1/;s/[\.\'\:]+$//;s/'s$//i;my$is_sigil=/^[\&\%\$\@\:\<\*\\\_]/;my$is_strange=/[\%\^\&\#\$\@\_\<\>\(\)\[\]\{\}\\\*\:\+\/\=\|\`\~]/;$_='' if$is_sigil || $is_strange;next unless /\w/;print "  Checking as <$_>\n" if$self->_is_debug;$_=$self->_strip_a_word($_);print "  Keeping as  <$_>\n" if $_ && $self->_is_debug}return join(" ",grep {defined && length}@words)}sub _strip_a_word {my ($self,$word)=@_;my$remainder;if ($self->is_stopword($word)){$remainder=''}elsif (index($word,'.')>= 0){my$abbr="$word.";$remainder=$self->is_stopword($abbr)? '' : $abbr}elsif (index($word,'-')>= 0){my@keep;for my$part (split /-/,$word){push@keep,$part if!$self->is_stopword($part)}$remainder=join(" ",@keep)if@keep}else {$remainder=$word}return$remainder}1;
POD_WORDLIST

$fatpacked{"Readonly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'READONLY';
  package Readonly;use 5.005;use strict;package Readonly;our$VERSION='0.01';$VERSION=eval$VERSION;sub croak {require Carp;goto&Carp::croak}use vars qw/$XSokay/;sub _ARRAY (\@);sub _HASH (\%);if ($] < 5.008){*is_sv_readonly=sub ($) {0};*make_sv_readonly =sub ($) {die "make_sv_readonly called but not overridden"};$Readonly::XS::MAGIC_COOKIE=$Readonly::XS::MAGIC_COOKIE ="Do NOT use or require Readonly::XS unless you're me.";eval 'use Readonly::XS'}else {*is_sv_readonly=sub ($) {Internals::SvREADONLY($_[0])};*make_sv_readonly =sub ($) {Internals::SvREADONLY($_[0],1)};$XSokay=1}sub _SCALAR ($) {my ($r_var)=@_;if ($XSokay){Internals::SvREADONLY($r_var,0)if is_sv_readonly($r_var)}else {return if tied($r_var)!~ 'Readonly::Scalar';my$r_scalar;{my$obj=tied $$r_var;$r_scalar=$obj}untie$r_var;$r_var=$r_scalar}}sub _ARRAY (\@) {my ($r_var)=@_;return if!tied(@$r_var);return if tied(@$r_var)!~ 'Readonly::Array';my$r_array;{my$obj=tied @$r_var;$r_array=$obj}untie @$r_var;@$r_var=@$r_array;for (@$r_var){my$_reftype=ref $_;if ($_reftype eq 'SCALAR'){_SCALAR($_)}elsif ($_reftype eq 'ARRAY'){_ARRAY(@$_)}elsif ($_reftype eq 'HASH'){_HASH(%$_)}}}sub _HASH (\%) {my ($r_var)=@_;return if!tied(%$r_var);return if tied(%$r_var)!~ 'Readonly::Hash';my$r_hash;{my$obj=tied %$r_var;$r_hash=$obj}untie %$r_var;%$r_var=%$r_hash;for (values %$r_var){my$_reftype=ref $_;if ($_reftype eq 'SCALAR'){_SCALAR($_)}elsif ($_reftype eq 'ARRAY'){_ARRAY(@$_)}elsif ($_reftype eq 'HASH'){_HASH(%$_)}}}use vars qw/$MODIFY $REASSIGN $ODDHASH/;$MODIFY='Modification of a read-only value attempted';$REASSIGN='Attempt to reassign a readonly';$ODDHASH='May not store an odd number of values in a hash';package Readonly::Scalar;sub STORABLE_freeze {my ($self,$cloning)=@_;Readonly::_SCALAR($$self)if$cloning}sub TIESCALAR {my$whence =(caller 2)[3];Readonly::croak "Invalid tie" unless$whence && $whence =~ /^Readonly::(?:Scalar1?|Readonly)$/;my$class=shift;Readonly::croak "No value specified for readonly scalar" unless @_;Readonly::croak "Too many values specified for readonly scalar" unless @_==1;my$value=shift;return bless \$value,$class}sub FETCH {my$self=shift;return $$self}*STORE=*STORE=sub {Readonly::croak$Readonly::MODIFY};*UNTIE=*UNTIE =sub {Readonly::croak$Readonly::MODIFY if caller()ne 'Readonly'};package Readonly::Array;sub STORABLE_freeze {my ($self,$cloning)=@_;Readonly::_ARRAY(@$self)if$cloning}sub TIEARRAY {my$whence =(caller 1)[3];Readonly::croak "Invalid tie" unless$whence =~ /^Readonly::Array1?$/;my$class=shift;my@self=@_;return bless \@self,$class}sub FETCH {my$self=shift;my$index=shift;return$self->[$index]}sub FETCHSIZE {my$self=shift;return scalar @$self}BEGIN {eval q{
          sub EXISTS
             {
             my $self  = shift;
             my $index = shift;
             return exists $self->[$index];
             }
      } if $] >= 5.006}*STORE=*STORESIZE=*EXTEND=*PUSH=*POP=*UNSHIFT=*SHIFT=*SPLICE =*CLEAR=*STORE=*STORESIZE=*EXTEND=*PUSH=*POP=*UNSHIFT =*SHIFT=*SPLICE=*CLEAR=sub {Readonly::croak$Readonly::MODIFY};*UNTIE=*UNTIE =sub {Readonly::croak$Readonly::MODIFY if caller()ne 'Readonly'};package Readonly::Hash;sub STORABLE_freeze {my ($self,$cloning)=@_;Readonly::_HASH(%$self)if$cloning}sub TIEHASH {my$whence =(caller 1)[3];Readonly::croak "Invalid tie" unless$whence =~ /^Readonly::Hash1?$/;my$class=shift;Readonly::croak$Readonly::ODDHASH unless (@_ % 2==0);my%self=@_;return bless \%self,$class}sub FETCH {my$self=shift;my$key=shift;return$self->{$key}}sub EXISTS {my$self=shift;my$key=shift;return exists$self->{$key}}sub FIRSTKEY {my$self=shift;my$dummy=keys %$self;return scalar each %$self}sub NEXTKEY {my$self=shift;return scalar each %$self}*STORE=*DELETE=*CLEAR=*STORE=*DELETE=*CLEAR =sub {Readonly::croak$Readonly::MODIFY};*UNTIE=*UNTIE =sub {Readonly::croak$Readonly::MODIFY if caller()ne 'Readonly'};package Readonly;use Exporter;use vars qw/@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS/;push@ISA,'Exporter';push@EXPORT,qw/Readonly/;push@EXPORT_OK,qw/Scalar Array Hash Scalar1 Array1 Hash1/;sub Scalar ($$);sub Array (\@;@);sub Hash (\%;@);sub _is_badtype {my$type=$_[0];return lc$type if$type =~ s/^Readonly:://;return}sub Scalar1 ($$) {croak "$REASSIGN scalar" if is_sv_readonly($_[0]);my$badtype=_is_badtype(ref tied $_[0]);croak "$REASSIGN $badtype" if$badtype;if ($XSokay){$_[0]=$_[1];make_sv_readonly($_[0]);return}my$tieobj=eval {tie $_[0],'Readonly::Scalar',$_[1]};if ($@){croak "$REASSIGN scalar" if substr($@,0,43)eq $MODIFY;die $@}return$tieobj}sub Array1 (\@;@) {my$badtype=_is_badtype(ref tied $_[0]);croak "$REASSIGN $badtype" if$badtype;my$aref=shift;return tie @$aref,'Readonly::Array',@_}sub Hash1 (\%;@) {my$badtype=_is_badtype(ref tied $_[0]);croak "$REASSIGN $badtype" if$badtype;my$href=shift;if (@_==1 && ref $_[0]eq 'HASH'){return tie %$href,'Readonly::Hash',%{$_[0]}}croak$ODDHASH unless (@_ % 2==0);return tie %$href,'Readonly::Hash',@_}sub Scalar ($$) {croak "$REASSIGN scalar" if is_sv_readonly($_[0]);my$badtype=_is_badtype(ref tied $_[0]);croak "$REASSIGN $badtype" if$badtype;my$value=$_[1];for ($value){if (ref eq 'SCALAR'){Scalar my$v=>$$_;$_=\$v}elsif (ref eq 'ARRAY'){Array my@v=>@$_;$_=\@v}elsif (ref eq 'HASH'){Hash my%v=>$_;$_=\%v}}if ($XSokay){$_[0]=$value;make_sv_readonly($_[0]);return}my$tieobj=eval {tie $_[0],'Readonly::Scalar',$value};if ($@){croak "$REASSIGN scalar" if substr($@,0,43)eq $MODIFY;die $@}return$tieobj}sub Array (\@;@) {my$badtype=_is_badtype(ref tied @{$_[0]});croak "$REASSIGN $badtype" if$badtype;my$aref=shift;my@values=@_;for (@values){if (ref eq 'SCALAR'){Scalar my$v=>$$_;$_=\$v}elsif (ref eq 'ARRAY'){Array my@v=>@$_;$_=\@v}elsif (ref eq 'HASH'){Hash my%v=>$_;$_=\%v}}return tie @$aref,'Readonly::Array',@values}sub Hash (\%;@) {my$badtype=_is_badtype(ref tied %{$_[0]});croak "$REASSIGN $badtype" if$badtype;my$href=shift;my@values=@_;if (@_==1 && ref $_[0]eq 'HASH'){@values=%{$_[0]}}croak$ODDHASH unless (@values % 2==0);for (@values){if (ref eq 'SCALAR'){Scalar my$v=>$$_;$_=\$v}elsif (ref eq 'ARRAY'){Array my@v=>@$_;$_=\@v}elsif (ref eq 'HASH'){Hash my%v=>$_;$_=\%v}}return tie %$href,'Readonly::Hash',@values}sub Clone(\[$@%]) {require Storable;my$retval=Storable::dclone($_[0]);$retval=$$retval if ref$retval eq 'REF';my$reftype=ref$retval;if ($reftype eq 'SCALAR'){_SCALAR($retval);return $$retval}elsif ($reftype eq 'ARRAY'){_ARRAY(@$retval)}elsif ($reftype eq 'HASH'){_HASH(%$retval);return %$retval if wantarray}return$retval}eval q{sub Readonly} .($] < 5.008 ? '' : '(\[$@%]@)').<<'SUB_READONLY';1;
  {
      if (ref $_[0] eq 'SCALAR')
      {
          croak $MODIFY if is_sv_readonly ${$_[0]};
          my $badtype = _is_badtype (ref tied ${$_[0]});
          croak "$REASSIGN $badtype" if $badtype;
          croak "Readonly scalar must have only one value" if @_ > 2;
  
          # Because of problems with handling \$ prototypes declarations like
          # Readonly my @a = ... and Readonly my %h = ... are also caught here
          croak 'Invalid initialization by assignment'
              if @_ == 1 && defined ${$_[0]};
  
          my $tieobj = eval {tie ${$_[0]}, 'Readonly::Scalar', $_[1]};
          # Tie may have failed because user tried to tie a constant, or we screwed up somehow.
          if ($@)
          {
              croak $MODIFY if $@ =~ /^$MODIFY at/;    # Point the finger at the user.
              die "$@\n";        # Not a modify read-only message; must be our fault.
          }
          return $tieobj;
      }
      elsif (ref $_[0] eq 'ARRAY')
      {
          my $aref = shift;
          return Array @$aref, @_;
      }
      elsif (ref $_[0] eq 'HASH')
      {
          my $href = shift;
          croak $ODDHASH  if @_%2 != 0  &&  !(@_ == 1  && ref $_[0] eq 'HASH');
          return Hash %$href, @_;
      }
      elsif (ref $_[0])
      {
          croak "Readonly only supports scalar, array, and hash variables.";
      }
      else
      {
          croak "First argument to Readonly must be a reference.";
      }
  }
  SUB_READONLY
READONLY

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}use strict;use warnings;our$VERSION='0.01';$VERSION=eval$VERSION;our%INFO;our%APPLIED_TO;our%COMPOSED;our%COMPOSITE_INFO;our@ON_ROLE_CREATE;BEGIN {*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0};*_MRO_MODULE="$]" < 5.010 ? sub(){"MRO/Compat.pm"}: sub(){"mro.pm"}}sub croak {require Carp;no warnings 'redefine';*croak=\&Carp::croak;goto&Carp::croak}sub Role::Tiny::__GUARD__::DESTROY {delete$INC{$_[0]->[0]}if @{$_[0]}}sub _load_module {(my$proto=$_[0])=~ s/::/\//g;$proto .= '.pm';return 1 if$INC{$proto};return 1 if grep!/::$/,keys %{_getstash($_[0])||{}};my$guard=_WORK_AROUND_BROKEN_MODULE_STATE && bless([$proto ],'Role::Tiny::__GUARD__');require$proto;pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;return 1}sub import {my$target=caller;my$me=shift;strict->import;warnings->import;$me->_install_subs($target);return if$me->is_role($target);$INFO{$target}{is_role}=1;my$stash=_getstash($target);my@not_methods=(map {*$_{CODE}||()}grep!ref($_),values %$stash);@{$INFO{$target}{not_methods}={}}{@not_methods}=@not_methods;$APPLIED_TO{$target}={$target=>undef };for my$hook (@ON_ROLE_CREATE){$hook->($target)}}sub _install_subs {my ($me,$target)=@_;return if$me->is_role($target);for my$type (qw(before after around)){*{_getglob "${target}::${type}"}=sub {push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];return}}*{_getglob "${target}::requires"}=sub {push @{$INFO{$target}{requires}||=[]},@_;return};*{_getglob "${target}::with"}=sub {$me->apply_roles_to_package($target,@_);return}}sub role_application_steps {qw(_install_methods _check_requires _install_modifiers _copy_applied_list)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;_load_module($role);croak "This is apply_role_to_package" if ref($to);croak "${role} is not a Role::Tiny" unless$me->is_role($role);for my$step ($me->role_application_steps){$me->$step($to,$role)}}sub _copy_applied_list {my ($me,$to,$role)=@_;@{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}}=()}sub apply_roles_to_object {my ($me,$object,@roles)=@_;croak "No roles supplied!" unless@roles;my$class=ref($object);bless($_[1],$me->create_class_with_roles($class,@roles))}my$role_suffix='A000';sub _composite_name {my ($me,$superclass,@roles)=@_;my$new_name=join('__WITH__',$superclass,my$compose_name=join '__AND__',@roles);if (length($new_name)> 252){$new_name=$COMPOSED{abbrev}{$new_name}||= do {my$abbrev=substr$new_name,0,250 - length$role_suffix;$abbrev =~ s/(?<!:):$//;$abbrev.'__'.$role_suffix++}}return wantarray ? ($new_name,$compose_name): $new_name}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;croak "No roles supplied!" unless@roles;_load_module($superclass);{my%seen;if (my@dupes=grep 1==$seen{$_}++,@roles){croak "Duplicated roles: ".join(', ',@dupes)}}my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$COMPOSED{class}{$new_name};for my$role (@roles){_load_module($role);croak "${role} is not a Role::Tiny" unless$me->is_role($role)}require(_MRO_MODULE);my$composite_info=$me->_composite_info_for(@roles);my%conflicts=%{$composite_info->{conflicts}};if (keys%conflicts){my$fail=join "\n",map {"Method name conflict for '$_' between roles " ."'".join("' and '",sort values %{$conflicts{$_}})."'" .", cannot apply these simultaneously to an object."}keys%conflicts;croak$fail}my@composable=map$me->_composable_package_for($_),reverse@roles;my@requires=grep {my$method=$_;!grep $_->can($method)&&!$COMPOSED{role}{$_}{modifiers_only}{$method},@composable}@{$composite_info->{requires}};$me->_check_requires($superclass,$compose_name,\@requires);*{_getglob("${new_name}::ISA")}=[@composable,$superclass ];@{$APPLIED_TO{$new_name}||={}}{map keys %{$APPLIED_TO{$_}},@roles }=();$COMPOSED{class}{$new_name}=1;return$new_name}sub apply_role_to_package {shift->apply_single_role_to_package(@_)}sub apply_roles_to_package {my ($me,$to,@roles)=@_;return$me->apply_role_to_package($to,$roles[0])if@roles==1;my%conflicts=%{$me->_composite_info_for(@roles)->{conflicts}};my@have=grep$to->can($_),keys%conflicts;delete@conflicts{@have};if (keys%conflicts){my$fail=join "\n",map {"Due to a method name conflict between roles " ."'".join(' and ',sort values %{$conflicts{$_}})."'" .", the method '$_' must be implemented by '${to}'"}keys%conflicts;croak$fail}my@role_methods=map$me->_concrete_methods_of($_),@roles;local @{$_}{@have}for@role_methods;delete @{$_}{@have}for@role_methods;if ($INFO{$to}){delete$INFO{$to}{methods}}our%BACKCOMPAT_HACK;if($me ne __PACKAGE__ and exists$BACKCOMPAT_HACK{$me}? $BACKCOMPAT_HACK{$me}: $BACKCOMPAT_HACK{$me}=$me->can('role_application_steps')==\&role_application_steps && $me->can('apply_single_role_to_package')!=\&apply_single_role_to_package){for my$role (@roles){$me->apply_single_role_to_package($to,$role)}}else {for my$step ($me->role_application_steps){for my$role (@roles){$me->$step($to,$role)}}}$APPLIED_TO{$to}{join('|',@roles)}=1}sub _composite_info_for {my ($me,@roles)=@_;$COMPOSITE_INFO{join('|',sort@roles)}||= do {for my$role (@roles){_load_module($role)}my%methods;for my$role (@roles){my$this_methods=$me->_concrete_methods_of($role);$methods{$_}{$this_methods->{$_}}=$role for keys %$this_methods}my%requires;@requires{map @{$INFO{$_}{requires}||[]},@roles}=();delete$requires{$_}for keys%methods;delete$methods{$_}for grep keys(%{$methods{$_}})==1,keys%methods;+{conflicts=>\%methods,requires=>[keys%requires]}}}sub _composable_package_for {my ($me,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$COMPOSED{role}{$composed_name};$me->_install_methods($composed_name,$role);my$base_name=$composed_name.'::_BASE';_getstash($base_name);{no strict 'refs';@{"${composed_name}::ISA"}=($base_name)}my$modifiers=$INFO{$role}{modifiers}||[];my@mod_base;my@modifiers=grep!$composed_name->can($_),do {my%h;@h{map @{$_}[1..$#$_-1],@$modifiers}=();keys%h};for my$modified (@modifiers){push@mod_base,"sub ${modified} { shift->next::method(\@_) }"}my$e;{local $@;eval(my$code=join "\n","package ${base_name};",@mod_base);$e="Evaling failed: $@\nTrying to eval:\n${code}" if $@}die$e if$e;$me->_install_modifiers($composed_name,$role);$COMPOSED{role}{$composed_name}={modifiers_only=>{map {$_=>1}@modifiers },};return$composed_name}sub _check_requires {my ($me,$to,$name,$requires)=@_;return unless my@requires=@{$requires||$INFO{$name}{requires}||[]};if (my@requires_fail=grep!$to->can($_),@requires){if (my$to_info=$INFO{$to}){push @{$to_info->{requires}||=[]},@requires_fail}else {croak "Can't apply ${name} to ${to} - missing ".join(', ',@requires_fail)}}}sub _concrete_methods_of {my ($me,$role)=@_;my$info=$INFO{$role};my$stash=_getstash($role);my$not_methods={reverse %{$info->{not_methods}||{}}};$info->{methods}||= +{map {;no strict 'refs';my$code=exists &{"${role}::$_"}? \&{"${role}::$_"}: undef;(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep!ref($stash->{$_}),keys %$stash }}sub methods_provided_by {my ($me,$role)=@_;croak "${role} is not a Role::Tiny" unless$me->is_role($role);(keys %{$me->_concrete_methods_of($role)},@{$INFO{$role}->{requires}||[]})}sub _install_methods {my ($me,$to,$role)=@_;my$info=$INFO{$role};my$methods=$me->_concrete_methods_of($role);my$stash=_getstash($to);my%has_methods;@has_methods{grep +(ref($stash->{$_})|| *{$stash->{$_}}{CODE}),keys %$stash }=();for my$i (grep!exists$has_methods{$_},keys %$methods){no warnings 'once';my$glob=_getglob "${to}::${i}";*$glob=$methods->{$i};next unless$i =~ /^\(/ && ((defined&overload::nil && $methods->{$i}==\&overload::nil)|| (defined&overload::_nil && $methods->{$i}==\&overload::_nil));my$overload=${*{_getglob "${role}::${i}"}{SCALAR}};next unless defined$overload;*$glob=\$overload}$me->_install_does($to)}sub _install_modifiers {my ($me,$to,$name)=@_;return unless my$modifiers=$INFO{$name}{modifiers};my$info=$INFO{$to};my$existing=($info ? $info->{modifiers}: $COMPOSED{modifiers}{$to})||= [];my@modifiers=grep {my$modifier=$_;!grep $_==$modifier,@$existing}@{$modifiers||[]};push @$existing,@modifiers;if (!$info){for my$modifier (@modifiers){$me->_install_single_modifier($to,@$modifier)}}}my$vcheck_error;sub _install_single_modifier {my ($me,@args)=@_;defined($vcheck_error)or $vcheck_error=do {local $@;eval {require Class::Method::Modifiers;Class::Method::Modifiers->VERSION(1.05);1}? 0 : $@};$vcheck_error and die$vcheck_error;Class::Method::Modifiers::install_modifier(@args)}my$FALLBACK=sub {0};sub _install_does {my ($me,$to)=@_;return if$me->is_role($to);my$does=$me->can('does_role');*{_getglob "${to}::does"}=$does unless$to->can('does');return if$to->can('DOES')and $to->can('DOES')!=(UNIVERSAL->can('DOES')|| 0);my$existing=$to->can('DOES')|| $to->can('isa')|| $FALLBACK;my$new_sub=sub {my ($proto,$role)=@_;$proto->$does($role)or $proto->$existing($role)};no warnings 'redefine';return *{_getglob "${to}::DOES"}=$new_sub}sub does_role {my ($proto,$role)=@_;require(_MRO_MODULE);for my$class (@{mro::get_linear_isa(ref($proto)||$proto)}){return 1 if exists$APPLIED_TO{$class}{$role}}return 0}sub is_role {my ($me,$role)=@_;return!!($INFO{$role}&& ($INFO{$role}{is_role}|| $INFO{$role}{not_methods}))}1;
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;use strict;use warnings;our$VERSION='0.01';$VERSION=eval$VERSION;use Role::Tiny ();use Exporter 'import';our@EXPORT=qw(with);sub with {my$target=caller;Role::Tiny->apply_roles_to_package($target,@_)}1;
ROLE_TINY_WITH

$fatpacked{"Router/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROUTER_SIMPLE';
  package Router::Simple;use strict;use warnings;use 5.00800;our$VERSION='0.01';use Router::Simple::SubMapper;use Router::Simple::Route;use List::Util qw/max/;use Carp ();use Class::Accessor::Lite 0.05 (new=>1,ro=>[qw(routes directory_slash)],);our$_METHOD_NOT_ALLOWED;sub connect {my$self=shift;if ($self->{directory_slash}){if (@_==1 || ref $_[1]){unshift(@_,undef)}$_[3]||= {};$_[3]->{directory_slash}=1}my$route=Router::Simple::Route->new(@_);push @{$self->{routes}},$route;return$self}sub submapper {my ($self,$pattern,$dest,$opt)=@_;return Router::Simple::SubMapper->new(parent=>$self,pattern=>$pattern,dest=>$dest || +{},opt=>$opt || +{},)}sub _match {my ($self,$env)=@_;if (ref$env){if ($env->{PATH_INFO}eq ''){$env->{PATH_INFO}='/'}}else {$env=+{PATH_INFO=>$env }}local$_METHOD_NOT_ALLOWED;$self->{method_not_allowed}=0;for my$route (@{$self->{routes}}){my$match=$route->match($env);return ($match,$route)if$match}$self->{method_not_allowed}=$_METHOD_NOT_ALLOWED;return undef}sub method_not_allowed {my$self=shift;$self->{method_not_allowed}}sub match {my ($self,$req)=@_;my ($match)=$self->_match($req);return$match}sub routematch {my ($self,$req)=@_;return$self->_match($req)}sub as_string {my$self=shift;my$mn=max(map {$_->{name}? length($_->{name}): 0}@{$self->{routes}});my$nn=max(map {$_->{method}? length(join(",",@{$_->{method}})): 0}@{$self->{routes}});return join('',map {sprintf "%-${mn}s %-${nn}s %s\n",$_->{name}||'',join(',',@{$_->{method}|| []})|| '',$_->{pattern}}@{$self->{routes}})."\n"}1;
ROUTER_SIMPLE

$fatpacked{"Router/Simple/Declare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROUTER_SIMPLE_DECLARE';
  package Router::Simple::Declare;use strict;use warnings;use parent 'Exporter';use Router::Simple;use Carp ();our@EXPORT=qw/router connect submapper/;our$_ROUTER;sub router (&) {local$_ROUTER=Router::Simple->new();$_[0]->();$_ROUTER}BEGIN {no strict 'refs';for my$meth (qw/connect submapper/){*{$meth}=sub {local$Carp::CarpLevel=$Carp::CarpLevel + 1;$_ROUTER->$meth(@_)}}}1;
ROUTER_SIMPLE_DECLARE

$fatpacked{"Router/Simple/Route.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROUTER_SIMPLE_ROUTE';
  package Router::Simple::Route;use strict;use warnings;use Carp ();use Class::Accessor::Lite 0.05 (rw=>[qw(name dest on_match method host pattern)],);sub new {my$class=shift;if (@_==1 || ref $_[1]){unshift(@_,undef)}my ($name,$pattern,$dest,$opt)=@_;Carp::croak("missing pattern")unless$pattern;my$row=+{name=>$name,dest=>$dest,on_match=>$opt->{on_match},};if (my$method=$opt->{method}){$method=[$method]unless ref$method;$row->{method}=$method;my$method_re=join '|',@{$method};$row->{method_re}=qr{^(?:$method_re)$}}if (my$host=$opt->{host}){$row->{host}=$host;$row->{host_re}=ref$host ? $host : qr(^\Q$host\E$)}$row->{pattern}=$pattern;my@capture;$row->{pattern_re}=do {if (ref$pattern){$row->{_regexp_capture}=1;$pattern}else {$pattern =~ s!
                  \{((?:\{[0-9,]+\}|[^{}]+)+)\} | # /blog/{year:\d{4}}
                  :([A-Za-z0-9_]+)              | # /blog/:year
                  (\*)                          | # /blog/*/*
                  ([^{:*]+)                       # normal string
              !
                  if ($1) {
                      my ($name, $pattern) = split /:/, $1, 2;
                      push @capture, $name;
                      $pattern ? "($pattern)" : "([^/]+)";
                  } elsif ($2) {
                      push @capture, $2;
                      "([^/]+)";
                  } elsif ($3) {
                      push @capture, '__splat__';
                      "(.+)";
                  } else {
                      quotemeta($4);
                  }
              !gex;$pattern .= '?' if$opt->{directory_slash}and $pattern =~ m{\/$};qr{^$pattern$}}};$row->{capture}=\@capture;$row->{dest}||= +{};return bless$row,$class}sub match {my ($self,$env)=@_;if ($self->{host_re}){unless ($env->{HTTP_HOST}=~ $self->{host_re}){return undef}}if (my@captured=($env->{PATH_INFO}=~ $self->{pattern_re})){my%args;my@splat;if ($self->{_regexp_capture}){push@splat,@captured}else {if (@{$self->{capture}}> 0 && scalar(@{$self->{capture}})!=scalar(@captured)){Carp::carp("Path pattern should not contain paren. This code may not works in future version of Router::Simple. : " .$self->{pattern})}for my$i (0..@{$self->{capture}}-1){if ($self->{capture}->[$i]eq '__splat__'){push@splat,$captured[$i]}else {$args{$self->{capture}->[$i]}=$captured[$i]}}}if ($self->{method_re}){unless (($env->{REQUEST_METHOD}|| '')=~ $self->{method_re}){$Router::Simple::_METHOD_NOT_ALLOWED=1;return undef}}my$match=+{%{$self->{dest}},%args,(@splat ? (splat=>\@splat): ()),};if ($self->{on_match}){my$ret=$self->{on_match}->($env,$match);return undef unless$ret}return$match}return undef}1;
ROUTER_SIMPLE_ROUTE

$fatpacked{"Router/Simple/SubMapper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROUTER_SIMPLE_SUBMAPPER';
  package Router::Simple::SubMapper;use strict;use warnings;use Scalar::Util qw/weaken/;use Router::Simple ();sub new {my ($class,%args)=@_;my$self=bless {%args },$class;weaken($self->{parent});$self}sub connect {my ($self,$pattern,$dest,$opt)=@_;$pattern=$self->{pattern}.$pattern if$self->{pattern};$dest ||= +{};$opt ||= +{};$self->{parent}->connect($pattern,{%{$self->{dest}},%$dest },{%{$self->{opt}},%$opt });$self}sub submapper {my$self=shift;Router::Simple::submapper($self,@_)}1;
ROUTER_SIMPLE_SUBMAPPER

$fatpacked{"String/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_FORMAT';
  package String::Format;use strict;use vars qw($VERSION @EXPORT);use Exporter;use base qw(Exporter);$VERSION='0.01';@EXPORT=qw(stringf);sub _replace {my ($args,$orig,$alignment,$min_width,$max_width,$passme,$formchar)=@_;return$orig unless defined$args->{$formchar};$alignment='+' unless defined$alignment;my$replacement=$args->{$formchar};if (ref$replacement eq 'CODE'){$passme ||= "";$passme =~ tr/{}//d;$replacement=$replacement->($passme)}my$replength=length$replacement;$min_width ||= $replength;$max_width ||= $replength;if (($replength > $min_width)&& ($replength < $max_width)){return$replacement}if ($replength > $max_width){return substr($replacement,0,$max_width)}if ($alignment eq '-'){return$replacement ." " x ($min_width - $replength)}return " " x ($min_width - $replength).$replacement}my$regex=qr/
                 (%             # leading '%'
                  (-)?          # left-align, rather than right
                  (\d*)?        # (optional) minimum field width
                  (?:\.(\d*))?  # (optional) maximum field width
                  ({.*?})?      # (optional) stuff inside
                  (\S)          # actual format character
               )/x;sub stringf {my$format=shift || return;my$args=UNIVERSAL::isa($_[0],'HASH')? shift : {@_};$args->{'n'}="\n" unless exists$args->{'n'};$args->{'t'}="\t" unless exists$args->{'t'};$args->{'%'}="%" unless exists$args->{'%'};$format =~ s/$regex/_replace($args, $1, $2, $3, $4, $5, $6)/ge;return$format}sub stringfactory {shift;my$args=UNIVERSAL::isa($_[0],"HASH")? shift : {@_};return sub {stringf($_[0],$args)}}1;
STRING_FORMAT

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use strict;use warnings;use Exporter qw(import);use Scalar::Util qw(weaken);use Carp qw(croak);our$VERSION='0.01';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub undefer_all);our@EXPORT_OK=qw(undefer_package defer_info);our%DEFERRED;sub _getglob {no strict 'refs';\*{$_[0]}}BEGIN {my$no_subname;*_subname =defined&Sub::Util::set_subname ? \&Sub::Util::set_subname : defined&Sub::Name::subname ? \&Sub::Name::subname : (eval {require Sub::Util}&& defined&Sub::Util::set_subname)? \&Sub::Util::set_subname : (eval {require Sub::Name}&& defined&Sub::Name::subname)? \&Sub::Name::subname : ($no_subname=1,sub {$_[1]});*_CAN_SUBNAME=$no_subname ? sub(){0}: sub(){1}}sub _name_coderef {shift if @_ > 2;_CAN_SUBNAME ? _subname(@_): $_[1]}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}sub undefer_sub {my ($deferred)=@_;my ($target,$maker,$undeferred_ref)=@{$DEFERRED{$deferred}||return$deferred};return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}$DEFERRED{$made}=$DEFERRED{$deferred};weaken$DEFERRED{$made}unless$target;return$made}sub undefer_all {undefer_sub($_)for keys%DEFERRED;return}sub undefer_package {my$package=shift;undefer_sub($_)for grep {my$name=$DEFERRED{$_}&& $DEFERRED{$_}[0];$name && $name =~ /^${package}::[^:]+$/}keys%DEFERRED;return}sub defer_info {my ($deferred)=@_;my$info=$DEFERRED{$deferred||''}or return undef;[@$info ]}sub defer_sub {my ($target,$maker,$options)=@_;my$package;my$subname;($package,$subname)=$target =~ /^(.*)::([^:]+)$/ or croak "$target is not a fully qualified sub name!" if$target;$package ||= $options && $options->{package}|| caller;my@attributes=@{$options && $options->{attributes}|| []};my$deferred;my$undeferred;my$deferred_info=[$target,$maker,\$undeferred ];if (@attributes || $target &&!_CAN_SUBNAME){my$code =q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n] .qq[package $package;\n] .($target ? "sub $subname" : '+sub').join(' ',map ":$_",@attributes).q[ {
          package Sub::Defer;
          # uncoverable subroutine
          # uncoverable statement
          $undeferred ||= undefer_sub($deferred_info->[3]);
          goto &$undeferred; # uncoverable statement
          $undeferred; # fake lvalue return
        }]."\n" .($target ? "\\&$subname" : '');my$e;$deferred=do {no warnings qw(redefine closure);local $@;eval$code or $e=$@};die$e if defined$e}else {$deferred=sub {$undeferred ||= undefer_sub($deferred_info->[3]);goto &$undeferred};_install_coderef($target,$deferred)if$target}weaken($deferred_info->[3]=$deferred);weaken($DEFERRED{$deferred}=$deferred_info);return$deferred}sub CLONE {%DEFERRED=map {defined $_ && $_->[3]? ($_->[3]=>$_): ()}values%DEFERRED;for my$info (values%DEFERRED){weaken($info)unless$info->[0]&& ${$info->[2]}}}1;
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;$Sub::Exporter::Progressive::VERSION='0.01';use strict;use warnings;sub _croak {require Carp;&Carp::croak}sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';no warnings 'once';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (grep {length ref $_ or $_ !~ / \A [:-]? \w+ \z /xm}@args){_croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined((my ($num)=grep {m/^\d/}@args)[0])){_croak "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if (($setup||'')eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){_croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};_croak$too_complicated if grep {length ref $_}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){_croak$too_complicated if grep {length ref $_ or $_ =~ / \A - (?! all \b ) /x}@{$tagset}}@defaults=@{$tags{default}|| []}}else {_croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||= [@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;_croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;sub _clean_eval {eval $_[0]}use strict;use warnings;use Sub::Defer qw(defer_sub);use Scalar::Util qw(weaken);use Exporter qw(import);use Carp qw(croak);BEGIN {our@CARP_NOT=qw(Sub::Defer)}use B ();BEGIN {*_HAVE_PERLSTRING=defined&B::perlstring ? sub(){1}: sub(){0}}our$VERSION='0.01';$VERSION=eval$VERSION;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub qsub);our@EXPORT_OK=qw(quotify capture_unroll inlinify sanitize_identifier);our%QUOTED;sub quotify {no warnings 'numeric';!defined $_[0]? 'undef()' : (length((my$dummy='')& $_[0])&& 0 + $_[0]eq $_[0]&& $_[0]* 0==0)? $_[0]: _HAVE_PERLSTRING ? B::perlstring($_[0]): qq["\Q$_[0]\E"]}sub sanitize_identifier {my$name=shift;$name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;$name}sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or croak "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;my$do='do { '.($extra||'');if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//){$do .= $1}if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms){my ($pre,$indent,$code_args)=($1,$2,$3);$do .= $pre;if ($code_args ne $args){$do .= $indent .'my ('.$code_args.') = ('.$args.'); '}}elsif ($local || $args ne '@_'){$do .= ($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$code.' }'}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=ref($_[-1])eq 'HASH' ? pop : undef;undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];if ($name){my$subname=$name;my$package=$subname =~ s/(.*)::// ? $1 : caller;$name=join '::',$package,$subname;croak qq{package name "$package" too long!} if length$package > 252;croak qq{package name "$package" is not valid!} unless$package =~ /^[^\d\W]\w*(?:::\w+)*$/;croak qq{sub name "$subname" too long!} if length$subname > 252;croak qq{sub name "$subname" is not valid!} unless$subname =~ /^[^\d\W]\w*$/}my@caller=caller(0);my$attributes=$options->{attributes};my$quoted_info={name=>$name,code=>$code,captures=>$captures,package=>(exists$options->{package}? $options->{package}: $caller[0]),hints=>(exists$options->{hints}? $options->{hints}: $caller[8]),warning_bits=>(exists$options->{warning_bits}? $options->{warning_bits}: $caller[9]),hintshash=>(exists$options->{hintshash}? $options->{hintshash}: $caller[10]),($attributes ? (attributes=>$attributes): ()),};my$unquoted;weaken($quoted_info->{unquoted}=\$unquoted);if ($options->{no_defer}){my$fake=\my$var;local$QUOTED{$fake}=$quoted_info;my$sub=unquote_sub($fake);Sub::Defer::_install_coderef($name,$sub)if$name &&!$options->{no_install};return$sub}else {my$deferred=defer_sub +($options->{no_install}? undef : $name)=>sub {$unquoted if 0;unquote_sub($quoted_info->{deferred})},($attributes ? {attributes=>$attributes }: ());weaken($quoted_info->{deferred}=$deferred);weaken($QUOTED{$deferred}=$quoted_info);return$deferred}}sub _context {my$info=shift;$info->{context}||= do {my ($package,$hints,$warning_bits,$hintshash)=@{$info}{qw(package hints warning_bits hintshash)};$info->{context}="# BEGIN quote_sub PRELUDE\n" ."package $package;\n" ."BEGIN {\n" ."  \$^H = ".quotify($hints).";\n" ."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n" ."  \%^H = (\n" .join('',map "    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",keys %$hintshash)."  );\n" ."}\n" ."# END quote_sub PRELUDE\n"}}sub quoted_from_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub||''}or return undef;my ($name,$code,$captures,$unquoted,$deferred)=@{$quoted_info}{qw(name code captures unquoted deferred)};$code=_context($quoted_info).$code;$unquoted &&= $$unquoted;if (($deferred && $deferred eq $sub)|| ($unquoted && $unquoted eq $sub)){return [$name,$code,$captures,$unquoted,$deferred ]}return undef}sub unquote_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub}or return undef;my$unquoted=$quoted_info->{unquoted};unless ($unquoted && $$unquoted){my ($name,$code,$captures,$package,$attributes)=@{$quoted_info}{qw(name code captures package attributes)};($package,$name)=$name =~ /(.*)::(.*)/ if$name;my%captures=$captures ? %$captures : ();$captures{'$_UNQUOTED'}=\$unquoted;$captures{'$_QUOTED'}=\$quoted_info;my$make_sub ="{\n" .capture_unroll("\$_[1]",\%captures,2)."  package ${package};\n" .($name ? "  no warnings 'closure';\n  sub ${name} " : "  \$\$_UNQUOTED = sub ").($attributes ? join('',map ":$_ ",@$attributes): '')."{\n" ."  (\$_QUOTED,\$_UNQUOTED) if 0;\n" ._context($quoted_info).$code ."  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '').";\n" ."}\n" ."1;\n";$ENV{SUB_QUOTE_DEBUG}&& warn$make_sub;{no strict 'refs';local *{"${package}::${name}"}if$name;my ($success,$e);{local $@;$success=_clean_eval($make_sub,\%captures);$e=$@}unless ($success){croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e"}weaken($QUOTED{$$unquoted}=$quoted_info)}}$$unquoted}sub qsub ($) {goto&quote_sub}sub CLONE {%QUOTED=map {defined $_ ? ($_->{unquoted}&& ${$_->{unquoted}}? (${$_->{unquoted}}=>$_): (),$_->{deferred}? ($_->{deferred}=>$_): (),): ()}values%QUOTED;weaken($_)for values%QUOTED}1;
SUB_QUOTE

$fatpacked{"Sub/Uplevel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_UPLEVEL';
  package Sub::Uplevel;use 5.006;use strict;our$VERSION='0.01';our$CHECK_FRAMES;BEGIN {$CHECK_FRAMES=!!$CHECK_FRAMES}use constant CHECK_FRAMES=>$CHECK_FRAMES;if (not defined*CORE::GLOBAL::caller{CODE}){*CORE::GLOBAL::caller=\&_normal_caller}my@reload_list=qw/Exporter Exporter::Heavy/;sub import {no strict 'refs';my ($class,@args)=@_;for my$tag (@args,'uplevel'){if ($tag eq 'uplevel'){my$caller=caller(0);*{"$caller\::uplevel"}=\&uplevel}elsif($tag eq ':aggressive'){_force_reload(@reload_list)}else {die qq{"$tag" is not exported by the $class module\n}}}return}sub _force_reload {no warnings 'redefine';local $^W=0;for my$m (@_){$m =~ s{::}{/}g;$m .= ".pm";require$m if delete$INC{$m}}}our (@Up_Frames,$Caller_Proxy);sub _apparent_stack_height {my$height=1;while (1){last if!defined scalar$Caller_Proxy->($height);$height++}return$height - 1}sub uplevel {my$old_W=$^W;$^W=0;local$Caller_Proxy=*CORE::GLOBAL::caller{CODE}if*CORE::GLOBAL::caller{CODE}!=\&_uplevel_caller;local*CORE::GLOBAL::caller=\&_uplevel_caller;$^W=$old_W;if (CHECK_FRAMES and $_[0]>= _apparent_stack_height()){require Carp;Carp::carp("uplevel $_[0] is more than the caller stack")}local@Up_Frames=(shift,@Up_Frames);my$function=shift;return$function->(@_)}sub _normal_caller (;$) {my ($height)=@_;$height++;my@caller=CORE::caller($height);if (CORE::caller()eq 'DB'){package DB;@caller=CORE::caller($height)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}sub _uplevel_caller (;$) {my$height=$_[0]|| 0;return$Caller_Proxy->($height + 1)if!@Up_Frames;my$saw_uplevel=0;my$adjust=0;my$test_caller;for (my$up=0;$up <= $height + $adjust;$up++ ){$test_caller=scalar CORE::caller($up + 1);if($test_caller && $test_caller eq __PACKAGE__){$adjust += 1 + $Up_Frames[$saw_uplevel];$saw_uplevel++}}my@caller=$Caller_Proxy->($height + $adjust + 1);if (CORE::caller()eq 'DB'){package DB;@caller=$Sub::Uplevel::Caller_Proxy->($height + $adjust + 1)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}1;
SUB_UPLEVEL

$fatpacked{"Task/Weaken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TASK_WEAKEN';
  package Task::Weaken;use 5.005;use strict;use vars qw{$VERSION};BEGIN {$VERSION='0.01'}1;
TASK_WEAKEN

$fatpacked{"Test/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_EXCEPTION';
  use strict;use warnings;package Test::Exception;use Test::Builder;use Sub::Uplevel qw(uplevel);use base qw(Exporter);our$VERSION='0.01';$VERSION=eval$VERSION;our@EXPORT=qw(dies_ok lives_ok throws_ok lives_and);my$Tester=Test::Builder->new;sub import {my$self=shift;if (@_){my$package=caller;$Tester->exported_to($package);$Tester->plan(@_)};$self->export_to_level(1,$self,$_)foreach@EXPORT}sub _quiet_caller (;$) {my$height=$_[0];$height++;if (CORE::caller()eq 'DB'){package DB;if(wantarray){if (!@_){return (CORE::caller($height))[0..2]}else {my@frame_info=CORE::caller($height);@DB::args=();return@frame_info}}return CORE::caller($height)}else {if(wantarray and!@_){return (CORE::caller($height))[0..2]}else {return CORE::caller($height)}}}sub _try_as_caller {my$coderef=shift;local*CORE::GLOBAL::caller;{no warnings 'redefine';*CORE::GLOBAL::caller=\&_quiet_caller}eval {uplevel 3,$coderef};return $@};sub _is_exception {my$exception=shift;return ref$exception || $exception ne ''};sub _exception_as_string {my ($prefix,$exception)=@_;return "$prefix normal exit" unless _is_exception($exception);my$class=ref$exception;$exception="$class ($exception)" if$class && "$exception" !~ m/^\Q$class/;chomp$exception;return "$prefix $exception"};sub throws_ok (&$;$) {my ($coderef,$expecting,$description)=@_;unless (defined$expecting){require Carp;Carp::croak("throws_ok: must pass exception class/object or regex")}$description=_exception_as_string("threw",$expecting)unless defined$description;my$exception=_try_as_caller($coderef);my$regex=$Tester->maybe_regex($expecting);my$ok=$regex ? ($exception =~ m/$regex/): eval {$exception->isa(ref$expecting ? ref$expecting : $expecting)};$Tester->ok($ok,$description);unless ($ok){$Tester->diag(_exception_as_string("expecting:",$expecting));$Tester->diag(_exception_as_string("found:",$exception))};$@=$exception;return$ok};sub dies_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(_is_exception($exception),$description);$@=$exception;return$ok}sub lives_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(!_is_exception($exception),$description);$Tester->diag(_exception_as_string("died:",$exception))unless$ok;$@=$exception;return$ok}sub lives_and (&;$) {my ($test,$description)=@_;{my$ok=\&Test::Builder::ok;no warnings;local*Test::Builder::ok=sub {local$Test::Builder::Level=$Test::Builder::Level + 1;$_[2]=$description unless defined $_[2];$ok->(@_)};use warnings;eval {$test->()}and return 1};my$exception=$@;if (_is_exception($exception)){$Tester->ok(0,$description);$Tester->diag(_exception_as_string("died:",$exception))};$@=$exception;return}1;
TEST_EXCEPTION

$fatpacked{"Test/NoWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NOWARNINGS';
  package Test::NoWarnings;use 5.006;use strict;use warnings;use Carp ();use Exporter ();use Test::Builder ();use Test::NoWarnings::Warning ();use vars qw($VERSION @EXPORT_OK @ISA $do_end_test);BEGIN {$VERSION='0.01';@ISA='Exporter';@EXPORT_OK=qw(clear_warnings had_no_warnings warnings);$do_end_test=0}my$TEST=Test::Builder->new;my$PID=$$;my@WARNINGS=();my$EARLY=0;$SIG{__WARN__}=make_catcher(\@WARNINGS);sub import {$do_end_test=1;if (grep {$_ eq ':early'}@_){@_=grep {$_ ne ':early'}@_;$EARLY=1}goto&Exporter::import}END {had_no_warnings()if$do_end_test}sub make_warning {local$SIG{__WARN__};my$msg=shift;my$warning=Test::NoWarnings::Warning->new;$warning->setMessage($msg);$warning->fillTest($TEST);$warning->fillTrace(__PACKAGE__);$Carp::Internal{__PACKAGE__.""}++;local$Carp::CarpLevel=$Carp::CarpLevel + 1;$warning->fillCarp($msg);$Carp::Internal{__PACKAGE__.""}--;return$warning}sub make_catcher {my$array=shift;return sub {my$msg=shift;$Carp::Internal{__PACKAGE__.""}++;push(@$array,make_warning($msg));$Carp::Internal{__PACKAGE__.""}--;if ($EARLY){$TEST->diag($array->[-1]->toString)}return$msg}}sub had_no_warnings {return 0 if $$!=$PID;local$SIG{__WARN__};my$name=shift || "no warnings";my$ok;my$diag;if (@WARNINGS==0){$ok=1}else {$ok=0;$diag="There were " .scalar(@WARNINGS)." warning(s)\n";unless ($EARLY){$diag .= join "----------\n",map {$_->toString}@WARNINGS}}$TEST->ok($ok,$name)|| $TEST->diag($diag);return$ok}sub clear_warnings {local$SIG{__WARN__};@WARNINGS=()}sub warnings {local$SIG{__WARN__};return@WARNINGS}sub builder {local$SIG{__WARN__};if (@_){$TEST=shift}return$TEST}1;
TEST_NOWARNINGS

$fatpacked{"Test/NoWarnings/Warning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NOWARNINGS_WARNING';
  package Test::NoWarnings::Warning;use 5.006;use strict;use Carp ();use vars qw{$VERSION};BEGIN {$VERSION='0.01';eval "require Devel::StackTrace"}sub new {my$class=shift;bless {@_ },$class}sub getTrace {$_[0]->{Trace}}sub fillTrace {my$self=shift;$self->{Trace}=Devel::StackTrace->new(ignore_class=>[__PACKAGE__,@_],)if$Devel::StackTrace::VERSION}sub getCarp {$_[0]->{Carp}}sub fillCarp {my$self=shift;my$msg=shift;$Carp::Internal{__PACKAGE__ ."" }++;local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->{Carp}=Carp::longmess($msg);$Carp::Internal{__PACKAGE__ ."" }--}sub getMessage {$_[0]->{Message}}sub setMessage {$_[0]->{Message}=$_[1]}sub fillTest {my$self=shift;my$builder=shift;my$prev_test=$builder->current_test;$self->{Test}=$prev_test;my@tests=$builder->details;my$prev_test_name=$prev_test ? $tests[$prev_test - 1]->{name}: "";$self->{TestName}=$prev_test_name}sub getTest {$_[0]->{Test}}sub getTestName {$_[0]->{TestName}}sub toString {my$self=shift;return <<EOM}1;
  	Previous test $self->{Test} '$self->{TestName}'
  	$self->{Carp}
  EOM
TEST_NOWARNINGS_WARNING

$fatpacked{"Test/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_OBJECT';
  package Test::Object;use 5.005;use strict;use Carp ();use Exporter ();use Test::More ();use Scalar::Util ();use Test::Object::Test ();use vars qw{$VERSION @ISA @EXPORT};BEGIN {$VERSION='0.01';@ISA='Exporter';@EXPORT='object_ok'}my@TESTS=();sub register {my$class=shift;push@TESTS,Test::Object::Test->new(@_)}sub object_ok {my$object=Scalar::Util::blessed($_[0])? shift : Carp::croak("Did not provide an object to object_ok");for my$test (@TESTS){$test->run($object)if$object->isa($test->class)}1}1;
TEST_OBJECT

$fatpacked{"Test/Object/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_OBJECT_TEST';
  package Test::Object::Test;use strict;use Carp ();use Scalar::Util ();use vars qw{$VERSION};BEGIN {$VERSION='0.01'}sub new {my$class=shift;my$self=bless {@_ },$class;unless (_CLASS($self->class)){Carp::croak("Did not provide a valid test class")}unless (_CODELIKE($self->code)){Carp::croak("Did not provide a valid CODE or callable object")}$self}sub class {$_[0]->{class}}sub tests {$_[0]->{tests}}sub code {$_[0]->{code}}sub run {$_[0]->code->($_[1])}sub _CLASS ($) {(defined $_[0]and!ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*$/s)? $_[0]: undef}sub _CODELIKE {(Scalar::Util::reftype($_[0])||'')eq 'CODE' or Scalar::Util::blessed($_[0])and overload::Method($_[0],'&{}')? $_[0]: undef}1;
TEST_OBJECT_TEST

$fatpacked{"Test/Perl/Critic/Policy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_PERL_CRITIC_POLICY';
  package Test::Perl::Critic::Policy;use 5.006001;use strict;use warnings;use Carp qw<croak confess>;use English qw<-no_match_vars>;use List::MoreUtils qw<all none>;use Readonly;use Test::Builder qw<>;use Test::More;use Perl::Critic::Violation;use Perl::Critic::TestUtils qw<pcritique_with_violations fcritique_with_violations subtests_in_tree>;our$VERSION='0.01';use Exporter 'import';Readonly::Array our@EXPORT_OK=>qw<all_policies_ok>;Readonly::Hash our%EXPORT_TAGS=>(all=>\@EXPORT_OK);Perl::Critic::Violation::set_format("%m at line %l, column %c.  (%r)\n");Perl::Critic::TestUtils::block_perlcriticrc();my$TEST=Test::Builder->new();sub all_policies_ok {my (%args)=@_;my$wanted_policies=$args{-policies};my$test_dir=$args{'-test-directory'}|| 't';my$subtests_with_extras=subtests_in_tree($test_dir,'include extras');if ($wanted_policies){_validate_wanted_policy_names($wanted_policies,$subtests_with_extras);_filter_unwanted_subtests($wanted_policies,$subtests_with_extras)}$TEST->plan(tests=>_compute_test_count($subtests_with_extras));my$policies_to_test=join q{, },keys %{$subtests_with_extras};$TEST->note("Running tests for policies: $policies_to_test");for my$policy (sort keys %{$subtests_with_extras}){my ($full_policy_name,$method)=("Perl::Critic::Policy::$policy",'violates');my$can_ok_label=qq{Class '$full_policy_name' has method '$method'};$TEST->ok($full_policy_name->can($method),$can_ok_label);for my$subtest (@{$subtests_with_extras->{$policy}{subtests}}){my$todo=$subtest->{TODO};if ($todo){$TEST->todo_start($todo)}my ($error,@violations)=_run_subtest($policy,$subtest);my ($ok,@diag)=_evaluate_test_results($subtest,$error,\@violations);$TEST->ok($ok,_create_test_name($policy,$subtest));if (@diag){$TEST->diag(@diag)}if ($todo){$TEST->todo_end()}}}return}sub _validate_wanted_policy_names {my ($wanted_policies,$subtests_with_extras)=@_;return 1 if not $wanted_policies;my@all_testable_policies=keys %{$subtests_with_extras};my@wanted_policies=@{$wanted_policies};my@invalid=grep {my$p=$_;none {$_ =~ $p}@all_testable_policies}@wanted_policies;croak(q{No tests found for policies matching: } .join q{, },@invalid)if@invalid;return 1}sub _filter_unwanted_subtests {my ($wanted_policies,$subtests_with_extras)=@_;return 1 if not $wanted_policies;my@all_testable_policies=keys %{$subtests_with_extras};my@wanted_policies=@{$wanted_policies};for my$p (@all_testable_policies){if (none {$p =~ m/$_/xism}@wanted_policies){delete$subtests_with_extras->{$p}}}return 1}sub _run_subtest {my ($policy,$subtest)=@_;my@violations;my$error;if ($subtest->{filename}){eval {@violations=fcritique_with_violations($policy,\$subtest->{code},$subtest->{filename},$subtest->{parms},);1}or do {$error=$EVAL_ERROR || 'An unknown problem occurred.'}}else {eval {@violations=pcritique_with_violations($policy,\$subtest->{code},$subtest->{parms},);1}or do {$error=$EVAL_ERROR || 'An unknown problem occurred.'}}return ($error,@violations)}sub _evaluate_test_results {my ($subtest,$error,$violations)=@_;if ($subtest->{error}){return _evaluate_error_case($subtest,$error)}elsif ($error){confess$error}else {return _evaluate_violation_case($subtest,$violations)}}sub _evaluate_violation_case {my ($subtest,$violations)=@_;my ($ok,@diagnostics);my@violations=@{$violations};my$have=scalar@violations;my$want=_compute_wanted_violation_count($subtest);if (not $ok=$have==$want){my$msg=qq(Expected $want violations, got $have. );if (@violations){$msg .= q(Found violations follow...)}push@diagnostics,$msg ."\n";push@diagnostics,map {qq(Found violation: $_)}@violations}return ($ok,@diagnostics)}sub _evaluate_error_case {my ($subtest,$error)=@_;my ($ok,@diagnostics);if ('Regexp' eq ref$subtest->{error}){$ok=$error =~ $subtest->{error}or push@diagnostics,qq(Error message '$error' doesn't match $subtest->{error}.)}else {$ok=$subtest->{error}or push@diagnostics,q(Didn't get an error message when we expected one.)}return ($ok,@diagnostics)}sub _compute_test_count {my ($subtests_with_extras)=@_;my$npolicies=scalar keys %{$subtests_with_extras};my$nsubtests=0;for my$subtest_with_extras (values %{$subtests_with_extras}){$nsubtests += @{$subtest_with_extras->{subtests}}}return$nsubtests + $npolicies}sub _compute_wanted_violation_count {my ($subtest)=@_;return 0 if not _all_optional_modules_are_available($subtest);return$subtest->{failures}}sub _all_optional_modules_are_available {my ($subtest)=@_;my$optional_modules=$subtest->{optional_modules}or return 1;return all {eval "require $_;" or 0}split m/,\s*/xms,$optional_modules}sub _create_test_name {my ($policy,$subtest)=@_;return join ' - ',$policy,"line $subtest->{lineno}",$subtest->{name}}1;
TEST_PERL_CRITIC_POLICY

$fatpacked{"Test/SubCalls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SUBCALLS';
  package Test::SubCalls;use 5.006;use strict;use File::Spec 0.80 ();use Test::More 0.42 ();use Hook::LexWrap 0.20 ();use Exporter ();use Test::Builder ();use vars qw{$VERSION @ISA @EXPORT};BEGIN {$VERSION='0.01';@ISA='Exporter';@EXPORT=qw{sub_track sub_calls sub_reset sub_reset_all}}my$Test=Test::Builder->new;my%CALLS=();sub sub_track {my$subname=shift;SCOPE: {no strict 'refs';unless (defined *{"$subname"}{CODE}){die "Test::SubCalls::sub_track : The sub '$subname' does not exist"}if (defined$CALLS{$subname}){die "Test::SubCalls::sub_track : Cannot add duplicate tracker for '$subname'"}}$CALLS{$subname}=0;Hook::LexWrap::wrap($subname,pre=>sub {$CALLS{$subname}++},);1}sub sub_calls {my$subname=shift;unless (defined$CALLS{$subname}){die "Test::SubCalls::sub_calls : Cannot test untracked sub '$subname'"}my$count=shift;unless ($count =~ /^(?:0|[1-9]\d*)\z/s){die "Test::SubCalls::sub_calls : Expected count '$count' is not an integer"}my$message=shift || "$subname was called $count times";$Test->is_num($CALLS{$subname},$count,$message)}sub sub_reset {my$subname=shift;unless (defined$CALLS{$subname}){die "Test::SubCalls::sub_reset : Cannot reset untracked sub '$subname'"}$CALLS{$subname}=0;1}sub sub_reset_all {for my$subname (keys%CALLS){$CALLS{$subname}=0}1}1;
TEST_SUBCALLS

$fatpacked{"Test/Warn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_WARN';
  package Test::Warn;use 5.006;use strict;use warnings;use Sub::Uplevel 0.12;our$VERSION='0.01';require Exporter;our@ISA=qw(Exporter);our%EXPORT_TAGS=('all'=>[qw(@EXPORT) ]);our@EXPORT_OK=(@{$EXPORT_TAGS{'all'}});our@EXPORT=qw(warning_is warnings_are warning_like warnings_like warnings_exist);use Test::Builder;my$Tester=Test::Builder->new;{no warnings 'once';*warning_is=*warnings_are;*warning_like=*warnings_like}sub warnings_are (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);push@got_warning,_canonical_got_warning($called_from,shift())};uplevel 1,$block;my$ok=_cmp_is(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub warnings_like (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);push@got_warning,_canonical_got_warning($called_from,shift())};uplevel 1,$block;my$ok=_cmp_like(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub warnings_exist (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);my$wrn_text=shift;my$wrn_rec=_canonical_got_warning($called_from,$wrn_text);for my$wrn (@exp_warning){if (_cmp_got_to_exp_warning_like($wrn_rec,$wrn)){push@got_warning,$wrn_rec;return}}warn$wrn_text};uplevel 1,$block;my$ok=_cmp_like(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub _to_array_if_necessary {return (ref($_[0])eq 'ARRAY')? @{$_[0]}: ($_[0])}sub _canonical_got_warning {my ($called_from,$msg)=@_;my$warn_kind=$called_from eq 'Carp' ? 'carped' : 'warn';my@warning_stack=split /\n/,$msg;return {$warn_kind=>$warning_stack[0]}}sub _canonical_exp_warning {my ($exp)=@_;if (ref($exp)eq 'HASH'){my$to_carp=$exp->{carped}or return;return (ref($to_carp)eq 'ARRAY')? map({{carped=>$_}}grep {defined $_}@$to_carp): +{carped=>$to_carp}}return {warn=>$exp}}sub _cmp_got_to_exp_warning {my ($got_kind,$got_msg)=%{shift()};my ($exp_kind,$exp_msg)=%{shift()};return 0 if ($got_kind eq 'warn')&& ($exp_kind eq 'carped');my$cmp;if ($exp_msg =~ /\n$/s){$cmp="$got_msg\n" eq $exp_msg}else {$cmp=$got_msg =~ /^\Q$exp_msg\E at .+ line \d+\.?$/s}return$cmp}sub _cmp_got_to_exp_warning_like {my ($got_kind,$got_msg)=%{shift()};my ($exp_kind,$exp_msg)=%{shift()};return 0 if ($got_kind eq 'warn')&& ($exp_kind eq 'carped');if (my$re=$Tester->maybe_regex($exp_msg)){my$cmp=$got_msg =~ /$re/;return$cmp}else {return Test::Warn::Categorization::warning_like_category($got_msg,$exp_msg)}}sub _cmp_is {my@got=@{shift()};my@exp=@{shift()};scalar@got==scalar@exp or return 0;my$cmp=1;$cmp &&= _cmp_got_to_exp_warning($got[$_],$exp[$_])for (0 .. $#got);return$cmp}sub _cmp_like {my@got=@{shift()};my@exp=@{shift()};scalar@got==scalar@exp or return 0;my$cmp=1;$cmp &&= _cmp_got_to_exp_warning_like($got[$_],$exp[$_])for (0 .. $#got);return$cmp}sub _diag_found_warning {for (@_){if (ref($_)eq 'HASH'){${$_}{carped}? $Tester->diag("found carped warning: ${$_}{carped}"): $Tester->diag("found warning: ${$_}{warn}")}else {$Tester->diag("found warning: $_")}}$Tester->diag("didn't find a warning")unless @_}sub _diag_exp_warning {for (@_){if (ref($_)eq 'HASH'){${$_}{carped}? $Tester->diag("expected to find carped warning: ${$_}{carped}"): $Tester->diag("expected to find warning: ${$_}{warn}")}else {$Tester->diag("expected to find warning: $_")}}$Tester->diag("didn't expect to find a warning")unless @_}package Test::Warn::Categorization;use Carp;my$bits=\%warnings::Bits;my@warnings=sort grep {my$warn_bits=$bits->{$_}}keys %$bits;my%warnings_in_category=('utf8'=>['Wide character in \w+\b',],);sub _warning_category_regexp {my$category=shift;my$category_bits=$bits->{$category}or return;my@category_warnings =grep {($bits->{$_}& $category_bits)eq $bits->{$_}}@warnings;my@list=map {exists$warnings_in_category{$_}? (@{$warnings_in_category{$_}}): ($_)}@category_warnings;my$re=join "|",@list;return qr/$re/}sub warning_like_category {my ($warning,$category)=@_;my$re=_warning_category_regexp($category)or carp("Unknown warning category '$category'"),return;my$ok=$warning =~ /$re/;return$ok}1;
TEST_WARN

$fatpacked{"Text/Glob.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_GLOB';
  package Text::Glob;use strict;use Exporter;use vars qw/$VERSION @ISA @EXPORT_OK $strict_leading_dot $strict_wildcard_slash/;$VERSION='0.01';@ISA='Exporter';@EXPORT_OK=qw(glob_to_regex glob_to_regex_string match_glob);$strict_leading_dot=1;$strict_wildcard_slash=1;use constant debug=>0;sub glob_to_regex {my$glob=shift;my$regex=glob_to_regex_string($glob);return qr/^$regex$/}sub glob_to_regex_string {my$glob=shift;my$seperator=$Text::Glob::seperator;$seperator="/" unless defined$seperator;$seperator=quotemeta($seperator);my ($regex,$in_curlies,$escaping);local $_;my$first_byte=1;for ($glob =~ m/(.)/gs){if ($first_byte){if ($strict_leading_dot){$regex .= '(?=[^\.])' unless $_ eq '.'}$first_byte=0}if ($_ eq '/'){$first_byte=1}if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' || $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%'){$regex .= "\\$_"}elsif ($_ eq '*'){$regex .= $escaping ? "\\*" : $strict_wildcard_slash ? "(?:(?!$seperator).)*" : ".*"}elsif ($_ eq '?'){$regex .= $escaping ? "\\?" : $strict_wildcard_slash ? "(?!$seperator)." : "."}elsif ($_ eq '{'){$regex .= $escaping ? "\\{" : "(";++$in_curlies unless$escaping}elsif ($_ eq '}' && $in_curlies){$regex .= $escaping ? "}" : ")";--$in_curlies unless$escaping}elsif ($_ eq ',' && $in_curlies){$regex .= $escaping ? "," : "|"}elsif ($_ eq "\\"){if ($escaping){$regex .= "\\\\";$escaping=0}else {$escaping=1}next}else {$regex .= $_;$escaping=0}$escaping=0}print "# $glob $regex\n" if debug;return$regex}sub match_glob {print "# ",join(', ',map {"'$_'"}@_),"\n" if debug;my$glob=shift;my$regex=glob_to_regex$glob;local $_;grep {$_ =~ $regex}@_}1;
TEXT_GLOB

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.01';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}my$caller=caller;_subname("${caller}::try {...} "=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;my$caller=caller;_subname("${caller}::catch {...} "=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;my$caller=caller;_subname("${caller}::finally {...} "=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"Variable/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VARIABLE_MAGIC';
  package Variable::Magic;use 5.008;use strict;use warnings;our$VERSION;BEGIN {$VERSION='0.01'}BEGIN {require XSLoader;XSLoader::load(__PACKAGE__,$VERSION)}sub wizard {if (@_ % 2){require Carp;Carp::croak('Wrong number of arguments for wizard()')}my%opts=@_;my@keys=qw<op_info data get set len clear free copy dup>;push@keys,'local' if MGf_LOCAL;push@keys,qw<fetch store exists delete copy_key> if VMG_UVAR;my ($wiz,$err);{local $@;$wiz=eval {_wizard(map$opts{$_},@keys)};$err=$@}if ($err){$err =~ s/\sat\s+.*?\n//;require Carp;Carp::croak($err)}return$wiz}use base qw<Exporter>;our@EXPORT=();our%EXPORT_TAGS=('funcs'=>[qw<wizard cast getdata dispell> ],'consts'=>[qw<MGf_COPY MGf_DUP MGf_LOCAL VMG_UVAR VMG_COMPAT_SCALAR_LENGTH_NOLEN VMG_COMPAT_SCALAR_NOLEN VMG_COMPAT_ARRAY_PUSH_NOLEN VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID VMG_COMPAT_ARRAY_UNDEF_CLEAR VMG_COMPAT_HASH_DELETE_NOUVAR_VOID VMG_COMPAT_CODE_COPY_CLONE VMG_COMPAT_GLOB_GET VMG_PERL_PATCHLEVEL VMG_THREADSAFE VMG_FORKSAFE VMG_OP_INFO_NAME VMG_OP_INFO_OBJECT> ],);our@EXPORT_OK=map {@$_}values%EXPORT_TAGS;$EXPORT_TAGS{'all'}=[@EXPORT_OK ];1;
VARIABLE_MAGIC

$fatpacked{"auto/Clone/autosplit.ix"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTO_CLONE_AUTOSPLIT.IX';
  1;
AUTO_CLONE_AUTOSPLIT.IX

$fatpacked{"namespace/clean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN';
  package namespace::clean;use warnings;use strict;our$VERSION='0.01';$VERSION=eval$VERSION if$VERSION =~ /_/;our$STORAGE_VAR='__NAMESPACE_CLEAN_STORAGE';use B::Hooks::EndOfScope 'on_scope_end';BEGIN {my$provider;if ("$]" < 5.008007){require Package::Stash::PP;$provider='Package::Stash::PP'}else {require Package::Stash;$provider='Package::Stash'}eval <<"EOS" or die $@}use namespace::clean::_Util qw(DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT);my$RemoveSubs=sub {my$cleanee=shift;my$store=shift;my$cleanee_stash=stash_for($cleanee);my$deleted_stash;SYMBOL: for my$f (@_){next SYMBOL if$store->{exclude}{$f };my$sub=$cleanee_stash->get_symbol("&$f")or next SYMBOL;my$need_debugger_fixup=(DEBUGGER_NEEDS_CV_RENAME or DEBUGGER_NEEDS_CV_PIVOT)&& $^P & 0x01 && defined&DB::sub && ref(my$globref=\$cleanee_stash->namespace->{$f})eq 'GLOB' && ($deleted_stash ||= stash_for("namespace::clean::deleted::$cleanee"));if (DEBUGGER_NEEDS_CV_RENAME and $need_debugger_fixup){namespace::clean::_Util::get_subname($sub)eq ($cleanee_stash->name ."::$f")and $deleted_stash->add_symbol("&$f",namespace::clean::_Util::set_subname($deleted_stash->name ."::$f",$sub),)}elsif (DEBUGGER_NEEDS_CV_PIVOT and $need_debugger_fixup){$deleted_stash->add_symbol("&$f",$sub)}my@symbols=map {my$name=$_ .$f;my$def=$cleanee_stash->get_symbol($name);defined($def)? [$name,$def]: ()}'$','@','%','';$cleanee_stash->remove_glob($f);DEBUGGER_NEEDS_CV_PIVOT and $need_debugger_fixup and *$globref=$deleted_stash->namespace->{$f};$cleanee_stash->add_symbol(@$_)for@symbols}};sub clean_subroutines {my ($nc,$cleanee,@subs)=@_;$RemoveSubs->($cleanee,{},@subs)}sub import {my ($pragma,@args)=@_;my (%args,$is_explicit);ARG: while (@args){if ($args[0]=~ /^\-/){my$key=shift@args;my$value=shift@args;$args{$key }=$value}else {$is_explicit++;last ARG}}my$cleanee=exists$args{-cleanee }? $args{-cleanee }: scalar caller;if ($is_explicit){on_scope_end {$RemoveSubs->($cleanee,{},@args)}}else {my$functions=$pragma->get_functions($cleanee);my$store=$pragma->get_class_store($cleanee);my$stash=stash_for($cleanee);my%except=map {($_=>1)}($args{-except }? (ref$args{-except }eq 'ARRAY' ? @{$args{-except }}: $args{-except }): ());for my$f (keys %$functions){next if$except{$f };next unless$stash->has_symbol("&$f");$store->{remove}{$f }=1}on_scope_end {$RemoveSubs->($cleanee,$store,keys %{$store->{remove}})};return 1}}sub unimport {my ($pragma,%args)=@_;my$cleanee=exists$args{-cleanee }? $args{-cleanee }: scalar caller;my$functions=$pragma->get_functions($cleanee);my$store=$pragma->get_class_store($cleanee);for my$f (keys %$functions){next if$store->{remove}{$f }or $store->{exclude}{$f };$store->{exclude}{$f }=1}return 1}sub get_class_store {my ($pragma,$class)=@_;my$stash=stash_for($class);my$var="%$STORAGE_VAR";$stash->add_symbol($var,{})unless$stash->has_symbol($var);return$stash->get_symbol($var)}sub get_functions {my ($pragma,$class)=@_;my$stash=stash_for($class);return {map {$_=>$stash->get_symbol("&$_")}$stash->list_all_symbols('CODE')}}'Danger! Laws of Thermodynamics may not apply.' 
  
  sub stash_for (\$) {
    $provider->new(\$_[0]);
  }
  
  1;
  
  EOS
NAMESPACE_CLEAN

$fatpacked{"namespace/clean/_Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN__UTIL';
  package namespace::clean::_Util;use warnings;use strict;use base 'Exporter';our@EXPORT_OK=qw(DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT);use constant DEBUGGER_NEEDS_CV_RENAME=>(("$]" > 5.008_008)and ("$]" < 5.013_006));use constant DEBUGGER_NEEDS_CV_PIVOT=>((!DEBUGGER_NEEDS_CV_RENAME)and ("$]" < 5.015_005));BEGIN {DEBUGGER_NEEDS_CV_RENAME and (eval <<'EOS' or die $@)}1;
  {
    my( $sub_name_loaded, $sub_util_loaded );
  
    sub _namer_load_error {
      return '' if $sub_util_loaded or $sub_name_loaded;
  
      # if S::N is loaded first *and* so is B - then go with that, otherwise
      # prefer Sub::Util as S::U will provide a faster get_subname and will
      # not need further require() calls
      # this is rather arbitrary but remember this code exists only perls
      # between 5.8.9 ~ 5.13.5
  
      # when changing version also change in Makefile.PL
      my $sn_ver = 0.04;
  
      local $@;
      my $err = '';
  
      (
        ! (
          $INC{"B.pm"}
            and
          $INC{"Sub/Name.pm"}
            and
          eval { Sub::Name->VERSION($sn_ver) }
        )
          and
        eval { require Sub::Util }
          and
        # see https://github.com/moose/Moo/commit/dafa5118
        defined &Sub::Util::set_subname
          and
        $sub_util_loaded = 1
      )
        or
      (
        eval { require Sub::Name and Sub::Name->VERSION($sn_ver) }
          and
        $sub_name_loaded = 1
      )
        or
      $err = "When running under -d on this perl $], namespace::clean requires either Sub::Name $sn_ver or Sub::Util to be installed"
      ;
  
      $err;
    }
  
    sub set_subname {
      if( my $err = _namer_load_error() ) {
        die $err;
      }
      elsif( $sub_name_loaded ) {
        &Sub::Name::subname;
      }
      elsif( $sub_util_loaded ) {
        &Sub::Util::set_subname;
      }
      else {
        die "How the fuck did we get here? Read source and debug please!";
      }
    }
  
    sub get_subname {
      if(
        _namer_load_error()
          or
        ! $sub_util_loaded
      ) {
        require B;
        my $gv = B::svref_2object( $_[0] )->GV;
        join '::', $gv->STASH->NAME, $gv->NAME;
      }
      else {
        &Sub::Util::subname;
      }
    }
  }
  1;
  EOS
NAMESPACE_CLEAN__UTIL

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;use Moo::_strictures;use Moo::_Utils qw(_load_module);sub moo {print <<'EOMOO';exit 0}BEGIN {my$package;sub import {moo()if $0 eq '-';$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;_load_module($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moo;\n/}}1;
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
OO

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

# vim: set ft=perl:

use feature ':5.10';
use strict;
use warnings;

our $VERSION = '0.01';

use App::Monastery;
App::Monastery->run;

__END__

=encoding utf-8

=head1 NAME

monastery - Perl Language Server

=head1 DESCRIPTION

This is the script interface to L<App::Monastery>. Configure your
editor to point here. Most documentation is available at the module
however the script takes a single argument.

=head1 SYNOPSIS

monastery [options]

  --log LEVEL   Uses L<AnyEvent::Log/"LOGGING-LEVELS">, logs to /tmp/perl-lang-server.log

=cut
